[
  {
    "discussion_id": "1898775380",
    "pr_number": 3938,
    "pr_file": "lib/include/tree_sitter/api.h",
    "created_at": "2024-12-28T02:02:48+00:00",
    "commented_code": "*/\n uint32_t ts_language_state_count(const TSLanguage *self);\n \n+/**\n+ * Get the number of supertype symbols in the language.\n+*/\n+uint32_t ts_language_supertype_count(const TSLanguage *self);\n+\n+/**\n+ * Get a list of all supertype symbols for the language.\n+*/\n+const TSSymbol *ts_language_supertypes(const TSLanguage *self);",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1898775380",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3938,
        "pr_file": "lib/include/tree_sitter/api.h",
        "discussion_id": "1898775380",
        "commented_code": "@@ -1166,6 +1166,26 @@ uint32_t ts_language_symbol_count(const TSLanguage *self);\n */\n uint32_t ts_language_state_count(const TSLanguage *self);\n \n+/**\n+ * Get the number of supertype symbols in the language.\n+*/\n+uint32_t ts_language_supertype_count(const TSLanguage *self);\n+\n+/**\n+ * Get a list of all supertype symbols for the language.\n+*/\n+const TSSymbol *ts_language_supertypes(const TSLanguage *self);",
        "comment_created_at": "2024-12-28T02:02:48+00:00",
        "comment_author": "amaanq",
        "comment_body": "Instead of exposing a function for just getting the # of supertypes (which I question the usefulness of), why not instead have the caller pass in a pointer to a `uint32_t`, called `length`, which is written to in the function body. This will let the user know how many supertypes there are, see `ts_tree_included_ranges` for an example of what I mean. The main reason being this will set the precedence for us to add `_count` functions for other node types, which we don't want to add.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "324863438",
    "pr_number": 444,
    "pr_file": "lib/include/tree_sitter/api.h",
    "created_at": "2019-09-16T20:11:12+00:00",
    "commented_code": "TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *);\n \n+/*******************/\n+/* Section - Query */\n+/*******************/\n+\n+/**\n+ * Create a new query from a string containing one or more S-expression\n+ * patterns. The query is associated with a particular language, and can\n+ * only be run on syntax nodes parsed with that language.\n+ *\n+ * If all of the given patterns are valid, this returns a `TSQuery`.\n+ * If a pattern is invalid, this returns `NULL`, and provides two pieces\n+ * of information about the problem:\n+ * 1. The byte offset of the error is written to the `error_offset` parameter.\n+ * 2. The type of error is written to the `error_type` parameter.\n+ */\n+TSQuery *ts_query_new(\n+  const TSLanguage *language,\n+  const char *source,\n+  uint32_t source_len,\n+  uint32_t *error_offset,\n+  TSQueryError *error_type\n+);\n+\n+/**\n+ * Delete a query, freeing all of the memory that it used.\n+ */\n+void ts_query_delete(TSQuery *);\n+\n+/**\n+ * Get the number of patterns in the query.\n+ */\n+uint32_t ts_query_pattern_count(const TSQuery *);\n+\n+/**\n+ * Get the predicates for the given pattern in the query.\n+ */\n+const TSQueryPredicateStep *ts_query_predicates_for_pattern(\n+  const TSQuery *self,\n+  uint32_t pattern_index,\n+  uint32_t *length\n+);\n+\n+/**\n+ * Get the number of distinct capture names in the query, or the number of\n+ * distinct string literals in the query.\n+ */\n+uint32_t ts_query_capture_count(const TSQuery *);\n+uint32_t ts_query_string_count(const TSQuery *);\n+\n+/**\n+ * Get the name and length of one of the query's captures, or one of the\n+ * query's string literals. Each capture and string is associated with a\n+ * numeric id based on the order that it appeared in the query's source.\n+ */\n+const char *ts_query_capture_name_for_id(\n+  const TSQuery *,\n+  uint32_t id,\n+  uint32_t *length\n+);\n+const char *ts_query_string_value_for_id(",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "324863438",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 444,
        "pr_file": "lib/include/tree_sitter/api.h",
        "discussion_id": "324863438",
        "commented_code": "@@ -602,6 +635,147 @@ int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *, uint32_t);\n \n TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *);\n \n+/*******************/\n+/* Section - Query */\n+/*******************/\n+\n+/**\n+ * Create a new query from a string containing one or more S-expression\n+ * patterns. The query is associated with a particular language, and can\n+ * only be run on syntax nodes parsed with that language.\n+ *\n+ * If all of the given patterns are valid, this returns a `TSQuery`.\n+ * If a pattern is invalid, this returns `NULL`, and provides two pieces\n+ * of information about the problem:\n+ * 1. The byte offset of the error is written to the `error_offset` parameter.\n+ * 2. The type of error is written to the `error_type` parameter.\n+ */\n+TSQuery *ts_query_new(\n+  const TSLanguage *language,\n+  const char *source,\n+  uint32_t source_len,\n+  uint32_t *error_offset,\n+  TSQueryError *error_type\n+);\n+\n+/**\n+ * Delete a query, freeing all of the memory that it used.\n+ */\n+void ts_query_delete(TSQuery *);\n+\n+/**\n+ * Get the number of patterns in the query.\n+ */\n+uint32_t ts_query_pattern_count(const TSQuery *);\n+\n+/**\n+ * Get the predicates for the given pattern in the query.\n+ */\n+const TSQueryPredicateStep *ts_query_predicates_for_pattern(\n+  const TSQuery *self,\n+  uint32_t pattern_index,\n+  uint32_t *length\n+);\n+\n+/**\n+ * Get the number of distinct capture names in the query, or the number of\n+ * distinct string literals in the query.\n+ */\n+uint32_t ts_query_capture_count(const TSQuery *);\n+uint32_t ts_query_string_count(const TSQuery *);\n+\n+/**\n+ * Get the name and length of one of the query's captures, or one of the\n+ * query's string literals. Each capture and string is associated with a\n+ * numeric id based on the order that it appeared in the query's source.\n+ */\n+const char *ts_query_capture_name_for_id(\n+  const TSQuery *,\n+  uint32_t id,\n+  uint32_t *length\n+);\n+const char *ts_query_string_value_for_id(",
        "comment_created_at": "2019-09-16T20:11:12+00:00",
        "comment_author": "bfredl",
        "comment_body": "Why not have capture names and this kind of general \"strings\" (only used by predicates, and not the query engine itself?) share a single \"namespace\" of interned string id:s, and a single function to look them up? It could still have all the capture names in the beginning, if there is a need to index a dense array of captures or something. It would simplify FFI by only managing one table of interned strings, and not two. ",
        "pr_file_module": null
      },
      {
        "comment_id": "324896498",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 444,
        "pr_file": "lib/include/tree_sitter/api.h",
        "discussion_id": "324863438",
        "commented_code": "@@ -602,6 +635,147 @@ int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *, uint32_t);\n \n TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *);\n \n+/*******************/\n+/* Section - Query */\n+/*******************/\n+\n+/**\n+ * Create a new query from a string containing one or more S-expression\n+ * patterns. The query is associated with a particular language, and can\n+ * only be run on syntax nodes parsed with that language.\n+ *\n+ * If all of the given patterns are valid, this returns a `TSQuery`.\n+ * If a pattern is invalid, this returns `NULL`, and provides two pieces\n+ * of information about the problem:\n+ * 1. The byte offset of the error is written to the `error_offset` parameter.\n+ * 2. The type of error is written to the `error_type` parameter.\n+ */\n+TSQuery *ts_query_new(\n+  const TSLanguage *language,\n+  const char *source,\n+  uint32_t source_len,\n+  uint32_t *error_offset,\n+  TSQueryError *error_type\n+);\n+\n+/**\n+ * Delete a query, freeing all of the memory that it used.\n+ */\n+void ts_query_delete(TSQuery *);\n+\n+/**\n+ * Get the number of patterns in the query.\n+ */\n+uint32_t ts_query_pattern_count(const TSQuery *);\n+\n+/**\n+ * Get the predicates for the given pattern in the query.\n+ */\n+const TSQueryPredicateStep *ts_query_predicates_for_pattern(\n+  const TSQuery *self,\n+  uint32_t pattern_index,\n+  uint32_t *length\n+);\n+\n+/**\n+ * Get the number of distinct capture names in the query, or the number of\n+ * distinct string literals in the query.\n+ */\n+uint32_t ts_query_capture_count(const TSQuery *);\n+uint32_t ts_query_string_count(const TSQuery *);\n+\n+/**\n+ * Get the name and length of one of the query's captures, or one of the\n+ * query's string literals. Each capture and string is associated with a\n+ * numeric id based on the order that it appeared in the query's source.\n+ */\n+const char *ts_query_capture_name_for_id(\n+  const TSQuery *,\n+  uint32_t id,\n+  uint32_t *length\n+);\n+const char *ts_query_string_value_for_id(",
        "comment_created_at": "2019-09-16T21:34:51+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "The main reason I lean toward keeping them separate is that callers will need to use them slightly differently. When creating bindings to this API, the `capture_names` need to stored in an array that will be used every time you run a query, whereas the `strings` only need to be loaded temporarily, while constructing a query.\r\n\r\nWith this approach, we can preallocate and populate the `captureNames` array using `ts_query_capture_count / ts_query_capture_name_for_id`, and preallocate and populate a separate `stringValues` array using `ts_query_string_count / ts_query_string_value_for_id`. Then, at the end of the query constructor function, we can simply drop the `stringValues` array.\r\n\r\n> It could still have all the capture names in the beginning, if there is a need to index a dense array of captures or something.\r\n\r\nThat's true. With that approach, we could at least *shrink* the array once we are done using the `strings`. But in order to do this, callers still need to know how many captures there are, so there still needs to be a separate `ts_query_capture_count` function.\r\n\r\nIn the end, I think the APIs are slightly more obvious in their meaning if `captures` and `strings` are just presented as two separate arrays, where each one has identical APIs for accessing its length and its contents.",
        "pr_file_module": null
      },
      {
        "comment_id": "324907283",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 444,
        "pr_file": "lib/include/tree_sitter/api.h",
        "discussion_id": "324863438",
        "commented_code": "@@ -602,6 +635,147 @@ int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *, uint32_t);\n \n TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *);\n \n+/*******************/\n+/* Section - Query */\n+/*******************/\n+\n+/**\n+ * Create a new query from a string containing one or more S-expression\n+ * patterns. The query is associated with a particular language, and can\n+ * only be run on syntax nodes parsed with that language.\n+ *\n+ * If all of the given patterns are valid, this returns a `TSQuery`.\n+ * If a pattern is invalid, this returns `NULL`, and provides two pieces\n+ * of information about the problem:\n+ * 1. The byte offset of the error is written to the `error_offset` parameter.\n+ * 2. The type of error is written to the `error_type` parameter.\n+ */\n+TSQuery *ts_query_new(\n+  const TSLanguage *language,\n+  const char *source,\n+  uint32_t source_len,\n+  uint32_t *error_offset,\n+  TSQueryError *error_type\n+);\n+\n+/**\n+ * Delete a query, freeing all of the memory that it used.\n+ */\n+void ts_query_delete(TSQuery *);\n+\n+/**\n+ * Get the number of patterns in the query.\n+ */\n+uint32_t ts_query_pattern_count(const TSQuery *);\n+\n+/**\n+ * Get the predicates for the given pattern in the query.\n+ */\n+const TSQueryPredicateStep *ts_query_predicates_for_pattern(\n+  const TSQuery *self,\n+  uint32_t pattern_index,\n+  uint32_t *length\n+);\n+\n+/**\n+ * Get the number of distinct capture names in the query, or the number of\n+ * distinct string literals in the query.\n+ */\n+uint32_t ts_query_capture_count(const TSQuery *);\n+uint32_t ts_query_string_count(const TSQuery *);\n+\n+/**\n+ * Get the name and length of one of the query's captures, or one of the\n+ * query's string literals. Each capture and string is associated with a\n+ * numeric id based on the order that it appeared in the query's source.\n+ */\n+const char *ts_query_capture_name_for_id(\n+  const TSQuery *,\n+  uint32_t id,\n+  uint32_t *length\n+);\n+const char *ts_query_string_value_for_id(",
        "comment_created_at": "2019-09-16T22:08:37+00:00",
        "comment_author": "bfredl",
        "comment_body": "I see  what you mean, though this seems to assume very specific details how you would use the API. In the first iteration I would do as much as possible lua-side, at least the non-hot preprocessing of the queries. So this would just imply needing two code paths (or helper functions) for converting an internal id to a lua string instead of just one. Though it is not much duplicated code, probably only like 3-5 lines.",
        "pr_file_module": null
      },
      {
        "comment_id": "324909996",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 444,
        "pr_file": "lib/include/tree_sitter/api.h",
        "discussion_id": "324863438",
        "commented_code": "@@ -602,6 +635,147 @@ int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *, uint32_t);\n \n TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *);\n \n+/*******************/\n+/* Section - Query */\n+/*******************/\n+\n+/**\n+ * Create a new query from a string containing one or more S-expression\n+ * patterns. The query is associated with a particular language, and can\n+ * only be run on syntax nodes parsed with that language.\n+ *\n+ * If all of the given patterns are valid, this returns a `TSQuery`.\n+ * If a pattern is invalid, this returns `NULL`, and provides two pieces\n+ * of information about the problem:\n+ * 1. The byte offset of the error is written to the `error_offset` parameter.\n+ * 2. The type of error is written to the `error_type` parameter.\n+ */\n+TSQuery *ts_query_new(\n+  const TSLanguage *language,\n+  const char *source,\n+  uint32_t source_len,\n+  uint32_t *error_offset,\n+  TSQueryError *error_type\n+);\n+\n+/**\n+ * Delete a query, freeing all of the memory that it used.\n+ */\n+void ts_query_delete(TSQuery *);\n+\n+/**\n+ * Get the number of patterns in the query.\n+ */\n+uint32_t ts_query_pattern_count(const TSQuery *);\n+\n+/**\n+ * Get the predicates for the given pattern in the query.\n+ */\n+const TSQueryPredicateStep *ts_query_predicates_for_pattern(\n+  const TSQuery *self,\n+  uint32_t pattern_index,\n+  uint32_t *length\n+);\n+\n+/**\n+ * Get the number of distinct capture names in the query, or the number of\n+ * distinct string literals in the query.\n+ */\n+uint32_t ts_query_capture_count(const TSQuery *);\n+uint32_t ts_query_string_count(const TSQuery *);\n+\n+/**\n+ * Get the name and length of one of the query's captures, or one of the\n+ * query's string literals. Each capture and string is associated with a\n+ * numeric id based on the order that it appeared in the query's source.\n+ */\n+const char *ts_query_capture_name_for_id(\n+  const TSQuery *,\n+  uint32_t id,\n+  uint32_t *length\n+);\n+const char *ts_query_string_value_for_id(",
        "comment_created_at": "2019-09-16T22:18:42+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Yeah, good point. I'm writing the API with the assumption that FFI has some noticeable cost, based on experience with JavaScript via Node and WebAssembly. If you aren't keeping a managed copy of the captures array, then none of the things that I said above are applicable.\r\n\r\nI think I'll keep it separate for now, though I see your point about the potential reduction in API functions.\r\n\r\nOn a related note, in 1af85dc3f758e5b4e2179fec81f95b89dadc26e3 I did delete two APIs related to captures and string values, which I realized were unused by either of my bindings. So now there are slightly fewer \ud83d\ude01. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1338010273",
    "pr_number": 2670,
    "pr_file": "lib/include/tree_sitter/parser.h",
    "created_at": "2023-09-27T03:49:18+00:00",
    "commented_code": "TSSymbol result_symbol;\n   void (*advance)(TSLexer *, bool);\n   void (*mark_end)(TSLexer *);\n+  uint32_t* line;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1338010273",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2670,
        "pr_file": "lib/include/tree_sitter/parser.h",
        "discussion_id": "1338010273",
        "commented_code": "@@ -44,6 +44,7 @@ struct TSLexer {\n   TSSymbol result_symbol;\n   void (*advance)(TSLexer *, bool);\n   void (*mark_end)(TSLexer *);\n+  uint32_t* line;",
        "comment_created_at": "2023-09-27T03:49:18+00:00",
        "comment_author": "llllvvuu",
        "comment_body": "Note: changing this to a getter could be worth the indirection if in the future this field might get a dynamic address or be computed on-demand",
        "pr_file_module": null
      },
      {
        "comment_id": "1338012438",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2670,
        "pr_file": "lib/include/tree_sitter/parser.h",
        "discussion_id": "1338010273",
        "commented_code": "@@ -44,6 +44,7 @@ struct TSLexer {\n   TSSymbol result_symbol;\n   void (*advance)(TSLexer *, bool);\n   void (*mark_end)(TSLexer *);\n+  uint32_t* line;",
        "comment_created_at": "2023-09-27T03:54:29+00:00",
        "comment_author": "ahlinc",
        "comment_body": "There are two types of objects in scanner's API, method pointers and values, this change doesn't cost to introduce a third type, a pointer to a value. Also to minimize breaking changes it makes sense to implement the final best solution at once.",
        "pr_file_module": null
      },
      {
        "comment_id": "1338018508",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2670,
        "pr_file": "lib/include/tree_sitter/parser.h",
        "discussion_id": "1338010273",
        "commented_code": "@@ -44,6 +44,7 @@ struct TSLexer {\n   TSSymbol result_symbol;\n   void (*advance)(TSLexer *, bool);\n   void (*mark_end)(TSLexer *);\n+  uint32_t* line;",
        "comment_created_at": "2023-09-27T04:09:13+00:00",
        "comment_author": "llllvvuu",
        "comment_body": "Yup, I realized the direct pointer was a mistake too, just changed it to a getter",
        "pr_file_module": null
      }
    ]
  }
]