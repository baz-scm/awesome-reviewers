[
  {
    "discussion_id": "122088088",
    "pr_number": 77,
    "pr_file": "src/runtime/parser.c",
    "created_at": "2017-06-14T23:21:06+00:00",
    "commented_code": "if (parser__select_tree(self, self->finished_tree, root)) {\n       ts_tree_release(self->finished_tree);\n-      assert(root->ref_count > 0);\n+      assert((root == NULL) || (root->ref_count > 0));",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "122088088",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 77,
        "pr_file": "src/runtime/parser.c",
        "discussion_id": "122088088",
        "commented_code": "@@ -839,7 +839,7 @@ static void parser__accept(Parser *self, StackVersion version,\n \n     if (parser__select_tree(self, self->finished_tree, root)) {\n       ts_tree_release(self->finished_tree);\n-      assert(root->ref_count > 0);\n+      assert((root == NULL) || (root->ref_count > 0));",
        "comment_created_at": "2017-06-14T23:21:06+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "It shouldn't be possible for `root` to be `NULL` here; would it make `scan-build` happy if we asserted that it was non-null before asserting about its ref_count?\r\n\r\n```c\r\nassert(root && root->ref_count > 0);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "91108137",
    "pr_number": 54,
    "pr_file": "src/runtime/parser.c",
    "created_at": "2016-12-06T15:59:41+00:00",
    "commented_code": "self->lexer.data.result_symbol = ts_builtin_sym_error;\n         break;\n       }\n-      self->lexer.data.advance(&self->lexer, ERROR_STATE, false);\n+      self->lexer.data.advance(&self->lexer, false);\n     }\n \n     skipped_error = true;\n     error_end_position = self->lexer.current_position;\n   }\n \n   Tree *result;\n-\n   if (skipped_error) {\n     Length padding = length_sub(error_start_position, start_position);\n     Length size = length_sub(error_end_position, error_start_position);\n     ts_lexer_reset(&self->lexer, error_end_position);\n     result = ts_tree_make_error(size, padding, first_error_character);\n   } else {\n     TSSymbol symbol = self->lexer.data.result_symbol;\n-    Length padding =\n-      length_sub(self->lexer.token_start_position, start_position);\n-    Length size = length_sub(self->lexer.current_position,\n-                                  self->lexer.token_start_position);\n-    result =\n-      ts_tree_make_leaf(symbol, padding, size,\n-                        ts_language_symbol_metadata(self->language, symbol));\n+    Length padding = length_sub(self->lexer.token_start_position, start_position);\n+    Length size = length_sub(self->lexer.current_position, self->lexer.token_start_position);\n+    TSSymbolMetadata metadata = ts_language_symbol_metadata(self->language, symbol);\n+    result = ts_tree_make_leaf(symbol, padding, size, metadata);\n   }\n \n-  if (!result)",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "91108137",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 54,
        "pr_file": "src/runtime/parser.c",
        "discussion_id": "91108137",
        "commented_code": "@@ -239,34 +269,27 @@ static Tree *parser__lex(Parser *self, TSStateId parse_state) {\n         self->lexer.data.result_symbol = ts_builtin_sym_error;\n         break;\n       }\n-      self->lexer.data.advance(&self->lexer, ERROR_STATE, false);\n+      self->lexer.data.advance(&self->lexer, false);\n     }\n \n     skipped_error = true;\n     error_end_position = self->lexer.current_position;\n   }\n \n   Tree *result;\n-\n   if (skipped_error) {\n     Length padding = length_sub(error_start_position, start_position);\n     Length size = length_sub(error_end_position, error_start_position);\n     ts_lexer_reset(&self->lexer, error_end_position);\n     result = ts_tree_make_error(size, padding, first_error_character);\n   } else {\n     TSSymbol symbol = self->lexer.data.result_symbol;\n-    Length padding =\n-      length_sub(self->lexer.token_start_position, start_position);\n-    Length size = length_sub(self->lexer.current_position,\n-                                  self->lexer.token_start_position);\n-    result =\n-      ts_tree_make_leaf(symbol, padding, size,\n-                        ts_language_symbol_metadata(self->language, symbol));\n+    Length padding = length_sub(self->lexer.token_start_position, start_position);\n+    Length size = length_sub(self->lexer.current_position, self->lexer.token_start_position);\n+    TSSymbolMetadata metadata = ts_language_symbol_metadata(self->language, symbol);\n+    result = ts_tree_make_leaf(symbol, padding, size, metadata);\n   }\n \n-  if (!result)",
        "comment_created_at": "2016-12-06T15:59:41+00:00",
        "comment_author": "joshvera",
        "comment_body": "Why was this check removed? Is it that `ts_tree_make_leaf` no longer returns `NULL`?",
        "pr_file_module": null
      },
      {
        "comment_id": "91135505",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 54,
        "pr_file": "src/runtime/parser.c",
        "discussion_id": "91108137",
        "commented_code": "@@ -239,34 +269,27 @@ static Tree *parser__lex(Parser *self, TSStateId parse_state) {\n         self->lexer.data.result_symbol = ts_builtin_sym_error;\n         break;\n       }\n-      self->lexer.data.advance(&self->lexer, ERROR_STATE, false);\n+      self->lexer.data.advance(&self->lexer, false);\n     }\n \n     skipped_error = true;\n     error_end_position = self->lexer.current_position;\n   }\n \n   Tree *result;\n-\n   if (skipped_error) {\n     Length padding = length_sub(error_start_position, start_position);\n     Length size = length_sub(error_end_position, error_start_position);\n     ts_lexer_reset(&self->lexer, error_end_position);\n     result = ts_tree_make_error(size, padding, first_error_character);\n   } else {\n     TSSymbol symbol = self->lexer.data.result_symbol;\n-    Length padding =\n-      length_sub(self->lexer.token_start_position, start_position);\n-    Length size = length_sub(self->lexer.current_position,\n-                                  self->lexer.token_start_position);\n-    result =\n-      ts_tree_make_leaf(symbol, padding, size,\n-                        ts_language_symbol_metadata(self->language, symbol));\n+    Length padding = length_sub(self->lexer.token_start_position, start_position);\n+    Length size = length_sub(self->lexer.current_position, self->lexer.token_start_position);\n+    TSSymbolMetadata metadata = ts_language_symbol_metadata(self->language, symbol);\n+    result = ts_tree_make_leaf(symbol, padding, size, metadata);\n   }\n \n-  if (!result)",
        "comment_created_at": "2016-12-06T18:02:47+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Yeah, this conditional was leftover from before https://github.com/tree-sitter/tree-sitter/pull/43, when the system tried to recover from malloc failure. I've removed that logic across the board, since malloc never even actually returns null on most systems, and apps that use tree-sitter aren't likely to have a fine-grained OOM recovery strategy anyway.",
        "pr_file_module": null
      },
      {
        "comment_id": "91137453",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 54,
        "pr_file": "src/runtime/parser.c",
        "discussion_id": "91108137",
        "commented_code": "@@ -239,34 +269,27 @@ static Tree *parser__lex(Parser *self, TSStateId parse_state) {\n         self->lexer.data.result_symbol = ts_builtin_sym_error;\n         break;\n       }\n-      self->lexer.data.advance(&self->lexer, ERROR_STATE, false);\n+      self->lexer.data.advance(&self->lexer, false);\n     }\n \n     skipped_error = true;\n     error_end_position = self->lexer.current_position;\n   }\n \n   Tree *result;\n-\n   if (skipped_error) {\n     Length padding = length_sub(error_start_position, start_position);\n     Length size = length_sub(error_end_position, error_start_position);\n     ts_lexer_reset(&self->lexer, error_end_position);\n     result = ts_tree_make_error(size, padding, first_error_character);\n   } else {\n     TSSymbol symbol = self->lexer.data.result_symbol;\n-    Length padding =\n-      length_sub(self->lexer.token_start_position, start_position);\n-    Length size = length_sub(self->lexer.current_position,\n-                                  self->lexer.token_start_position);\n-    result =\n-      ts_tree_make_leaf(symbol, padding, size,\n-                        ts_language_symbol_metadata(self->language, symbol));\n+    Length padding = length_sub(self->lexer.token_start_position, start_position);\n+    Length size = length_sub(self->lexer.current_position, self->lexer.token_start_position);\n+    TSSymbolMetadata metadata = ts_language_symbol_metadata(self->language, symbol);\n+    result = ts_tree_make_leaf(symbol, padding, size, metadata);\n   }\n \n-  if (!result)",
        "comment_created_at": "2016-12-06T18:14:12+00:00",
        "comment_author": "joshvera",
        "comment_body": "\ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  }
]