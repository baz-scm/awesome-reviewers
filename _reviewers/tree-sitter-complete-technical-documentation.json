[
  {
    "discussion_id": "1847436745",
    "pr_number": 3949,
    "pr_file": "docs/section-2-using-parsers.md",
    "created_at": "2024-11-18T23:30:44+00:00",
    "commented_code": "uint32_t ts_node_end_byte(TSNode);\n \n typedef struct {\n-  uint32_t row;\n-  uint32_t column;\n+  uint32_t row;    // zero-based\n+  uint32_t column; // zero-based, measured in bytes",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1847436745",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3949,
        "pr_file": "docs/section-2-using-parsers.md",
        "discussion_id": "1847436745",
        "commented_code": "@@ -180,8 +180,8 @@ uint32_t ts_node_start_byte(TSNode);\n uint32_t ts_node_end_byte(TSNode);\n \n typedef struct {\n-  uint32_t row;\n-  uint32_t column;\n+  uint32_t row;    // zero-based\n+  uint32_t column; // zero-based, measured in bytes",
        "comment_created_at": "2024-11-18T23:30:44+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Instead of line comments, why don't we add to the paragraph above? \r\n\r\n> In a point, rows and columns are zero-based. The `row` field represents the number of newlines before a given position, while `column` represents the number of bytes between the position and beginning of the line.",
        "pr_file_module": null
      },
      {
        "comment_id": "1848970699",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3949,
        "pr_file": "docs/section-2-using-parsers.md",
        "discussion_id": "1847436745",
        "commented_code": "@@ -180,8 +180,8 @@ uint32_t ts_node_start_byte(TSNode);\n uint32_t ts_node_end_byte(TSNode);\n \n typedef struct {\n-  uint32_t row;\n-  uint32_t column;\n+  uint32_t row;    // zero-based\n+  uint32_t column; // zero-based, measured in bytes",
        "comment_created_at": "2024-11-19T19:47:22+00:00",
        "comment_author": "ktraunmueller",
        "comment_body": "Fine for me \ud83d\udc4d Applied your suggestion in a new commit.\r\n\r\nMy thinking with the comments was that this would be a very compact and unintrusive way of conveying that information.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1312720859",
    "pr_number": 2532,
    "pr_file": "docs/section-2-using-parsers.md",
    "created_at": "2023-09-01T08:17:32+00:00",
    "commented_code": ")\n ```\n \n-_Note_ - Predicates are not handled directly by the Tree-sitter C library. They are just exposed in a structured form so that higher-level code can perform the filtering. However, higher-level bindings to Tree-sitter like [the Rust crate](https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust) or the [WebAssembly binding](https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web) implement a few common predicates like `#eq?` and `#match?`.\n+The prefix \"any-\" is meant for use with quantified captures. Here's\n+an example finding a segment of empty comments\n+\n+```scheme\n+((comment)+ @comment.empty\n+  (#any-eq? @comment.empty \"//\"))\n+```\n+\n+Note that \"#any-eq?\" will match a quantified capture if\n+_any_ of the nodes match the predicate, while by default a quantified capture\n+will only match if _all_ the nodes match the predicate.",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1312720859",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2532,
        "pr_file": "docs/section-2-using-parsers.md",
        "discussion_id": "1312720859",
        "commented_code": "@@ -651,7 +669,87 @@ And this pattern would match key-value pairs where the `value` is an identifier\n )\n ```\n \n-_Note_ - Predicates are not handled directly by the Tree-sitter C library. They are just exposed in a structured form so that higher-level code can perform the filtering. However, higher-level bindings to Tree-sitter like [the Rust crate](https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust) or the [WebAssembly binding](https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web) implement a few common predicates like `#eq?` and `#match?`.\n+The prefix \"any-\" is meant for use with quantified captures. Here's\n+an example finding a segment of empty comments\n+\n+```scheme\n+((comment)+ @comment.empty\n+  (#any-eq? @comment.empty \"//\"))\n+```\n+\n+Note that \"#any-eq?\" will match a quantified capture if\n+_any_ of the nodes match the predicate, while by default a quantified capture\n+will only match if _all_ the nodes match the predicate.",
        "comment_created_at": "2023-09-01T08:17:32+00:00",
        "comment_author": "clason",
        "comment_body": "While/if you fix the above: Would be useful to also explicitly mention/give an example for the `#any-not-eq?` behavior.",
        "pr_file_module": null
      }
    ]
  }
]