[
  {
    "discussion_id": "2203310843",
    "pr_number": 4568,
    "pr_file": "crates/generate/src/prepare_grammar/flatten_grammar.rs",
    "created_at": "2025-07-13T10:25:55+00:00",
    "commented_code": "for (i, variable) in variables.iter().enumerate() {\n         let symbol = Symbol::non_terminal(i);\n+        let used = symbol_is_used(&variables, symbol);\n \n         for production in &variable.productions {\n-            if production.steps.is_empty() && symbol_is_used(&variables, symbol) {\n+            if production.steps.is_empty() && used {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "2203310843",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4568,
        "pr_file": "crates/generate/src/prepare_grammar/flatten_grammar.rs",
        "discussion_id": "2203310843",
        "commented_code": "@@ -262,9 +262,10 @@ pub(super) fn flatten_grammar(\n \n     for (i, variable) in variables.iter().enumerate() {\n         let symbol = Symbol::non_terminal(i);\n+        let used = symbol_is_used(&variables, symbol);\n \n         for production in &variable.productions {\n-            if production.steps.is_empty() && symbol_is_used(&variables, symbol) {\n+            if production.steps.is_empty() && used {",
        "comment_created_at": "2025-07-13T10:25:55+00:00",
        "comment_author": "homersimpsons",
        "comment_body": "Would it also make sense to put `used` check first? If it is often `false` this would short-circuit the check for `production.steps.is_empty()`. If it is often `true` then this would probably not change anything.\n\n```suggestion\n            if used && production.steps.is_empty() {\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2203469969",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4568,
        "pr_file": "crates/generate/src/prepare_grammar/flatten_grammar.rs",
        "discussion_id": "2203310843",
        "commented_code": "@@ -262,9 +262,10 @@ pub(super) fn flatten_grammar(\n \n     for (i, variable) in variables.iter().enumerate() {\n         let symbol = Symbol::non_terminal(i);\n+        let used = symbol_is_used(&variables, symbol);\n \n         for production in &variable.productions {\n-            if production.steps.is_empty() && symbol_is_used(&variables, symbol) {\n+            if production.steps.is_empty() && used {",
        "comment_created_at": "2025-07-13T17:16:59+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Addressed in #4602 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1895217741",
    "pr_number": 4026,
    "pr_file": "cli/config/src/lib.rs",
    "created_at": "2024-12-23T04:05:54+00:00",
    "commented_code": "return Ok(Some(xdg_path));\n         }\n \n-        let legacy_path = dirs::home_dir()\n-            .ok_or_else(|| anyhow!(\"Cannot determine home directory\"))?\n+        if cfg!(target_os = \"macos\") {\n+            let legacy_apple_path = etcetera::base_strategy::Apple::new()?\n+                .data_dir() // `$HOME/Library/Application Support/`\n+                .join(\"tree-sitter\")\n+                .join(\"config.json\");\n+            if legacy_apple_path.is_file() {\n+                fs::copy(&legacy_apple_path, &xdg_path)?;\n+                fs::remove_file(&legacy_apple_path)?;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1895217741",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4026,
        "pr_file": "cli/config/src/lib.rs",
        "discussion_id": "1895217741",
        "commented_code": "@@ -38,8 +39,23 @@ impl Config {\n             return Ok(Some(xdg_path));\n         }\n \n-        let legacy_path = dirs::home_dir()\n-            .ok_or_else(|| anyhow!(\"Cannot determine home directory\"))?\n+        if cfg!(target_os = \"macos\") {\n+            let legacy_apple_path = etcetera::base_strategy::Apple::new()?\n+                .data_dir() // `$HOME/Library/Application Support/`\n+                .join(\"tree-sitter\")\n+                .join(\"config.json\");\n+            if legacy_apple_path.is_file() {\n+                fs::copy(&legacy_apple_path, &xdg_path)?;\n+                fs::remove_file(&legacy_apple_path)?;",
        "comment_created_at": "2024-12-23T04:05:54+00:00",
        "comment_author": "amaanq",
        "comment_body": "A [`rename`](https://linux.die.net/man/2/rename) would be faster than a [`copy`](https://man7.org/linux/man-pages/man2/copy_file_range.2.html) + [`unlink`](https://linux.die.net/man/2/unlink)\r\n\r\n```suggestion\r\n                fs::rename(&legacy_apple_path, &xdg_path)?;\r\n```\r\n\r\nAlso, if `xdg_path`'s parent folder doesn't exist, you'll get an error either way because it can't write to that file. Use `create_dir_all` on the parent.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1835513359",
    "pr_number": 3880,
    "pr_file": "cli/loader/src/lib.rs",
    "created_at": "2024-11-09T20:16:24+00:00",
    "commented_code": ".and_then(|n| n.to_str())\n             .and_then(|file_name| self.language_configuration_ids_by_file_type.get(file_name))\n             .or_else(|| {\n-                path.extension()\n-                    .and_then(|extension| extension.to_str())\n-                    .and_then(|extension| {\n-                        self.language_configuration_ids_by_file_type.get(extension)\n-                    })\n+                let mut path = path.to_owned();\n+                let mut full_extension = String::new();\n+                while let Some(extension) = path.extension() {\n+                    full_extension = format!(\n+                        \"{}{}{full_extension}\",\n+                        extension.to_str()?,\n+                        if full_extension.is_empty() { \"\" } else { \".\" }\n+                    );\n+                    path = PathBuf::from(path.file_stem()?.to_os_string());\n+                }\n+                self.language_configuration_ids_by_file_type\n+                    .get(&full_extension)",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1835513359",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3880,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1835513359",
        "commented_code": "@@ -521,11 +521,18 @@ impl Loader {\n             .and_then(|n| n.to_str())\n             .and_then(|file_name| self.language_configuration_ids_by_file_type.get(file_name))\n             .or_else(|| {\n-                path.extension()\n-                    .and_then(|extension| extension.to_str())\n-                    .and_then(|extension| {\n-                        self.language_configuration_ids_by_file_type.get(extension)\n-                    })\n+                let mut path = path.to_owned();\n+                let mut full_extension = String::new();\n+                while let Some(extension) = path.extension() {\n+                    full_extension = format!(\n+                        \"{}{}{full_extension}\",\n+                        extension.to_str()?,\n+                        if full_extension.is_empty() { \"\" } else { \".\" }\n+                    );\n+                    path = PathBuf::from(path.file_stem()?.to_os_string());\n+                }\n+                self.language_configuration_ids_by_file_type\n+                    .get(&full_extension)",
        "comment_created_at": "2024-11-09T20:16:24+00:00",
        "comment_author": "amaanq",
        "comment_body": "for clarity and avoiding allocations on every call to format, store a `Vec` of extensions, and push to it on each iteration while there is an extension, then just join them with a `.` at the end",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797496076",
    "pr_number": 3762,
    "pr_file": "cli/src/parse.rs",
    "created_at": "2024-10-11T23:39:15+00:00",
    "commented_code": "})\n }\n \n+const fn escape_invisible(c: char) -> Option<&'static str> {\n+    Some(match c {\n+        '\n' => \"\\\n\",\n+        '\\r' => \"\\\\r\",\n+        '\\t' => \"\\\\t\",\n+        '\\0' => \"\\\\0\",\n+        '\\\\' => \"\\\\\\\\\",\n+        '\\x0b' => \"\\\\v\",\n+        '\\x0c' => \"\\\\f\",\n+        _ => return None,\n+    })\n+}\n+\n+fn render_node_text(source: &str) -> String {\n+    let mut escaped = String::new();\n+    escaped.reserve(source.len());\n+\n+    for c in source.chars() {\n+        if let Some(esc) = escape_invisible(c) {\n+            escaped.push_str(esc);\n+        } else {\n+            escaped.push(c);\n+        }\n+    }\n+\n+    escaped\n+}\n+\n+#[allow(clippy::too_many_arguments)]\n+fn write_node_text(\n+    opts: &ParseFileOptions,\n+    stdout: &mut StdoutLock<'static>,\n+    cursor: &TreeCursor,\n+    source: &str,\n+    color: Option<impl Into<Color> + Copy>,\n+    quote: char,\n+    row_width: usize,\n+    indent_level: usize,\n+) -> Result<()> {\n+    if source.find('\n') == Some(source.len() - 1)\n+        || source.find('\n').is_none()\n+        || !cursor.node().is_named()\n+    {\n+        write!(\n+            stdout,\n+            \"{quote}{}{quote}\",\n+            paint(color, &render_node_text(source))\n+        )?;\n+    } else {\n+        for line in source.split_inclusive('\n') {\n+            if line.is_empty() {\n+                break;\n+            }\n+            if !opts.no_ranges {\n+                write!(\n+                    stdout,\n+                    \"\n{}{}{quote}{}{quote}\",\n+                    render_node_range(opts, cursor, row_width),\n+                    \"  \".repeat(indent_level + 1),\n+                    &paint(color, &render_node_text(line)),\n+                )?;\n+            } else {\n+                write!(\n+                    stdout,\n+                    \"\n{}{quote}{}{quote}\",\n+                    \"  \".repeat(indent_level + 1),\n+                    &paint(color, &render_node_text(line)),\n+                )?;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn render_node_range(opts: &ParseFileOptions, cursor: &TreeCursor, row_width: usize) -> String {\n+    let node = cursor.node();\n+    let is_named = node.is_named();",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1797496076",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3762,
        "pr_file": "cli/src/parse.rs",
        "discussion_id": "1797496076",
        "commented_code": "@@ -393,6 +526,177 @@ pub fn parse_file_at_path(parser: &mut Parser, opts: &ParseFileOptions) -> Resul\n     })\n }\n \n+const fn escape_invisible(c: char) -> Option<&'static str> {\n+    Some(match c {\n+        '\\n' => \"\\\\n\",\n+        '\\r' => \"\\\\r\",\n+        '\\t' => \"\\\\t\",\n+        '\\0' => \"\\\\0\",\n+        '\\\\' => \"\\\\\\\\\",\n+        '\\x0b' => \"\\\\v\",\n+        '\\x0c' => \"\\\\f\",\n+        _ => return None,\n+    })\n+}\n+\n+fn render_node_text(source: &str) -> String {\n+    let mut escaped = String::new();\n+    escaped.reserve(source.len());\n+\n+    for c in source.chars() {\n+        if let Some(esc) = escape_invisible(c) {\n+            escaped.push_str(esc);\n+        } else {\n+            escaped.push(c);\n+        }\n+    }\n+\n+    escaped\n+}\n+\n+#[allow(clippy::too_many_arguments)]\n+fn write_node_text(\n+    opts: &ParseFileOptions,\n+    stdout: &mut StdoutLock<'static>,\n+    cursor: &TreeCursor,\n+    source: &str,\n+    color: Option<impl Into<Color> + Copy>,\n+    quote: char,\n+    row_width: usize,\n+    indent_level: usize,\n+) -> Result<()> {\n+    if source.find('\\n') == Some(source.len() - 1)\n+        || source.find('\\n').is_none()\n+        || !cursor.node().is_named()\n+    {\n+        write!(\n+            stdout,\n+            \"{quote}{}{quote}\",\n+            paint(color, &render_node_text(source))\n+        )?;\n+    } else {\n+        for line in source.split_inclusive('\\n') {\n+            if line.is_empty() {\n+                break;\n+            }\n+            if !opts.no_ranges {\n+                write!(\n+                    stdout,\n+                    \"\\n{}{}{quote}{}{quote}\",\n+                    render_node_range(opts, cursor, row_width),\n+                    \"  \".repeat(indent_level + 1),\n+                    &paint(color, &render_node_text(line)),\n+                )?;\n+            } else {\n+                write!(\n+                    stdout,\n+                    \"\\n{}{quote}{}{quote}\",\n+                    \"  \".repeat(indent_level + 1),\n+                    &paint(color, &render_node_text(line)),\n+                )?;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn render_node_range(opts: &ParseFileOptions, cursor: &TreeCursor, row_width: usize) -> String {\n+    let node = cursor.node();\n+    let is_named = node.is_named();",
        "comment_created_at": "2024-10-11T23:39:15+00:00",
        "comment_author": "amaanq",
        "comment_body": "you called `node.is_named()` in the caller of this function - just pass the value of the first call into here instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1569618844",
    "pr_number": 3305,
    "pr_file": "cli/src/tests/parser_test.rs",
    "created_at": "2024-04-17T22:30:31+00:00",
    "commented_code": ")\n     );\n \n-    assert_eq!(recorder.strings_read(), vec![\"123 || 5 \"]);\n+    assert_eq!(recorder.strings_read(), vec![\"123 || 5 + 456 * (10 + x);\"]);",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1569618844",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3305,
        "pr_file": "cli/src/tests/parser_test.rs",
        "discussion_id": "1569618844",
        "commented_code": "@@ -364,7 +364,7 @@ fn test_parsing_after_editing_beginning_of_code() {\n         )\n     );\n \n-    assert_eq!(recorder.strings_read(), vec![\"123 || 5 \"]);\n+    assert_eq!(recorder.strings_read(), vec![\"123 || 5 + 456 * (10 + x);\"]);",
        "comment_created_at": "2024-04-17T22:30:31+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "This assertion change shows how failing to reuse nodes can destroy performance. We're now re-reading all the way to the end of the file, even though we should be able to reuse the unchanged code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1287712478",
    "pr_number": 2479,
    "pr_file": "cli/loader/src/lib.rs",
    "created_at": "2023-08-08T21:36:15+00:00",
    "commented_code": ".and_then(|extension| {\n                         self.language_configuration_ids_by_file_type.get(extension)\n                     })\n+            })\n+            .or_else(|| {\n+                let Ok(file) = fs::File::open(path) else {\n+                    return None;\n+                };\n+                let reader = BufReader::new(file);\n+                let Some(Ok(first_line)) = std::io::BufRead::lines(reader).next() else {\n+                    return None;\n+                };\n+\n+                self.language_configuration_ids_by_first_line_regex\n+                    .iter()\n+                    .find(|(regex, _)| {\n+                        Regex::from_str(regex)",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1287712478",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2479,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1287712478",
        "commented_code": "@@ -220,6 +223,24 @@ impl Loader {\n                     .and_then(|extension| {\n                         self.language_configuration_ids_by_file_type.get(extension)\n                     })\n+            })\n+            .or_else(|| {\n+                let Ok(file) = fs::File::open(path) else {\n+                    return None;\n+                };\n+                let reader = BufReader::new(file);\n+                let Some(Ok(first_line)) = std::io::BufRead::lines(reader).next() else {\n+                    return None;\n+                };\n+\n+                self.language_configuration_ids_by_first_line_regex\n+                    .iter()\n+                    .find(|(regex, _)| {\n+                        Regex::from_str(regex)",
        "comment_created_at": "2023-08-08T21:36:15+00:00",
        "comment_author": "ahlinc",
        "comment_body": "See above comment, it's not a good idea to instantiate Regex instances here every time.",
        "pr_file_module": null
      }
    ]
  }
]