[
  {
    "discussion_id": "163277921",
    "pr_number": 125,
    "pr_file": "tree-sitter-tips.md",
    "created_at": "2018-01-23T15:28:23+00:00",
    "commented_code": "+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "163277921",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 125,
        "pr_file": "tree-sitter-tips.md",
        "discussion_id": "163277921",
        "commented_code": "@@ -0,0 +1,79 @@\n+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.",
        "comment_created_at": "2018-01-23T15:28:23+00:00",
        "comment_author": "robrix",
        "comment_body": "I think we probably want to support 100% of a language\u2014or, curiously, more, since we often want to support multiple versions and such\u2014but not necessarily all in one go, if that makes sense. I.e. spread it out over multiple PRs, and/or accept that you\u2019ll catch errors \u201cin the wild\u201d sometimes. Is that what you mean here?",
        "pr_file_module": null
      },
      {
        "comment_id": "166178753",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 125,
        "pr_file": "tree-sitter-tips.md",
        "discussion_id": "163277921",
        "commented_code": "@@ -0,0 +1,79 @@\n+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.",
        "comment_created_at": "2018-02-06T03:26:48+00:00",
        "comment_author": "aymannadeem",
        "comment_body": "No, I guess I was trying to posit that while there's always more to do (given the evolving nature of languages), that for our purposes development can be paused. But you're right that I should instead say we can theoretically keep going. \r\n\r\nWould it be fair to say that it's worth knowing what you'll be using the output for, in order to constrain and place some guard rails around what you prioritize supporting?",
        "pr_file_module": null
      },
      {
        "comment_id": "168523597",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 125,
        "pr_file": "tree-sitter-tips.md",
        "discussion_id": "163277921",
        "commented_code": "@@ -0,0 +1,79 @@\n+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.",
        "comment_created_at": "2018-02-15T16:09:52+00:00",
        "comment_author": "robrix",
        "comment_body": "Ah\u2014that\u2019s an excellent point! Calling out language evolution explicitly seems like a good idea \ud83d\udc4d\r\n\r\n> Would it be fair to say that it's worth knowing what you'll be using the output for, in order to constrain and place some guard rails around what you prioritize supporting?\r\n\r\nTotally \ud83d\udc4d",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "163281042",
    "pr_number": 125,
    "pr_file": "tree-sitter-tips.md",
    "created_at": "2018-01-23T15:37:08+00:00",
    "commented_code": "+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.\n+\n+### :bulb: Handling conflicts\n+\n+Conflicts may arise due to ambiguities in the grammar. This is when the parser can not decide what the next symbol in an input stream should be because there are multiple ways to parse some strings. There are three ways to handle conflict:\n+1. Rearrange code.\n+2. Specifying associativity and/or precedence.\n+3. Adding a conflict.",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "163281042",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 125,
        "pr_file": "tree-sitter-tips.md",
        "discussion_id": "163281042",
        "commented_code": "@@ -0,0 +1,79 @@\n+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.\n+\n+### :bulb: Handling conflicts\n+\n+Conflicts may arise due to ambiguities in the grammar. This is when the parser can not decide what the next symbol in an input stream should be because there are multiple ways to parse some strings. There are three ways to handle conflict:\n+1. Rearrange code.\n+2. Specifying associativity and/or precedence.\n+3. Adding a conflict.",
        "comment_created_at": "2018-01-23T15:37:08+00:00",
        "comment_author": "robrix",
        "comment_body": "Another tactic here is to take two rules that parse the same string and combine them into a single rule that gets used in two places. I think this could be part of \u201crearrange code,\u201d tho I like the focus that item currently has on using combinators.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "163331856",
    "pr_number": 125,
    "pr_file": "tree-sitter-tips.md",
    "created_at": "2018-01-23T18:20:52+00:00",
    "commented_code": "+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.\n+\n+### :bulb: Handling conflicts\n+\n+Conflicts may arise due to ambiguities in the grammar. This is when the parser can not decide what the next symbol in an input stream should be because there are multiple ways to parse some strings. There are three ways to handle conflict:\n+1. Rearrange code.\n+2. Specifying associativity and/or precedence.\n+3. Adding a conflict.\n+\n+**1. Rearrange code.** There are ways to specify rules in a way that makes it easier for the lexer to digest. This can be done by using the following helper functions:\n+\n+_(WIP: Explain why the following help you avoid conflicts)_\n+\n+- `inline` - _(need Max's help here)_\n+- `commaSep` - creates a repeating sequence of 0 or more tokens separated by a comma\n+- `commaSep1` - creates a repeating sequence of 1 or more tokens separated by a comma\n+- `sep1`- creates a repeating sequence of 0 or more tokens separated by the specified delimiter\n+\n+**2. Specifying associativity and/or precedence.**",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "163331856",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 125,
        "pr_file": "tree-sitter-tips.md",
        "discussion_id": "163331856",
        "commented_code": "@@ -0,0 +1,79 @@\n+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.\n+\n+### :bulb: Handling conflicts\n+\n+Conflicts may arise due to ambiguities in the grammar. This is when the parser can not decide what the next symbol in an input stream should be because there are multiple ways to parse some strings. There are three ways to handle conflict:\n+1. Rearrange code.\n+2. Specifying associativity and/or precedence.\n+3. Adding a conflict.\n+\n+**1. Rearrange code.** There are ways to specify rules in a way that makes it easier for the lexer to digest. This can be done by using the following helper functions:\n+\n+_(WIP: Explain why the following help you avoid conflicts)_\n+\n+- `inline` - _(need Max's help here)_\n+- `commaSep` - creates a repeating sequence of 0 or more tokens separated by a comma\n+- `commaSep1` - creates a repeating sequence of 1 or more tokens separated by a comma\n+- `sep1`- creates a repeating sequence of 0 or more tokens separated by the specified delimiter\n+\n+**2. Specifying associativity and/or precedence.**",
        "comment_created_at": "2018-01-23T18:20:52+00:00",
        "comment_author": "tclem",
        "comment_body": "\ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "163333174",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 125,
        "pr_file": "tree-sitter-tips.md",
        "discussion_id": "163331856",
        "commented_code": "@@ -0,0 +1,79 @@\n+# Tree-sitter tips and tricks\n+\n+Language development using [Tree-Sitter](https://github.com/tree-sitter/tree-sitter) can be an arduous task. These tips are intended to help bring empiricism to the process by reducing trial and error (or at least introducing some guard rails).\n+\n+### :bulb: Rely on Language Specs, but not too much.\n+There are language specifications (like [this one for Java](https://docs.oracle.com/javase/specs/jls/se9/html/index.html)) that comprehensively describe a language. Specs provide the lexical and syntactic structure of a language in addition to its components (ex., types, variables, declarations, etc.) and how they interconnect. This can serve as a great baseline for writing your grammar. However, mirroring the spec 100% is not always the best approach, especially when its structure does not align with the parse tree you'd like to generate using tree-sitter. In this situation, it's better to deviate from the spec and prioritize generating a good parse tree. One way to do this may be to find an LR parser for the language you're working on ([such as this one for Java](https://github.com/javaparser/javaparser)) to see how they've modeled their tree outputs. Studying tree outputs from other LR parsers can be a good way to guide your own grammar development. \n+\n+### :bulb: What does a \"good\" parse tree look like?\n+\n+Here are some attributes of a \"pretty\" tree:\n+\n+:white_check_mark: Not overly verbose.\n+\n+:white_check_mark: Everything is outlined clearly.\n+\n+:white_check_mark: Communicates good information needed further along in the pipeline.\n+\n+![image](https://user-images.githubusercontent.com/875834/34972577-41bc12ac-fa37-11e7-9a12-a05d18b6f6e4.png)\n+\n+_Example of a good tree (WIP -- better examples welcome!):_\n+\n+```\n+===\n+module\n+===\n+\n+module com.foo { }\n+open module com.foo { }\n+\n+---\n+\n+(program\n+  (module_declaration (module_identifier (identifier) (identifier)))\n+  (module_declaration (module_identifier (identifier) (identifier))))\n+```\n+\n+### :bulb: Improving a parse tree by making it more compact\n+Here are some things that might help:\n+\n+**1. Aliasing** - by aliasing different things, you can maintain compact tree structure while marking differences in your grammar. _(Need better description)_\n+\n+**2. Making things hidden** - by putting an underscore before a rule (`_rule` vs `rule`), it will allow you to omit displaying it in the tree.\n+\n+### :bulb: Testing in the wild to help prioritize what to support next.\n+\n+Once you have developed a significant portion of the grammar, find a file from an active open source repository that follows the typical structure of the language and see how much of it can be successfully parsed by your system. Is it 40%? 60%? This can be a good way to benchmark how practical your grammar is in terms of popular usage of your language. It can also be an effective way to identify what to support and prioritize what's next.\n+\n+### :bulb: Knowing when to stop development\n+Most languages have a long-tail of features that don't get utilized frequently. It is reasonable to prioritize developing 80% of a language and only supporting commonly used elements.\n+\n+### :bulb: Handling conflicts\n+\n+Conflicts may arise due to ambiguities in the grammar. This is when the parser can not decide what the next symbol in an input stream should be because there are multiple ways to parse some strings. There are three ways to handle conflict:\n+1. Rearrange code.\n+2. Specifying associativity and/or precedence.\n+3. Adding a conflict.\n+\n+**1. Rearrange code.** There are ways to specify rules in a way that makes it easier for the lexer to digest. This can be done by using the following helper functions:\n+\n+_(WIP: Explain why the following help you avoid conflicts)_\n+\n+- `inline` - _(need Max's help here)_\n+- `commaSep` - creates a repeating sequence of 0 or more tokens separated by a comma\n+- `commaSep1` - creates a repeating sequence of 1 or more tokens separated by a comma\n+- `sep1`- creates a repeating sequence of 0 or more tokens separated by the specified delimiter\n+\n+**2. Specifying associativity and/or precedence.**",
        "comment_created_at": "2018-01-23T18:25:32+00:00",
        "comment_author": "tclem",
        "comment_body": "Might be good to note that resolving conflicts this way is a compile time solution as opposed to the \"Add a conflict\" section below which means the parser will try deal with the ambiguity at runtime.",
        "pr_file_module": null
      }
    ]
  }
]