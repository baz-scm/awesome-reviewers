[
  {
    "discussion_id": "2265439794",
    "pr_number": 4681,
    "pr_file": "crates/cli/src/init.rs",
    "created_at": "2025-08-10T21:03:32+00:00",
    "commented_code": "\"Cargo.toml\" => {\n                 replacement = replacement.replace(AUTHOR_EMAIL_PLACEHOLDER_RS, \"\");\n             }\n+            \"pom.xml\" => {\n+                replacement = replacement.replace(AUTHOR_EMAIL_PLACEHOLDER_JAVA, \"\");\n+            }\n             _ => {}\n         }\n     }\n \n-    if filename == \"package.json\" {\n+    if filename == \"package.json\" || filename == \"pom.xml\" {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "2265439794",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4681,
        "pr_file": "crates/cli/src/init.rs",
        "discussion_id": "2265439794",
        "commented_code": "@@ -910,30 +972,49 @@ fn generate_file(\n             \"Cargo.toml\" => {\n                 replacement = replacement.replace(AUTHOR_EMAIL_PLACEHOLDER_RS, \"\");\n             }\n+            \"pom.xml\" => {\n+                replacement = replacement.replace(AUTHOR_EMAIL_PLACEHOLDER_JAVA, \"\");\n+            }\n             _ => {}\n         }\n     }\n \n-    if filename == \"package.json\" {\n+    if filename == \"package.json\" || filename == \"pom.xml\" {",
        "comment_created_at": "2025-08-10T21:03:32+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Nit, but having to check for the filename twice feels a bit awkward.  I think this could be a little clearer with a match:\r\n\r\n```rust\r\nmatch (generate_opts.author_url, filename) {\r\n    (Some(url), \"package.json\" | \"pom.xml\") => replacement.replace(AUTHOR_URL_PLACEHOLDER, url),\r\n    (None, \"package.json\") => replacement.replace(AUTHOR_URL_PLACEHOLDER_JS, \"\"),\r\n    (None, \"pom.xml\") => replacement.replace(AUTHOR_URL_PLACEHOLDER_JAVA, \"\"),\r\n    _ => {},\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2233582564",
    "pr_number": 4645,
    "pr_file": "crates/loader/src/loader.rs",
    "created_at": "2025-07-27T01:41:08+00:00",
    "commented_code": "path: &Path,\n         current_dir: &Path,\n         scope: Option<&str>,\n+        // path to dynamic library, name of language\n+        lib_info: Option<&(&Path, &str)>,\n     ) -> Result<Language> {\n-        if let Some(scope) = scope {\n+        if let Some((lib_path, language_name)) = lib_info {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "2233582564",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4645,
        "pr_file": "crates/loader/src/loader.rs",
        "discussion_id": "2233582564",
        "commented_code": "@@ -1410,8 +1407,27 @@ impl Loader {\n         path: &Path,\n         current_dir: &Path,\n         scope: Option<&str>,\n+        // path to dynamic library, name of language\n+        lib_info: Option<&(&Path, &str)>,\n     ) -> Result<Language> {\n-        if let Some(scope) = scope {\n+        if let Some((lib_path, language_name)) = lib_info {",
        "comment_created_at": "2025-07-27T01:41:08+00:00",
        "comment_author": "WillLillis",
        "comment_body": "This logic is marginally adapted from the end of `Loader::load_language_at_path_with_name`. It may make sense to pull this logic into a helper for `Loader` so it can live in one place.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1788685888",
    "pr_number": 3740,
    "pr_file": "cli/src/parse.rs",
    "created_at": "2024-10-05T20:08:32+00:00",
    "commented_code": "let time = Instant::now();\n \n     #[inline(always)]\n-    fn is_utf16_bom(bom_bytes: &[u8]) -> bool {\n-        bom_bytes == [0xFF, 0xFE] || bom_bytes == [0xFE, 0xFF]\n+    fn is_utf16_le_bom(bom_bytes: &[u8]) -> bool {\n+        bom_bytes == [0xFF, 0xFE]\n     }\n \n+    #[inline(always)]\n+    fn is_utf16_be_bom(bom_bytes: &[u8]) -> bool {\n+        bom_bytes == [0xFE, 0xFF]\n+    }\n+\n+    // if encoding is none and it's got an LE or BE bom, assign to LE or BE\n+    opts.encoding = match opts.encoding {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1788685888",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3740,
        "pr_file": "cli/src/parse.rs",
        "discussion_id": "1788685888",
        "commented_code": "@@ -100,24 +100,43 @@ pub fn parse_file_at_path(parser: &mut Parser, opts: &ParseFileOptions) -> Resul\n     let time = Instant::now();\n \n     #[inline(always)]\n-    fn is_utf16_bom(bom_bytes: &[u8]) -> bool {\n-        bom_bytes == [0xFF, 0xFE] || bom_bytes == [0xFE, 0xFF]\n+    fn is_utf16_le_bom(bom_bytes: &[u8]) -> bool {\n+        bom_bytes == [0xFF, 0xFE]\n     }\n \n+    #[inline(always)]\n+    fn is_utf16_be_bom(bom_bytes: &[u8]) -> bool {\n+        bom_bytes == [0xFE, 0xFF]\n+    }\n+\n+    // if encoding is none and it's got an LE or BE bom, assign to LE or BE\n+    opts.encoding = match opts.encoding {",
        "comment_created_at": "2024-10-05T20:08:32+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Nitpick, but would it be better to assign the chosen encoding to a local here and pass `opts` as an immutable reference? Doesn't seem to make a difference in performance (tried with some large and small files) but imo does help with readability (since that's the only part of the struct being modified).\r\n\r\n\r\n<details>\r\n<summary>Bench</summary>\r\n\r\n![image](https://github.com/user-attachments/assets/8d135b73-fe53-44ad-a483-c7c62e41aca5)\r\n\r\n</details>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1902185749",
    "pr_number": 4048,
    "pr_file": "cli/src/main.rs",
    "created_at": "2025-01-03T21:36:55+00:00",
    "commented_code": "parse_theme: &parse_theme,\n             };\n \n-            let parse_result = parse::parse_file_at_path(&mut parser, &opts)?;\n+            let parse_result = parse::parse_file_at_path(&mut parser, &mut opts)?;\n+            let last_summary = stats.parse_summaries.last_mut().unwrap();\n+            last_summary.successful = parse_result.successful;\n+            last_summary.duration = parse_result.duration;\n+            last_summary.bytes = Some(parse_result.bytes as u128);",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1902185749",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4048,
        "pr_file": "cli/src/main.rs",
        "discussion_id": "1902185749",
        "commented_code": "@@ -906,24 +911,31 @@ impl Parse {\n                 parse_theme: &parse_theme,\n             };\n \n-            let parse_result = parse::parse_file_at_path(&mut parser, &opts)?;\n+            let parse_result = parse::parse_file_at_path(&mut parser, &mut opts)?;\n+            let last_summary = stats.parse_summaries.last_mut().unwrap();\n+            last_summary.successful = parse_result.successful;\n+            last_summary.duration = parse_result.duration;\n+            last_summary.bytes = Some(parse_result.bytes as u128);",
        "comment_created_at": "2025-01-03T21:36:55+00:00",
        "comment_author": "amaanq",
        "comment_body": "We don't need to duplicate data, since we're mutating the summary data inside `parse_file_at_path`, why not just have that return a Result of the unit type, set the fields `successful`, `duration`, and `bytes` inside that call, and then use *that* data later on when updating the cumulative stats? This way we avoid a couple things:\r\n\r\n- two sources of truth (error prone to updates)\r\n- two sites of mutation",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1901452035",
    "pr_number": 4054,
    "pr_file": "cli/src/query.rs",
    "created_at": "2025-01-03T04:07:20+00:00",
    "commented_code": "#[allow(clippy::too_many_arguments)]\n pub fn query_files_at_paths(\n     language: &Language,\n-    paths: Vec<String>,\n+    paths: &Vec<String>,\n     query_path: &Path,\n     ordered_captures: bool,\n     byte_range: Option<Range<usize>>,\n     point_range: Option<Range<Point>>,\n     should_test: bool,\n     quiet: bool,\n     print_time: bool,\n+    stdin: bool,",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1901452035",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4054,
        "pr_file": "cli/src/query.rs",
        "discussion_id": "1901452035",
        "commented_code": "@@ -19,14 +19,15 @@ use crate::{\n #[allow(clippy::too_many_arguments)]\n pub fn query_files_at_paths(\n     language: &Language,\n-    paths: Vec<String>,\n+    paths: &Vec<String>,\n     query_path: &Path,\n     ordered_captures: bool,\n     byte_range: Option<Range<usize>>,\n     point_range: Option<Range<Point>>,\n     should_test: bool,\n     quiet: bool,\n     print_time: bool,\n+    stdin: bool,",
        "comment_created_at": "2025-01-03T04:07:20+00:00",
        "comment_author": "amaanq",
        "comment_body": "this is getting a bit unruly, can we refactor this to move these parameters into a `QueryFileOptions` struct, similar to the `ParseFileOptions` for the parse subcommand?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1901454122",
    "pr_number": 4054,
    "pr_file": "cli/src/main.rs",
    "created_at": "2025-01-03T04:15:14+00:00",
    "commented_code": "let timeout = self.timeout.unwrap_or_default();\n \n-        let (paths, language) = if let Some(target_test) = self.test_number {\n+        let (paths, language, parse_stdin) = if let Some(target_test) = self.test_number {\n             let (test_path, language_names) = test::get_tmp_test_file(target_test, color)?;\n             let languages = loader.languages_at_path(current_dir)?;\n             let language = languages\n                 .iter()\n                 .find(|(_, n)| language_names.contains(&Box::from(n.as_str())))\n                 .map(|(l, _)| l.clone());\n-            let paths = collect_paths(None, Some(vec![test_path.to_str().unwrap().to_owned()]))?;\n-            (paths, language)\n+            let paths =\n+                collect_paths(None, Some(vec![test_path.to_str().unwrap().to_owned()]))?.unwrap();\n+            (paths, language, false)\n         } else {\n-            (collect_paths(self.paths_file.as_deref(), self.paths)?, None)\n+            (\n+                if let Some(collected) = collect_paths(self.paths_file.as_deref(), self.paths)? {\n+                    collected\n+                } else {\n+                    vec![get_tmp_parse_file()?.to_str().unwrap().to_owned()]\n+                },\n+                None,\n+                true,\n+            )",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1901454122",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4054,
        "pr_file": "cli/src/main.rs",
        "discussion_id": "1901454122",
        "commented_code": "@@ -853,17 +853,26 @@ impl Parse {\n \n         let timeout = self.timeout.unwrap_or_default();\n \n-        let (paths, language) = if let Some(target_test) = self.test_number {\n+        let (paths, language, parse_stdin) = if let Some(target_test) = self.test_number {\n             let (test_path, language_names) = test::get_tmp_test_file(target_test, color)?;\n             let languages = loader.languages_at_path(current_dir)?;\n             let language = languages\n                 .iter()\n                 .find(|(_, n)| language_names.contains(&Box::from(n.as_str())))\n                 .map(|(l, _)| l.clone());\n-            let paths = collect_paths(None, Some(vec![test_path.to_str().unwrap().to_owned()]))?;\n-            (paths, language)\n+            let paths =\n+                collect_paths(None, Some(vec![test_path.to_str().unwrap().to_owned()]))?.unwrap();\n+            (paths, language, false)\n         } else {\n-            (collect_paths(self.paths_file.as_deref(), self.paths)?, None)\n+            (\n+                if let Some(collected) = collect_paths(self.paths_file.as_deref(), self.paths)? {\n+                    collected\n+                } else {\n+                    vec![get_tmp_parse_file()?.to_str().unwrap().to_owned()]\n+                },\n+                None,\n+                true,\n+            )",
        "comment_created_at": "2025-01-03T04:15:14+00:00",
        "comment_author": "amaanq",
        "comment_body": "can you hoist out the paths into its own variable above the tuple construction? This feels a bit unruly and messy...also, there's a repeated habit of calling `get_tmp_parse_file()?.to_str().unwrap().to_owned()`, and `get_tmp_parse_file()` isn't using its path besides to convert it as a string, so we should move that logic into `get_tmp_parse_file` and have it return a String, so in the end we have something like this:\r\n\r\n```suggestion\r\n            let paths =\r\n                if let Some(collected) = collect_paths(self.paths_file.as_deref(), self.paths)? {\r\n                    collected\r\n                } else {\r\n                    vec![get_tmp_parse_file()?]\r\n                };\r\n            (paths, None, true)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861122960",
    "pr_number": 3927,
    "pr_file": "cli/src/query_testing.rs",
    "created_at": "2024-11-27T18:49:42+00:00",
    "commented_code": "let mut has_arrow = false;\n                         let mut negative = false;\n                         let mut arrow_end = 0;\n+                        let mut arrow_count = 0;\n                         for (i, c) in text.char_indices() {\n                             arrow_end = i + 1;\n                             if c == '-' && has_left_caret {\n                                 has_arrow = true;\n+                                arrow_count = 1;\n                                 break;\n                             }\n                             if c == '^' {\n                                 has_arrow = true;\n+                                arrow_count = 1;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1861122960",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3927,
        "pr_file": "cli/src/query_testing.rs",
        "discussion_id": "1861122960",
        "commented_code": "@@ -117,15 +120,26 @@ pub fn parse_position_comments(\n                         let mut has_arrow = false;\n                         let mut negative = false;\n                         let mut arrow_end = 0;\n+                        let mut arrow_count = 0;\n                         for (i, c) in text.char_indices() {\n                             arrow_end = i + 1;\n                             if c == '-' && has_left_caret {\n                                 has_arrow = true;\n+                                arrow_count = 1;\n                                 break;\n                             }\n                             if c == '^' {\n                                 has_arrow = true;\n+                                arrow_count = 1;",
        "comment_created_at": "2024-11-27T18:49:42+00:00",
        "comment_author": "amaanq",
        "comment_body": "nit, since we check `has_arrow` later before we make an `Assertion`, I think we can just set `arrow_count` to 1 at the beginning\r\n\r\n```suggestion\r\n                        let mut arrow_count = 1;\r\n                        for (i, c) in text.char_indices() {\r\n                            arrow_end = i + 1;\r\n                            if c == '-' && has_left_caret {\r\n                                has_arrow = true;\r\n                                break;\r\n                            }\r\n                            if c == '^' {\r\n                                has_arrow = true;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1861140745",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3927,
        "pr_file": "cli/src/query_testing.rs",
        "discussion_id": "1861122960",
        "commented_code": "@@ -117,15 +120,26 @@ pub fn parse_position_comments(\n                         let mut has_arrow = false;\n                         let mut negative = false;\n                         let mut arrow_end = 0;\n+                        let mut arrow_count = 0;\n                         for (i, c) in text.char_indices() {\n                             arrow_end = i + 1;\n                             if c == '-' && has_left_caret {\n                                 has_arrow = true;\n+                                arrow_count = 1;\n                                 break;\n                             }\n                             if c == '^' {\n                                 has_arrow = true;\n+                                arrow_count = 1;",
        "comment_created_at": "2024-11-27T19:08:08+00:00",
        "comment_author": "novusnota",
        "comment_body": "Sure. My code explicitly set `arrow_count` to 1 only next to `has_arrow` just so one won't accidentally mess up the logic returning to this later on. But let's go with your suggestion :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1835518758",
    "pr_number": 3897,
    "pr_file": "cli/loader/src/lib.rs",
    "created_at": "2024-11-09T20:31:24+00:00",
    "commented_code": ") -> Result<&[LanguageConfiguration]> {\n         let initial_language_configuration_count = self.language_configurations.len();\n \n-        if let Some(config) = TreeSitterJSON::from_file(parser_path) {\n+        let ts_json = TreeSitterJSON::from_file(parser_path);\n+        if let Ok(config) = ts_json {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1835518758",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3897,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1835518758",
        "commented_code": "@@ -1112,7 +1113,8 @@ impl Loader {\n     ) -> Result<&[LanguageConfiguration]> {\n         let initial_language_configuration_count = self.language_configurations.len();\n \n-        if let Some(config) = TreeSitterJSON::from_file(parser_path) {\n+        let ts_json = TreeSitterJSON::from_file(parser_path);\n+        if let Ok(config) = ts_json {",
        "comment_created_at": "2024-11-09T20:31:24+00:00",
        "comment_author": "amaanq",
        "comment_body": "~~why split it up?~~ nvm I see",
        "pr_file_module": null
      },
      {
        "comment_id": "1835519018",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3897,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1835518758",
        "commented_code": "@@ -1112,7 +1113,8 @@ impl Loader {\n     ) -> Result<&[LanguageConfiguration]> {\n         let initial_language_configuration_count = self.language_configurations.len();\n \n-        if let Some(config) = TreeSitterJSON::from_file(parser_path) {\n+        let ts_json = TreeSitterJSON::from_file(parser_path);\n+        if let Ok(config) = ts_json {",
        "comment_created_at": "2024-11-09T20:32:37+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Not sure how to access the `Err` value in the else block without calling `from_file` twice.",
        "pr_file_module": null
      },
      {
        "comment_id": "1835520065",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3897,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1835518758",
        "commented_code": "@@ -1112,7 +1113,8 @@ impl Loader {\n     ) -> Result<&[LanguageConfiguration]> {\n         let initial_language_configuration_count = self.language_configurations.len();\n \n-        if let Some(config) = TreeSitterJSON::from_file(parser_path) {\n+        let ts_json = TreeSitterJSON::from_file(parser_path);\n+        if let Ok(config) = ts_json {",
        "comment_created_at": "2024-11-09T20:36:44+00:00",
        "comment_author": "amaanq",
        "comment_body": "yeah this is fine, the diff w/ the match arms felt chaotic, and I'd rather not nest such a large block too deeply. thanks :slightly_smiling_face:",
        "pr_file_module": null
      },
      {
        "comment_id": "1835527674",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3897,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1835518758",
        "commented_code": "@@ -1112,7 +1113,8 @@ impl Loader {\n     ) -> Result<&[LanguageConfiguration]> {\n         let initial_language_configuration_count = self.language_configurations.len();\n \n-        if let Some(config) = TreeSitterJSON::from_file(parser_path) {\n+        let ts_json = TreeSitterJSON::from_file(parser_path);\n+        if let Ok(config) = ts_json {",
        "comment_created_at": "2024-11-09T21:11:43+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Makes perfect sense. I tend to nest stuff way too deeply and need to start catching that sooner, appreciate it :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797490136",
    "pr_number": 3762,
    "pr_file": "cli/src/parse.rs",
    "created_at": "2024-10-11T23:19:36+00:00",
    "commented_code": "}\n }\n \n+#[derive(Debug, Copy, Clone)]\n+pub struct ParseTheme {\n+    pub node_kind: Option<Color>,\n+    pub node_text: Option<Color>,\n+    pub field: Option<Color>,\n+    pub token: Option<Color>,\n+    pub row_color: Option<Color>,\n+    pub row_color_named: Option<Color>,\n+    pub extra: Option<Color>,\n+    pub error: Option<Color>,\n+}\n+\n+impl ParseTheme {\n+    #[must_use]\n+    pub const fn blank() -> Self {\n+        Self {\n+            node_kind: None,\n+            node_text: None,\n+            field: None,\n+            token: None,\n+            row_color: None,\n+            row_color_named: None,\n+            extra: None,\n+            error: None,\n+        }\n+    }\n+}\n+\n+impl Default for ParseTheme {\n+    fn default() -> Self {\n+        const GRAY: Color = Color::Rgb(RgbColor(118, 118, 118));\n+        Self {\n+            node_kind: Some(AnsiColor::BrightCyan.into()),\n+            node_text: Some(GRAY),\n+            field: Some(AnsiColor::Blue.into()),\n+            token: Some(GRAY),\n+            row_color: Some(AnsiColor::White.into()),\n+            row_color_named: Some(AnsiColor::BrightYellow.into()),\n+            extra: Some(AnsiColor::BrightMagenta.into()),\n+            error: Some(AnsiColor::Red.into()),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Deserialize, Serialize)]\n+pub struct Rgb(pub u8, pub u8, pub u8);\n+\n+impl From<Rgb> for RgbColor {\n+    fn from(val: Rgb) -> Self {\n+        Self(val.0, val.1, val.2)\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub struct Config {\n+    pub parse_theme: ParseThemeRaw,\n+}\n+\n+#[derive(Debug, Copy, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub struct ParseThemeRaw {\n+    pub node_kind: Option<Rgb>,\n+    pub node_text: Option<Rgb>,\n+    pub field: Option<Rgb>,\n+    pub token: Option<Rgb>,\n+    pub row_color: Option<Rgb>,\n+    pub row_color_named: Option<Rgb>,\n+    pub extra: Option<Rgb>,\n+    pub error: Option<Rgb>,\n+}\n+\n+impl From<ParseThemeRaw> for ParseTheme {\n+    fn from(value: ParseThemeRaw) -> Self {\n+        let resolve_val = |val: Option<Rgb>, default: Option<Color>| -> Option<Color> {\n+            val.map_or_else(|| default, |v| Some(Into::<RgbColor>::into(v).into()))\n+        };\n+        let default = Self::default();\n+\n+        Self {\n+            node_kind: resolve_val(value.node_kind, default.node_kind),\n+            node_text: resolve_val(value.node_text, default.node_text),\n+            field: resolve_val(value.field, default.field),\n+            token: resolve_val(value.token, default.token),\n+            row_color: resolve_val(value.row_color, default.row_color),\n+            row_color_named: resolve_val(value.row_color_named, default.row_color_named),\n+            extra: resolve_val(value.extra, default.extra),\n+            error: resolve_val(value.error, default.error),\n+        }",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1797490136",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3762,
        "pr_file": "cli/src/parse.rs",
        "discussion_id": "1797490136",
        "commented_code": "@@ -39,11 +42,104 @@ impl fmt::Display for Stats {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+pub struct ParseTheme {\n+    pub node_kind: Option<Color>,\n+    pub node_text: Option<Color>,\n+    pub field: Option<Color>,\n+    pub token: Option<Color>,\n+    pub row_color: Option<Color>,\n+    pub row_color_named: Option<Color>,\n+    pub extra: Option<Color>,\n+    pub error: Option<Color>,\n+}\n+\n+impl ParseTheme {\n+    #[must_use]\n+    pub const fn blank() -> Self {\n+        Self {\n+            node_kind: None,\n+            node_text: None,\n+            field: None,\n+            token: None,\n+            row_color: None,\n+            row_color_named: None,\n+            extra: None,\n+            error: None,\n+        }\n+    }\n+}\n+\n+impl Default for ParseTheme {\n+    fn default() -> Self {\n+        const GRAY: Color = Color::Rgb(RgbColor(118, 118, 118));\n+        Self {\n+            node_kind: Some(AnsiColor::BrightCyan.into()),\n+            node_text: Some(GRAY),\n+            field: Some(AnsiColor::Blue.into()),\n+            token: Some(GRAY),\n+            row_color: Some(AnsiColor::White.into()),\n+            row_color_named: Some(AnsiColor::BrightYellow.into()),\n+            extra: Some(AnsiColor::BrightMagenta.into()),\n+            error: Some(AnsiColor::Red.into()),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Deserialize, Serialize)]\n+pub struct Rgb(pub u8, pub u8, pub u8);\n+\n+impl From<Rgb> for RgbColor {\n+    fn from(val: Rgb) -> Self {\n+        Self(val.0, val.1, val.2)\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub struct Config {\n+    pub parse_theme: ParseThemeRaw,\n+}\n+\n+#[derive(Debug, Copy, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub struct ParseThemeRaw {\n+    pub node_kind: Option<Rgb>,\n+    pub node_text: Option<Rgb>,\n+    pub field: Option<Rgb>,\n+    pub token: Option<Rgb>,\n+    pub row_color: Option<Rgb>,\n+    pub row_color_named: Option<Rgb>,\n+    pub extra: Option<Rgb>,\n+    pub error: Option<Rgb>,\n+}\n+\n+impl From<ParseThemeRaw> for ParseTheme {\n+    fn from(value: ParseThemeRaw) -> Self {\n+        let resolve_val = |val: Option<Rgb>, default: Option<Color>| -> Option<Color> {\n+            val.map_or_else(|| default, |v| Some(Into::<RgbColor>::into(v).into()))\n+        };\n+        let default = Self::default();\n+\n+        Self {\n+            node_kind: resolve_val(value.node_kind, default.node_kind),\n+            node_text: resolve_val(value.node_text, default.node_text),\n+            field: resolve_val(value.field, default.field),\n+            token: resolve_val(value.token, default.token),\n+            row_color: resolve_val(value.row_color, default.row_color),\n+            row_color_named: resolve_val(value.row_color_named, default.row_color_named),\n+            extra: resolve_val(value.extra, default.extra),\n+            error: resolve_val(value.error, default.error),\n+        }",
        "comment_created_at": "2024-10-11T23:19:36+00:00",
        "comment_author": "amaanq",
        "comment_body": "two nits - `val_or_default` is a better name imo, and the `Into` chain is a bit crazy\r\n\r\n```suggestion\r\n        let val_or_default = |val: Option<Rgb>, default: Option<Color>| -> Option<Color> {\r\n            val.map_or(default, |v| Some(Color::Rgb(v.into())))\r\n        };\r\n        let default = Self::default();\r\n\r\n        Self {\r\n            node_kind: val_or_default(value.node_kind, default.node_kind),\r\n            node_text: val_or_default(value.node_text, default.node_text),\r\n            field: val_or_default(value.field, default.field),\r\n            token: val_or_default(value.token, default.token),\r\n            row_color: val_or_default(value.row_color, default.row_color),\r\n            row_color_named: val_or_default(value.row_color_named, default.row_color_named),\r\n            extra: val_or_default(value.extra, default.extra),\r\n            error: val_or_default(value.error, default.error),\r\n        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1797512674",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3762,
        "pr_file": "cli/src/parse.rs",
        "discussion_id": "1797490136",
        "commented_code": "@@ -39,11 +42,104 @@ impl fmt::Display for Stats {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+pub struct ParseTheme {\n+    pub node_kind: Option<Color>,\n+    pub node_text: Option<Color>,\n+    pub field: Option<Color>,\n+    pub token: Option<Color>,\n+    pub row_color: Option<Color>,\n+    pub row_color_named: Option<Color>,\n+    pub extra: Option<Color>,\n+    pub error: Option<Color>,\n+}\n+\n+impl ParseTheme {\n+    #[must_use]\n+    pub const fn blank() -> Self {\n+        Self {\n+            node_kind: None,\n+            node_text: None,\n+            field: None,\n+            token: None,\n+            row_color: None,\n+            row_color_named: None,\n+            extra: None,\n+            error: None,\n+        }\n+    }\n+}\n+\n+impl Default for ParseTheme {\n+    fn default() -> Self {\n+        const GRAY: Color = Color::Rgb(RgbColor(118, 118, 118));\n+        Self {\n+            node_kind: Some(AnsiColor::BrightCyan.into()),\n+            node_text: Some(GRAY),\n+            field: Some(AnsiColor::Blue.into()),\n+            token: Some(GRAY),\n+            row_color: Some(AnsiColor::White.into()),\n+            row_color_named: Some(AnsiColor::BrightYellow.into()),\n+            extra: Some(AnsiColor::BrightMagenta.into()),\n+            error: Some(AnsiColor::Red.into()),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Deserialize, Serialize)]\n+pub struct Rgb(pub u8, pub u8, pub u8);\n+\n+impl From<Rgb> for RgbColor {\n+    fn from(val: Rgb) -> Self {\n+        Self(val.0, val.1, val.2)\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub struct Config {\n+    pub parse_theme: ParseThemeRaw,\n+}\n+\n+#[derive(Debug, Copy, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub struct ParseThemeRaw {\n+    pub node_kind: Option<Rgb>,\n+    pub node_text: Option<Rgb>,\n+    pub field: Option<Rgb>,\n+    pub token: Option<Rgb>,\n+    pub row_color: Option<Rgb>,\n+    pub row_color_named: Option<Rgb>,\n+    pub extra: Option<Rgb>,\n+    pub error: Option<Rgb>,\n+}\n+\n+impl From<ParseThemeRaw> for ParseTheme {\n+    fn from(value: ParseThemeRaw) -> Self {\n+        let resolve_val = |val: Option<Rgb>, default: Option<Color>| -> Option<Color> {\n+            val.map_or_else(|| default, |v| Some(Into::<RgbColor>::into(v).into()))\n+        };\n+        let default = Self::default();\n+\n+        Self {\n+            node_kind: resolve_val(value.node_kind, default.node_kind),\n+            node_text: resolve_val(value.node_text, default.node_text),\n+            field: resolve_val(value.field, default.field),\n+            token: resolve_val(value.token, default.token),\n+            row_color: resolve_val(value.row_color, default.row_color),\n+            row_color_named: resolve_val(value.row_color_named, default.row_color_named),\n+            extra: resolve_val(value.extra, default.extra),\n+            error: resolve_val(value.error, default.error),\n+        }",
        "comment_created_at": "2024-10-12T00:53:20+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Yeah I definitely felt a little weird writing that many `into`s, much happier with this version",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1696461969",
    "pr_number": 3502,
    "pr_file": "cli/src/test.rs",
    "created_at": "2024-07-30T07:30:57+00:00",
    "commented_code": "}\n                 } else {\n                     let mut actual = tree.root_node().to_sexp();\n-                    if !has_fields {\n+                    let show_fields = opts.show_fields || has_fields;\n+\n+                    if !show_fields {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1696461969",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3502,
        "pr_file": "cli/src/test.rs",
        "discussion_id": "1696461969",
        "commented_code": "@@ -388,7 +389,9 @@ fn run_tests(\n                     }\n                 } else {\n                     let mut actual = tree.root_node().to_sexp();\n-                    if !has_fields {\n+                    let show_fields = opts.show_fields || has_fields;\n+\n+                    if !show_fields {",
        "comment_created_at": "2024-07-30T07:30:57+00:00",
        "comment_author": "ObserverOfTime",
        "comment_body": "```suggestion\r\n                    if !(opts.show_fields || has_fields) {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1199672869",
    "pr_number": 2278,
    "pr_file": "lib/binding_rust/lib.rs",
    "created_at": "2023-05-20T23:38:38+00:00",
    "commented_code": "self\n     }\n \n+    /// Set the maximum start depth for a cursor.\n+    ///\n+    /// This prevents cursors from exploring children nodes at a certain depth.\n+    /// Note if a pattern includes many children, then they will still be checked.\n+    ///\n+    /// The zero max depth value can be used as a special behavior and help to _destructure_\n+    /// a subtree by staying on a node and using captures for interested parts.\n+    ///\n+    /// Set to `None` to remove the maximum start depth.\n     #[doc(alias = \"ts_query_cursor_set_max_start_depth\")]\n-    pub fn set_max_start_depth(&mut self, max_start_depth: u32) -> &mut Self {\n+    pub fn set_max_start_depth(&mut self, max_start_depth: Option<u32>) -> &mut Self {\n         unsafe {\n-            ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), max_start_depth);\n+            if let Some(depth) = max_start_depth {\n+                ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), depth);\n+            } else {\n+                ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), u32::MAX);\n+            }",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1199672869",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2278,
        "pr_file": "lib/binding_rust/lib.rs",
        "discussion_id": "1199672869",
        "commented_code": "@@ -1933,10 +1933,23 @@ impl QueryCursor {\n         self\n     }\n \n+    /// Set the maximum start depth for a cursor.\n+    ///\n+    /// This prevents cursors from exploring children nodes at a certain depth.\n+    /// Note if a pattern includes many children, then they will still be checked.\n+    ///\n+    /// The zero max depth value can be used as a special behavior and help to _destructure_\n+    /// a subtree by staying on a node and using captures for interested parts.\n+    ///\n+    /// Set to `None` to remove the maximum start depth.\n     #[doc(alias = \"ts_query_cursor_set_max_start_depth\")]\n-    pub fn set_max_start_depth(&mut self, max_start_depth: u32) -> &mut Self {\n+    pub fn set_max_start_depth(&mut self, max_start_depth: Option<u32>) -> &mut Self {\n         unsafe {\n-            ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), max_start_depth);\n+            if let Some(depth) = max_start_depth {\n+                ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), depth);\n+            } else {\n+                ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), u32::MAX);\n+            }",
        "comment_created_at": "2023-05-20T23:38:38+00:00",
        "comment_author": "smoelius",
        "comment_body": "You may prefer the above, but another way to write this could be:\r\n```rust\r\nffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), max_start_depth.unwrap_or(u32::MAX));\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1199770619",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2278,
        "pr_file": "lib/binding_rust/lib.rs",
        "discussion_id": "1199672869",
        "commented_code": "@@ -1933,10 +1933,23 @@ impl QueryCursor {\n         self\n     }\n \n+    /// Set the maximum start depth for a cursor.\n+    ///\n+    /// This prevents cursors from exploring children nodes at a certain depth.\n+    /// Note if a pattern includes many children, then they will still be checked.\n+    ///\n+    /// The zero max depth value can be used as a special behavior and help to _destructure_\n+    /// a subtree by staying on a node and using captures for interested parts.\n+    ///\n+    /// Set to `None` to remove the maximum start depth.\n     #[doc(alias = \"ts_query_cursor_set_max_start_depth\")]\n-    pub fn set_max_start_depth(&mut self, max_start_depth: u32) -> &mut Self {\n+    pub fn set_max_start_depth(&mut self, max_start_depth: Option<u32>) -> &mut Self {\n         unsafe {\n-            ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), max_start_depth);\n+            if let Some(depth) = max_start_depth {\n+                ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), depth);\n+            } else {\n+                ffi::ts_query_cursor_set_max_start_depth(self.ptr.as_ptr(), u32::MAX);\n+            }",
        "comment_created_at": "2023-05-21T13:51:03+00:00",
        "comment_author": "ahlinc",
        "comment_body": "Good point, thanks! The idea of writing functionally doesn't always cross my mind.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1285334032",
    "pr_number": 2474,
    "pr_file": "cli/src/generate/prepare_grammar/expand_tokens.rs",
    "created_at": "2023-08-07T02:54:00+00:00",
    "commented_code": "if class.negated {\n                         chars = chars.negate();\n                     }\n+                    if self.case_insensitive {\n+                        for char in chars.clone().chars() {\n+                            let inverted = inverse_char(char);\n+                            if char != inverted {\n+                                chars = chars.add_char(inverted);\n+                            }\n+                        }",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1285334032",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2474,
        "pr_file": "cli/src/generate/prepare_grammar/expand_tokens.rs",
        "discussion_id": "1285334032",
        "commented_code": "@@ -229,6 +249,14 @@ impl NfaBuilder {\n                     if class.negated {\n                         chars = chars.negate();\n                     }\n+                    if self.case_insensitive {\n+                        for char in chars.clone().chars() {\n+                            let inverted = inverse_char(char);\n+                            if char != inverted {\n+                                chars = chars.add_char(inverted);\n+                            }\n+                        }",
        "comment_created_at": "2023-08-07T02:54:00+00:00",
        "comment_author": "ahlinc",
        "comment_body": "I'd wrap this to something like `with_inverse_char(&chars, |inverted| chars = chars.add_char(inverted))` and avoid repetition in other places.",
        "pr_file_module": null
      }
    ]
  }
]