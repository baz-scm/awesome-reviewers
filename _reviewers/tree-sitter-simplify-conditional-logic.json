[
  {
    "discussion_id": "1667040815",
    "pr_number": 3450,
    "pr_file": "lib/src/query.c",
    "created_at": "2024-07-05T18:13:32+00:00",
    "commented_code": "point_gte(ts_node_start_point(parent_node), self->end_point)\n       );\n       bool node_precedes_range = parent_precedes_range || (\n-        ts_node_end_byte(node) <= self->start_byte ||\n-        point_lte(ts_node_end_point(node), self->start_point)\n+        (!is_empty && ts_node_end_byte(node) <= self->start_byte) ||\n+        (!is_empty && point_lte(ts_node_end_point(node), self->start_point))",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1667040815",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3450,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1667040815",
        "commented_code": "@@ -3541,8 +3542,8 @@ static inline bool ts_query_cursor__advance(\n         point_gte(ts_node_start_point(parent_node), self->end_point)\n       );\n       bool node_precedes_range = parent_precedes_range || (\n-        ts_node_end_byte(node) <= self->start_byte ||\n-        point_lte(ts_node_end_point(node), self->start_point)\n+        (!is_empty && ts_node_end_byte(node) <= self->start_byte) ||\n+        (!is_empty && point_lte(ts_node_end_point(node), self->start_point))",
        "comment_created_at": "2024-07-05T18:13:32+00:00",
        "comment_author": "NinoScript",
        "comment_body": "I believe it would be clearer if you factor `is_empty` out of those conditions\r\n```suggestion\r\n        !is_empty && (\r\n          ts_node_end_byte(node) <= self->start_byte ||\r\n          point_lte(ts_node_end_point(node), self->start_point))\r\n```\r\n(but feel free to disregard if you don't agree)",
        "pr_file_module": null
      },
      {
        "comment_id": "1667063260",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3450,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1667040815",
        "commented_code": "@@ -3541,8 +3542,8 @@ static inline bool ts_query_cursor__advance(\n         point_gte(ts_node_start_point(parent_node), self->end_point)\n       );\n       bool node_precedes_range = parent_precedes_range || (\n-        ts_node_end_byte(node) <= self->start_byte ||\n-        point_lte(ts_node_end_point(node), self->start_point)\n+        (!is_empty && ts_node_end_byte(node) <= self->start_byte) ||\n+        (!is_empty && point_lte(ts_node_end_point(node), self->start_point))",
        "comment_created_at": "2024-07-05T18:55:31+00:00",
        "comment_author": "amaanq",
        "comment_body": "totally agree, thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "768158736",
    "pr_number": 1504,
    "pr_file": "lib/src/query.c",
    "created_at": "2021-12-13T22:06:33+00:00",
    "commented_code": "self->free_capture_list_count++;\n }\n \n+/**************\n+ * Quantifiers\n+ **************/\n+\n+static TSQuantifier quantifier_mul(\n+  TSQuantifier left,\n+  TSQuantifier right\n+) {\n+  TSQuantifier result = Zero; // initialized to make compiler happy, but all cases should be covered below!\n+  switch (left)\n+  {\n+    case Zero:\n+      result = Zero;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "768158736",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1504,
        "pr_file": "lib/src/query.c",
        "discussion_id": "768158736",
        "commented_code": "@@ -452,6 +458,296 @@ static void capture_list_pool_release(CaptureListPool *self, uint16_t id) {\n   self->free_capture_list_count++;\n }\n \n+/**************\n+ * Quantifiers\n+ **************/\n+\n+static TSQuantifier quantifier_mul(\n+  TSQuantifier left,\n+  TSQuantifier right\n+) {\n+  TSQuantifier result = Zero; // initialized to make compiler happy, but all cases should be covered below!\n+  switch (left)\n+  {\n+    case Zero:\n+      result = Zero;",
        "comment_created_at": "2021-12-13T22:06:33+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "What do you think of shortening these functions up a bit by removing the `result` variable, and using early return statements in each case?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "782329179",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1504,
        "pr_file": "lib/src/query.c",
        "discussion_id": "768158736",
        "commented_code": "@@ -452,6 +458,296 @@ static void capture_list_pool_release(CaptureListPool *self, uint16_t id) {\n   self->free_capture_list_count++;\n }\n \n+/**************\n+ * Quantifiers\n+ **************/\n+\n+static TSQuantifier quantifier_mul(\n+  TSQuantifier left,\n+  TSQuantifier right\n+) {\n+  TSQuantifier result = Zero; // initialized to make compiler happy, but all cases should be covered below!\n+  switch (left)\n+  {\n+    case Zero:\n+      result = Zero;",
        "comment_created_at": "2022-01-11T16:34:52+00:00",
        "comment_author": "hendrikvanantwerpen",
        "comment_body": "That is what I had at first, but the compiler kept complaining about a missing default case. Since there is no meaningful default, I wrote it like this, so the uninitialized state acts as a default. This default is never returned (bar invalid inputs) since the case is exhaustive. However, the compiler (in CI at least) wouldn't realize that \ud83e\udd37\ud83c\udffb.\r\n\r\nIf you prefer early returns, I can write it as such, use an arbitrary default value and add a big comment explaining that the default value is really meaningless.",
        "pr_file_module": null
      },
      {
        "comment_id": "782333007",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1504,
        "pr_file": "lib/src/query.c",
        "discussion_id": "768158736",
        "commented_code": "@@ -452,6 +458,296 @@ static void capture_list_pool_release(CaptureListPool *self, uint16_t id) {\n   self->free_capture_list_count++;\n }\n \n+/**************\n+ * Quantifiers\n+ **************/\n+\n+static TSQuantifier quantifier_mul(\n+  TSQuantifier left,\n+  TSQuantifier right\n+) {\n+  TSQuantifier result = Zero; // initialized to make compiler happy, but all cases should be covered below!\n+  switch (left)\n+  {\n+    case Zero:\n+      result = Zero;",
        "comment_created_at": "2022-01-11T16:39:04+00:00",
        "comment_author": "hendrikvanantwerpen",
        "comment_body": "Actually, after rereading the code, I see that the result is not even uninitialized. I'll compact this a bit, then :+1:",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "774109503",
    "pr_number": 1504,
    "pr_file": "lib/src/query.c",
    "created_at": "2021-12-22T19:12:16+00:00",
    "commented_code": "stream_skip_whitespace(stream);\n \n     // Parse the pattern\n+    CaptureQuantifiers field_capture_quantifiers = capture_quantifiers_new();\n     TSQueryError e = ts_query__parse_pattern(\n       self,\n       stream,\n       depth,\n-      is_immediate\n+      is_immediate,\n+      &field_capture_quantifiers\n     );\n-    if (e == PARENT_DONE) return TSQueryErrorSyntax;\n-    if (e) return e;\n+    if (e == PARENT_DONE) {\n+      capture_quantifiers_delete(&field_capture_quantifiers);\n+      return TSQueryErrorSyntax;\n+    }\n+    if (e) {\n+      capture_quantifiers_delete(&field_capture_quantifiers);\n+      return e;\n+    }",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "774109503",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1504,
        "pr_file": "lib/src/query.c",
        "discussion_id": "774109503",
        "commented_code": "@@ -1975,14 +2311,22 @@ static TSQueryError ts_query__parse_pattern(\n     stream_skip_whitespace(stream);\n \n     // Parse the pattern\n+    CaptureQuantifiers field_capture_quantifiers = capture_quantifiers_new();\n     TSQueryError e = ts_query__parse_pattern(\n       self,\n       stream,\n       depth,\n-      is_immediate\n+      is_immediate,\n+      &field_capture_quantifiers\n     );\n-    if (e == PARENT_DONE) return TSQueryErrorSyntax;\n-    if (e) return e;\n+    if (e == PARENT_DONE) {\n+      capture_quantifiers_delete(&field_capture_quantifiers);\n+      return TSQueryErrorSyntax;\n+    }\n+    if (e) {\n+      capture_quantifiers_delete(&field_capture_quantifiers);\n+      return e;\n+    }",
        "comment_created_at": "2021-12-22T19:12:16+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Maybe now it'd be cleaner to unify these two conditionals:\r\n\r\n```c\r\nif (e) {\r\n  capture_quantifiers_delete(&field_capture_quantifiers);\r\n  if (e == PARENT_DONE) e = TSQueryErrorSyntax;\r\n  return e;\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "799091288",
    "pr_number": 1637,
    "pr_file": "lib/src/lexer.c",
    "created_at": "2022-02-04T01:05:34+00:00",
    "commented_code": "static uint32_t ts_lexer__get_column(TSLexer *_self) {\n   Lexer *self = (Lexer *)_self;\n   \n-  uint32_t goal_byte = self->current_position.bytes;\n-  \n   self->did_get_column = true;\n-  self->current_position.bytes -= self->current_position.extent.column;\n-  self->current_position.extent.column = 0;\n-\n-  if (self->current_position.bytes < self->chunk_start) {\n-    ts_lexer__get_chunk(self);\n-  }\n \n   uint32_t result = 0;\n-  ts_lexer__get_lookahead(self);\n-  while (self->current_position.bytes < goal_byte && !ts_lexer__eof(_self) && self->chunk) {\n-    ts_lexer__do_advance(self, false);\n-    result++;\n-  }\n+  if (!ts_lexer__try_get_cached_column_value(self, &result)) {\n+    uint32_t goal_byte = self->current_position.bytes;\n+    \n+    self->current_position.bytes -= self->current_position.extent.column;\n+    self->current_position.extent.column = 0;\n \n+    if (self->current_position.bytes < self->chunk_start) {\n+      ts_lexer__get_chunk(self);\n+    }\n+\n+    result = 0;\n+    ts_lexer__get_lookahead(self);\n+    \n+    // Don't count BOM in column position\n+    if (\n+      self->current_position.bytes == 0 &&\n+      self->data.lookahead == BYTE_ORDER_MARK\n+    ) ts_lexer__do_advance(self, false, false);\n+\n+    while (self->current_position.bytes < goal_byte && !ts_lexer__eof(_self) && self->chunk) {\n+      ts_lexer__do_advance(self, false, false);\n+      result++;\n+    }\n+\n+    ts_lexer__set_column_cache(self, result);\n+  }",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "799091288",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1637,
        "pr_file": "lib/src/lexer.c",
        "discussion_id": "799091288",
        "commented_code": "@@ -239,23 +289,36 @@ static void ts_lexer__mark_end(TSLexer *_self) {\n static uint32_t ts_lexer__get_column(TSLexer *_self) {\n   Lexer *self = (Lexer *)_self;\n   \n-  uint32_t goal_byte = self->current_position.bytes;\n-  \n   self->did_get_column = true;\n-  self->current_position.bytes -= self->current_position.extent.column;\n-  self->current_position.extent.column = 0;\n-\n-  if (self->current_position.bytes < self->chunk_start) {\n-    ts_lexer__get_chunk(self);\n-  }\n \n   uint32_t result = 0;\n-  ts_lexer__get_lookahead(self);\n-  while (self->current_position.bytes < goal_byte && !ts_lexer__eof(_self) && self->chunk) {\n-    ts_lexer__do_advance(self, false);\n-    result++;\n-  }\n+  if (!ts_lexer__try_get_cached_column_value(self, &result)) {\n+    uint32_t goal_byte = self->current_position.bytes;\n+    \n+    self->current_position.bytes -= self->current_position.extent.column;\n+    self->current_position.extent.column = 0;\n \n+    if (self->current_position.bytes < self->chunk_start) {\n+      ts_lexer__get_chunk(self);\n+    }\n+\n+    result = 0;\n+    ts_lexer__get_lookahead(self);\n+    \n+    // Don't count BOM in column position\n+    if (\n+      self->current_position.bytes == 0 &&\n+      self->data.lookahead == BYTE_ORDER_MARK\n+    ) ts_lexer__do_advance(self, false, false);\n+\n+    while (self->current_position.bytes < goal_byte && !ts_lexer__eof(_self) && self->chunk) {\n+      ts_lexer__do_advance(self, false, false);\n+      result++;\n+    }\n+\n+    ts_lexer__set_column_cache(self, result);\n+  }",
        "comment_created_at": "2022-02-04T01:05:34+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think that you simplify this code a little bit. I would suggest:\r\n\r\n1. Eliminating the `update_column_cache` parameter to `ts_lexer__do_advance`. Just have that method *always* update the column cache.\r\n\r\n2. Restructure this `ts_lexer__get_column` function so that it just populates the column cache if necessary, using the normal code path, and then returns its value:\r\n\r\n```c\r\nstatic uint32_t ts_lexer__get_column(TSLexer *_self) {\r\n  Lexer *self = (Lexer *)_self;\r\n  self->did_get_column = true;\r\n\r\n  if (!self->column_cache.valid) {\r\n    uint32_t goal_byte = self->current_position.bytes;\r\n\r\n    // back up to the beginning of the line\r\n    self->current_position.bytes -= self->current_position.extent.column;\r\n    self->current_position.extent.column = 0;\r\n    self->column_cache.valid = true;\r\n    self->column_cache.value = 0;\r\n\r\n    // advance back to the initial position\r\n    // ...\r\n  }\r\n  \r\n  return self->column_cache.value;\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]