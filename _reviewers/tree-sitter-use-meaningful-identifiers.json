[
  {
    "discussion_id": "537639873",
    "pr_number": 837,
    "pr_file": "lib/src/stack.c",
    "created_at": "2020-12-07T16:23:10+00:00",
    "commented_code": "#define MAX_ITERATOR_COUNT 64\n \n #if defined _WIN32 && !defined __GNUC__\n-#define inline __forceinline\n+#define force_inline __forceinline",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "537639873",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 837,
        "pr_file": "lib/src/stack.c",
        "discussion_id": "537639873",
        "commented_code": "@@ -12,9 +12,9 @@\n #define MAX_ITERATOR_COUNT 64\n \n #if defined _WIN32 && !defined __GNUC__\n-#define inline __forceinline\n+#define force_inline __forceinline",
        "comment_created_at": "2020-12-07T16:23:10+00:00",
        "comment_author": "patrickt",
        "comment_body": "It\u2019s technically invalid to override a keyword with a #define.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "782612527",
    "pr_number": 1581,
    "pr_file": "test/fixtures/test_grammars/external_unicode_column_alignment/scanner.c",
    "created_at": "2022-01-11T23:58:58+00:00",
    "commented_code": "+#include <tree_sitter/parser.h>\n+#include <wctype.h>\n+#include <string.h>\n+\n+enum {\n+  LIST_START,\n+  LIST_ITEM,\n+  LIST_END\n+};\n+\n+typedef struct {\n+  int32_t column;\n+} Scanner;\n+\n+void *tree_sitter_external_unicode_column_alignment_external_scanner_create() {\n+  Scanner *scanner = malloc(sizeof(Scanner));\n+  *scanner = (Scanner){\n+    .column = -1 \n+  };\n+  return scanner;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_destroy(void *payload) {\n+  free(payload);\n+}\n+\n+unsigned tree_sitter_external_unicode_column_alignment_external_scanner_serialize(\n+  void *payload,\n+  char *buffer\n+) {\n+  Scanner *scanner = payload;\n+  unsigned copied = sizeof(int32_t);\n+  memcpy(buffer, &(scanner->column), copied);\n+  return copied;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_deserialize(\n+  void *payload,\n+  const char *buffer,\n+  unsigned length\n+) {\n+  Scanner *scanner = payload;\n+  scanner->column = -1;\n+  if (length > 0) {\n+    memcpy(&(scanner->column), buffer, sizeof(int32_t));\n+  }\n+}\n+\n+bool tree_sitter_external_unicode_column_alignment_external_scanner_scan(\n+  void *payload,\n+  TSLexer *lexer,\n+  const bool *whitelist\n+) {\n+  Scanner *scanner = payload;\n+  // 9633 is the int equivalent of \u25a1 (U+25A1)\n+  while (iswspace(lexer->lookahead) || 9633 == lexer->lookahead) {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "782612527",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1581,
        "pr_file": "test/fixtures/test_grammars/external_unicode_column_alignment/scanner.c",
        "discussion_id": "782612527",
        "commented_code": "@@ -0,0 +1,85 @@\n+#include <tree_sitter/parser.h>\n+#include <wctype.h>\n+#include <string.h>\n+\n+enum {\n+  LIST_START,\n+  LIST_ITEM,\n+  LIST_END\n+};\n+\n+typedef struct {\n+  int32_t column;\n+} Scanner;\n+\n+void *tree_sitter_external_unicode_column_alignment_external_scanner_create() {\n+  Scanner *scanner = malloc(sizeof(Scanner));\n+  *scanner = (Scanner){\n+    .column = -1 \n+  };\n+  return scanner;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_destroy(void *payload) {\n+  free(payload);\n+}\n+\n+unsigned tree_sitter_external_unicode_column_alignment_external_scanner_serialize(\n+  void *payload,\n+  char *buffer\n+) {\n+  Scanner *scanner = payload;\n+  unsigned copied = sizeof(int32_t);\n+  memcpy(buffer, &(scanner->column), copied);\n+  return copied;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_deserialize(\n+  void *payload,\n+  const char *buffer,\n+  unsigned length\n+) {\n+  Scanner *scanner = payload;\n+  scanner->column = -1;\n+  if (length > 0) {\n+    memcpy(&(scanner->column), buffer, sizeof(int32_t));\n+  }\n+}\n+\n+bool tree_sitter_external_unicode_column_alignment_external_scanner_scan(\n+  void *payload,\n+  TSLexer *lexer,\n+  const bool *whitelist\n+) {\n+  Scanner *scanner = payload;\n+  // 9633 is the int equivalent of \u25a1 (U+25A1)\n+  while (iswspace(lexer->lookahead) || 9633 == lexer->lookahead) {",
        "comment_created_at": "2022-01-11T23:58:58+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Maybe write this integer in hexadecimal as `0x25A1`? It's probably still worth having a comment explaining that's the box character, but it would be slightly  more self-explanatory.",
        "pr_file_module": null
      },
      {
        "comment_id": "782616460",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1581,
        "pr_file": "test/fixtures/test_grammars/external_unicode_column_alignment/scanner.c",
        "discussion_id": "782612527",
        "commented_code": "@@ -0,0 +1,85 @@\n+#include <tree_sitter/parser.h>\n+#include <wctype.h>\n+#include <string.h>\n+\n+enum {\n+  LIST_START,\n+  LIST_ITEM,\n+  LIST_END\n+};\n+\n+typedef struct {\n+  int32_t column;\n+} Scanner;\n+\n+void *tree_sitter_external_unicode_column_alignment_external_scanner_create() {\n+  Scanner *scanner = malloc(sizeof(Scanner));\n+  *scanner = (Scanner){\n+    .column = -1 \n+  };\n+  return scanner;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_destroy(void *payload) {\n+  free(payload);\n+}\n+\n+unsigned tree_sitter_external_unicode_column_alignment_external_scanner_serialize(\n+  void *payload,\n+  char *buffer\n+) {\n+  Scanner *scanner = payload;\n+  unsigned copied = sizeof(int32_t);\n+  memcpy(buffer, &(scanner->column), copied);\n+  return copied;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_deserialize(\n+  void *payload,\n+  const char *buffer,\n+  unsigned length\n+) {\n+  Scanner *scanner = payload;\n+  scanner->column = -1;\n+  if (length > 0) {\n+    memcpy(&(scanner->column), buffer, sizeof(int32_t));\n+  }\n+}\n+\n+bool tree_sitter_external_unicode_column_alignment_external_scanner_scan(\n+  void *payload,\n+  TSLexer *lexer,\n+  const bool *whitelist\n+) {\n+  Scanner *scanner = payload;\n+  // 9633 is the int equivalent of \u25a1 (U+25A1)\n+  while (iswspace(lexer->lookahead) || 9633 == lexer->lookahead) {",
        "comment_created_at": "2022-01-12T00:09:00+00:00",
        "comment_author": "ahelwer",
        "comment_body": "I actually ran into a lot of difficulty with this, weirdly. Neither `L'\u25a1'` nor `'\u25a1'` worked, nor `'\\x25A1'`. Even stranger is that it works just fine in my grammar: https://github.com/tlaplus-community/tree-sitter-tlaplus/blob/26bbaf5d07356cacbf21defa9316988bc732c8b3/src/scanner.cc#L517",
        "pr_file_module": null
      },
      {
        "comment_id": "782617580",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1581,
        "pr_file": "test/fixtures/test_grammars/external_unicode_column_alignment/scanner.c",
        "discussion_id": "782612527",
        "commented_code": "@@ -0,0 +1,85 @@\n+#include <tree_sitter/parser.h>\n+#include <wctype.h>\n+#include <string.h>\n+\n+enum {\n+  LIST_START,\n+  LIST_ITEM,\n+  LIST_END\n+};\n+\n+typedef struct {\n+  int32_t column;\n+} Scanner;\n+\n+void *tree_sitter_external_unicode_column_alignment_external_scanner_create() {\n+  Scanner *scanner = malloc(sizeof(Scanner));\n+  *scanner = (Scanner){\n+    .column = -1 \n+  };\n+  return scanner;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_destroy(void *payload) {\n+  free(payload);\n+}\n+\n+unsigned tree_sitter_external_unicode_column_alignment_external_scanner_serialize(\n+  void *payload,\n+  char *buffer\n+) {\n+  Scanner *scanner = payload;\n+  unsigned copied = sizeof(int32_t);\n+  memcpy(buffer, &(scanner->column), copied);\n+  return copied;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_deserialize(\n+  void *payload,\n+  const char *buffer,\n+  unsigned length\n+) {\n+  Scanner *scanner = payload;\n+  scanner->column = -1;\n+  if (length > 0) {\n+    memcpy(&(scanner->column), buffer, sizeof(int32_t));\n+  }\n+}\n+\n+bool tree_sitter_external_unicode_column_alignment_external_scanner_scan(\n+  void *payload,\n+  TSLexer *lexer,\n+  const bool *whitelist\n+) {\n+  Scanner *scanner = payload;\n+  // 9633 is the int equivalent of \u25a1 (U+25A1)\n+  while (iswspace(lexer->lookahead) || 9633 == lexer->lookahead) {",
        "comment_created_at": "2022-01-12T00:11:41+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Not a single-quoted character literal; just the plain integer `0x25A1`.",
        "pr_file_module": null
      },
      {
        "comment_id": "782619222",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1581,
        "pr_file": "test/fixtures/test_grammars/external_unicode_column_alignment/scanner.c",
        "discussion_id": "782612527",
        "commented_code": "@@ -0,0 +1,85 @@\n+#include <tree_sitter/parser.h>\n+#include <wctype.h>\n+#include <string.h>\n+\n+enum {\n+  LIST_START,\n+  LIST_ITEM,\n+  LIST_END\n+};\n+\n+typedef struct {\n+  int32_t column;\n+} Scanner;\n+\n+void *tree_sitter_external_unicode_column_alignment_external_scanner_create() {\n+  Scanner *scanner = malloc(sizeof(Scanner));\n+  *scanner = (Scanner){\n+    .column = -1 \n+  };\n+  return scanner;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_destroy(void *payload) {\n+  free(payload);\n+}\n+\n+unsigned tree_sitter_external_unicode_column_alignment_external_scanner_serialize(\n+  void *payload,\n+  char *buffer\n+) {\n+  Scanner *scanner = payload;\n+  unsigned copied = sizeof(int32_t);\n+  memcpy(buffer, &(scanner->column), copied);\n+  return copied;\n+}\n+\n+void tree_sitter_external_unicode_column_alignment_external_scanner_deserialize(\n+  void *payload,\n+  const char *buffer,\n+  unsigned length\n+) {\n+  Scanner *scanner = payload;\n+  scanner->column = -1;\n+  if (length > 0) {\n+    memcpy(&(scanner->column), buffer, sizeof(int32_t));\n+  }\n+}\n+\n+bool tree_sitter_external_unicode_column_alignment_external_scanner_scan(\n+  void *payload,\n+  TSLexer *lexer,\n+  const bool *whitelist\n+) {\n+  Scanner *scanner = payload;\n+  // 9633 is the int equivalent of \u25a1 (U+25A1)\n+  while (iswspace(lexer->lookahead) || 9633 == lexer->lookahead) {",
        "comment_created_at": "2022-01-12T00:16:11+00:00",
        "comment_author": "ahelwer",
        "comment_body": "Ah sure, that works. I'll need to figure out the various ways of writing a codepoint and when they work/don't work eventually.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "780930143",
    "pr_number": 1578,
    "pr_file": "lib/src/query.c",
    "created_at": "2022-01-10T07:08:22+00:00",
    "commented_code": "return false;\n }\n \n+static inline AnalysisState *analysis_state__clone(AnalysisState const *self) {\n+  AnalysisState *new_state = ts_malloc(sizeof(AnalysisState));\n+  *new_state = *self;\n+  return new_state;\n+}\n+\n+/****************\n+ * AnalysisStateSet\n+ ****************/\n+\n+// Constructs an empty AnalysisStateSet.\n+static inline AnalysisStateSet analysis_state_set__new() {\n+  return ((AnalysisStateSet) {\n+    array_new()\n+  });\n+}\n+\n+// Returns the number of states present in this analysis state set.\n+static inline unsigned analysis_state_set__size(AnalysisStateSet *self) {\n+  return self->states.size;\n+}\n+\n+// Returns a pointer to the item at the passed-in position in this analysis state set. The state set\n+// retains ownership of the item at that index, meaning that the caller is not responsible for\n+// freeing it.\n+static inline AnalysisState **analysis_state_set__get(\n+  AnalysisStateSet *self,\n+  unsigned index\n+) {\n+  return &self->states.contents[index];\n+}\n+\n+// Returns a pointer to the item in the last position of this analysis state set. The state set\n+// retains ownership of the item at that index, meaning that the caller is not responsible for\n+// freeing it.\n+static inline AnalysisState **analysis_state_set__back(AnalysisStateSet *self) {\n+  return array_back(&self->states);\n+}\n+\n+// Inserts a clone of the passed-in item at the appropriate position to maintain ordering in this\n+// set. The set does not contain duplicates, so if the item is already present, it will not be\n+// inserted, and no clone will be made.\n+//\n+// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n+// function will be managed by the state set.\n+static inline void analysis_state_set__insert_sorted_by_clone(\n+  AnalysisStateSet *self,\n+  AnalysisState *borrowed_item\n+) {\n+  unsigned index, exists;\n+  array_search_sorted_with(&self->states, analysis_state__compare, &borrowed_item, &index, &exists);\n+  if (!exists) {\n+    AnalysisState *new_item = analysis_state__clone(borrowed_item);\n+    array_insert(&self->states, index, new_item);\n+  }\n+}\n+\n+// Inserts a clone of the passed-in item at the end position of this list.\n+//\n+// IMPORTANT: The caller MUST ENSURE that this item is larger (by the comparison function\n+// `analysis_state__compare`) than largest item already in this set. If items are inserted in the\n+// wrong order, the set will not function properly for future use.\n+//\n+// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n+// function will be managed by the state set.\n+static inline void analysis_state_set__push_by_clone(\n+  AnalysisStateSet *self,\n+  AnalysisState *owned_item",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "780930143",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1578,
        "pr_file": "lib/src/query.c",
        "discussion_id": "780930143",
        "commented_code": "@@ -669,6 +671,96 @@ static inline bool analysis_state__has_supertype(AnalysisState *self, TSSymbol s\n   return false;\n }\n \n+static inline AnalysisState *analysis_state__clone(AnalysisState const *self) {\n+  AnalysisState *new_state = ts_malloc(sizeof(AnalysisState));\n+  *new_state = *self;\n+  return new_state;\n+}\n+\n+/****************\n+ * AnalysisStateSet\n+ ****************/\n+\n+// Constructs an empty AnalysisStateSet.\n+static inline AnalysisStateSet analysis_state_set__new() {\n+  return ((AnalysisStateSet) {\n+    array_new()\n+  });\n+}\n+\n+// Returns the number of states present in this analysis state set.\n+static inline unsigned analysis_state_set__size(AnalysisStateSet *self) {\n+  return self->states.size;\n+}\n+\n+// Returns a pointer to the item at the passed-in position in this analysis state set. The state set\n+// retains ownership of the item at that index, meaning that the caller is not responsible for\n+// freeing it.\n+static inline AnalysisState **analysis_state_set__get(\n+  AnalysisStateSet *self,\n+  unsigned index\n+) {\n+  return &self->states.contents[index];\n+}\n+\n+// Returns a pointer to the item in the last position of this analysis state set. The state set\n+// retains ownership of the item at that index, meaning that the caller is not responsible for\n+// freeing it.\n+static inline AnalysisState **analysis_state_set__back(AnalysisStateSet *self) {\n+  return array_back(&self->states);\n+}\n+\n+// Inserts a clone of the passed-in item at the appropriate position to maintain ordering in this\n+// set. The set does not contain duplicates, so if the item is already present, it will not be\n+// inserted, and no clone will be made.\n+//\n+// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n+// function will be managed by the state set.\n+static inline void analysis_state_set__insert_sorted_by_clone(\n+  AnalysisStateSet *self,\n+  AnalysisState *borrowed_item\n+) {\n+  unsigned index, exists;\n+  array_search_sorted_with(&self->states, analysis_state__compare, &borrowed_item, &index, &exists);\n+  if (!exists) {\n+    AnalysisState *new_item = analysis_state__clone(borrowed_item);\n+    array_insert(&self->states, index, new_item);\n+  }\n+}\n+\n+// Inserts a clone of the passed-in item at the end position of this list.\n+//\n+// IMPORTANT: The caller MUST ENSURE that this item is larger (by the comparison function\n+// `analysis_state__compare`) than largest item already in this set. If items are inserted in the\n+// wrong order, the set will not function properly for future use.\n+//\n+// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n+// function will be managed by the state set.\n+static inline void analysis_state_set__push_by_clone(\n+  AnalysisStateSet *self,\n+  AnalysisState *owned_item",
        "comment_created_at": "2022-01-10T07:08:22+00:00",
        "comment_author": "alex-pinkus",
        "comment_body": "This should be named `borrowed_item`, not `owned_item`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "644203464",
    "pr_number": 1127,
    "pr_file": "lib/src/query.c",
    "created_at": "2021-06-02T18:03:51+00:00",
    "commented_code": "} QueryState;\n \n typedef Array(TSQueryCapture) CaptureList;\n+typedef Array(CaptureList) CaptureListPoolEntry;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "644203464",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1127,
        "pr_file": "lib/src/query.c",
        "discussion_id": "644203464",
        "commented_code": "@@ -165,6 +164,7 @@ typedef struct {\n } QueryState;\n \n typedef Array(TSQueryCapture) CaptureList;\n+typedef Array(CaptureList) CaptureListPoolEntry;",
        "comment_created_at": "2021-06-02T18:03:51+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "What do you think of eliminating this typedef? It seems like it's only used in one place; also the name suffix \"Entry\" makes me think that it's going to be represent one element of some collection, which isn't the case here.",
        "pr_file_module": null
      },
      {
        "comment_id": "644212250",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1127,
        "pr_file": "lib/src/query.c",
        "discussion_id": "644203464",
        "commented_code": "@@ -165,6 +164,7 @@ typedef struct {\n } QueryState;\n \n typedef Array(TSQueryCapture) CaptureList;\n+typedef Array(CaptureList) CaptureListPoolEntry;",
        "comment_created_at": "2021-06-02T18:16:41+00:00",
        "comment_author": "dcreager",
        "comment_body": ":+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "568039271",
    "pr_number": 908,
    "pr_file": "lib/binding_web/binding.c",
    "created_at": "2021-02-01T18:18:30+00:00",
    "commented_code": "return ts_parser_parse(self, old_tree, input);\n }\n \n+/**********************/\n+/* Section - Language */\n+/**********************/\n+\n+int ts_node_type_is_named_wasm(const TSLanguage *self, TSSymbol typeId) {\n+  const TSSymbolType symbolType = ts_language_symbol_type(self, typeId);\n+  return symbolType == TSSymbolTypeRegular;\n+}\n+\n+int ts_node_type_is_visible_wasm(const TSLanguage *self, TSSymbol typeId) {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "568039271",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 908,
        "pr_file": "lib/binding_web/binding.c",
        "discussion_id": "568039271",
        "commented_code": "@@ -184,6 +184,20 @@ TSTree *ts_parser_parse_wasm(\n   return ts_parser_parse(self, old_tree, input);\n }\n \n+/**********************/\n+/* Section - Language */\n+/**********************/\n+\n+int ts_node_type_is_named_wasm(const TSLanguage *self, TSSymbol typeId) {\n+  const TSSymbolType symbolType = ts_language_symbol_type(self, typeId);\n+  return symbolType == TSSymbolTypeRegular;\n+}\n+\n+int ts_node_type_is_visible_wasm(const TSLanguage *self, TSSymbol typeId) {",
        "comment_created_at": "2021-02-01T18:18:30+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "For consistency with the other functions, could you rename these new methods so that they begin with the prefix `ts_language_`?",
        "pr_file_module": null
      }
    ]
  }
]