[
  {
    "discussion_id": "768135193",
    "pr_number": 1504,
    "pr_file": "lib/include/tree_sitter/api.h",
    "created_at": "2021-12-13T21:27:43+00:00",
    "commented_code": "uint32_t index;\n } TSQueryCapture;\n \n+typedef enum {\n+  Zero = 0, // must match the array initialization value\n+  ZeroOrOne,\n+  ZeroOrMore,\n+  One,\n+  OneOrMore,",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "768135193",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1504,
        "pr_file": "lib/include/tree_sitter/api.h",
        "discussion_id": "768135193",
        "commented_code": "@@ -106,6 +106,14 @@ typedef struct {\n   uint32_t index;\n } TSQueryCapture;\n \n+typedef enum {\n+  Zero = 0, // must match the array initialization value\n+  ZeroOrOne,\n+  ZeroOrMore,\n+  One,\n+  OneOrMore,",
        "comment_created_at": "2021-12-13T21:27:43+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "In C, these variant names are all added to the top-level namespace, so my usual practice is prefix them with the name of the enum, e.g. `TSQuantifierOneOrMore` (even though it is repetitive).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "774739900",
    "pr_number": 1473,
    "pr_file": "lib/src/subtree.h",
    "created_at": "2021-12-23T19:06:41+00:00",
    "commented_code": "//\n // This representation is used for small leaf nodes that are not\n // errors, and were not created by an external scanner.\n+// The idea behind the layout of this struct is that the `is_inline`\n+// bit will fall exactly into the same location as the least significant\n+// bit of the pointer in `Subtree` or `MutableSubtree`, respectively.\n+// Because of alignment, for any valid pointer this will be 0, giving\n+// us the opportunity to make use of this bit to signify whether to use\n+// the pointer or the inline struct.\n typedef struct {\n-  bool is_inline : 1;\n-  bool visible : 1;\n-  bool named : 1;\n-  bool extra : 1;\n-  bool has_changes : 1;\n-  bool is_missing : 1;\n+#define SUBTREE_3_BYTES \\\n+  uint8_t symbol; \\\n+  uint8_t padding_bytes; \\\n+  uint8_t size_bytes; \\\n+\n+#define SUBTREE_6_BITS \\\n+  bool visible : 1; \\\n+  bool named : 1; \\\n+  bool extra : 1; \\\n+  bool has_changes : 1; \\\n+  bool is_missing : 1; \\\n   bool is_keyword : 1;\n-  uint8_t symbol;\n-  uint8_t padding_bytes;\n-  uint8_t size_bytes;\n-  uint8_t padding_columns;\n-  uint8_t padding_rows : 4;\n-  uint8_t lookahead_bytes : 4;\n+\n+#define SUBTREE_4_BYTES \\\n+  uint8_t padding_columns; \\\n+  uint8_t padding_rows : 4; \\\n+  uint8_t lookahead_bytes : 4; \\\n   uint16_t parse_state;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "774739900",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1473,
        "pr_file": "lib/src/subtree.h",
        "discussion_id": "774739900",
        "commented_code": "@@ -39,21 +40,56 @@ typedef struct {\n //\n // This representation is used for small leaf nodes that are not\n // errors, and were not created by an external scanner.\n+// The idea behind the layout of this struct is that the `is_inline`\n+// bit will fall exactly into the same location as the least significant\n+// bit of the pointer in `Subtree` or `MutableSubtree`, respectively.\n+// Because of alignment, for any valid pointer this will be 0, giving\n+// us the opportunity to make use of this bit to signify whether to use\n+// the pointer or the inline struct.\n typedef struct {\n-  bool is_inline : 1;\n-  bool visible : 1;\n-  bool named : 1;\n-  bool extra : 1;\n-  bool has_changes : 1;\n-  bool is_missing : 1;\n+#define SUBTREE_3_BYTES \\\n+  uint8_t symbol; \\\n+  uint8_t padding_bytes; \\\n+  uint8_t size_bytes; \\\n+\n+#define SUBTREE_6_BITS \\\n+  bool visible : 1; \\\n+  bool named : 1; \\\n+  bool extra : 1; \\\n+  bool has_changes : 1; \\\n+  bool is_missing : 1; \\\n   bool is_keyword : 1;\n-  uint8_t symbol;\n-  uint8_t padding_bytes;\n-  uint8_t size_bytes;\n-  uint8_t padding_columns;\n-  uint8_t padding_rows : 4;\n-  uint8_t lookahead_bytes : 4;\n+\n+#define SUBTREE_4_BYTES \\\n+  uint8_t padding_columns; \\\n+  uint8_t padding_rows : 4; \\\n+  uint8_t lookahead_bytes : 4; \\\n   uint16_t parse_state;",
        "comment_created_at": "2021-12-23T19:06:41+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Some minor naming suggestions:\r\n\r\n1. If you switched the `uint16_t parse_state;` with `uint8_t padding_bytes; uint8_t size_bytes;`, then all of the \"size\"-related fields would be together in `SUBTREE_4_BYTES`, and you could rename that macro to `SUBTREE_SIZE`, which indicates more about its meaning.\r\n2. Then, `SUBTREE_3_BYTES` would only contain two fields, and you could just inline them, instead of having that macro at all.\r\n2. I think `SUBTREE_6_BITS` could be renamed to just `SUBTREE_BITS`.",
        "pr_file_module": null
      },
      {
        "comment_id": "775050131",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1473,
        "pr_file": "lib/src/subtree.h",
        "discussion_id": "774739900",
        "commented_code": "@@ -39,21 +40,56 @@ typedef struct {\n //\n // This representation is used for small leaf nodes that are not\n // errors, and were not created by an external scanner.\n+// The idea behind the layout of this struct is that the `is_inline`\n+// bit will fall exactly into the same location as the least significant\n+// bit of the pointer in `Subtree` or `MutableSubtree`, respectively.\n+// Because of alignment, for any valid pointer this will be 0, giving\n+// us the opportunity to make use of this bit to signify whether to use\n+// the pointer or the inline struct.\n typedef struct {\n-  bool is_inline : 1;\n-  bool visible : 1;\n-  bool named : 1;\n-  bool extra : 1;\n-  bool has_changes : 1;\n-  bool is_missing : 1;\n+#define SUBTREE_3_BYTES \\\n+  uint8_t symbol; \\\n+  uint8_t padding_bytes; \\\n+  uint8_t size_bytes; \\\n+\n+#define SUBTREE_6_BITS \\\n+  bool visible : 1; \\\n+  bool named : 1; \\\n+  bool extra : 1; \\\n+  bool has_changes : 1; \\\n+  bool is_missing : 1; \\\n   bool is_keyword : 1;\n-  uint8_t symbol;\n-  uint8_t padding_bytes;\n-  uint8_t size_bytes;\n-  uint8_t padding_columns;\n-  uint8_t padding_rows : 4;\n-  uint8_t lookahead_bytes : 4;\n+\n+#define SUBTREE_4_BYTES \\\n+  uint8_t padding_columns; \\\n+  uint8_t padding_rows : 4; \\\n+  uint8_t lookahead_bytes : 4; \\\n   uint16_t parse_state;",
        "comment_created_at": "2021-12-24T16:20:50+00:00",
        "comment_author": "thestr4ng3r",
        "comment_body": "The idea behind the names was that each indicates exactly how much space it takes so the layout is directly visible. But your suggestion works too, so I have updated it accordingly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "506698669",
    "pr_number": 766,
    "pr_file": "lib/src/alloc.h",
    "created_at": "2020-10-16T20:11:29+00:00",
    "commented_code": "return false;\n }\n \n-static inline void *ts_malloc(size_t size) {\n+#ifndef ts_malloc\n+#define ts_malloc(_sz)       ts_malloc_dflt(_sz)\n+#endif\n+#ifndef ts_calloc\n+#define ts_calloc(_cnt,_sz)  ts_calloc_dflt(_cnt,_sz)\n+#endif\n+#ifndef ts_realloc\n+#define ts_realloc(_ptr,_sz) ts_realloc_dflt(_ptr,_sz)\n+#endif\n+#ifndef ts_free\n+#define ts_free(_ptr)        ts_free_dflt(_ptr)\n+#endif\n+\n+static inline void *ts_malloc_dflt(size_t size) {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "506698669",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 766,
        "pr_file": "lib/src/alloc.h",
        "discussion_id": "506698669",
        "commented_code": "@@ -42,7 +42,20 @@ static inline bool ts_toggle_allocation_recording(bool value) {\n   return false;\n }\n \n-static inline void *ts_malloc(size_t size) {\n+#ifndef ts_malloc\n+#define ts_malloc(_sz)       ts_malloc_dflt(_sz)\n+#endif\n+#ifndef ts_calloc\n+#define ts_calloc(_cnt,_sz)  ts_calloc_dflt(_cnt,_sz)\n+#endif\n+#ifndef ts_realloc\n+#define ts_realloc(_ptr,_sz) ts_realloc_dflt(_ptr,_sz)\n+#endif\n+#ifndef ts_free\n+#define ts_free(_ptr)        ts_free_dflt(_ptr)\n+#endif\n+\n+static inline void *ts_malloc_dflt(size_t size) {",
        "comment_created_at": "2020-10-16T20:11:29+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I'd prefer to just spell out \"default\" fully. Can you change these functions to `*_default`?",
        "pr_file_module": null
      },
      {
        "comment_id": "506746695",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 766,
        "pr_file": "lib/src/alloc.h",
        "discussion_id": "506698669",
        "commented_code": "@@ -42,7 +42,20 @@ static inline bool ts_toggle_allocation_recording(bool value) {\n   return false;\n }\n \n-static inline void *ts_malloc(size_t size) {\n+#ifndef ts_malloc\n+#define ts_malloc(_sz)       ts_malloc_dflt(_sz)\n+#endif\n+#ifndef ts_calloc\n+#define ts_calloc(_cnt,_sz)  ts_calloc_dflt(_cnt,_sz)\n+#endif\n+#ifndef ts_realloc\n+#define ts_realloc(_ptr,_sz) ts_realloc_dflt(_ptr,_sz)\n+#endif\n+#ifndef ts_free\n+#define ts_free(_ptr)        ts_free_dflt(_ptr)\n+#endif\n+\n+static inline void *ts_malloc_dflt(size_t size) {",
        "comment_created_at": "2020-10-16T22:25:08+00:00",
        "comment_author": "ikrima",
        "comment_body": "updated the PR and renamed the macro args for consistency\r\n\r\nside note: i assume github actions runs through all the necessary tests? lmk if that's incorrect/docs on running any integration/build tests",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "416852446",
    "pr_number": 607,
    "pr_file": "lib/include/tree_sitter/parser.h",
    "created_at": "2020-04-28T19:02:31+00:00",
    "commented_code": "TSStateId state;\n       bool extra : 1;\n       bool repetition : 1;\n-    };\n+    } status;",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "416852446",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 607,
        "pr_file": "lib/include/tree_sitter/parser.h",
        "discussion_id": "416852446",
        "commented_code": "@@ -62,13 +62,13 @@ typedef struct {\n       TSStateId state;\n       bool extra : 1;\n       bool repetition : 1;\n-    };\n+    } status;",
        "comment_created_at": "2020-04-28T19:02:31+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think this field should be called `shift`. \"Shift\" and \"reduce\" are the two main types of actions.",
        "pr_file_module": null
      },
      {
        "comment_id": "417486273",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 607,
        "pr_file": "lib/include/tree_sitter/parser.h",
        "discussion_id": "416852446",
        "commented_code": "@@ -62,13 +62,13 @@ typedef struct {\n       TSStateId state;\n       bool extra : 1;\n       bool repetition : 1;\n-    };\n+    } status;",
        "comment_created_at": "2020-04-29T17:26:44+00:00",
        "comment_author": "ret2libc",
        "comment_body": "yeah sure. I didn't know how to name it as I'm not that familiar with tree-sitter internals",
        "pr_file_module": null
      }
    ]
  }
]