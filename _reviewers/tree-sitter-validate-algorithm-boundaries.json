[
  {
    "discussion_id": "1818198609",
    "pr_number": 3836,
    "pr_file": "lib/src/node.c",
    "created_at": "2024-10-27T22:42:07+00:00",
    "commented_code": "return self;\n       }\n \n-      // Here we check the current self node and *all* of its zero-width token siblings that follow.\n-      // If any of these nodes contain the target subnode, we return that node. Otherwise, we restore the node we started at\n-      // for the loop condition, and that will continue with the next *non-zero-width* sibling.\n-      TSNode old = self;\n-      // While the next sibling is a zero-width token\n-      while (ts_node_child_iterator_next_sibling_is_empty_adjacent(&iter, self)) {\n-        TSNode current_node = ts_node_child_with_descendant(self, descendant);\n-        // If the target child is in self, return it\n-        if (!ts_node_is_null(current_node)) {\n-          return current_node;\n-        }\n-        ts_node_child_iterator_next(&iter, &self);\n-        if (self.id == descendant.id) {\n-          return self;\n+      // If the descendant is empty, we check whether `self` contains it or not.\n+      if (is_empty && ts_node_child_count(self) > 0) {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1818198609",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3836,
        "pr_file": "lib/src/node.c",
        "discussion_id": "1818198609",
        "commented_code": "@@ -612,24 +594,19 @@ TSNode ts_node_child_with_descendant(TSNode self, TSNode descendant) {\n         return self;\n       }\n \n-      // Here we check the current self node and *all* of its zero-width token siblings that follow.\n-      // If any of these nodes contain the target subnode, we return that node. Otherwise, we restore the node we started at\n-      // for the loop condition, and that will continue with the next *non-zero-width* sibling.\n-      TSNode old = self;\n-      // While the next sibling is a zero-width token\n-      while (ts_node_child_iterator_next_sibling_is_empty_adjacent(&iter, self)) {\n-        TSNode current_node = ts_node_child_with_descendant(self, descendant);\n-        // If the target child is in self, return it\n-        if (!ts_node_is_null(current_node)) {\n-          return current_node;\n-        }\n-        ts_node_child_iterator_next(&iter, &self);\n-        if (self.id == descendant.id) {\n-          return self;\n+      // If the descendant is empty, we check whether `self` contains it or not.\n+      if (is_empty && ts_node_child_count(self) > 0) {",
        "comment_created_at": "2024-10-27T22:42:07+00:00",
        "comment_author": "vanaigr",
        "comment_body": "If I understand correctly, this will recursively check every descendant of every node before the `descendant` node, even if they can't possibly contain it.\r\nI think it should also check that `ts_node_end_byte(self) >= end_byte` or `iter.position.bytes >= end_byte` ",
        "pr_file_module": null
      },
      {
        "comment_id": "1818200955",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3836,
        "pr_file": "lib/src/node.c",
        "discussion_id": "1818198609",
        "commented_code": "@@ -612,24 +594,19 @@ TSNode ts_node_child_with_descendant(TSNode self, TSNode descendant) {\n         return self;\n       }\n \n-      // Here we check the current self node and *all* of its zero-width token siblings that follow.\n-      // If any of these nodes contain the target subnode, we return that node. Otherwise, we restore the node we started at\n-      // for the loop condition, and that will continue with the next *non-zero-width* sibling.\n-      TSNode old = self;\n-      // While the next sibling is a zero-width token\n-      while (ts_node_child_iterator_next_sibling_is_empty_adjacent(&iter, self)) {\n-        TSNode current_node = ts_node_child_with_descendant(self, descendant);\n-        // If the target child is in self, return it\n-        if (!ts_node_is_null(current_node)) {\n-          return current_node;\n-        }\n-        ts_node_child_iterator_next(&iter, &self);\n-        if (self.id == descendant.id) {\n-          return self;\n+      // If the descendant is empty, we check whether `self` contains it or not.\n+      if (is_empty && ts_node_child_count(self) > 0) {",
        "comment_created_at": "2024-10-27T22:54:54+00:00",
        "comment_author": "amaanq",
        "comment_body": "Yeah that's a good point, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1670898011",
    "pr_number": 3450,
    "pr_file": "lib/src/query.c",
    "created_at": "2024-07-09T17:09:41+00:00",
    "commented_code": "point_gte(ts_node_start_point(parent_node), self->end_point)\n       );\n       bool node_precedes_range = parent_precedes_range || (\n-        ts_node_end_byte(node) <= self->start_byte ||\n-        point_lte(ts_node_end_point(node), self->start_point)\n+        !is_empty && (\n+          ts_node_end_byte(node) <= self->start_byte ||\n+          point_lte(ts_node_end_point(node), self->start_point)\n+        )",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1670898011",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3450,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1670898011",
        "commented_code": "@@ -3541,8 +3542,10 @@ static inline bool ts_query_cursor__advance(\n         point_gte(ts_node_start_point(parent_node), self->end_point)\n       );\n       bool node_precedes_range = parent_precedes_range || (\n-        ts_node_end_byte(node) <= self->start_byte ||\n-        point_lte(ts_node_end_point(node), self->start_point)\n+        !is_empty && (\n+          ts_node_end_byte(node) <= self->start_byte ||\n+          point_lte(ts_node_end_point(node), self->start_point)\n+        )",
        "comment_created_at": "2024-07-09T17:09:41+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think this would falsely *include* the node if it is empty, but disjoint from the range. For example, say we had an empty node at 0, but were looking for matches in the range `5 - 10`. I think that instead of special-casing byte offset 0, we may want to have a special-case where the node is empty and touches the range boundary.\r\n\r\nWhat about something like this?\r\n\r\n```c\r\nuint32_t start_byte = ts_node_start_byte(node);\r\nuint32_t end_byte = ts_node_end_byte(node);\r\nTSPoint start_point = ts_node_start_point(node);\r\nTSPoint end_point = ts_node_end_point(node);\r\nbool is_empty = start_byte == end_byte;\r\n\r\n// ...\r\n\r\nbool node_precedes_range =\r\n  parent_precedes_range ||\r\n  end_byte < self->start_byte ||\r\n  point_lt(end_point, self->start_point) ||\r\n  (!is_empty && end_byte == self->start_byte) ||\r\n  (!is_empty && point_eq(end_point, self->start_point));\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1720831346",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3450,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1670898011",
        "commented_code": "@@ -3541,8 +3542,10 @@ static inline bool ts_query_cursor__advance(\n         point_gte(ts_node_start_point(parent_node), self->end_point)\n       );\n       bool node_precedes_range = parent_precedes_range || (\n-        ts_node_end_byte(node) <= self->start_byte ||\n-        point_lte(ts_node_end_point(node), self->start_point)\n+        !is_empty && (\n+          ts_node_end_byte(node) <= self->start_byte ||\n+          point_lte(ts_node_end_point(node), self->start_point)\n+        )",
        "comment_created_at": "2024-08-17T20:42:53+00:00",
        "comment_author": "amaanq",
        "comment_body": "This makes total sense, and is definitely a lot clearer too",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1374342556",
    "pr_number": 2714,
    "pr_file": "lib/src/query.c",
    "created_at": "2023-10-27T09:55:26+00:00",
    "commented_code": "// Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1374342556",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-10-27T09:55:26+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think this should be an **and**, not an **or**. To be counted, a node must be within the supplied byte range **and** within any supplied point range.",
        "pr_file_module": null
      },
      {
        "comment_id": "1375048252",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-10-27T21:10:39+00:00",
        "comment_author": "MrPrezident",
        "comment_body": "Thanks @maxbrunsfeld for the response! I think this should be **or** not **and** since this section of code is supposed to filter out nodes, not include them. When I run the debugger on a query that was specified with a point range, I see that the start/end bytes look like this:\r\n```\r\n(gdb) p self->start_byte\r\n$29 = 0\r\n(gdb) p self->end_byte\r\n$30 = 4294967295\r\n```\r\nwhereas the start/end points look like this:\r\n```\r\n(gdb) p self->start_point\r\n$27 = {row = 9, column = 3}\r\n(gdb) p self->end_point\r\n$28 = {row = 9, column = 27}\r\n\r\n```\r\n\r\nSo in this case, the node will always be inside the byte range, but not the point range, and so we need to **or** them together.\r\n\r\nThat being said, when I went over this again to see if I was missing anything, I realized that there are also some nodes that are not getting filtered out beyond the end of the range as well. So we probably need to do something like this. Let me know what you think. I'll test this out on my end and update the PR.\r\n\r\n```python\r\n      TSNode node = captures->contents[state->consumed_capture_count].node;\r\n      \r\n      bool node_precedes_range = (\r\n        ts_node_end_byte(node) <= self->start_byte ||\r\n        point_lte(ts_node_end_point(node), self->start_point)\r\n      );\r\n      bool node_follows_range = (\r\n        ts_node_start_byte(node) >= self->end_byte ||\r\n        point_gte(ts_node_start_point(node), self->end_point)\r\n      );\r\n      bool node_outside_of_range = node_precedes_range || node_follows_range;\r\n\r\n      // Skip captures that are outside of the cursor's range.\r\n      if (node_outside_of_range) {\r\n        state->consumed_capture_count++;\r\n        continue;\r\n      }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1375155009",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-10-28T03:09:06+00:00",
        "comment_author": "MrPrezident",
        "comment_body": "Alright tested out the new code to skip both preceding and following ranges. This works great! I have updated the PR branch.",
        "pr_file_module": null
      },
      {
        "comment_id": "1388183640",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-11-09T15:35:54+00:00",
        "comment_author": "MrPrezident",
        "comment_body": "@maxbrunsfeld does this updated PR look ok to you?",
        "pr_file_module": null
      },
      {
        "comment_id": "1388370716",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-11-09T17:49:15+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Ah yes; you're quite right. Thanks for the explanation, and for making that code a bit clearer.\r\n\r\nWould you be willing to add a test for this in `query_test.rs`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1388372507",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-11-09T17:50:40+00:00",
        "comment_author": "MrPrezident",
        "comment_body": "Sure. Will do.",
        "pr_file_module": null
      },
      {
        "comment_id": "1390599906",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 2714,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1374342556",
        "commented_code": "@@ -4050,7 +4050,10 @@ bool ts_query_cursor_next_capture(\n \n       // Skip captures that precede the cursor's start byte.\n       TSNode node = captures->contents[state->consumed_capture_count].node;\n-      if (ts_node_end_byte(node) <= self->start_byte) {\n+      if (\n+        ts_node_end_byte(node) <= self->start_byte ||\n+        point_lte(ts_node_end_point(node), self->start_point)",
        "comment_created_at": "2023-11-13T03:49:43+00:00",
        "comment_author": "MrPrezident",
        "comment_body": "@maxbrunsfeld I added two unit tests. One for testing byte_range and one for testing point_range. Without my fix, the point_range test fails with extra captures both following and proceeding the point_range. The byte_range test fails with extra captures following the byte_range.\r\n\r\npoint_range fail:\r\n> thread 'tests::query_test::test_query_cursor_next_capture_with_point_range' panicked at 'assertion failed: `(left == right)`\r\n  left: `[(\"function\", \"func\"), (\"variable\", \"foo\"), (\"property\", \"bar\"), (\"property\", \"baz\")]`,\r\n right: `[(\"variable\", \"foo\")]`', cli/src/tests/query_test.rs:2168:9\r\n\r\nbyte_range fail:\r\n> thread 'tests::query_test::test_query_cursor_next_capture_with_byte_range' panicked at 'assertion failed: `(left == right)`\r\n  left: `[(\"variable\", \"foo\"), (\"property\", \"bar\"), (\"property\", \"baz\")]`,\r\n right: `[(\"variable\", \"foo\")]`', cli/src/tests/query_test.rs:2135:9\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "498893279",
    "pr_number": 733,
    "pr_file": "lib/src/language.c",
    "created_at": "2020-10-02T15:28:46+00:00",
    "commented_code": ") {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "498893279",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-02T15:28:46+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Will this change silence the warning?\r\n\r\n```c\r\nfor (TSSymbol i = 0; (uint32_t)i < count; i++) {\r\n```\r\n\r\nI think I'd rather add a cast than an additional runtime check.",
        "pr_file_module": null
      },
      {
        "comment_id": "498968100",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-02T17:57:43+00:00",
        "comment_author": "ret2libc",
        "comment_body": "I don't think that would work well. It would just hide the warning but it wouldn't remove the problem, which is that if count is bigger than uint16max this becomes an infinite loop because i  will always be less than count. ",
        "pr_file_module": null
      },
      {
        "comment_id": "499031449",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-02T20:17:38+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Actually, I think a better fix would be to simply change line 90 to this:\r\n\r\n```\r\nuint16_t count = ts_language_symbol_count(self);\r\n```\r\n\r\nIn practice there will only ever be a few hundred \"symbols\" in a grammar. This is why we can use the type `uint16_t` to represent `TSSymbol`, which is good because it allows parser binaries to be much smaller. It follows that the variable `count`, which represents the number of distinct `TSSymbol` values in a parser, must itself be representable as `uint16_t`.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "499390804",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-05T07:26:33+00:00",
        "comment_author": "ret2libc",
        "comment_body": "Then why does `ts_language_symbol_count` returns `uint32_t` (and `field_count` is `uint32_t` as well)? If you think this is the proper fix, then we should update that API and the type of `field_count` as well. If, however, you think that would break some users, probably just changing the type of the `count` variable in this function won't really fix the issue but just hide it again.",
        "pr_file_module": null
      },
      {
        "comment_id": "499723295",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-05T16:25:57+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think it would be valid for those functions to return `uint16_t`, but it's also fine to keep them as `uint32_t`. For right now, I'd rather leave them as they are.\r\n\r\n> just changing the type of the `count` variable in this function won't really fix the issue but just hide it again.\r\n\r\nThere isn't *really* a bug here; all we need to do is help the static analyzer understand that `count` is, due to the way that the parsers are constructed, always going to be much less than `UINT16_MAX`.",
        "pr_file_module": null
      },
      {
        "comment_id": "500859832",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-07T09:14:01+00:00",
        "comment_author": "ret2libc",
        "comment_body": "@maxbrunsfeld is `count` the number of symbols defined by the user? Or is it something else (maybe some auto-generated stuff)?",
        "pr_file_module": null
      },
      {
        "comment_id": "503492030",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-12T19:31:37+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "There are some auto-generated ones as well as those defined by the user.",
        "pr_file_module": null
      },
      {
        "comment_id": "503750852",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-13T08:09:48+00:00",
        "comment_author": "ret2libc",
        "comment_body": "So are you sure auto-generated + a big grammar can't reach the limit?",
        "pr_file_module": null
      },
      {
        "comment_id": "503998831",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 733,
        "pr_file": "lib/src/language.c",
        "discussion_id": "498893279",
        "commented_code": "@@ -87,7 +87,7 @@ TSSymbol ts_language_symbol_for_name(\n ) {\n   if (!strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n   uint32_t count = ts_language_symbol_count(self);\n-  for (TSSymbol i = 0; i < count; i++) {\n+  for (TSSymbol i = 0; i < count && i < UINT16_MAX; i++) {",
        "comment_created_at": "2020-10-13T14:28:07+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Yeah. A parser wouldn\u2019t work at all if the limit was reached.",
        "pr_file_module": null
      }
    ]
  }
]