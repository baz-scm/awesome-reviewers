[
  {
    "discussion_id": "1826496947",
    "pr_number": 3865,
    "pr_file": "lib/src/query.c",
    "created_at": "2024-11-02T05:18:44+00:00",
    "commented_code": "}\n }\n \n-void ts_query_cursor_set_byte_range(\n+bool ts_query_cursor_set_byte_range(\n   TSQueryCursor *self,\n   uint32_t start_byte,\n   uint32_t end_byte\n ) {\n   if (end_byte == 0) {\n     end_byte = UINT32_MAX;\n+  } else if (start_byte > end_byte) {\n+    return false;\n   }",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1826496947",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3865,
        "pr_file": "lib/src/query.c",
        "discussion_id": "1826496947",
        "commented_code": "@@ -3103,28 +3103,34 @@ void ts_query_cursor_exec_with_options(\n   }\n }\n \n-void ts_query_cursor_set_byte_range(\n+bool ts_query_cursor_set_byte_range(\n   TSQueryCursor *self,\n   uint32_t start_byte,\n   uint32_t end_byte\n ) {\n   if (end_byte == 0) {\n     end_byte = UINT32_MAX;\n+  } else if (start_byte > end_byte) {\n+    return false;\n   }",
        "comment_created_at": "2024-11-02T05:18:44+00:00",
        "comment_author": "amaanq",
        "comment_body": "same thing\r\n\r\n```suggestion\r\n  if (start_byte > end_byte) {\r\n    return false;\r\n  }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "621360041",
    "pr_number": 1075,
    "pr_file": "lib/binding_web/binding.c",
    "created_at": "2021-04-27T16:03:35+00:00",
    "commented_code": "TRANSFER_BUFFER[0] = (const void *)(capture_count);\n   TRANSFER_BUFFER[1] = result.contents;\n }\n+\n+bool ts_query_did_exceed_match_limit_wasm(\n+  const TSQuery *self\n+) {\n+  if (!scratch_query_cursor) return false;\n+  return ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "621360041",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1075,
        "pr_file": "lib/binding_web/binding.c",
        "discussion_id": "621360041",
        "commented_code": "@@ -670,3 +670,10 @@ void ts_query_captures_wasm(\n   TRANSFER_BUFFER[0] = (const void *)(capture_count);\n   TRANSFER_BUFFER[1] = result.contents;\n }\n+\n+bool ts_query_did_exceed_match_limit_wasm(\n+  const TSQuery *self\n+) {\n+  if (!scratch_query_cursor) return false;\n+  return ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);",
        "comment_created_at": "2021-04-27T16:03:35+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "The only problem with this is that, while the `didExceedMatchLimit` method is on the `Query` object, its behavior right now isn't scoped to that particular query. So it could give an unexpected result if you ran two different queries, and then called `didExceedMatchLimit` on the *first* query (admittedly, an unlikely sequence).\r\n\r\nWhat do you think of the following tweak, which would fix that minor issue:\r\n\r\nAt the ends of the functions `ts_query_matches_wasm` and `ts_query_captures_wasm`, we'd write a `did_exceed_match_limit` boolean as a third value to our `TRANSFER_BUFFER`. We'd have to cast it to a `void *`, which we're already doing with the result count. Then, on the JavaScript side, we'd just have to store that value as a boolean field on the `Query` object, and then return the same field value from the `didExceedMatchLimit` method.\r\n\r\nIt's slightly more complicated, but I feel like it's not too bad, so it'd be worth it to be able to avoid confusion if people call the methods in an unusual order.",
        "pr_file_module": null
      },
      {
        "comment_id": "622259195",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1075,
        "pr_file": "lib/binding_web/binding.c",
        "discussion_id": "621360041",
        "commented_code": "@@ -670,3 +670,10 @@ void ts_query_captures_wasm(\n   TRANSFER_BUFFER[0] = (const void *)(capture_count);\n   TRANSFER_BUFFER[1] = result.contents;\n }\n+\n+bool ts_query_did_exceed_match_limit_wasm(\n+  const TSQuery *self\n+) {\n+  if (!scratch_query_cursor) return false;\n+  return ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);",
        "comment_created_at": "2021-04-28T14:51:52+00:00",
        "comment_author": "dcreager",
        "comment_body": "I completely agree re the query / cursor mismatch!  At first I had considered keeping track of which query object the scratch cursor had been used with most recently, and verifying that the new method was called from the same query object.  But I like your suggestion about the transfer buffer better.  I'll take a stab at that.",
        "pr_file_module": null
      },
      {
        "comment_id": "622488144",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1075,
        "pr_file": "lib/binding_web/binding.c",
        "discussion_id": "621360041",
        "commented_code": "@@ -670,3 +670,10 @@ void ts_query_captures_wasm(\n   TRANSFER_BUFFER[0] = (const void *)(capture_count);\n   TRANSFER_BUFFER[1] = result.contents;\n }\n+\n+bool ts_query_did_exceed_match_limit_wasm(\n+  const TSQuery *self\n+) {\n+  if (!scratch_query_cursor) return false;\n+  return ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);",
        "comment_created_at": "2021-04-28T19:48:16+00:00",
        "comment_author": "dcreager",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  }
]