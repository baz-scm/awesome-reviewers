[
  {
    "discussion_id": "1833530754",
    "pr_number": 9409,
    "pr_file": "crates/turborepo-ui/src/tui/app.rs",
    "created_at": "2024-11-08T00:18:34+00:00",
    "commented_code": "#[tracing::instrument(skip(self))]\n     pub fn next(&mut self) {\n         let num_rows = self.tasks_by_status.count_all();\n-        let next_index = (self.selected_task_index + 1).clamp(0, num_rows - 1);\n-        self.selected_task_index = next_index;\n-        self.scroll.select(Some(next_index));\n-        self.has_user_scrolled = true;\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + 1) % num_rows;\n+            self.scroll.select(Some(self.selected_task_index));\n+            self.has_user_scrolled = true;\n+        }\n     }\n \n     #[tracing::instrument(skip(self))]\n     pub fn previous(&mut self) {\n-        let i = match self.selected_task_index {\n-            0 => 0,\n-            i => i - 1,\n-        };\n-        self.selected_task_index = i;\n-        self.scroll.select(Some(i));\n-        self.has_user_scrolled = true;\n+        let num_rows = self.tasks_by_status.count_all();\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + num_rows - 1) % num_rows;",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1833530754",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9409,
        "pr_file": "crates/turborepo-ui/src/tui/app.rs",
        "discussion_id": "1833530754",
        "commented_code": "@@ -142,21 +142,21 @@ impl<W> App<W> {\n     #[tracing::instrument(skip(self))]\n     pub fn next(&mut self) {\n         let num_rows = self.tasks_by_status.count_all();\n-        let next_index = (self.selected_task_index + 1).clamp(0, num_rows - 1);\n-        self.selected_task_index = next_index;\n-        self.scroll.select(Some(next_index));\n-        self.has_user_scrolled = true;\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + 1) % num_rows;\n+            self.scroll.select(Some(self.selected_task_index));\n+            self.has_user_scrolled = true;\n+        }\n     }\n \n     #[tracing::instrument(skip(self))]\n     pub fn previous(&mut self) {\n-        let i = match self.selected_task_index {\n-            0 => 0,\n-            i => i - 1,\n-        };\n-        self.selected_task_index = i;\n-        self.scroll.select(Some(i));\n-        self.has_user_scrolled = true;\n+        let num_rows = self.tasks_by_status.count_all();\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + num_rows - 1) % num_rows;",
        "comment_created_at": "2024-11-08T00:18:34+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "This one is totally up to you if you think explicitly handling the underflow case is easier to reason about than leveraging modulos.\r\n```suggestion\r\n            self.selected_task_index = self.selected_task_index.checked_sub(1).unwrap_or(num_rows - 1);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1833606619",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9409,
        "pr_file": "crates/turborepo-ui/src/tui/app.rs",
        "discussion_id": "1833530754",
        "commented_code": "@@ -142,21 +142,21 @@ impl<W> App<W> {\n     #[tracing::instrument(skip(self))]\n     pub fn next(&mut self) {\n         let num_rows = self.tasks_by_status.count_all();\n-        let next_index = (self.selected_task_index + 1).clamp(0, num_rows - 1);\n-        self.selected_task_index = next_index;\n-        self.scroll.select(Some(next_index));\n-        self.has_user_scrolled = true;\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + 1) % num_rows;\n+            self.scroll.select(Some(self.selected_task_index));\n+            self.has_user_scrolled = true;\n+        }\n     }\n \n     #[tracing::instrument(skip(self))]\n     pub fn previous(&mut self) {\n-        let i = match self.selected_task_index {\n-            0 => 0,\n-            i => i - 1,\n-        };\n-        self.selected_task_index = i;\n-        self.scroll.select(Some(i));\n-        self.has_user_scrolled = true;\n+        let num_rows = self.tasks_by_status.count_all();\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + num_rows - 1) % num_rows;",
        "comment_created_at": "2024-11-08T02:10:53+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "Classic me not knowing methods I have available.",
        "pr_file_module": null
      },
      {
        "comment_id": "1834441265",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9409,
        "pr_file": "crates/turborepo-ui/src/tui/app.rs",
        "discussion_id": "1833530754",
        "commented_code": "@@ -142,21 +142,21 @@ impl<W> App<W> {\n     #[tracing::instrument(skip(self))]\n     pub fn next(&mut self) {\n         let num_rows = self.tasks_by_status.count_all();\n-        let next_index = (self.selected_task_index + 1).clamp(0, num_rows - 1);\n-        self.selected_task_index = next_index;\n-        self.scroll.select(Some(next_index));\n-        self.has_user_scrolled = true;\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + 1) % num_rows;\n+            self.scroll.select(Some(self.selected_task_index));\n+            self.has_user_scrolled = true;\n+        }\n     }\n \n     #[tracing::instrument(skip(self))]\n     pub fn previous(&mut self) {\n-        let i = match self.selected_task_index {\n-            0 => 0,\n-            i => i - 1,\n-        };\n-        self.selected_task_index = i;\n-        self.scroll.select(Some(i));\n-        self.has_user_scrolled = true;\n+        let num_rows = self.tasks_by_status.count_all();\n+        if num_rows > 0 {\n+            self.selected_task_index = (self.selected_task_index + num_rows - 1) % num_rows;",
        "comment_created_at": "2024-11-08T13:53:31+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "I'm an `Option` addict, I love how clean the control flow that methods provide is.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1303876097",
    "pr_number": 5732,
    "pr_file": "crates/turbopack/src/rebase/mod.rs",
    "created_at": "2023-08-24T06:47:56+00:00",
    "commented_code": "#[turbo_tasks::function]\n     async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        let mut references = Vec::new();\n-        for &module in all_referenced_modules(self.source).await?.iter() {\n-            references.push(Vc::upcast(RebasedAsset::new(\n-                module,\n-                self.input_dir,\n-                self.output_dir,\n-            )));\n-        }\n+        let references = all_modules_iter([self.source].into_iter())",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1303876097",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 5732,
        "pr_file": "crates/turbopack/src/rebase/mod.rs",
        "discussion_id": "1303876097",
        "commented_code": "@@ -50,14 +50,10 @@ impl OutputAsset for RebasedAsset {\n \n     #[turbo_tasks::function]\n     async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        let mut references = Vec::new();\n-        for &module in all_referenced_modules(self.source).await?.iter() {\n-            references.push(Vc::upcast(RebasedAsset::new(\n-                module,\n-                self.input_dir,\n-                self.output_dir,\n-            )));\n-        }\n+        let references = all_modules_iter([self.source].into_iter())",
        "comment_created_at": "2023-08-24T06:47:56+00:00",
        "comment_author": "sokra",
        "comment_body": "This should only return the shallow references (not the whole graph). It was using `all_referenced_modules` which only returns the shallow references.\r\n\r\nIt should also include primary and secondary references.\r\n\r\nThis is used in NFT and that's why it's failing",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1696962608",
    "pr_number": 8852,
    "pr_file": "crates/turbopack-core/src/resolve/alias_map.rs",
    "created_at": "2024-07-30T13:25:57+00:00",
    "commented_code": "/// Looks up a request in the alias map.\n     ///\n     /// Returns an iterator to all the matching aliases.\n-    pub fn lookup<'a>(&'a self, request: &'a str) -> AliasMapLookupIterator<'a, T>\n+    pub fn lookup<'a>(&'a self, request: &'a Pattern) -> AliasMapLookupIterator<'a, T>\n     where\n         T: Debug,\n     {\n         // Invariant: prefixes should be sorted by increasing length (base lengths),\n         // according to PATTERN_KEY_COMPARE. Since we're using a prefix tree, this is\n         // the default behavior of the common prefix iterator.\n-        let common_prefixes = self.map.common_prefixes(request.as_bytes());\n+        let common_prefixes = self\n+            .map\n+            .common_prefixes(request.constant_prefix().as_bytes());",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1696962608",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8852,
        "pr_file": "crates/turbopack-core/src/resolve/alias_map.rs",
        "discussion_id": "1696962608",
        "commented_code": "@@ -192,14 +193,16 @@ impl<T> AliasMap<T> {\n     /// Looks up a request in the alias map.\n     ///\n     /// Returns an iterator to all the matching aliases.\n-    pub fn lookup<'a>(&'a self, request: &'a str) -> AliasMapLookupIterator<'a, T>\n+    pub fn lookup<'a>(&'a self, request: &'a Pattern) -> AliasMapLookupIterator<'a, T>\n     where\n         T: Debug,\n     {\n         // Invariant: prefixes should be sorted by increasing length (base lengths),\n         // according to PATTERN_KEY_COMPARE. Since we're using a prefix tree, this is\n         // the default behavior of the common prefix iterator.\n-        let common_prefixes = self.map.common_prefixes(request.as_bytes());\n+        let common_prefixes = self\n+            .map\n+            .common_prefixes(request.constant_prefix().as_bytes());",
        "comment_created_at": "2024-07-30T13:25:57+00:00",
        "comment_author": "sokra",
        "comment_body": "This will lead to also returning non-matching results. e. g. Pattern could be `\"a\" | \"b\"` which has no constant_prefix so it would return `\"c\"` too.\r\n\r\nYou probably want:\r\n* Do multiple lookups internally when you have Alternatives\r\n* Filter the results by matching with the Pattern",
        "pr_file_module": null
      },
      {
        "comment_id": "1698143881",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8852,
        "pr_file": "crates/turbopack-core/src/resolve/alias_map.rs",
        "discussion_id": "1696962608",
        "commented_code": "@@ -192,14 +193,16 @@ impl<T> AliasMap<T> {\n     /// Looks up a request in the alias map.\n     ///\n     /// Returns an iterator to all the matching aliases.\n-    pub fn lookup<'a>(&'a self, request: &'a str) -> AliasMapLookupIterator<'a, T>\n+    pub fn lookup<'a>(&'a self, request: &'a Pattern) -> AliasMapLookupIterator<'a, T>\n     where\n         T: Debug,\n     {\n         // Invariant: prefixes should be sorted by increasing length (base lengths),\n         // according to PATTERN_KEY_COMPARE. Since we're using a prefix tree, this is\n         // the default behavior of the common prefix iterator.\n-        let common_prefixes = self.map.common_prefixes(request.as_bytes());\n+        let common_prefixes = self\n+            .map\n+            .common_prefixes(request.constant_prefix().as_bytes());",
        "comment_created_at": "2024-07-31T08:51:36+00:00",
        "comment_author": "mischnic",
        "comment_body": "Looks like this doesn't happen, `map.common_prefixes(\"\")` is just empty. That does align with example on https://docs.rs/patricia_tree/latest/patricia_tree/map/type.PatriciaMap.html#method.common_prefixes\r\n\r\nBut still, `map.lookup(Pattern::Alternative(...))` currently never returns anything even if some/all alternatives match. And even then, just returning `enum AliasMatch<R> {Exact(R), Replaced(R)}` is wrong anyway because some might be exact and some might be replaced matches",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1668203221",
    "pr_number": 8671,
    "pr_file": "crates/turbo-tasks-memory/src/task.rs",
    "created_at": "2024-07-08T08:25:55+00:00",
    "commented_code": "format!(\"TaskState({})::event\", description())\n                             }),\n                             outdated_edges: Box::new(outdated_edges),\n+                            clean: recomputing,",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1668203221",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8671,
        "pr_file": "crates/turbo-tasks-memory/src/task.rs",
        "discussion_id": "1668203221",
        "commented_code": "@@ -1058,6 +1083,7 @@ impl Task {\n                                 format!(\"TaskState({})::event\", description())\n                             }),\n                             outdated_edges: Box::new(outdated_edges),\n+                            clean: recomputing,",
        "comment_created_at": "2024-07-08T08:25:55+00:00",
        "comment_author": "arlyon",
        "comment_body": "Should this be clean if it is not currently recomputing?",
        "pr_file_module": null
      },
      {
        "comment_id": "1668207843",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8671,
        "pr_file": "crates/turbo-tasks-memory/src/task.rs",
        "discussion_id": "1668203221",
        "commented_code": "@@ -1058,6 +1083,7 @@ impl Task {\n                                 format!(\"TaskState({})::event\", description())\n                             }),\n                             outdated_edges: Box::new(outdated_edges),\n+                            clean: recomputing,",
        "comment_created_at": "2024-07-08T08:28:22+00:00",
        "comment_author": "sokra",
        "comment_body": "If it's marked as dirty due to changes, it's not clean.\r\nIf it's marked as dirty when trying to read a missing value, it's still clean.",
        "pr_file_module": null
      },
      {
        "comment_id": "1668251957",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8671,
        "pr_file": "crates/turbo-tasks-memory/src/task.rs",
        "discussion_id": "1668203221",
        "commented_code": "@@ -1058,6 +1083,7 @@ impl Task {\n                                 format!(\"TaskState({})::event\", description())\n                             }),\n                             outdated_edges: Box::new(outdated_edges),\n+                            clean: recomputing,",
        "comment_created_at": "2024-07-08T08:53:12+00:00",
        "comment_author": "sokra",
        "comment_body": "I split mark_dirty_internal into two methods: mark_dirty and recompute to make it more clear.",
        "pr_file_module": null
      }
    ]
  }
]