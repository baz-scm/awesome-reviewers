[
  {
    "discussion_id": "960490576",
    "pr_number": 1819,
    "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
    "created_at": "2022-09-01T10:38:17+00:00",
    "commented_code": "+package lockfile\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\n+\t\"text/template\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+const pnpmLockfileTemplate = `lockfileVersion: {{ .Version }}\n+\n+importers:\n+{{ range $key, $val := .Importers }}\n+  {{ $key }}:\n+{{ displayProjectSnapshot $val }}\n+{{ end }}\n+packages:\n+{{ range $key, $val :=  .Packages }}\n+  {{ $key }}:\n+{{ displayPackageSnapshot $val }}\n+{{ end }}{{ if (eq .Version 5.4) }}\n+{{ end }}`",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "960490576",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 1819,
        "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
        "discussion_id": "960490576",
        "commented_code": "@@ -0,0 +1,321 @@\n+package lockfile\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\n+\t\"text/template\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+const pnpmLockfileTemplate = `lockfileVersion: {{ .Version }}\n+\n+importers:\n+{{ range $key, $val := .Importers }}\n+  {{ $key }}:\n+{{ displayProjectSnapshot $val }}\n+{{ end }}\n+packages:\n+{{ range $key, $val :=  .Packages }}\n+  {{ $key }}:\n+{{ displayPackageSnapshot $val }}\n+{{ end }}{{ if (eq .Version 5.4) }}\n+{{ end }}`",
        "comment_created_at": "2022-09-01T10:38:17+00:00",
        "comment_author": "nathanhammond",
        "comment_body": "A `pnpm` lockfile is 100% yaml. Is there a particular reason you construct it via a template instead of going all the way to yaml and then serializing it?",
        "pr_file_module": null
      },
      {
        "comment_id": "960919385",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 1819,
        "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
        "discussion_id": "960490576",
        "commented_code": "@@ -0,0 +1,321 @@\n+package lockfile\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\n+\t\"text/template\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+const pnpmLockfileTemplate = `lockfileVersion: {{ .Version }}\n+\n+importers:\n+{{ range $key, $val := .Importers }}\n+  {{ $key }}:\n+{{ displayProjectSnapshot $val }}\n+{{ end }}\n+packages:\n+{{ range $key, $val :=  .Packages }}\n+  {{ $key }}:\n+{{ displayPackageSnapshot $val }}\n+{{ end }}{{ if (eq .Version 5.4) }}\n+{{ end }}`",
        "comment_created_at": "2022-09-01T17:22:31+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "The go yaml package explicitly doesn't support controlling whitespace: https://github.com/go-yaml/yaml/issues/627\r\nHaving encoding/decoding to preserve the file was really helpful for development when diffing the original and pruned lockfile. If sacrificing that for a straightforward yaml serialization is desired we can do that. I'll quick double check that pnpm doesn't throw if parsing these formatting differences.",
        "pr_file_module": null
      },
      {
        "comment_id": "961497707",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 1819,
        "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
        "discussion_id": "960490576",
        "commented_code": "@@ -0,0 +1,321 @@\n+package lockfile\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\n+\t\"text/template\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+const pnpmLockfileTemplate = `lockfileVersion: {{ .Version }}\n+\n+importers:\n+{{ range $key, $val := .Importers }}\n+  {{ $key }}:\n+{{ displayProjectSnapshot $val }}\n+{{ end }}\n+packages:\n+{{ range $key, $val :=  .Packages }}\n+  {{ $key }}:\n+{{ displayPackageSnapshot $val }}\n+{{ end }}{{ if (eq .Version 5.4) }}\n+{{ end }}`",
        "comment_created_at": "2022-09-02T09:44:07+00:00",
        "comment_author": "nathanhammond",
        "comment_body": "If `pnpm` can support arbitrary whitespace differences this may be a _feature_, not a bug. Non-meaningful whitespace inclusion would unnecessarily break a hash.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "963196134",
    "pr_number": 1819,
    "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
    "created_at": "2022-09-06T02:17:22+00:00",
    "commented_code": "+package lockfile\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+// PnpmLockfile Go representation of the contents of 'pnpm-lock.yaml'\n+// Reference https://github.com/pnpm/pnpm/blob/main/packages/lockfile-types/src/index.ts\n+type PnpmLockfile struct {\n+\tVersion            float32                    `yaml:\"lockfileVersion\"`\n+\tImporters          map[string]ProjectSnapshot `yaml:\"importers\"`\n+\tPackages           map[string]PackageSnapshot `yaml:\"packages,omitempty\"`\n+\tNeverBuiltDeps     []string                   `yaml:\"neverBuiltDependencies,omitempty\"`\n+\tOnlyBuiltDeps      []string                   `yaml:\"onlyBuiltDependencies,omitempty\"`\n+\tOverrides          map[string]string          `yaml:\"overrides,omitempty\"`\n+\tPackageExtChecksum string                     `yaml:\"packageExtensionsChecksum,omitempty\"`\n+\tPatchedDeps        map[string]PatchFile       `yaml:\"patchedDependencies,omitempty\"`\n+}\n+\n+var _ Lockfile = (*PnpmLockfile)(nil)\n+\n+// ProjectSnapshot Snapshot used to represent projects in the importers section\n+type ProjectSnapshot struct {\n+\tSpecifiers           map[string]string         `yaml:\"specifiers\"`\n+\tDependencies         map[string]string         `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string         `yaml:\"optionalDependencies,omitempty\"`\n+\tDevDependencies      map[string]string         `yaml:\"devDependencies,omitempty\"`\n+\tDependenciesMeta     map[string]DependencyMeta `yaml:\"dependenciesMeta,omitempty\"`\n+\tPublishDirectory     string                    `yaml:\"publishDirectory,omitempty\"`\n+}\n+\n+// PackageSnapshot Snapshot used to represent a package in the packages setion\n+type PackageSnapshot struct {\n+\tID string `yaml:\"id,omitempty\"`\n+\n+\tResolution PackageResolution `yaml:\"resolution,flow\"`\n+\tEngines    struct {\n+\t\tNode string `yaml:\"node\"`\n+\t\tNPM  string `yaml:\"npm,omitempty\"`\n+\t} `yaml:\"engines,omitempty,flow\"`\n+\tCPU           []string `yaml:\"cpu,omitempty,flow\"`\n+\tOs            []string `yaml:\"os,omitempty,flow\"`\n+\tHasBin        bool     `yaml:\"hasBin,omitempty\"`\n+\tRequiresBuild bool     `yaml:\"requiresBuild,omitempty\"`\n+\n+\tPeerDependencies     map[string]string `yaml:\"peerDependencies,omitempty\"`\n+\tPeerDependenciesMeta map[string]struct {\n+\t\tOptional bool `yaml:\"optional\"`\n+\t} `yaml:\"peerDependenciesMeta,omitempty\"`\n+\tDependencies         map[string]string `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string `yaml:\"optionalDependencies,omitempty\"`\n+\tTransitivePeerDeps   []string          `yaml:\"transitivePeerDependencies,omitempty\"`\n+\tBundledDependencies  []string          `yaml:\"bundledDependencies,omitempty\"`\n+\n+\tDev      bool `yaml:\"dev\"`\n+\tOptional bool `yaml:\"optional,omitempty\"`\n+\tPatched  bool `yaml:\"patched,omitempty\"`\n+\tPrepare  bool `yaml:\"prepare,omitempty\"`\n+\n+\t// only needed for packages that aren't in npm\n+\tName    string `yaml:\"name,omitempty\"`\n+\tVersion string `yaml:\"version,omitempty\"`\n+\n+\tLibC       []string `yaml:\"libc,omitempty\"`\n+\tDeprecated string   `yaml:\"deprecated,omitempty\"`\n+}\n+\n+// PackageResolution Various resolution strategies for packages\n+type PackageResolution struct {\n+\tType string `yaml:\"type,omitempty\"`\n+\t// For npm or tarball\n+\tIntegrity string `yaml:\"integrity,omitempty\"`\n+\n+\t// For tarball\n+\tTarball string `yaml:\"tarball,omitempty\"`\n+\n+\t// For local directory\n+\tDir string `yaml:\"directory,omitempty\"`\n+\n+\t// For git repo\n+\tRepo   string `yaml:\"repo,omitempty\"`\n+\tCommit string `yaml:\"commit,omitempty\"`\n+}\n+\n+// PatchFile represent a patch applied to a package\n+type PatchFile struct {\n+\tPath string `yaml:\"path\"`\n+\tHash string `yaml:\"hash\"`\n+}\n+\n+func isSupportedVersion(version float32) error {\n+\tsupportedVersions := []float32{5.3, 5.4}\n+\tfor _, supportedVersion := range supportedVersions {\n+\t\tif version == supportedVersion {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errors.Errorf(\"Unable to generate pnpm-lock.yaml with lockfileVersion: %f. Supported lockfile versions are %v\", version, supportedVersions)\n+}\n+\n+// DependencyMeta metadata for dependencies\n+type DependencyMeta struct {\n+\tInjected bool   `yaml:\"injected,omitempty\"`\n+\tNode     string `yaml:\"node,omitempty\"`\n+\tPatch    string `yaml:\"string,omitempty\"`\n+}\n+\n+// DecodePnpmLockfile parse a pnpm lockfile\n+func DecodePnpmLockfile(contents []byte) (*PnpmLockfile, error) {\n+\tvar lockfile PnpmLockfile\n+\tif err := yaml.Unmarshal(contents, &lockfile); err != nil {\n+\t\treturn nil, errors.Wrap(err, \"could not unmarshal lockfile: \")\n+\t}\n+\n+\tif err := isSupportedVersion(lockfile.Version); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &lockfile, nil\n+}\n+\n+// ResolvePackage Given a package and version returns the key, resolved version, and if it was found\n+func (p *PnpmLockfile) ResolvePackage(name string, version string) (string, string, bool) {\n+\tresolvedVersion, ok := p.resolveSpecifier(name, version)\n+\tif !ok {\n+\t\treturn \"\", \"\", false\n+\t}\n+\tkey := fmt.Sprintf(\"/%s/%s\", name, resolvedVersion)\n+\tif entry, ok := (p.Packages)[key]; ok {\n+\t\tvar version string\n+\t\tif entry.Version != \"\" {\n+\t\t\tversion = entry.Version\n+\t\t} else {\n+\t\t\tversion = resolvedVersion\n+\t\t}\n+\t\treturn key, version, true\n+\t}\n+\n+\treturn \"\", \"\", false\n+}\n+\n+// AllDependencies Given a lockfile key return all (dev/optional/peer) dependencies of that package\n+func (p *PnpmLockfile) AllDependencies(key string) (map[string]string, bool) {\n+\tdeps := map[string]string{}\n+\tentry, ok := (p.Packages)[key]\n+\tif !ok {\n+\t\treturn deps, false\n+\t}\n+\n+\tfor name, version := range entry.Dependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.OptionalDependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.PeerDependencies {\n+\t\tdeps[name] = version\n+\t}",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "963196134",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 1819,
        "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
        "discussion_id": "963196134",
        "commented_code": "@@ -0,0 +1,234 @@\n+package lockfile\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+// PnpmLockfile Go representation of the contents of 'pnpm-lock.yaml'\n+// Reference https://github.com/pnpm/pnpm/blob/main/packages/lockfile-types/src/index.ts\n+type PnpmLockfile struct {\n+\tVersion            float32                    `yaml:\"lockfileVersion\"`\n+\tImporters          map[string]ProjectSnapshot `yaml:\"importers\"`\n+\tPackages           map[string]PackageSnapshot `yaml:\"packages,omitempty\"`\n+\tNeverBuiltDeps     []string                   `yaml:\"neverBuiltDependencies,omitempty\"`\n+\tOnlyBuiltDeps      []string                   `yaml:\"onlyBuiltDependencies,omitempty\"`\n+\tOverrides          map[string]string          `yaml:\"overrides,omitempty\"`\n+\tPackageExtChecksum string                     `yaml:\"packageExtensionsChecksum,omitempty\"`\n+\tPatchedDeps        map[string]PatchFile       `yaml:\"patchedDependencies,omitempty\"`\n+}\n+\n+var _ Lockfile = (*PnpmLockfile)(nil)\n+\n+// ProjectSnapshot Snapshot used to represent projects in the importers section\n+type ProjectSnapshot struct {\n+\tSpecifiers           map[string]string         `yaml:\"specifiers\"`\n+\tDependencies         map[string]string         `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string         `yaml:\"optionalDependencies,omitempty\"`\n+\tDevDependencies      map[string]string         `yaml:\"devDependencies,omitempty\"`\n+\tDependenciesMeta     map[string]DependencyMeta `yaml:\"dependenciesMeta,omitempty\"`\n+\tPublishDirectory     string                    `yaml:\"publishDirectory,omitempty\"`\n+}\n+\n+// PackageSnapshot Snapshot used to represent a package in the packages setion\n+type PackageSnapshot struct {\n+\tID string `yaml:\"id,omitempty\"`\n+\n+\tResolution PackageResolution `yaml:\"resolution,flow\"`\n+\tEngines    struct {\n+\t\tNode string `yaml:\"node\"`\n+\t\tNPM  string `yaml:\"npm,omitempty\"`\n+\t} `yaml:\"engines,omitempty,flow\"`\n+\tCPU           []string `yaml:\"cpu,omitempty,flow\"`\n+\tOs            []string `yaml:\"os,omitempty,flow\"`\n+\tHasBin        bool     `yaml:\"hasBin,omitempty\"`\n+\tRequiresBuild bool     `yaml:\"requiresBuild,omitempty\"`\n+\n+\tPeerDependencies     map[string]string `yaml:\"peerDependencies,omitempty\"`\n+\tPeerDependenciesMeta map[string]struct {\n+\t\tOptional bool `yaml:\"optional\"`\n+\t} `yaml:\"peerDependenciesMeta,omitempty\"`\n+\tDependencies         map[string]string `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string `yaml:\"optionalDependencies,omitempty\"`\n+\tTransitivePeerDeps   []string          `yaml:\"transitivePeerDependencies,omitempty\"`\n+\tBundledDependencies  []string          `yaml:\"bundledDependencies,omitempty\"`\n+\n+\tDev      bool `yaml:\"dev\"`\n+\tOptional bool `yaml:\"optional,omitempty\"`\n+\tPatched  bool `yaml:\"patched,omitempty\"`\n+\tPrepare  bool `yaml:\"prepare,omitempty\"`\n+\n+\t// only needed for packages that aren't in npm\n+\tName    string `yaml:\"name,omitempty\"`\n+\tVersion string `yaml:\"version,omitempty\"`\n+\n+\tLibC       []string `yaml:\"libc,omitempty\"`\n+\tDeprecated string   `yaml:\"deprecated,omitempty\"`\n+}\n+\n+// PackageResolution Various resolution strategies for packages\n+type PackageResolution struct {\n+\tType string `yaml:\"type,omitempty\"`\n+\t// For npm or tarball\n+\tIntegrity string `yaml:\"integrity,omitempty\"`\n+\n+\t// For tarball\n+\tTarball string `yaml:\"tarball,omitempty\"`\n+\n+\t// For local directory\n+\tDir string `yaml:\"directory,omitempty\"`\n+\n+\t// For git repo\n+\tRepo   string `yaml:\"repo,omitempty\"`\n+\tCommit string `yaml:\"commit,omitempty\"`\n+}\n+\n+// PatchFile represent a patch applied to a package\n+type PatchFile struct {\n+\tPath string `yaml:\"path\"`\n+\tHash string `yaml:\"hash\"`\n+}\n+\n+func isSupportedVersion(version float32) error {\n+\tsupportedVersions := []float32{5.3, 5.4}\n+\tfor _, supportedVersion := range supportedVersions {\n+\t\tif version == supportedVersion {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errors.Errorf(\"Unable to generate pnpm-lock.yaml with lockfileVersion: %f. Supported lockfile versions are %v\", version, supportedVersions)\n+}\n+\n+// DependencyMeta metadata for dependencies\n+type DependencyMeta struct {\n+\tInjected bool   `yaml:\"injected,omitempty\"`\n+\tNode     string `yaml:\"node,omitempty\"`\n+\tPatch    string `yaml:\"string,omitempty\"`\n+}\n+\n+// DecodePnpmLockfile parse a pnpm lockfile\n+func DecodePnpmLockfile(contents []byte) (*PnpmLockfile, error) {\n+\tvar lockfile PnpmLockfile\n+\tif err := yaml.Unmarshal(contents, &lockfile); err != nil {\n+\t\treturn nil, errors.Wrap(err, \"could not unmarshal lockfile: \")\n+\t}\n+\n+\tif err := isSupportedVersion(lockfile.Version); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &lockfile, nil\n+}\n+\n+// ResolvePackage Given a package and version returns the key, resolved version, and if it was found\n+func (p *PnpmLockfile) ResolvePackage(name string, version string) (string, string, bool) {\n+\tresolvedVersion, ok := p.resolveSpecifier(name, version)\n+\tif !ok {\n+\t\treturn \"\", \"\", false\n+\t}\n+\tkey := fmt.Sprintf(\"/%s/%s\", name, resolvedVersion)\n+\tif entry, ok := (p.Packages)[key]; ok {\n+\t\tvar version string\n+\t\tif entry.Version != \"\" {\n+\t\t\tversion = entry.Version\n+\t\t} else {\n+\t\t\tversion = resolvedVersion\n+\t\t}\n+\t\treturn key, version, true\n+\t}\n+\n+\treturn \"\", \"\", false\n+}\n+\n+// AllDependencies Given a lockfile key return all (dev/optional/peer) dependencies of that package\n+func (p *PnpmLockfile) AllDependencies(key string) (map[string]string, bool) {\n+\tdeps := map[string]string{}\n+\tentry, ok := (p.Packages)[key]\n+\tif !ok {\n+\t\treturn deps, false\n+\t}\n+\n+\tfor name, version := range entry.Dependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.OptionalDependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.PeerDependencies {\n+\t\tdeps[name] = version\n+\t}",
        "comment_created_at": "2022-09-06T02:17:22+00:00",
        "comment_author": "nathanhammond",
        "comment_body": "Can these collide? Do we care if they do?",
        "pr_file_module": null
      },
      {
        "comment_id": "966313384",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 1819,
        "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
        "discussion_id": "963196134",
        "commented_code": "@@ -0,0 +1,234 @@\n+package lockfile\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+// PnpmLockfile Go representation of the contents of 'pnpm-lock.yaml'\n+// Reference https://github.com/pnpm/pnpm/blob/main/packages/lockfile-types/src/index.ts\n+type PnpmLockfile struct {\n+\tVersion            float32                    `yaml:\"lockfileVersion\"`\n+\tImporters          map[string]ProjectSnapshot `yaml:\"importers\"`\n+\tPackages           map[string]PackageSnapshot `yaml:\"packages,omitempty\"`\n+\tNeverBuiltDeps     []string                   `yaml:\"neverBuiltDependencies,omitempty\"`\n+\tOnlyBuiltDeps      []string                   `yaml:\"onlyBuiltDependencies,omitempty\"`\n+\tOverrides          map[string]string          `yaml:\"overrides,omitempty\"`\n+\tPackageExtChecksum string                     `yaml:\"packageExtensionsChecksum,omitempty\"`\n+\tPatchedDeps        map[string]PatchFile       `yaml:\"patchedDependencies,omitempty\"`\n+}\n+\n+var _ Lockfile = (*PnpmLockfile)(nil)\n+\n+// ProjectSnapshot Snapshot used to represent projects in the importers section\n+type ProjectSnapshot struct {\n+\tSpecifiers           map[string]string         `yaml:\"specifiers\"`\n+\tDependencies         map[string]string         `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string         `yaml:\"optionalDependencies,omitempty\"`\n+\tDevDependencies      map[string]string         `yaml:\"devDependencies,omitempty\"`\n+\tDependenciesMeta     map[string]DependencyMeta `yaml:\"dependenciesMeta,omitempty\"`\n+\tPublishDirectory     string                    `yaml:\"publishDirectory,omitempty\"`\n+}\n+\n+// PackageSnapshot Snapshot used to represent a package in the packages setion\n+type PackageSnapshot struct {\n+\tID string `yaml:\"id,omitempty\"`\n+\n+\tResolution PackageResolution `yaml:\"resolution,flow\"`\n+\tEngines    struct {\n+\t\tNode string `yaml:\"node\"`\n+\t\tNPM  string `yaml:\"npm,omitempty\"`\n+\t} `yaml:\"engines,omitempty,flow\"`\n+\tCPU           []string `yaml:\"cpu,omitempty,flow\"`\n+\tOs            []string `yaml:\"os,omitempty,flow\"`\n+\tHasBin        bool     `yaml:\"hasBin,omitempty\"`\n+\tRequiresBuild bool     `yaml:\"requiresBuild,omitempty\"`\n+\n+\tPeerDependencies     map[string]string `yaml:\"peerDependencies,omitempty\"`\n+\tPeerDependenciesMeta map[string]struct {\n+\t\tOptional bool `yaml:\"optional\"`\n+\t} `yaml:\"peerDependenciesMeta,omitempty\"`\n+\tDependencies         map[string]string `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string `yaml:\"optionalDependencies,omitempty\"`\n+\tTransitivePeerDeps   []string          `yaml:\"transitivePeerDependencies,omitempty\"`\n+\tBundledDependencies  []string          `yaml:\"bundledDependencies,omitempty\"`\n+\n+\tDev      bool `yaml:\"dev\"`\n+\tOptional bool `yaml:\"optional,omitempty\"`\n+\tPatched  bool `yaml:\"patched,omitempty\"`\n+\tPrepare  bool `yaml:\"prepare,omitempty\"`\n+\n+\t// only needed for packages that aren't in npm\n+\tName    string `yaml:\"name,omitempty\"`\n+\tVersion string `yaml:\"version,omitempty\"`\n+\n+\tLibC       []string `yaml:\"libc,omitempty\"`\n+\tDeprecated string   `yaml:\"deprecated,omitempty\"`\n+}\n+\n+// PackageResolution Various resolution strategies for packages\n+type PackageResolution struct {\n+\tType string `yaml:\"type,omitempty\"`\n+\t// For npm or tarball\n+\tIntegrity string `yaml:\"integrity,omitempty\"`\n+\n+\t// For tarball\n+\tTarball string `yaml:\"tarball,omitempty\"`\n+\n+\t// For local directory\n+\tDir string `yaml:\"directory,omitempty\"`\n+\n+\t// For git repo\n+\tRepo   string `yaml:\"repo,omitempty\"`\n+\tCommit string `yaml:\"commit,omitempty\"`\n+}\n+\n+// PatchFile represent a patch applied to a package\n+type PatchFile struct {\n+\tPath string `yaml:\"path\"`\n+\tHash string `yaml:\"hash\"`\n+}\n+\n+func isSupportedVersion(version float32) error {\n+\tsupportedVersions := []float32{5.3, 5.4}\n+\tfor _, supportedVersion := range supportedVersions {\n+\t\tif version == supportedVersion {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errors.Errorf(\"Unable to generate pnpm-lock.yaml with lockfileVersion: %f. Supported lockfile versions are %v\", version, supportedVersions)\n+}\n+\n+// DependencyMeta metadata for dependencies\n+type DependencyMeta struct {\n+\tInjected bool   `yaml:\"injected,omitempty\"`\n+\tNode     string `yaml:\"node,omitempty\"`\n+\tPatch    string `yaml:\"string,omitempty\"`\n+}\n+\n+// DecodePnpmLockfile parse a pnpm lockfile\n+func DecodePnpmLockfile(contents []byte) (*PnpmLockfile, error) {\n+\tvar lockfile PnpmLockfile\n+\tif err := yaml.Unmarshal(contents, &lockfile); err != nil {\n+\t\treturn nil, errors.Wrap(err, \"could not unmarshal lockfile: \")\n+\t}\n+\n+\tif err := isSupportedVersion(lockfile.Version); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &lockfile, nil\n+}\n+\n+// ResolvePackage Given a package and version returns the key, resolved version, and if it was found\n+func (p *PnpmLockfile) ResolvePackage(name string, version string) (string, string, bool) {\n+\tresolvedVersion, ok := p.resolveSpecifier(name, version)\n+\tif !ok {\n+\t\treturn \"\", \"\", false\n+\t}\n+\tkey := fmt.Sprintf(\"/%s/%s\", name, resolvedVersion)\n+\tif entry, ok := (p.Packages)[key]; ok {\n+\t\tvar version string\n+\t\tif entry.Version != \"\" {\n+\t\t\tversion = entry.Version\n+\t\t} else {\n+\t\t\tversion = resolvedVersion\n+\t\t}\n+\t\treturn key, version, true\n+\t}\n+\n+\treturn \"\", \"\", false\n+}\n+\n+// AllDependencies Given a lockfile key return all (dev/optional/peer) dependencies of that package\n+func (p *PnpmLockfile) AllDependencies(key string) (map[string]string, bool) {\n+\tdeps := map[string]string{}\n+\tentry, ok := (p.Packages)[key]\n+\tif !ok {\n+\t\treturn deps, false\n+\t}\n+\n+\tfor name, version := range entry.Dependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.OptionalDependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.PeerDependencies {\n+\t\tdeps[name] = version\n+\t}",
        "comment_created_at": "2022-09-08T18:49:05+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "From reading through pnpm I don't think these can collide. If a dep is marked optional then it won't appear in `dependencies`, peer deps are handled in the same manner. In the case that there's an optional peer it appears under peer with the `optional` attribute set true in `peerDependenciesMeta`",
        "pr_file_module": null
      },
      {
        "comment_id": "966850441",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 1819,
        "pr_file": "cli/internal/lockfile/pnpm_lockfile.go",
        "discussion_id": "963196134",
        "commented_code": "@@ -0,0 +1,234 @@\n+package lockfile\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\n+\t\"github.com/pkg/errors\"\n+\t\"gopkg.in/yaml.v3\"\n+)\n+\n+// PnpmLockfile Go representation of the contents of 'pnpm-lock.yaml'\n+// Reference https://github.com/pnpm/pnpm/blob/main/packages/lockfile-types/src/index.ts\n+type PnpmLockfile struct {\n+\tVersion            float32                    `yaml:\"lockfileVersion\"`\n+\tImporters          map[string]ProjectSnapshot `yaml:\"importers\"`\n+\tPackages           map[string]PackageSnapshot `yaml:\"packages,omitempty\"`\n+\tNeverBuiltDeps     []string                   `yaml:\"neverBuiltDependencies,omitempty\"`\n+\tOnlyBuiltDeps      []string                   `yaml:\"onlyBuiltDependencies,omitempty\"`\n+\tOverrides          map[string]string          `yaml:\"overrides,omitempty\"`\n+\tPackageExtChecksum string                     `yaml:\"packageExtensionsChecksum,omitempty\"`\n+\tPatchedDeps        map[string]PatchFile       `yaml:\"patchedDependencies,omitempty\"`\n+}\n+\n+var _ Lockfile = (*PnpmLockfile)(nil)\n+\n+// ProjectSnapshot Snapshot used to represent projects in the importers section\n+type ProjectSnapshot struct {\n+\tSpecifiers           map[string]string         `yaml:\"specifiers\"`\n+\tDependencies         map[string]string         `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string         `yaml:\"optionalDependencies,omitempty\"`\n+\tDevDependencies      map[string]string         `yaml:\"devDependencies,omitempty\"`\n+\tDependenciesMeta     map[string]DependencyMeta `yaml:\"dependenciesMeta,omitempty\"`\n+\tPublishDirectory     string                    `yaml:\"publishDirectory,omitempty\"`\n+}\n+\n+// PackageSnapshot Snapshot used to represent a package in the packages setion\n+type PackageSnapshot struct {\n+\tID string `yaml:\"id,omitempty\"`\n+\n+\tResolution PackageResolution `yaml:\"resolution,flow\"`\n+\tEngines    struct {\n+\t\tNode string `yaml:\"node\"`\n+\t\tNPM  string `yaml:\"npm,omitempty\"`\n+\t} `yaml:\"engines,omitempty,flow\"`\n+\tCPU           []string `yaml:\"cpu,omitempty,flow\"`\n+\tOs            []string `yaml:\"os,omitempty,flow\"`\n+\tHasBin        bool     `yaml:\"hasBin,omitempty\"`\n+\tRequiresBuild bool     `yaml:\"requiresBuild,omitempty\"`\n+\n+\tPeerDependencies     map[string]string `yaml:\"peerDependencies,omitempty\"`\n+\tPeerDependenciesMeta map[string]struct {\n+\t\tOptional bool `yaml:\"optional\"`\n+\t} `yaml:\"peerDependenciesMeta,omitempty\"`\n+\tDependencies         map[string]string `yaml:\"dependencies,omitempty\"`\n+\tOptionalDependencies map[string]string `yaml:\"optionalDependencies,omitempty\"`\n+\tTransitivePeerDeps   []string          `yaml:\"transitivePeerDependencies,omitempty\"`\n+\tBundledDependencies  []string          `yaml:\"bundledDependencies,omitempty\"`\n+\n+\tDev      bool `yaml:\"dev\"`\n+\tOptional bool `yaml:\"optional,omitempty\"`\n+\tPatched  bool `yaml:\"patched,omitempty\"`\n+\tPrepare  bool `yaml:\"prepare,omitempty\"`\n+\n+\t// only needed for packages that aren't in npm\n+\tName    string `yaml:\"name,omitempty\"`\n+\tVersion string `yaml:\"version,omitempty\"`\n+\n+\tLibC       []string `yaml:\"libc,omitempty\"`\n+\tDeprecated string   `yaml:\"deprecated,omitempty\"`\n+}\n+\n+// PackageResolution Various resolution strategies for packages\n+type PackageResolution struct {\n+\tType string `yaml:\"type,omitempty\"`\n+\t// For npm or tarball\n+\tIntegrity string `yaml:\"integrity,omitempty\"`\n+\n+\t// For tarball\n+\tTarball string `yaml:\"tarball,omitempty\"`\n+\n+\t// For local directory\n+\tDir string `yaml:\"directory,omitempty\"`\n+\n+\t// For git repo\n+\tRepo   string `yaml:\"repo,omitempty\"`\n+\tCommit string `yaml:\"commit,omitempty\"`\n+}\n+\n+// PatchFile represent a patch applied to a package\n+type PatchFile struct {\n+\tPath string `yaml:\"path\"`\n+\tHash string `yaml:\"hash\"`\n+}\n+\n+func isSupportedVersion(version float32) error {\n+\tsupportedVersions := []float32{5.3, 5.4}\n+\tfor _, supportedVersion := range supportedVersions {\n+\t\tif version == supportedVersion {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errors.Errorf(\"Unable to generate pnpm-lock.yaml with lockfileVersion: %f. Supported lockfile versions are %v\", version, supportedVersions)\n+}\n+\n+// DependencyMeta metadata for dependencies\n+type DependencyMeta struct {\n+\tInjected bool   `yaml:\"injected,omitempty\"`\n+\tNode     string `yaml:\"node,omitempty\"`\n+\tPatch    string `yaml:\"string,omitempty\"`\n+}\n+\n+// DecodePnpmLockfile parse a pnpm lockfile\n+func DecodePnpmLockfile(contents []byte) (*PnpmLockfile, error) {\n+\tvar lockfile PnpmLockfile\n+\tif err := yaml.Unmarshal(contents, &lockfile); err != nil {\n+\t\treturn nil, errors.Wrap(err, \"could not unmarshal lockfile: \")\n+\t}\n+\n+\tif err := isSupportedVersion(lockfile.Version); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &lockfile, nil\n+}\n+\n+// ResolvePackage Given a package and version returns the key, resolved version, and if it was found\n+func (p *PnpmLockfile) ResolvePackage(name string, version string) (string, string, bool) {\n+\tresolvedVersion, ok := p.resolveSpecifier(name, version)\n+\tif !ok {\n+\t\treturn \"\", \"\", false\n+\t}\n+\tkey := fmt.Sprintf(\"/%s/%s\", name, resolvedVersion)\n+\tif entry, ok := (p.Packages)[key]; ok {\n+\t\tvar version string\n+\t\tif entry.Version != \"\" {\n+\t\t\tversion = entry.Version\n+\t\t} else {\n+\t\t\tversion = resolvedVersion\n+\t\t}\n+\t\treturn key, version, true\n+\t}\n+\n+\treturn \"\", \"\", false\n+}\n+\n+// AllDependencies Given a lockfile key return all (dev/optional/peer) dependencies of that package\n+func (p *PnpmLockfile) AllDependencies(key string) (map[string]string, bool) {\n+\tdeps := map[string]string{}\n+\tentry, ok := (p.Packages)[key]\n+\tif !ok {\n+\t\treturn deps, false\n+\t}\n+\n+\tfor name, version := range entry.Dependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.OptionalDependencies {\n+\t\tdeps[name] = version\n+\t}\n+\n+\tfor name, version := range entry.PeerDependencies {\n+\t\tdeps[name] = version\n+\t}",
        "comment_created_at": "2022-09-09T09:45:09+00:00",
        "comment_author": "nathanhammond",
        "comment_body": "Thanks for the explanation!",
        "pr_file_module": null
      }
    ]
  }
]