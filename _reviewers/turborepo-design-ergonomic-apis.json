[
  {
    "discussion_id": "2078197752",
    "pr_number": 10452,
    "pr_file": "crates/turborepo-lockfiles/src/pnpm/data.rs",
    "created_at": "2025-05-07T18:01:32+00:00",
    "commented_code": "name: &str,\n         specifier: &'a str,\n     ) -> Result<Option<&'a str>, crate::Error> {\n+        // Handle catalog references (https://pnpm.io/catalogs)\n+        if specifier.starts_with(\"catalog:\") {\n+            if let Some(catalogs) = &self.catalogs {\n+                let catalog_name = specifier.strip_prefix(\"catalog:\").unwrap_or(\"default\");\n+                if let Some(catalog) = catalogs.get(catalog_name) {\n+                    if let Some(dep) = catalog.get(name) {\n+                        return Ok(Some(&dep.version));\n+                    }\n+                }\n+            }\n+            return Ok(None);",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "2078197752",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10452,
        "pr_file": "crates/turborepo-lockfiles/src/pnpm/data.rs",
        "discussion_id": "2078197752",
        "commented_code": "@@ -270,6 +272,19 @@ impl PnpmLockfile {\n         name: &str,\n         specifier: &'a str,\n     ) -> Result<Option<&'a str>, crate::Error> {\n+        // Handle catalog references (https://pnpm.io/catalogs)\n+        if specifier.starts_with(\"catalog:\") {\n+            if let Some(catalogs) = &self.catalogs {\n+                let catalog_name = specifier.strip_prefix(\"catalog:\").unwrap_or(\"default\");\n+                if let Some(catalog) = catalogs.get(catalog_name) {\n+                    if let Some(dep) = catalog.get(name) {\n+                        return Ok(Some(&dep.version));\n+                    }\n+                }\n+            }\n+            return Ok(None);",
        "comment_created_at": "2025-05-07T18:01:32+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Just using `strip_prefix` from the jump lets us skip the `unwrap`\r\n```suggestion\r\n        if let Some(catalog_name) = specifier.strip_prefix(\"catalog:\") {\r\n            if let Some(catalogs) = &self.catalogs {\r\n                if let Some(catalog) = catalogs.get(catalog_name) {\r\n                    if let Some(dep) = catalog.get(name) {\r\n                        return Ok(Some(&dep.version));\r\n                    }\r\n                }\r\n            }\r\n            return Ok(None);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1803577782",
    "pr_number": 9249,
    "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
    "created_at": "2024-10-16T18:05:38+00:00",
    "commented_code": "+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+        }\n+    }\n+}\n+\n+// this is an internal structure (that's a partial of ConfigurationOptions) that\n+// we use to store\n+pub struct Output {\n+    /// maps to ConfigurationOptions.team_id\n+    pub team_id: Option<String>,\n+    // maps to ConfigurationOptions.team_slug\n+    pub team_slug: Option<String>,\n+    // maps to ConfigurationOptions.token\n+    pub token: Option<String>,\n+}\n+\n+impl Output {\n+    fn new() -> Self {\n+        Self {\n+            team_id: None,\n+            team_slug: None,\n+            token: None,\n+        }\n+    }\n+}\n+\n+// get Output from Input\n+impl From<Input> for Output {\n+    fn from(input: Input) -> Self {\n+        let mut output = Output::new();\n+\n+        // TURBO_TEAMID+TURBO_TOKEN\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAM.is_some() {\n+                // there can also be a TURBO_TEAM, so we'll use that as well\n+                output.team_slug = input.TURBO_TEAM;\n+            }\n+\n+            return output;\n+        }\n+\n+        // TURBO_TEAM+TURBO_TOKEN\n+        if input.TURBO_TEAM.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_slug = input.TURBO_TEAM;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAMID.is_some() {\n+                // there can also be a TURBO_TEAMID, so we'll use that as well\n+                output.team_id = input.TURBO_TEAMID;\n+            }\n+\n+            return output;\n+        }\n+\n+        // if there's both Vercel items, we use those next\n+        if input.VERCEL_ARTIFACTS_OWNER.is_some() && input.VERCEL_ARTIFACTS_TOKEN.is_some() {\n+            output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            output.token = input.VERCEL_ARTIFACTS_TOKEN;\n+            return output;\n+        }\n+\n+        // from this point below, there's no token we can do anything with\n+        // ------------------------------------------------\n+\n+        // if there's no token, this is also permissible\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TEAM.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.team_slug = input.TURBO_TEAM;\n+            return output;\n+        }\n+\n+        // handle \"only\" cases\n+        // ------------------------------------------------\n+        if input.TURBO_TEAMID.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            return output;\n+        }\n+\n+        if input.TURBO_TEAM.is_some() {\n+            output.team_slug = input.TURBO_TEAM;\n+\n+            if input.VERCEL_ARTIFACTS_OWNER.is_some() {\n+                output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            }\n+\n+            return output;\n+        }\n+\n+        if input.VERCEL_ARTIFACTS_OWNER.is_some() {\n+            output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            return output;\n+        }\n+\n+        Output::new()\n+    }\n+}\n+\n+pub struct OverrideEnvVars<'a> {\n+    environment: &'a HashMap<OsString, OsString>,\n+    output: Output,\n+}\n+\n+impl<'a> OverrideEnvVars<'a> {\n+    pub fn new(environment: &'a HashMap<OsString, OsString>) -> Result<Self, Error> {\n+        let input = Input::from(environment);\n+        let output = Output::from(input);\n+\n+        Ok(Self {\n+            environment,\n+            output,\n+        })\n+    }\n+\n+    fn ui(&self) -> Option<UIMode> {\n+        // TODO double check on what's going on here\n+        let value = self\n+            .environment\n+            .get(OsStr::new(\"ci\"))\n+            .or_else(|| self.environment.get(OsStr::new(\"no_color\")))?;\n+        match truth_env_var(value.to_str()?)? {\n+            true => Some(UIMode::Stream),\n+            false => None,\n+        }\n+    }\n+}\n+\n+impl<'a> ResolvedConfigurationOptions for OverrideEnvVars<'a> {\n+    fn get_configuration_options(\n+        &self,\n+        _existing_config: Option<&ConfigurationOptions>,\n+    ) -> Result<ConfigurationOptions, Error> {\n+        let output = ConfigurationOptions {\n+            team_id: self.output.team_id.clone(),\n+            token: self.output.token.clone(),\n+            team_slug: self.output.team_slug.clone(),\n+            ui: self.ui(),\n+            api_url: None,\n+            ..Default::default()\n+        };\n+        Ok(output)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use lazy_static::lazy_static;\n+\n+    use super::*;\n+\n+    lazy_static! {\n+        static ref VERCEL_ARTIFACTS_OWNER: String = String::from(\"valueof:VERCEL_ARTIFACTS_OWNER\");\n+        static ref VERCEL_ARTIFACTS_TOKEN: String = String::from(\"valueof:VERCEL_ARTIFACTS_TOKEN\");\n+        static ref TURBO_TEAMID: String = String::from(\"valueof:TURBO_TEAMID\");\n+        static ref TURBO_TEAM: String = String::from(\"valueof:TURBO_TEAM\");\n+        static ref TURBO_TOKEN: String = String::from(\"valueof:TURBO_TOKEN\");\n+    }\n+\n+    struct TestCase {\n+        input: Input,\n+        output: Output,\n+        reason: &'static str,\n+    }\n+\n+    impl TestCase {\n+        fn new() -> Self {\n+            Self {\n+                input: Input::new(),\n+                output: Output::new(),\n+                reason: \"missing\",\n+            }\n+        }\n+\n+        fn reason(mut self, reason: &'static str) -> Self {\n+            self.reason = reason;\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn VERCEL_ARTIFACTS_OWNER(mut self) -> Self {\n+            self.input.VERCEL_ARTIFACTS_OWNER = Some(VERCEL_ARTIFACTS_OWNER.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn VERCEL_ARTIFACTS_TOKEN(mut self) -> Self {\n+            self.input.VERCEL_ARTIFACTS_TOKEN = Some(VERCEL_ARTIFACTS_TOKEN.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TEAMID(mut self) -> Self {\n+            self.input.TURBO_TEAMID = Some(TURBO_TEAMID.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TEAM(mut self) -> Self {\n+            self.input.TURBO_TEAM = Some(TURBO_TEAM.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TOKEN(mut self) -> Self {\n+            self.input.TURBO_TOKEN = Some(TURBO_TOKEN.clone());\n+            self\n+        }\n+\n+        fn team_id(mut self, value: String) -> Self {\n+            self.output.team_id = Some(value);\n+            self\n+        }\n+\n+        fn team_slug(mut self, value: String) -> Self {\n+            self.output.team_slug = Some(value);\n+            self\n+        }\n+\n+        fn token(mut self, value: String) -> Self {\n+            self.output.token = Some(value);\n+            self\n+        }",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1803577782",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9249,
        "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
        "discussion_id": "1803577782",
        "commented_code": "@@ -0,0 +1,493 @@\n+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+        }\n+    }\n+}\n+\n+// this is an internal structure (that's a partial of ConfigurationOptions) that\n+// we use to store\n+pub struct Output {\n+    /// maps to ConfigurationOptions.team_id\n+    pub team_id: Option<String>,\n+    // maps to ConfigurationOptions.team_slug\n+    pub team_slug: Option<String>,\n+    // maps to ConfigurationOptions.token\n+    pub token: Option<String>,\n+}\n+\n+impl Output {\n+    fn new() -> Self {\n+        Self {\n+            team_id: None,\n+            team_slug: None,\n+            token: None,\n+        }\n+    }\n+}\n+\n+// get Output from Input\n+impl From<Input> for Output {\n+    fn from(input: Input) -> Self {\n+        let mut output = Output::new();\n+\n+        // TURBO_TEAMID+TURBO_TOKEN\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAM.is_some() {\n+                // there can also be a TURBO_TEAM, so we'll use that as well\n+                output.team_slug = input.TURBO_TEAM;\n+            }\n+\n+            return output;\n+        }\n+\n+        // TURBO_TEAM+TURBO_TOKEN\n+        if input.TURBO_TEAM.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_slug = input.TURBO_TEAM;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAMID.is_some() {\n+                // there can also be a TURBO_TEAMID, so we'll use that as well\n+                output.team_id = input.TURBO_TEAMID;\n+            }\n+\n+            return output;\n+        }\n+\n+        // if there's both Vercel items, we use those next\n+        if input.VERCEL_ARTIFACTS_OWNER.is_some() && input.VERCEL_ARTIFACTS_TOKEN.is_some() {\n+            output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            output.token = input.VERCEL_ARTIFACTS_TOKEN;\n+            return output;\n+        }\n+\n+        // from this point below, there's no token we can do anything with\n+        // ------------------------------------------------\n+\n+        // if there's no token, this is also permissible\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TEAM.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.team_slug = input.TURBO_TEAM;\n+            return output;\n+        }\n+\n+        // handle \"only\" cases\n+        // ------------------------------------------------\n+        if input.TURBO_TEAMID.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            return output;\n+        }\n+\n+        if input.TURBO_TEAM.is_some() {\n+            output.team_slug = input.TURBO_TEAM;\n+\n+            if input.VERCEL_ARTIFACTS_OWNER.is_some() {\n+                output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            }\n+\n+            return output;\n+        }\n+\n+        if input.VERCEL_ARTIFACTS_OWNER.is_some() {\n+            output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            return output;\n+        }\n+\n+        Output::new()\n+    }\n+}\n+\n+pub struct OverrideEnvVars<'a> {\n+    environment: &'a HashMap<OsString, OsString>,\n+    output: Output,\n+}\n+\n+impl<'a> OverrideEnvVars<'a> {\n+    pub fn new(environment: &'a HashMap<OsString, OsString>) -> Result<Self, Error> {\n+        let input = Input::from(environment);\n+        let output = Output::from(input);\n+\n+        Ok(Self {\n+            environment,\n+            output,\n+        })\n+    }\n+\n+    fn ui(&self) -> Option<UIMode> {\n+        // TODO double check on what's going on here\n+        let value = self\n+            .environment\n+            .get(OsStr::new(\"ci\"))\n+            .or_else(|| self.environment.get(OsStr::new(\"no_color\")))?;\n+        match truth_env_var(value.to_str()?)? {\n+            true => Some(UIMode::Stream),\n+            false => None,\n+        }\n+    }\n+}\n+\n+impl<'a> ResolvedConfigurationOptions for OverrideEnvVars<'a> {\n+    fn get_configuration_options(\n+        &self,\n+        _existing_config: Option<&ConfigurationOptions>,\n+    ) -> Result<ConfigurationOptions, Error> {\n+        let output = ConfigurationOptions {\n+            team_id: self.output.team_id.clone(),\n+            token: self.output.token.clone(),\n+            team_slug: self.output.team_slug.clone(),\n+            ui: self.ui(),\n+            api_url: None,\n+            ..Default::default()\n+        };\n+        Ok(output)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use lazy_static::lazy_static;\n+\n+    use super::*;\n+\n+    lazy_static! {\n+        static ref VERCEL_ARTIFACTS_OWNER: String = String::from(\"valueof:VERCEL_ARTIFACTS_OWNER\");\n+        static ref VERCEL_ARTIFACTS_TOKEN: String = String::from(\"valueof:VERCEL_ARTIFACTS_TOKEN\");\n+        static ref TURBO_TEAMID: String = String::from(\"valueof:TURBO_TEAMID\");\n+        static ref TURBO_TEAM: String = String::from(\"valueof:TURBO_TEAM\");\n+        static ref TURBO_TOKEN: String = String::from(\"valueof:TURBO_TOKEN\");\n+    }\n+\n+    struct TestCase {\n+        input: Input,\n+        output: Output,\n+        reason: &'static str,\n+    }\n+\n+    impl TestCase {\n+        fn new() -> Self {\n+            Self {\n+                input: Input::new(),\n+                output: Output::new(),\n+                reason: \"missing\",\n+            }\n+        }\n+\n+        fn reason(mut self, reason: &'static str) -> Self {\n+            self.reason = reason;\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn VERCEL_ARTIFACTS_OWNER(mut self) -> Self {\n+            self.input.VERCEL_ARTIFACTS_OWNER = Some(VERCEL_ARTIFACTS_OWNER.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn VERCEL_ARTIFACTS_TOKEN(mut self) -> Self {\n+            self.input.VERCEL_ARTIFACTS_TOKEN = Some(VERCEL_ARTIFACTS_TOKEN.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TEAMID(mut self) -> Self {\n+            self.input.TURBO_TEAMID = Some(TURBO_TEAMID.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TEAM(mut self) -> Self {\n+            self.input.TURBO_TEAM = Some(TURBO_TEAM.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TOKEN(mut self) -> Self {\n+            self.input.TURBO_TOKEN = Some(TURBO_TOKEN.clone());\n+            self\n+        }\n+\n+        fn team_id(mut self, value: String) -> Self {\n+            self.output.team_id = Some(value);\n+            self\n+        }\n+\n+        fn team_slug(mut self, value: String) -> Self {\n+            self.output.team_slug = Some(value);\n+            self\n+        }\n+\n+        fn token(mut self, value: String) -> Self {\n+            self.output.token = Some(value);\n+            self\n+        }",
        "comment_created_at": "2024-10-16T18:05:38+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "If you follow the above suggestion you can change this to also just take `&str`\r\n```suggestion\r\n        fn token(mut self, value: &str) -> Self {\r\n            self.output.token = Some(value.into());\r\n            self\r\n        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1803987856",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9249,
        "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
        "discussion_id": "1803577782",
        "commented_code": "@@ -0,0 +1,493 @@\n+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+        }\n+    }\n+}\n+\n+// this is an internal structure (that's a partial of ConfigurationOptions) that\n+// we use to store\n+pub struct Output {\n+    /// maps to ConfigurationOptions.team_id\n+    pub team_id: Option<String>,\n+    // maps to ConfigurationOptions.team_slug\n+    pub team_slug: Option<String>,\n+    // maps to ConfigurationOptions.token\n+    pub token: Option<String>,\n+}\n+\n+impl Output {\n+    fn new() -> Self {\n+        Self {\n+            team_id: None,\n+            team_slug: None,\n+            token: None,\n+        }\n+    }\n+}\n+\n+// get Output from Input\n+impl From<Input> for Output {\n+    fn from(input: Input) -> Self {\n+        let mut output = Output::new();\n+\n+        // TURBO_TEAMID+TURBO_TOKEN\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAM.is_some() {\n+                // there can also be a TURBO_TEAM, so we'll use that as well\n+                output.team_slug = input.TURBO_TEAM;\n+            }\n+\n+            return output;\n+        }\n+\n+        // TURBO_TEAM+TURBO_TOKEN\n+        if input.TURBO_TEAM.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_slug = input.TURBO_TEAM;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAMID.is_some() {\n+                // there can also be a TURBO_TEAMID, so we'll use that as well\n+                output.team_id = input.TURBO_TEAMID;\n+            }\n+\n+            return output;\n+        }\n+\n+        // if there's both Vercel items, we use those next\n+        if input.VERCEL_ARTIFACTS_OWNER.is_some() && input.VERCEL_ARTIFACTS_TOKEN.is_some() {\n+            output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            output.token = input.VERCEL_ARTIFACTS_TOKEN;\n+            return output;\n+        }\n+\n+        // from this point below, there's no token we can do anything with\n+        // ------------------------------------------------\n+\n+        // if there's no token, this is also permissible\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TEAM.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.team_slug = input.TURBO_TEAM;\n+            return output;\n+        }\n+\n+        // handle \"only\" cases\n+        // ------------------------------------------------\n+        if input.TURBO_TEAMID.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            return output;\n+        }\n+\n+        if input.TURBO_TEAM.is_some() {\n+            output.team_slug = input.TURBO_TEAM;\n+\n+            if input.VERCEL_ARTIFACTS_OWNER.is_some() {\n+                output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            }\n+\n+            return output;\n+        }\n+\n+        if input.VERCEL_ARTIFACTS_OWNER.is_some() {\n+            output.team_id = input.VERCEL_ARTIFACTS_OWNER;\n+            return output;\n+        }\n+\n+        Output::new()\n+    }\n+}\n+\n+pub struct OverrideEnvVars<'a> {\n+    environment: &'a HashMap<OsString, OsString>,\n+    output: Output,\n+}\n+\n+impl<'a> OverrideEnvVars<'a> {\n+    pub fn new(environment: &'a HashMap<OsString, OsString>) -> Result<Self, Error> {\n+        let input = Input::from(environment);\n+        let output = Output::from(input);\n+\n+        Ok(Self {\n+            environment,\n+            output,\n+        })\n+    }\n+\n+    fn ui(&self) -> Option<UIMode> {\n+        // TODO double check on what's going on here\n+        let value = self\n+            .environment\n+            .get(OsStr::new(\"ci\"))\n+            .or_else(|| self.environment.get(OsStr::new(\"no_color\")))?;\n+        match truth_env_var(value.to_str()?)? {\n+            true => Some(UIMode::Stream),\n+            false => None,\n+        }\n+    }\n+}\n+\n+impl<'a> ResolvedConfigurationOptions for OverrideEnvVars<'a> {\n+    fn get_configuration_options(\n+        &self,\n+        _existing_config: Option<&ConfigurationOptions>,\n+    ) -> Result<ConfigurationOptions, Error> {\n+        let output = ConfigurationOptions {\n+            team_id: self.output.team_id.clone(),\n+            token: self.output.token.clone(),\n+            team_slug: self.output.team_slug.clone(),\n+            ui: self.ui(),\n+            api_url: None,\n+            ..Default::default()\n+        };\n+        Ok(output)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use lazy_static::lazy_static;\n+\n+    use super::*;\n+\n+    lazy_static! {\n+        static ref VERCEL_ARTIFACTS_OWNER: String = String::from(\"valueof:VERCEL_ARTIFACTS_OWNER\");\n+        static ref VERCEL_ARTIFACTS_TOKEN: String = String::from(\"valueof:VERCEL_ARTIFACTS_TOKEN\");\n+        static ref TURBO_TEAMID: String = String::from(\"valueof:TURBO_TEAMID\");\n+        static ref TURBO_TEAM: String = String::from(\"valueof:TURBO_TEAM\");\n+        static ref TURBO_TOKEN: String = String::from(\"valueof:TURBO_TOKEN\");\n+    }\n+\n+    struct TestCase {\n+        input: Input,\n+        output: Output,\n+        reason: &'static str,\n+    }\n+\n+    impl TestCase {\n+        fn new() -> Self {\n+            Self {\n+                input: Input::new(),\n+                output: Output::new(),\n+                reason: \"missing\",\n+            }\n+        }\n+\n+        fn reason(mut self, reason: &'static str) -> Self {\n+            self.reason = reason;\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn VERCEL_ARTIFACTS_OWNER(mut self) -> Self {\n+            self.input.VERCEL_ARTIFACTS_OWNER = Some(VERCEL_ARTIFACTS_OWNER.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn VERCEL_ARTIFACTS_TOKEN(mut self) -> Self {\n+            self.input.VERCEL_ARTIFACTS_TOKEN = Some(VERCEL_ARTIFACTS_TOKEN.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TEAMID(mut self) -> Self {\n+            self.input.TURBO_TEAMID = Some(TURBO_TEAMID.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TEAM(mut self) -> Self {\n+            self.input.TURBO_TEAM = Some(TURBO_TEAM.clone());\n+            self\n+        }\n+\n+        #[allow(non_snake_case)]\n+        fn TURBO_TOKEN(mut self) -> Self {\n+            self.input.TURBO_TOKEN = Some(TURBO_TOKEN.clone());\n+            self\n+        }\n+\n+        fn team_id(mut self, value: String) -> Self {\n+            self.output.team_id = Some(value);\n+            self\n+        }\n+\n+        fn team_slug(mut self, value: String) -> Self {\n+            self.output.team_slug = Some(value);\n+            self\n+        }\n+\n+        fn token(mut self, value: String) -> Self {\n+            self.output.token = Some(value);\n+            self\n+        }",
        "comment_created_at": "2024-10-17T01:28:24+00:00",
        "comment_author": "dimitropoulos",
        "comment_body": "!!!!!!!!!! AWESOME\r\n\r\ncffcb17fa23f293f483b45695304064813db9007\r\n\r\nthat's _EXACTLY_ the API I was hoping to achieve in the first place.  thanks for walking me through that!!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1761785344",
    "pr_number": 9149,
    "pr_file": "crates/turborepo-lib/src/turbo_json/loader.rs",
    "created_at": "2024-09-16T19:44:38+00:00",
    "commented_code": ")\n                 }\n             }\n+            Strategy::Noop => Err(Error::NoTurboJSON),",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1761785344",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9149,
        "pr_file": "crates/turborepo-lib/src/turbo_json/loader.rs",
        "discussion_id": "1761785344",
        "commented_code": "@@ -114,6 +144,7 @@ impl TurboJsonLoader {\n                     )\n                 }\n             }\n+            Strategy::Noop => Err(Error::NoTurboJSON),",
        "comment_created_at": "2024-09-16T19:44:38+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "I'm wondering if we should make the API into a `Result<Option<TurboJson>, Error>` to more explicitly force callers to handle the non-existent `turbo.json` case",
        "pr_file_module": null
      },
      {
        "comment_id": "1763148789",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9149,
        "pr_file": "crates/turborepo-lib/src/turbo_json/loader.rs",
        "discussion_id": "1761785344",
        "commented_code": "@@ -114,6 +144,7 @@ impl TurboJsonLoader {\n                     )\n                 }\n             }\n+            Strategy::Noop => Err(Error::NoTurboJSON),",
        "comment_created_at": "2024-09-17T12:24:05+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Only when building the engine do we view a non-existent `turbo.json` as a non-error. I'm not sure requiring the other callers to construct the `NoTurboJSON` error type manually is worth the better ergonomics in the engine builder.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1721966804",
    "pr_number": 9031,
    "pr_file": "crates/turborepo-lib/src/commands/ls.rs",
    "created_at": "2024-08-19T15:21:29+00:00",
    "commented_code": "packages: Vec<(&'a PackageName, &'a AnchoredSystemPath)>,\n }\n \n+impl<'a> Serialize for RepositoryDetails<'a> {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1721966804",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9031,
        "pr_file": "crates/turborepo-lib/src/commands/ls.rs",
        "discussion_id": "1721966804",
        "commented_code": "@@ -30,10 +31,42 @@ struct RepositoryDetails<'a> {\n     packages: Vec<(&'a PackageName, &'a AnchoredSystemPath)>,\n }\n \n+impl<'a> Serialize for RepositoryDetails<'a> {",
        "comment_created_at": "2024-08-19T15:21:29+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "Any reason we're implementing this manually versus doing the derive?",
        "pr_file_module": null
      },
      {
        "comment_id": "1721973316",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9031,
        "pr_file": "crates/turborepo-lib/src/commands/ls.rs",
        "discussion_id": "1721966804",
        "commented_code": "@@ -30,10 +31,42 @@ struct RepositoryDetails<'a> {\n     packages: Vec<(&'a PackageName, &'a AnchoredSystemPath)>,\n }\n \n+impl<'a> Serialize for RepositoryDetails<'a> {",
        "comment_created_at": "2024-08-19T15:26:00+00:00",
        "comment_author": "tknickman",
        "comment_body": "Using the derive gives us arrays:\r\n\r\n```\r\npackages: [\r\n [name, path]\r\n ...\r\n]\r\n```\r\n\r\nBut I wanted a little more control over it",
        "pr_file_module": null
      },
      {
        "comment_id": "1722041991",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9031,
        "pr_file": "crates/turborepo-lib/src/commands/ls.rs",
        "discussion_id": "1721966804",
        "commented_code": "@@ -30,10 +31,42 @@ struct RepositoryDetails<'a> {\n     packages: Vec<(&'a PackageName, &'a AnchoredSystemPath)>,\n }\n \n+impl<'a> Serialize for RepositoryDetails<'a> {",
        "comment_created_at": "2024-08-19T16:14:22+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "I would highly suggest leveraging `#[serde(into)]` [docs](https://serde.rs/container-attrs.html#into) here instead of manually implementing this. The general pattern is create a new type like `RepoDetailsDisplay` and then create a `impl<'a> From<&'a RepositoryDetails<'a>> for RepoDetailsDisplay<'a>` which does any of the desired conversions. e.g. `(&PackageName, &AnchoredSystemPath) -> PackageDetails { name: String, path: String }`",
        "pr_file_module": null
      },
      {
        "comment_id": "1722089715",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9031,
        "pr_file": "crates/turborepo-lib/src/commands/ls.rs",
        "discussion_id": "1721966804",
        "commented_code": "@@ -30,10 +31,42 @@ struct RepositoryDetails<'a> {\n     packages: Vec<(&'a PackageName, &'a AnchoredSystemPath)>,\n }\n \n+impl<'a> Serialize for RepositoryDetails<'a> {",
        "comment_created_at": "2024-08-19T16:56:16+00:00",
        "comment_author": "tknickman",
        "comment_body": "Nice, thanks for the suggestion - done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1663221365",
    "pr_number": 8650,
    "pr_file": "crates/turborepo-ui/src/tui/app.rs",
    "created_at": "2024-07-02T22:10:58+00:00",
    "commented_code": "app.next();\n         }\n         Event::ScrollUp => {\n-            app.scroll(Direction::Up);\n+            app.has_user_scrolled = true;\n+            app.tasks\n+                .get_mut(&app.active_task())\n+                .unwrap()\n+                .scroll(Direction::Up)\n+                .unwrap_or_default();\n         }\n         Event::ScrollDown => {\n-            app.scroll(Direction::Down);\n+            app.has_user_scrolled = true;\n+            app.tasks\n+                .get_mut(&app.active_task())\n+                .unwrap()\n+                .scroll(Direction::Down)\n+                .unwrap_or_default();\n         }\n         Event::EnterInteractive => {\n-            app.interact(true);\n+            app.has_user_scrolled = true;\n+            app.interact();\n         }\n         Event::ExitInteractive => {\n-            app.interact(false);\n+            app.has_user_scrolled = true;\n+            app.interact();\n         }\n         Event::Input { bytes } => {\n             app.forward_input(&bytes)?;\n         }\n-        Event::SetStdin { task, stdin } => {\n-            app.pane.insert_stdin(&task, Some(stdin))?;\n+        Event::SetStdin { stdin } => {\n+            app.insert_stdin(Some(stdin))?;\n         }\n         Event::UpdateTasks { tasks } => {\n             app.update_tasks(tasks);\n-            app.table.tick();\n+            // app.table.tick();\n         }\n     }\n     Ok(None)\n }\n \n-fn view<I>(app: &mut App<I>, f: &mut Frame) {\n-    let (_, width) = app.term_size();\n-    let vertical = Layout::horizontal([Constraint::Fill(1), Constraint::Length(width)]);\n-    let [table, pane] = vertical.areas(f.size());\n-    app.table.stateful_render(f, table);\n-    f.render_widget(&app.pane, pane);\n+fn view(app: &mut App<Box<dyn io::Write + Send>>, f: &mut Frame, rows: u16, cols: u16) {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1663221365",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8650,
        "pr_file": "crates/turborepo-ui/src/tui/app.rs",
        "discussion_id": "1663221365",
        "commented_code": "@@ -255,35 +429,236 @@ fn update(\n             app.next();\n         }\n         Event::ScrollUp => {\n-            app.scroll(Direction::Up);\n+            app.has_user_scrolled = true;\n+            app.tasks\n+                .get_mut(&app.active_task())\n+                .unwrap()\n+                .scroll(Direction::Up)\n+                .unwrap_or_default();\n         }\n         Event::ScrollDown => {\n-            app.scroll(Direction::Down);\n+            app.has_user_scrolled = true;\n+            app.tasks\n+                .get_mut(&app.active_task())\n+                .unwrap()\n+                .scroll(Direction::Down)\n+                .unwrap_or_default();\n         }\n         Event::EnterInteractive => {\n-            app.interact(true);\n+            app.has_user_scrolled = true;\n+            app.interact();\n         }\n         Event::ExitInteractive => {\n-            app.interact(false);\n+            app.has_user_scrolled = true;\n+            app.interact();\n         }\n         Event::Input { bytes } => {\n             app.forward_input(&bytes)?;\n         }\n-        Event::SetStdin { task, stdin } => {\n-            app.pane.insert_stdin(&task, Some(stdin))?;\n+        Event::SetStdin { stdin } => {\n+            app.insert_stdin(Some(stdin))?;\n         }\n         Event::UpdateTasks { tasks } => {\n             app.update_tasks(tasks);\n-            app.table.tick();\n+            // app.table.tick();\n         }\n     }\n     Ok(None)\n }\n \n-fn view<I>(app: &mut App<I>, f: &mut Frame) {\n-    let (_, width) = app.term_size();\n-    let vertical = Layout::horizontal([Constraint::Fill(1), Constraint::Length(width)]);\n-    let [table, pane] = vertical.areas(f.size());\n-    app.table.stateful_render(f, table);\n-    f.render_widget(&app.pane, pane);\n+fn view(app: &mut App<Box<dyn io::Write + Send>>, f: &mut Frame, rows: u16, cols: u16) {",
        "comment_created_at": "2024-07-02T22:10:58+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "We don't need to specify an exact underlying writer type here, we can render an app regardless of what sort of stdin handles it has.\r\n\r\n```suggestion\r\nfn view<W>(app: &mut App<W>, f: &mut Frame, rows: u16, cols: u16) {\r\n```",
        "pr_file_module": null
      }
    ]
  }
]