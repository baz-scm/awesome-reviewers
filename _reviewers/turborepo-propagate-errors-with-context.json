[
  {
    "discussion_id": "2068561107",
    "pr_number": 10407,
    "pr_file": "crates/turborepo-scm/src/git.rs",
    "created_at": "2025-04-30T12:27:52+00:00",
    "commented_code": "let stdout = String::from_utf8(stdout).unwrap();\n         for line in stdout.lines() {\n             let path = RelativeUnixPath::new(line).unwrap();\n-            let anchored_to_turbo_root_file_path = self\n-                .reanchor_path_from_git_root_to_turbo_root(turbo_root, path)\n-                .unwrap();\n-            files.insert(anchored_to_turbo_root_file_path);\n+            match self.reanchor_path_from_git_root_to_turbo_root(turbo_root, path) {\n+                Ok(anchored_to_turbo_root_file_path) => {\n+                    files.insert(anchored_to_turbo_root_file_path);\n+                }\n+                Err(err) => {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "2068561107",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10407,
        "pr_file": "crates/turborepo-scm/src/git.rs",
        "discussion_id": "2068561107",
        "commented_code": "@@ -354,10 +354,17 @@ impl GitRepo {\n         let stdout = String::from_utf8(stdout).unwrap();\n         for line in stdout.lines() {\n             let path = RelativeUnixPath::new(line).unwrap();\n-            let anchored_to_turbo_root_file_path = self\n-                .reanchor_path_from_git_root_to_turbo_root(turbo_root, path)\n-                .unwrap();\n-            files.insert(anchored_to_turbo_root_file_path);\n+            match self.reanchor_path_from_git_root_to_turbo_root(turbo_root, path) {\n+                Ok(anchored_to_turbo_root_file_path) => {\n+                    files.insert(anchored_to_turbo_root_file_path);\n+                }\n+                Err(err) => {",
        "comment_created_at": "2025-04-30T12:27:52+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Bubble up this error so it reaches the caller and they can decide what to do with it. In our case when this error is eventually returned in `change_detector.rs` we should catch it and behave as if every package changed since we cannot identify which exact packages changed. The warning you added should be moved there with an updated message.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070406873",
    "pr_number": 10407,
    "pr_file": "crates/turborepo-scm/src/git.rs",
    "created_at": "2025-05-01T15:25:48+00:00",
    "commented_code": "files: &mut HashSet<AnchoredSystemPathBuf>,\n         turbo_root: &AbsoluteSystemPath,\n         stdout: Vec<u8>,\n-    ) {\n-        let stdout = String::from_utf8(stdout).unwrap();\n+    ) -> Result<(), Error> {\n+        let stdout = String::from_utf8_lossy(&stdout);",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "2070406873",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10407,
        "pr_file": "crates/turborepo-scm/src/git.rs",
        "discussion_id": "2070406873",
        "commented_code": "@@ -350,15 +360,29 @@ impl GitRepo {\n         files: &mut HashSet<AnchoredSystemPathBuf>,\n         turbo_root: &AbsoluteSystemPath,\n         stdout: Vec<u8>,\n-    ) {\n-        let stdout = String::from_utf8(stdout).unwrap();\n+    ) -> Result<(), Error> {\n+        let stdout = String::from_utf8_lossy(&stdout);",
        "comment_created_at": "2025-05-01T15:25:48+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "I do not want a lossy conversion as this will cause silent failures upstream. Please report up any non-UTF8 output as an error.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1970572477",
    "pr_number": 9995,
    "pr_file": "crates/turborepo-signals/src/listeners.rs",
    "created_at": "2025-02-25T21:31:49+00:00",
    "commented_code": "+use futures::{stream, Stream};\n+\n+use crate::signals::Signal;\n+\n+#[cfg(windows)]\n+/// A listener for Windows Console Ctrl-C events\n+pub fn get_signal() -> Result<impl Stream<Item = Option<Signal>>, std::io::Error> {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1970572477",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9995,
        "pr_file": "crates/turborepo-signals/src/listeners.rs",
        "discussion_id": "1970572477",
        "commented_code": "@@ -0,0 +1,33 @@\n+use futures::{stream, Stream};\n+\n+use crate::signals::Signal;\n+\n+#[cfg(windows)]\n+/// A listener for Windows Console Ctrl-C events\n+pub fn get_signal() -> Result<impl Stream<Item = Option<Signal>>, std::io::Error> {",
        "comment_created_at": "2025-02-25T21:31:49+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "Minor detail, but maybe we should make this a custom error type so we can annotate the `run::Error` type with `#[from]` and avoid having to use `map_err` when calling this?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1884614203",
    "pr_number": 9512,
    "pr_file": "crates/turborepo-ui/src/tui/preferences.rs",
    "created_at": "2024-12-13T22:35:33+00:00",
    "commented_code": "+use std::{\n+    fs::{self, File},\n+    io::{BufReader, Write},\n+};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::{from_reader, json, Value};\n+use turbopath::AbsoluteSystemPathBuf;\n+\n+use super::task::TasksByStatus;\n+\n+#[derive(Serialize, Deserialize, Debug)]\n+pub struct Preferences {\n+    pub is_task_list_visible: Option<bool>,\n+    pub active_task: Option<String>,\n+    pub is_pinned_task_selection: Option<bool>,\n+}\n+\n+#[derive(Debug)]\n+pub enum PreferenceFields {\n+    IsTaskListVisible,\n+    ActiveTask,\n+    PinnedTaskSelection,\n+}\n+\n+impl Default for Preferences {\n+    fn default() -> Self {\n+        Self {\n+            active_task: None,\n+            is_task_list_visible: Some(true),\n+            is_pinned_task_selection: Some(false),\n+        }\n+    }\n+}\n+\n+const TUI_PREFERENCES_PATH_COMPONENTS: &[&str] = &[\".turbo\", \"preferences\", \"tui.json\"];\n+\n+fn read_json(path: &AbsoluteSystemPathBuf) -> Preferences {\n+    File::open(path)\n+        .ok()\n+        .and_then(|file| from_reader(BufReader::new(file)).ok())\n+        .unwrap_or_default()\n+}\n+\n+impl Preferences {\n+    pub fn update_preference(\n+        repo_root: &AbsoluteSystemPathBuf,\n+        field: PreferenceFields,\n+        new_value: Value,\n+    ) -> Result<(), Box<dyn std::error::Error>> {\n+        // TODO: Clean these up, should be taken from constants\n+        let preferences_dir = repo_root.join_components(&[\".turbo\", \"preferences\"]);\n+        let preferences_file = repo_root.join_components(&[\".turbo\", \"preferences\", \"tui.json\"]);\n+\n+        fs::create_dir_all(preferences_dir.as_std_path())?;",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1884614203",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9512,
        "pr_file": "crates/turborepo-ui/src/tui/preferences.rs",
        "discussion_id": "1884614203",
        "commented_code": "@@ -0,0 +1,132 @@\n+use std::{\n+    fs::{self, File},\n+    io::{BufReader, Write},\n+};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::{from_reader, json, Value};\n+use turbopath::AbsoluteSystemPathBuf;\n+\n+use super::task::TasksByStatus;\n+\n+#[derive(Serialize, Deserialize, Debug)]\n+pub struct Preferences {\n+    pub is_task_list_visible: Option<bool>,\n+    pub active_task: Option<String>,\n+    pub is_pinned_task_selection: Option<bool>,\n+}\n+\n+#[derive(Debug)]\n+pub enum PreferenceFields {\n+    IsTaskListVisible,\n+    ActiveTask,\n+    PinnedTaskSelection,\n+}\n+\n+impl Default for Preferences {\n+    fn default() -> Self {\n+        Self {\n+            active_task: None,\n+            is_task_list_visible: Some(true),\n+            is_pinned_task_selection: Some(false),\n+        }\n+    }\n+}\n+\n+const TUI_PREFERENCES_PATH_COMPONENTS: &[&str] = &[\".turbo\", \"preferences\", \"tui.json\"];\n+\n+fn read_json(path: &AbsoluteSystemPathBuf) -> Preferences {\n+    File::open(path)\n+        .ok()\n+        .and_then(|file| from_reader(BufReader::new(file)).ok())\n+        .unwrap_or_default()\n+}\n+\n+impl Preferences {\n+    pub fn update_preference(\n+        repo_root: &AbsoluteSystemPathBuf,\n+        field: PreferenceFields,\n+        new_value: Value,\n+    ) -> Result<(), Box<dyn std::error::Error>> {\n+        // TODO: Clean these up, should be taken from constants\n+        let preferences_dir = repo_root.join_components(&[\".turbo\", \"preferences\"]);\n+        let preferences_file = repo_root.join_components(&[\".turbo\", \"preferences\", \"tui.json\"]);\n+\n+        fs::create_dir_all(preferences_dir.as_std_path())?;",
        "comment_created_at": "2024-12-13T22:35:33+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Generally we should prefer methods on the `turbopath`s types since we have nicer error messages. (By default Rust io errors don't include paths in them which can lead to frustrating error messages).\r\n\r\n```suggestion\r\n        preferences_file.ensure_dir()?;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1887915076",
    "pr_number": 9512,
    "pr_file": "crates/turborepo-ui/src/tui/mod.rs",
    "created_at": "2024-12-17T05:24:48+00:00",
    "commented_code": "Stdin { name: String, e: std::io::Error },\n     #[error(transparent)]\n     Io(#[from] std::io::Error),\n+    #[error(\"Unable to persist preferences\")]",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1887915076",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9512,
        "pr_file": "crates/turborepo-ui/src/tui/mod.rs",
        "discussion_id": "1887915076",
        "commented_code": "@@ -36,4 +37,6 @@ pub enum Error {\n     Stdin { name: String, e: std::io::Error },\n     #[error(transparent)]\n     Io(#[from] std::io::Error),\n+    #[error(\"Unable to persist preferences\")]",
        "comment_created_at": "2024-12-17T05:24:48+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "Would it make sense to do:\r\n\r\n```suggestion\r\n    #[error(\"Unable to persist preferences. Please file a bug report.\")]\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1829517267",
    "pr_number": 9368,
    "pr_file": "crates/turborepo-lib/src/cli/mod.rs",
    "created_at": "2024-11-05T15:04:00+00:00",
    "commented_code": "generate::run(tag, command, &args, child_event)?;\n             Ok(0)\n         }\n+        Command::Info => {\n+            CommandEventBuilder::new(\"info\")\n+                .with_parent(&root_telemetry)\n+                .track_call();\n+            let base = CommandBase::new(cli_args.clone(), repo_root, version, color_config);\n+\n+            match info::run(base).await {\n+                Ok(()) => {}\n+                Err(_e) => panic!(\"`info` command failed.\"),\n+            }",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1829517267",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9368,
        "pr_file": "crates/turborepo-lib/src/cli/mod.rs",
        "discussion_id": "1829517267",
        "commented_code": "@@ -1214,6 +1214,18 @@ pub async fn run(\n             generate::run(tag, command, &args, child_event)?;\n             Ok(0)\n         }\n+        Command::Info => {\n+            CommandEventBuilder::new(\"info\")\n+                .with_parent(&root_telemetry)\n+                .track_call();\n+            let base = CommandBase::new(cli_args.clone(), repo_root, version, color_config);\n+\n+            match info::run(base).await {\n+                Ok(()) => {}\n+                Err(_e) => panic!(\"`info` command failed.\"),\n+            }",
        "comment_created_at": "2024-11-05T15:04:00+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "We generally want to avoid `panic` here and if we do panic, we should make sure to include the underlying error.\r\n\r\nYou can use `?` operator here to bubble up the error if you add a new variant to the cli error type [here](https://github.com/vercel/turborepo/blob/main/crates/turborepo-lib/src/cli/error.rs#L21):\r\n```\r\n#[error(transparent)]\r\nInfo(#[from] info::Error),\r\n```\r\n```suggestion\r\n            info::run(base).await?;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1829631588",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9368,
        "pr_file": "crates/turborepo-lib/src/cli/mod.rs",
        "discussion_id": "1829517267",
        "commented_code": "@@ -1214,6 +1214,18 @@ pub async fn run(\n             generate::run(tag, command, &args, child_event)?;\n             Ok(0)\n         }\n+        Command::Info => {\n+            CommandEventBuilder::new(\"info\")\n+                .with_parent(&root_telemetry)\n+                .track_call();\n+            let base = CommandBase::new(cli_args.clone(), repo_root, version, color_config);\n+\n+            match info::run(base).await {\n+                Ok(()) => {}\n+                Err(_e) => panic!(\"`info` command failed.\"),\n+            }",
        "comment_created_at": "2024-11-05T16:11:10+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "Oh I recommended panic here because the previous message was to open a GitHub Issue and panic includes that advice ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1831691733",
    "pr_number": 9368,
    "pr_file": "crates/turborepo-lib/src/commands/info.rs",
    "created_at": "2024-11-06T20:50:12+00:00",
    "commented_code": "+use std::{env, io};\n+\n+use sysinfo::{System, SystemExt};\n+use thiserror::Error;\n+use turborepo_repository::{package_json::PackageJson, package_manager::PackageManager};\n+\n+use super::CommandBase;\n+use crate::{DaemonConnector, DaemonConnectorError};\n+\n+#[derive(Debug, Error)]\n+pub enum Error {\n+    #[error(\"could not get path to turbo binary: {0}\")]\n+    NoCurrentExe(#[from] io::Error),\n+}\n+\n+pub async fn run(base: CommandBase) -> Result<(), Error> {\n+    let system = System::new_all();\n+    let connector = DaemonConnector::new(false, false, &base.repo_root);\n+    let daemon_status = match connector.connect().await {\n+        Ok(_status) => \"Running\",\n+        Err(DaemonConnectorError::NotRunning) => \"Not running\",\n+        Err(_e) => \"Error getting status\",\n+    };\n+    let package_manager = PackageJson::load(&base.repo_root.join_component(\"package.json\"))\n+        .and_then(|package_json| {\n+            Ok(PackageManager::read_or_detect_package_manager(\n+                &package_json,\n+                &base.repo_root,\n+            ))\n+        })\n+        .map_or_else(|_| \"Not found\".to_owned(), |pm| pm.unwrap().to_string());\n+\n+    println!(\"CLI:\");\n+    println!(\"   Version: {}\", base.version);\n+\n+    let exe_path = std::env::current_exe().map_or_else(\n+        |_| \"Cannot be found\".to_string(),",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1831691733",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9368,
        "pr_file": "crates/turborepo-lib/src/commands/info.rs",
        "discussion_id": "1831691733",
        "commented_code": "@@ -0,0 +1,79 @@\n+use std::{env, io};\n+\n+use sysinfo::{System, SystemExt};\n+use thiserror::Error;\n+use turborepo_repository::{package_json::PackageJson, package_manager::PackageManager};\n+\n+use super::CommandBase;\n+use crate::{DaemonConnector, DaemonConnectorError};\n+\n+#[derive(Debug, Error)]\n+pub enum Error {\n+    #[error(\"could not get path to turbo binary: {0}\")]\n+    NoCurrentExe(#[from] io::Error),\n+}\n+\n+pub async fn run(base: CommandBase) -> Result<(), Error> {\n+    let system = System::new_all();\n+    let connector = DaemonConnector::new(false, false, &base.repo_root);\n+    let daemon_status = match connector.connect().await {\n+        Ok(_status) => \"Running\",\n+        Err(DaemonConnectorError::NotRunning) => \"Not running\",\n+        Err(_e) => \"Error getting status\",\n+    };\n+    let package_manager = PackageJson::load(&base.repo_root.join_component(\"package.json\"))\n+        .and_then(|package_json| {\n+            Ok(PackageManager::read_or_detect_package_manager(\n+                &package_json,\n+                &base.repo_root,\n+            ))\n+        })\n+        .map_or_else(|_| \"Not found\".to_owned(), |pm| pm.unwrap().to_string());\n+\n+    println!(\"CLI:\");\n+    println!(\"   Version: {}\", base.version);\n+\n+    let exe_path = std::env::current_exe().map_or_else(\n+        |_| \"Cannot be found\".to_string(),",
        "comment_created_at": "2024-11-06T20:50:12+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Lets keep around the error as it could indicate some underlying issues with the system\r\n\r\n```suggestion\r\n        |e| format!(\"Cannot determine current binary: {e}\"),\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1803449655",
    "pr_number": 9249,
    "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
    "created_at": "2024-10-16T16:30:22+00:00",
    "commented_code": "+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1803449655",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9249,
        "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
        "discussion_id": "1803449655",
        "commented_code": "@@ -0,0 +1,493 @@\n+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),",
        "comment_created_at": "2024-10-16T16:30:22+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Can we keep the error messaging from `map_environment` in `env.rs`? The `unwrap`s will just report `tried to unwrap None` which isn't helpful for end users.",
        "pr_file_module": null
      },
      {
        "comment_id": "1805301802",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9249,
        "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
        "discussion_id": "1803449655",
        "commented_code": "@@ -0,0 +1,493 @@\n+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),",
        "comment_created_at": "2024-10-17T19:19:53+00:00",
        "comment_author": "dimitropoulos",
        "comment_body": "d999baad84aa0ec7890f9e71de161d61feddc321 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1742000591",
    "pr_number": 9087,
    "pr_file": "crates/turborepo-lib/src/config/mod.rs",
    "created_at": "2024-09-03T12:45:52+00:00",
    "commented_code": "+mod env;\n+mod file;\n+mod turbo_json;\n+\n+use std::{collections::HashMap, ffi::OsString, io};\n+\n+use camino::{Utf8Path, Utf8PathBuf};\n+use convert_case::{Case, Casing};\n+use env::{EnvVars, OverrideEnvVars};\n+use file::{AuthFile, ConfigFile};\n+use miette::{Diagnostic, NamedSource, SourceSpan};\n+use serde::Deserialize;\n+use struct_iterable::Iterable;\n+use thiserror::Error;\n+use turbo_json::TurboJsonReader;\n+use turbopath::{AbsoluteSystemPath, AbsoluteSystemPathBuf};\n+use turborepo_errors::TURBO_SITE;\n+\n+pub use crate::turbo_json::{RawTurboJson, UIMode};\n+use crate::{cli::EnvMode, commands::CommandBase, turbo_json::CONFIG_FILE};\n+\n+#[derive(Debug, Error, Diagnostic)]\n+#[error(\"Environment variables should not be prefixed with \\\"{env_pipeline_delimiter}\\\"\")]\n+#[diagnostic(\n+    code(invalid_env_prefix),\n+    url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab))\n+)]\n+pub struct InvalidEnvPrefixError {\n+    pub value: String,\n+    pub key: String,\n+    #[source_code]\n+    pub text: NamedSource,\n+    #[label(\"variable with invalid prefix declared here\")]\n+    pub span: Option<SourceSpan>,\n+    pub env_pipeline_delimiter: &'static str,\n+}\n+\n+#[allow(clippy::enum_variant_names)]\n+#[derive(Debug, Error, Diagnostic)]\n+pub enum Error {\n+    #[error(\"Authentication error: {0}\")]\n+    Auth(#[from] turborepo_auth::Error),\n+    #[error(\"Global config path not found\")]\n+    NoGlobalConfigPath,\n+    #[error(\"Global auth file path not found\")]\n+    NoGlobalAuthFilePath,\n+    #[error(\"Global config directory not found\")]\n+    NoGlobalConfigDir,\n+    #[error(transparent)]\n+    PackageJson(#[from] turborepo_repository::package_json::Error),\n+    #[error(\n+        \"Could not find turbo.json.\nFollow directions at https://turbo.build/repo/docs to create \\\n+         one\"\n+    )]\n+    NoTurboJSON,\n+    #[error(transparent)]\n+    SerdeJson(#[from] serde_json::Error),\n+    #[error(transparent)]\n+    Io(#[from] io::Error),\n+    #[error(transparent)]\n+    Camino(#[from] camino::FromPathBufError),\n+    #[error(transparent)]\n+    Reqwest(#[from] reqwest::Error),\n+    #[error(\"Encountered an IO error while attempting to read {config_path}: {error}\")]\n+    FailedToReadConfig {\n+        config_path: AbsoluteSystemPathBuf,\n+        error: io::Error,\n+    },\n+    #[error(\"Encountered an IO error while attempting to set {config_path}: {error}\")]\n+    FailedToSetConfig {\n+        config_path: AbsoluteSystemPathBuf,\n+        error: io::Error,\n+    },\n+    #[error(\n+        \"Package tasks (<package>#<task>) are not allowed in single-package repositories: found \\\n+         {task_id}\"\n+    )]\n+    #[diagnostic(code(package_task_in_single_package_mode), url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab)))]\n+    PackageTaskInSinglePackageMode {\n+        task_id: String,\n+        #[source_code]\n+        text: NamedSource,\n+        #[label(\"package task found here\")]\n+        span: Option<SourceSpan>,\n+    },\n+    #[error(transparent)]\n+    #[diagnostic(transparent)]\n+    InvalidEnvPrefix(Box<InvalidEnvPrefixError>),\n+    #[error(transparent)]\n+    PathError(#[from] turbopath::PathError),\n+    #[diagnostic(\n+        code(unnecessary_package_task_syntax),\n+        url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab))\n+    )]\n+    #[error(\"\\\"{actual}\\\". Use \\\"{wanted}\\\" instead\")]\n+    UnnecessaryPackageTaskSyntax {\n+        actual: String,\n+        wanted: String,\n+        #[label(\"unnecessary package syntax found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"You can only extend from the root workspace\")]\n+    ExtendFromNonRoot {\n+        #[label(\"non-root workspace found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"`{field}` cannot contain an environment variable\")]\n+    InvalidDependsOnValue {\n+        field: &'static str,\n+        #[label(\"environment variable found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"`{field}` cannot contain an absolute path\")]\n+    AbsolutePathInConfig {\n+        field: &'static str,\n+        #[label(\"absolute path found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"No \\\"extends\\\" key found\")]\n+    NoExtends {\n+        #[label(\"add extends key here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"Tasks cannot be marked as interactive and cacheable\")]\n+    InteractiveNoCacheable {\n+        #[label(\"marked interactive here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"found `pipeline` field instead of `tasks`\")]\n+    #[diagnostic(help(\"changed in 2.0: `pipeline` has been renamed to `tasks`\"))]\n+    PipelineField {\n+        #[label(\"rename `pipeline` field to `tasks`\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"Failed to create APIClient: {0}\")]\n+    ApiClient(#[source] turborepo_api_client::Error),\n+    #[error(\"{0} is not UTF8.\")]\n+    Encoding(String),\n+    #[error(\"TURBO_SIGNATURE should be either 1 or 0.\")]\n+    InvalidSignature,\n+    #[error(\"TURBO_REMOTE_CACHE_ENABLED should be either 1 or 0.\")]\n+    InvalidRemoteCacheEnabled,\n+    #[error(\"TURBO_REMOTE_CACHE_TIMEOUT: error parsing timeout.\")]\n+    InvalidRemoteCacheTimeout(#[source] std::num::ParseIntError),\n+    #[error(\"TURBO_REMOTE_CACHE_UPLOAD_TIMEOUT: error parsing timeout.\")]\n+    InvalidUploadTimeout(#[source] std::num::ParseIntError),\n+    #[error(\"TURBO_PREFLIGHT should be either 1 or 0.\")]\n+    InvalidPreflight,\n+    #[error(transparent)]\n+    #[diagnostic(transparent)]\n+    TurboJsonParseError(#[from] crate::turbo_json::parser::Error),\n+    #[error(\"found absolute path in `cacheDir`\")]\n+    #[diagnostic(help(\"if absolute paths are required, use `--cache-dir` or `TURBO_CACHE_DIR`\"))]\n+    AbsoluteCacheDir {\n+        #[label(\"make `cacheDir` value a relative unix path\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+}\n+\n+macro_rules! create_builder {\n+    ($func_name:ident, $property_name:ident, $type:ty) => {\n+        pub fn $func_name(mut self, value: $type) -> Self {\n+            self.override_config.$property_name = value;\n+            self\n+        }\n+    };\n+}\n+\n+const DEFAULT_API_URL: &str = \"https://vercel.com/api\";\n+const DEFAULT_LOGIN_URL: &str = \"https://vercel.com\";\n+const DEFAULT_TIMEOUT: u64 = 30;\n+const DEFAULT_UPLOAD_TIMEOUT: u64 = 60;\n+\n+// We intentionally don't derive Serialize so that different parts\n+// of the code that want to display the config can tune how they\n+// want to display and what fields they want to include.\n+#[derive(Deserialize, Default, Debug, PartialEq, Eq, Clone, Iterable)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ConfigurationOptions {\n+    #[serde(alias = \"apiurl\")]\n+    #[serde(alias = \"ApiUrl\")]\n+    #[serde(alias = \"APIURL\")]\n+    pub(crate) api_url: Option<String>,\n+    #[serde(alias = \"loginurl\")]\n+    #[serde(alias = \"LoginUrl\")]\n+    #[serde(alias = \"LOGINURL\")]\n+    pub(crate) login_url: Option<String>,\n+    #[serde(alias = \"teamslug\")]\n+    #[serde(alias = \"TeamSlug\")]\n+    #[serde(alias = \"TEAMSLUG\")]\n+    pub(crate) team_slug: Option<String>,\n+    #[serde(alias = \"teamid\")]\n+    #[serde(alias = \"TeamId\")]\n+    #[serde(alias = \"TEAMID\")]\n+    pub(crate) team_id: Option<String>,\n+    pub(crate) token: Option<String>,\n+    pub(crate) signature: Option<bool>,\n+    pub(crate) preflight: Option<bool>,\n+    pub(crate) timeout: Option<u64>,\n+    pub(crate) upload_timeout: Option<u64>,\n+    pub(crate) enabled: Option<bool>,\n+    pub(crate) spaces_id: Option<String>,\n+    #[serde(rename = \"ui\")]\n+    pub(crate) ui: Option<UIMode>,\n+    #[serde(rename = \"dangerouslyDisablePackageManagerCheck\")]\n+    pub(crate) allow_no_package_manager: Option<bool>,\n+    pub(crate) daemon: Option<bool>,\n+    #[serde(rename = \"envMode\")]\n+    pub(crate) env_mode: Option<EnvMode>,\n+    pub(crate) scm_base: Option<String>,\n+    pub(crate) scm_head: Option<String>,\n+    #[serde(rename = \"cacheDir\")]\n+    pub(crate) cache_dir: Option<Utf8PathBuf>,\n+    // This is skipped as we never want this to be stored in a file\n+    #[serde(skip)]\n+    pub(crate) root_turbo_json_path: Option<AbsoluteSystemPathBuf>,\n+}\n+\n+#[derive(Default)]\n+pub struct TurborepoConfigBuilder {\n+    repo_root: AbsoluteSystemPathBuf,\n+    override_config: ConfigurationOptions,\n+    global_config_path: Option<AbsoluteSystemPathBuf>,\n+    environment: Option<HashMap<OsString, OsString>>,\n+}\n+\n+// Getters\n+impl ConfigurationOptions {\n+    pub fn api_url(&self) -> &str {\n+        non_empty_str(self.api_url.as_deref()).unwrap_or(DEFAULT_API_URL)\n+    }\n+\n+    pub fn login_url(&self) -> &str {\n+        non_empty_str(self.login_url.as_deref()).unwrap_or(DEFAULT_LOGIN_URL)\n+    }\n+\n+    pub fn team_slug(&self) -> Option<&str> {\n+        self.team_slug\n+            .as_deref()\n+            .and_then(|slug| (!slug.is_empty()).then_some(slug))\n+    }\n+\n+    pub fn team_id(&self) -> Option<&str> {\n+        non_empty_str(self.team_id.as_deref())\n+    }\n+\n+    pub fn token(&self) -> Option<&str> {\n+        non_empty_str(self.token.as_deref())\n+    }\n+\n+    pub fn signature(&self) -> bool {\n+        self.signature.unwrap_or_default()\n+    }\n+\n+    pub fn enabled(&self) -> bool {\n+        self.enabled.unwrap_or(true)\n+    }\n+\n+    pub fn preflight(&self) -> bool {\n+        self.preflight.unwrap_or_default()\n+    }\n+\n+    /// Note: 0 implies no timeout\n+    pub fn timeout(&self) -> u64 {\n+        self.timeout.unwrap_or(DEFAULT_TIMEOUT)\n+    }\n+\n+    /// Note: 0 implies no timeout\n+    pub fn upload_timeout(&self) -> u64 {\n+        self.upload_timeout.unwrap_or(DEFAULT_UPLOAD_TIMEOUT)\n+    }\n+\n+    pub fn spaces_id(&self) -> Option<&str> {\n+        self.spaces_id.as_deref()\n+    }\n+\n+    pub fn ui(&self) -> UIMode {\n+        // If we aren't hooked up to a TTY, then do not use TUI\n+        if !atty::is(atty::Stream::Stdout) {\n+            return UIMode::Stream;\n+        }\n+\n+        self.ui.unwrap_or(UIMode::Stream)\n+    }\n+\n+    pub fn scm_base(&self) -> Option<&str> {\n+        non_empty_str(self.scm_base.as_deref())\n+    }\n+\n+    pub fn scm_head(&self) -> &str {\n+        non_empty_str(self.scm_head.as_deref()).unwrap_or(\"HEAD\")\n+    }\n+\n+    pub fn allow_no_package_manager(&self) -> bool {\n+        self.allow_no_package_manager.unwrap_or_default()\n+    }\n+\n+    pub fn daemon(&self) -> Option<bool> {\n+        self.daemon\n+    }\n+\n+    pub fn env_mode(&self) -> EnvMode {\n+        self.env_mode.unwrap_or_default()\n+    }\n+\n+    pub fn cache_dir(&self) -> &Utf8Path {\n+        self.cache_dir.as_deref().unwrap_or_else(|| {\n+            Utf8Path::new(if cfg!(windows) {\n+                \".turbo\\\\cache\"\n+            } else {\n+                \".turbo/cache\"\n+            })\n+        })\n+    }\n+\n+    pub fn root_turbo_json_path(&self, repo_root: &AbsoluteSystemPath) -> AbsoluteSystemPathBuf {\n+        self.root_turbo_json_path\n+            .clone()\n+            .unwrap_or_else(|| repo_root.join_component(CONFIG_FILE))\n+    }\n+}\n+\n+macro_rules! create_set_if_empty {\n+    ($func_name:ident, $property_name:ident, $type:ty) => {\n+        fn $func_name(&mut self, value: &mut Option<$type>) {\n+            if self.$property_name.is_none() {\n+                if let Some(value) = value.take() {\n+                    self.$property_name = Some(value);\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+// Private setters used only for construction\n+impl ConfigurationOptions {\n+    create_set_if_empty!(set_api_url, api_url, String);\n+    create_set_if_empty!(set_login_url, login_url, String);\n+    create_set_if_empty!(set_team_slug, team_slug, String);\n+    create_set_if_empty!(set_team_id, team_id, String);\n+    create_set_if_empty!(set_token, token, String);\n+    create_set_if_empty!(set_signature, signature, bool);\n+    create_set_if_empty!(set_enabled, enabled, bool);\n+    create_set_if_empty!(set_preflight, preflight, bool);\n+    create_set_if_empty!(set_timeout, timeout, u64);\n+    create_set_if_empty!(set_ui, ui, UIMode);\n+    create_set_if_empty!(set_allow_no_package_manager, allow_no_package_manager, bool);\n+    create_set_if_empty!(set_daemon, daemon, bool);\n+    create_set_if_empty!(set_env_mode, env_mode, EnvMode);\n+    create_set_if_empty!(set_cache_dir, cache_dir, Utf8PathBuf);\n+    create_set_if_empty!(set_scm_base, scm_base, String);\n+    create_set_if_empty!(set_scm_head, scm_head, String);\n+    create_set_if_empty!(set_spaces_id, spaces_id, String);\n+    create_set_if_empty!(\n+        set_root_turbo_json_path,\n+        root_turbo_json_path,\n+        AbsoluteSystemPathBuf\n+    );\n+}\n+\n+// Maps Some(\"\") to None to emulate how Go handles empty strings\n+fn non_empty_str(s: Option<&str>) -> Option<&str> {\n+    s.filter(|s| !s.is_empty())\n+}\n+\n+trait ResolvedConfigurationOptions {\n+    fn get_configuration_options(\n+        &self,\n+        existing_config: &ConfigurationOptions,\n+    ) -> Result<ConfigurationOptions, Error>;\n+}\n+\n+// Used for global config and local config.\n+impl<'a> ResolvedConfigurationOptions for &'a ConfigurationOptions {\n+    fn get_configuration_options(\n+        &self,\n+        _existing_config: &ConfigurationOptions,\n+    ) -> Result<ConfigurationOptions, Error> {\n+        Ok((*self).clone())\n+    }\n+}\n+\n+fn get_lowercased_env_vars() -> HashMap<OsString, OsString> {\n+    std::env::vars_os()\n+        .map(|(k, v)| (k.to_ascii_lowercase(), v))\n+        .collect()\n+}\n+\n+impl TurborepoConfigBuilder {\n+    pub fn new(base: &CommandBase) -> Self {\n+        Self {\n+            repo_root: base.repo_root.to_owned(),\n+            override_config: Default::default(),\n+            global_config_path: base.override_global_config_path.clone(),\n+            environment: None,\n+        }\n+    }\n+\n+    // Getting all of the paths.\n+    #[allow(dead_code)]\n+    fn root_package_json_path(&self) -> AbsoluteSystemPathBuf {\n+        self.repo_root.join_component(\"package.json\")\n+    }\n+    #[allow(dead_code)]\n+    fn root_turbo_json_path(&self) -> AbsoluteSystemPathBuf {\n+        self.repo_root.join_component(\"turbo.json\")\n+    }\n+\n+    fn get_environment(&self) -> HashMap<OsString, OsString> {\n+        self.environment\n+            .clone()\n+            .unwrap_or_else(get_lowercased_env_vars)\n+    }\n+\n+    create_builder!(with_api_url, api_url, Option<String>);\n+    create_builder!(with_login_url, login_url, Option<String>);\n+    create_builder!(with_team_slug, team_slug, Option<String>);\n+    create_builder!(with_team_id, team_id, Option<String>);\n+    create_builder!(with_token, token, Option<String>);\n+    create_builder!(with_signature, signature, Option<bool>);\n+    create_builder!(with_enabled, enabled, Option<bool>);\n+    create_builder!(with_preflight, preflight, Option<bool>);\n+    create_builder!(with_timeout, timeout, Option<u64>);\n+    create_builder!(with_ui, ui, Option<UIMode>);\n+    create_builder!(\n+        with_allow_no_package_manager,\n+        allow_no_package_manager,\n+        Option<bool>\n+    );\n+    create_builder!(with_daemon, daemon, Option<bool>);\n+    create_builder!(with_env_mode, env_mode, Option<EnvMode>);\n+    create_builder!(with_cache_dir, cache_dir, Option<Utf8PathBuf>);\n+    create_builder!(\n+        with_root_turbo_json_path,\n+        root_turbo_json_path,\n+        Option<AbsoluteSystemPathBuf>\n+    );\n+\n+    pub fn build(&self) -> Result<ConfigurationOptions, Error> {\n+        // Priority, from least significant to most significant:\n+        // - shared configuration (turbo.json)\n+        // - global configuration (~/.turbo/config.json)\n+        // - local configuration (<REPO_ROOT>/.turbo/config.json)\n+        // - environment variables\n+        // - CLI arguments\n+        // - builder pattern overrides.\n+\n+        let turbo_json = TurboJsonReader::new(&self.repo_root);\n+        let global_config = ConfigFile::global_config(self.global_config_path.clone())?;\n+        let global_auth = AuthFile::global_auth(self.global_config_path.clone())?;\n+        let local_config = ConfigFile::local_config(&self.repo_root);\n+        let env_vars = self.get_environment();\n+        let env_var_config = EnvVars::new(&env_vars)?;\n+        let override_env_var_config = OverrideEnvVars::new(&env_vars)?;\n+\n+        // These are ordered from highest to lowest priority\n+        let sources: [Box<dyn ResolvedConfigurationOptions>; 7] = [\n+            Box::new(override_env_var_config),\n+            Box::new(&self.override_config),\n+            Box::new(env_var_config),\n+            Box::new(local_config),\n+            Box::new(global_auth),\n+            Box::new(global_config),\n+            Box::new(turbo_json),\n+        ];\n+\n+        let config = sources.into_iter().try_fold(\n+            ConfigurationOptions::default(),\n+            |mut acc, current_source| {\n+                let mut current_source_config = current_source.get_configuration_options(&acc)?;",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1742000591",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9087,
        "pr_file": "crates/turborepo-lib/src/config/mod.rs",
        "discussion_id": "1742000591",
        "commented_code": "@@ -0,0 +1,651 @@\n+mod env;\n+mod file;\n+mod turbo_json;\n+\n+use std::{collections::HashMap, ffi::OsString, io};\n+\n+use camino::{Utf8Path, Utf8PathBuf};\n+use convert_case::{Case, Casing};\n+use env::{EnvVars, OverrideEnvVars};\n+use file::{AuthFile, ConfigFile};\n+use miette::{Diagnostic, NamedSource, SourceSpan};\n+use serde::Deserialize;\n+use struct_iterable::Iterable;\n+use thiserror::Error;\n+use turbo_json::TurboJsonReader;\n+use turbopath::{AbsoluteSystemPath, AbsoluteSystemPathBuf};\n+use turborepo_errors::TURBO_SITE;\n+\n+pub use crate::turbo_json::{RawTurboJson, UIMode};\n+use crate::{cli::EnvMode, commands::CommandBase, turbo_json::CONFIG_FILE};\n+\n+#[derive(Debug, Error, Diagnostic)]\n+#[error(\"Environment variables should not be prefixed with \\\"{env_pipeline_delimiter}\\\"\")]\n+#[diagnostic(\n+    code(invalid_env_prefix),\n+    url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab))\n+)]\n+pub struct InvalidEnvPrefixError {\n+    pub value: String,\n+    pub key: String,\n+    #[source_code]\n+    pub text: NamedSource,\n+    #[label(\"variable with invalid prefix declared here\")]\n+    pub span: Option<SourceSpan>,\n+    pub env_pipeline_delimiter: &'static str,\n+}\n+\n+#[allow(clippy::enum_variant_names)]\n+#[derive(Debug, Error, Diagnostic)]\n+pub enum Error {\n+    #[error(\"Authentication error: {0}\")]\n+    Auth(#[from] turborepo_auth::Error),\n+    #[error(\"Global config path not found\")]\n+    NoGlobalConfigPath,\n+    #[error(\"Global auth file path not found\")]\n+    NoGlobalAuthFilePath,\n+    #[error(\"Global config directory not found\")]\n+    NoGlobalConfigDir,\n+    #[error(transparent)]\n+    PackageJson(#[from] turborepo_repository::package_json::Error),\n+    #[error(\n+        \"Could not find turbo.json.\\nFollow directions at https://turbo.build/repo/docs to create \\\n+         one\"\n+    )]\n+    NoTurboJSON,\n+    #[error(transparent)]\n+    SerdeJson(#[from] serde_json::Error),\n+    #[error(transparent)]\n+    Io(#[from] io::Error),\n+    #[error(transparent)]\n+    Camino(#[from] camino::FromPathBufError),\n+    #[error(transparent)]\n+    Reqwest(#[from] reqwest::Error),\n+    #[error(\"Encountered an IO error while attempting to read {config_path}: {error}\")]\n+    FailedToReadConfig {\n+        config_path: AbsoluteSystemPathBuf,\n+        error: io::Error,\n+    },\n+    #[error(\"Encountered an IO error while attempting to set {config_path}: {error}\")]\n+    FailedToSetConfig {\n+        config_path: AbsoluteSystemPathBuf,\n+        error: io::Error,\n+    },\n+    #[error(\n+        \"Package tasks (<package>#<task>) are not allowed in single-package repositories: found \\\n+         {task_id}\"\n+    )]\n+    #[diagnostic(code(package_task_in_single_package_mode), url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab)))]\n+    PackageTaskInSinglePackageMode {\n+        task_id: String,\n+        #[source_code]\n+        text: NamedSource,\n+        #[label(\"package task found here\")]\n+        span: Option<SourceSpan>,\n+    },\n+    #[error(transparent)]\n+    #[diagnostic(transparent)]\n+    InvalidEnvPrefix(Box<InvalidEnvPrefixError>),\n+    #[error(transparent)]\n+    PathError(#[from] turbopath::PathError),\n+    #[diagnostic(\n+        code(unnecessary_package_task_syntax),\n+        url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab))\n+    )]\n+    #[error(\"\\\"{actual}\\\". Use \\\"{wanted}\\\" instead\")]\n+    UnnecessaryPackageTaskSyntax {\n+        actual: String,\n+        wanted: String,\n+        #[label(\"unnecessary package syntax found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"You can only extend from the root workspace\")]\n+    ExtendFromNonRoot {\n+        #[label(\"non-root workspace found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"`{field}` cannot contain an environment variable\")]\n+    InvalidDependsOnValue {\n+        field: &'static str,\n+        #[label(\"environment variable found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"`{field}` cannot contain an absolute path\")]\n+    AbsolutePathInConfig {\n+        field: &'static str,\n+        #[label(\"absolute path found here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"No \\\"extends\\\" key found\")]\n+    NoExtends {\n+        #[label(\"add extends key here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"Tasks cannot be marked as interactive and cacheable\")]\n+    InteractiveNoCacheable {\n+        #[label(\"marked interactive here\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"found `pipeline` field instead of `tasks`\")]\n+    #[diagnostic(help(\"changed in 2.0: `pipeline` has been renamed to `tasks`\"))]\n+    PipelineField {\n+        #[label(\"rename `pipeline` field to `tasks`\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+    #[error(\"Failed to create APIClient: {0}\")]\n+    ApiClient(#[source] turborepo_api_client::Error),\n+    #[error(\"{0} is not UTF8.\")]\n+    Encoding(String),\n+    #[error(\"TURBO_SIGNATURE should be either 1 or 0.\")]\n+    InvalidSignature,\n+    #[error(\"TURBO_REMOTE_CACHE_ENABLED should be either 1 or 0.\")]\n+    InvalidRemoteCacheEnabled,\n+    #[error(\"TURBO_REMOTE_CACHE_TIMEOUT: error parsing timeout.\")]\n+    InvalidRemoteCacheTimeout(#[source] std::num::ParseIntError),\n+    #[error(\"TURBO_REMOTE_CACHE_UPLOAD_TIMEOUT: error parsing timeout.\")]\n+    InvalidUploadTimeout(#[source] std::num::ParseIntError),\n+    #[error(\"TURBO_PREFLIGHT should be either 1 or 0.\")]\n+    InvalidPreflight,\n+    #[error(transparent)]\n+    #[diagnostic(transparent)]\n+    TurboJsonParseError(#[from] crate::turbo_json::parser::Error),\n+    #[error(\"found absolute path in `cacheDir`\")]\n+    #[diagnostic(help(\"if absolute paths are required, use `--cache-dir` or `TURBO_CACHE_DIR`\"))]\n+    AbsoluteCacheDir {\n+        #[label(\"make `cacheDir` value a relative unix path\")]\n+        span: Option<SourceSpan>,\n+        #[source_code]\n+        text: NamedSource,\n+    },\n+}\n+\n+macro_rules! create_builder {\n+    ($func_name:ident, $property_name:ident, $type:ty) => {\n+        pub fn $func_name(mut self, value: $type) -> Self {\n+            self.override_config.$property_name = value;\n+            self\n+        }\n+    };\n+}\n+\n+const DEFAULT_API_URL: &str = \"https://vercel.com/api\";\n+const DEFAULT_LOGIN_URL: &str = \"https://vercel.com\";\n+const DEFAULT_TIMEOUT: u64 = 30;\n+const DEFAULT_UPLOAD_TIMEOUT: u64 = 60;\n+\n+// We intentionally don't derive Serialize so that different parts\n+// of the code that want to display the config can tune how they\n+// want to display and what fields they want to include.\n+#[derive(Deserialize, Default, Debug, PartialEq, Eq, Clone, Iterable)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ConfigurationOptions {\n+    #[serde(alias = \"apiurl\")]\n+    #[serde(alias = \"ApiUrl\")]\n+    #[serde(alias = \"APIURL\")]\n+    pub(crate) api_url: Option<String>,\n+    #[serde(alias = \"loginurl\")]\n+    #[serde(alias = \"LoginUrl\")]\n+    #[serde(alias = \"LOGINURL\")]\n+    pub(crate) login_url: Option<String>,\n+    #[serde(alias = \"teamslug\")]\n+    #[serde(alias = \"TeamSlug\")]\n+    #[serde(alias = \"TEAMSLUG\")]\n+    pub(crate) team_slug: Option<String>,\n+    #[serde(alias = \"teamid\")]\n+    #[serde(alias = \"TeamId\")]\n+    #[serde(alias = \"TEAMID\")]\n+    pub(crate) team_id: Option<String>,\n+    pub(crate) token: Option<String>,\n+    pub(crate) signature: Option<bool>,\n+    pub(crate) preflight: Option<bool>,\n+    pub(crate) timeout: Option<u64>,\n+    pub(crate) upload_timeout: Option<u64>,\n+    pub(crate) enabled: Option<bool>,\n+    pub(crate) spaces_id: Option<String>,\n+    #[serde(rename = \"ui\")]\n+    pub(crate) ui: Option<UIMode>,\n+    #[serde(rename = \"dangerouslyDisablePackageManagerCheck\")]\n+    pub(crate) allow_no_package_manager: Option<bool>,\n+    pub(crate) daemon: Option<bool>,\n+    #[serde(rename = \"envMode\")]\n+    pub(crate) env_mode: Option<EnvMode>,\n+    pub(crate) scm_base: Option<String>,\n+    pub(crate) scm_head: Option<String>,\n+    #[serde(rename = \"cacheDir\")]\n+    pub(crate) cache_dir: Option<Utf8PathBuf>,\n+    // This is skipped as we never want this to be stored in a file\n+    #[serde(skip)]\n+    pub(crate) root_turbo_json_path: Option<AbsoluteSystemPathBuf>,\n+}\n+\n+#[derive(Default)]\n+pub struct TurborepoConfigBuilder {\n+    repo_root: AbsoluteSystemPathBuf,\n+    override_config: ConfigurationOptions,\n+    global_config_path: Option<AbsoluteSystemPathBuf>,\n+    environment: Option<HashMap<OsString, OsString>>,\n+}\n+\n+// Getters\n+impl ConfigurationOptions {\n+    pub fn api_url(&self) -> &str {\n+        non_empty_str(self.api_url.as_deref()).unwrap_or(DEFAULT_API_URL)\n+    }\n+\n+    pub fn login_url(&self) -> &str {\n+        non_empty_str(self.login_url.as_deref()).unwrap_or(DEFAULT_LOGIN_URL)\n+    }\n+\n+    pub fn team_slug(&self) -> Option<&str> {\n+        self.team_slug\n+            .as_deref()\n+            .and_then(|slug| (!slug.is_empty()).then_some(slug))\n+    }\n+\n+    pub fn team_id(&self) -> Option<&str> {\n+        non_empty_str(self.team_id.as_deref())\n+    }\n+\n+    pub fn token(&self) -> Option<&str> {\n+        non_empty_str(self.token.as_deref())\n+    }\n+\n+    pub fn signature(&self) -> bool {\n+        self.signature.unwrap_or_default()\n+    }\n+\n+    pub fn enabled(&self) -> bool {\n+        self.enabled.unwrap_or(true)\n+    }\n+\n+    pub fn preflight(&self) -> bool {\n+        self.preflight.unwrap_or_default()\n+    }\n+\n+    /// Note: 0 implies no timeout\n+    pub fn timeout(&self) -> u64 {\n+        self.timeout.unwrap_or(DEFAULT_TIMEOUT)\n+    }\n+\n+    /// Note: 0 implies no timeout\n+    pub fn upload_timeout(&self) -> u64 {\n+        self.upload_timeout.unwrap_or(DEFAULT_UPLOAD_TIMEOUT)\n+    }\n+\n+    pub fn spaces_id(&self) -> Option<&str> {\n+        self.spaces_id.as_deref()\n+    }\n+\n+    pub fn ui(&self) -> UIMode {\n+        // If we aren't hooked up to a TTY, then do not use TUI\n+        if !atty::is(atty::Stream::Stdout) {\n+            return UIMode::Stream;\n+        }\n+\n+        self.ui.unwrap_or(UIMode::Stream)\n+    }\n+\n+    pub fn scm_base(&self) -> Option<&str> {\n+        non_empty_str(self.scm_base.as_deref())\n+    }\n+\n+    pub fn scm_head(&self) -> &str {\n+        non_empty_str(self.scm_head.as_deref()).unwrap_or(\"HEAD\")\n+    }\n+\n+    pub fn allow_no_package_manager(&self) -> bool {\n+        self.allow_no_package_manager.unwrap_or_default()\n+    }\n+\n+    pub fn daemon(&self) -> Option<bool> {\n+        self.daemon\n+    }\n+\n+    pub fn env_mode(&self) -> EnvMode {\n+        self.env_mode.unwrap_or_default()\n+    }\n+\n+    pub fn cache_dir(&self) -> &Utf8Path {\n+        self.cache_dir.as_deref().unwrap_or_else(|| {\n+            Utf8Path::new(if cfg!(windows) {\n+                \".turbo\\\\cache\"\n+            } else {\n+                \".turbo/cache\"\n+            })\n+        })\n+    }\n+\n+    pub fn root_turbo_json_path(&self, repo_root: &AbsoluteSystemPath) -> AbsoluteSystemPathBuf {\n+        self.root_turbo_json_path\n+            .clone()\n+            .unwrap_or_else(|| repo_root.join_component(CONFIG_FILE))\n+    }\n+}\n+\n+macro_rules! create_set_if_empty {\n+    ($func_name:ident, $property_name:ident, $type:ty) => {\n+        fn $func_name(&mut self, value: &mut Option<$type>) {\n+            if self.$property_name.is_none() {\n+                if let Some(value) = value.take() {\n+                    self.$property_name = Some(value);\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+// Private setters used only for construction\n+impl ConfigurationOptions {\n+    create_set_if_empty!(set_api_url, api_url, String);\n+    create_set_if_empty!(set_login_url, login_url, String);\n+    create_set_if_empty!(set_team_slug, team_slug, String);\n+    create_set_if_empty!(set_team_id, team_id, String);\n+    create_set_if_empty!(set_token, token, String);\n+    create_set_if_empty!(set_signature, signature, bool);\n+    create_set_if_empty!(set_enabled, enabled, bool);\n+    create_set_if_empty!(set_preflight, preflight, bool);\n+    create_set_if_empty!(set_timeout, timeout, u64);\n+    create_set_if_empty!(set_ui, ui, UIMode);\n+    create_set_if_empty!(set_allow_no_package_manager, allow_no_package_manager, bool);\n+    create_set_if_empty!(set_daemon, daemon, bool);\n+    create_set_if_empty!(set_env_mode, env_mode, EnvMode);\n+    create_set_if_empty!(set_cache_dir, cache_dir, Utf8PathBuf);\n+    create_set_if_empty!(set_scm_base, scm_base, String);\n+    create_set_if_empty!(set_scm_head, scm_head, String);\n+    create_set_if_empty!(set_spaces_id, spaces_id, String);\n+    create_set_if_empty!(\n+        set_root_turbo_json_path,\n+        root_turbo_json_path,\n+        AbsoluteSystemPathBuf\n+    );\n+}\n+\n+// Maps Some(\"\") to None to emulate how Go handles empty strings\n+fn non_empty_str(s: Option<&str>) -> Option<&str> {\n+    s.filter(|s| !s.is_empty())\n+}\n+\n+trait ResolvedConfigurationOptions {\n+    fn get_configuration_options(\n+        &self,\n+        existing_config: &ConfigurationOptions,\n+    ) -> Result<ConfigurationOptions, Error>;\n+}\n+\n+// Used for global config and local config.\n+impl<'a> ResolvedConfigurationOptions for &'a ConfigurationOptions {\n+    fn get_configuration_options(\n+        &self,\n+        _existing_config: &ConfigurationOptions,\n+    ) -> Result<ConfigurationOptions, Error> {\n+        Ok((*self).clone())\n+    }\n+}\n+\n+fn get_lowercased_env_vars() -> HashMap<OsString, OsString> {\n+    std::env::vars_os()\n+        .map(|(k, v)| (k.to_ascii_lowercase(), v))\n+        .collect()\n+}\n+\n+impl TurborepoConfigBuilder {\n+    pub fn new(base: &CommandBase) -> Self {\n+        Self {\n+            repo_root: base.repo_root.to_owned(),\n+            override_config: Default::default(),\n+            global_config_path: base.override_global_config_path.clone(),\n+            environment: None,\n+        }\n+    }\n+\n+    // Getting all of the paths.\n+    #[allow(dead_code)]\n+    fn root_package_json_path(&self) -> AbsoluteSystemPathBuf {\n+        self.repo_root.join_component(\"package.json\")\n+    }\n+    #[allow(dead_code)]\n+    fn root_turbo_json_path(&self) -> AbsoluteSystemPathBuf {\n+        self.repo_root.join_component(\"turbo.json\")\n+    }\n+\n+    fn get_environment(&self) -> HashMap<OsString, OsString> {\n+        self.environment\n+            .clone()\n+            .unwrap_or_else(get_lowercased_env_vars)\n+    }\n+\n+    create_builder!(with_api_url, api_url, Option<String>);\n+    create_builder!(with_login_url, login_url, Option<String>);\n+    create_builder!(with_team_slug, team_slug, Option<String>);\n+    create_builder!(with_team_id, team_id, Option<String>);\n+    create_builder!(with_token, token, Option<String>);\n+    create_builder!(with_signature, signature, Option<bool>);\n+    create_builder!(with_enabled, enabled, Option<bool>);\n+    create_builder!(with_preflight, preflight, Option<bool>);\n+    create_builder!(with_timeout, timeout, Option<u64>);\n+    create_builder!(with_ui, ui, Option<UIMode>);\n+    create_builder!(\n+        with_allow_no_package_manager,\n+        allow_no_package_manager,\n+        Option<bool>\n+    );\n+    create_builder!(with_daemon, daemon, Option<bool>);\n+    create_builder!(with_env_mode, env_mode, Option<EnvMode>);\n+    create_builder!(with_cache_dir, cache_dir, Option<Utf8PathBuf>);\n+    create_builder!(\n+        with_root_turbo_json_path,\n+        root_turbo_json_path,\n+        Option<AbsoluteSystemPathBuf>\n+    );\n+\n+    pub fn build(&self) -> Result<ConfigurationOptions, Error> {\n+        // Priority, from least significant to most significant:\n+        // - shared configuration (turbo.json)\n+        // - global configuration (~/.turbo/config.json)\n+        // - local configuration (<REPO_ROOT>/.turbo/config.json)\n+        // - environment variables\n+        // - CLI arguments\n+        // - builder pattern overrides.\n+\n+        let turbo_json = TurboJsonReader::new(&self.repo_root);\n+        let global_config = ConfigFile::global_config(self.global_config_path.clone())?;\n+        let global_auth = AuthFile::global_auth(self.global_config_path.clone())?;\n+        let local_config = ConfigFile::local_config(&self.repo_root);\n+        let env_vars = self.get_environment();\n+        let env_var_config = EnvVars::new(&env_vars)?;\n+        let override_env_var_config = OverrideEnvVars::new(&env_vars)?;\n+\n+        // These are ordered from highest to lowest priority\n+        let sources: [Box<dyn ResolvedConfigurationOptions>; 7] = [\n+            Box::new(override_env_var_config),\n+            Box::new(&self.override_config),\n+            Box::new(env_var_config),\n+            Box::new(local_config),\n+            Box::new(global_auth),\n+            Box::new(global_config),\n+            Box::new(turbo_json),\n+        ];\n+\n+        let config = sources.into_iter().try_fold(\n+            ConfigurationOptions::default(),\n+            |mut acc, current_source| {\n+                let mut current_source_config = current_source.get_configuration_options(&acc)?;",
        "comment_created_at": "2024-09-03T12:45:52+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "There was an existing bug where we would ignore any errors that came from resolving config options from a source. In reality since these were (mostly) eagerly calculated it only affected and validation errors from extracting config options from a `turbo.json`.\r\n\r\nWe now bubble up any errors generated by resolving config options.",
        "pr_file_module": null
      }
    ]
  }
]