[
  {
    "discussion_id": "1831696242",
    "pr_number": 9368,
    "pr_file": "crates/turborepo-lib/src/commands/info.rs",
    "created_at": "2024-11-06T20:54:39+00:00",
    "commented_code": "+use std::{env, io};\n+\n+use sysinfo::{System, SystemExt};\n+use thiserror::Error;\n+use turborepo_repository::{package_json::PackageJson, package_manager::PackageManager};\n+\n+use super::CommandBase;\n+use crate::{DaemonConnector, DaemonConnectorError};\n+\n+#[derive(Debug, Error)]\n+pub enum Error {\n+    #[error(\"could not get path to turbo binary: {0}\")]\n+    NoCurrentExe(#[from] io::Error),\n+}\n+\n+pub async fn run(base: CommandBase) -> Result<(), Error> {\n+    let system = System::new_all();\n+    let connector = DaemonConnector::new(false, false, &base.repo_root);\n+    let daemon_status = match connector.connect().await {\n+        Ok(_status) => \"Running\",\n+        Err(DaemonConnectorError::NotRunning) => \"Not running\",\n+        Err(_e) => \"Error getting status\",\n+    };\n+    let package_manager = PackageJson::load(&base.repo_root.join_component(\"package.json\"))\n+        .and_then(|package_json| {\n+            Ok(PackageManager::read_or_detect_package_manager(\n+                &package_json,\n+                &base.repo_root,\n+            ))\n+        })\n+        .map_or_else(|_| \"Not found\".to_owned(), |pm| pm.unwrap().to_string());",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1831696242",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9368,
        "pr_file": "crates/turborepo-lib/src/commands/info.rs",
        "discussion_id": "1831696242",
        "commented_code": "@@ -0,0 +1,79 @@\n+use std::{env, io};\n+\n+use sysinfo::{System, SystemExt};\n+use thiserror::Error;\n+use turborepo_repository::{package_json::PackageJson, package_manager::PackageManager};\n+\n+use super::CommandBase;\n+use crate::{DaemonConnector, DaemonConnectorError};\n+\n+#[derive(Debug, Error)]\n+pub enum Error {\n+    #[error(\"could not get path to turbo binary: {0}\")]\n+    NoCurrentExe(#[from] io::Error),\n+}\n+\n+pub async fn run(base: CommandBase) -> Result<(), Error> {\n+    let system = System::new_all();\n+    let connector = DaemonConnector::new(false, false, &base.repo_root);\n+    let daemon_status = match connector.connect().await {\n+        Ok(_status) => \"Running\",\n+        Err(DaemonConnectorError::NotRunning) => \"Not running\",\n+        Err(_e) => \"Error getting status\",\n+    };\n+    let package_manager = PackageJson::load(&base.repo_root.join_component(\"package.json\"))\n+        .and_then(|package_json| {\n+            Ok(PackageManager::read_or_detect_package_manager(\n+                &package_json,\n+                &base.repo_root,\n+            ))\n+        })\n+        .map_or_else(|_| \"Not found\".to_owned(), |pm| pm.unwrap().to_string());",
        "comment_created_at": "2024-11-06T20:54:39+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "We can get rid of the unwrap by converting these `Result<T,E>` to `Option<T>` since we're already not doing anything with the error type\r\n```suggestion\r\n    let package_manager = PackageJson::load(&base.repo_root.join_component(\"package.json\"))\r\n        .ok()\r\n        .and_then(|package_json| {\r\n            PackageManager::read_or_detect_package_manager(&package_json, &base.repo_root).ok()\r\n        })\r\n        .map_or_else(|| \"Not found\".to_owned(), |pm| pm.to_string());\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1774066987",
    "pr_number": 9169,
    "pr_file": "crates/turborepo-scm/src/git.rs",
    "created_at": "2024-09-24T20:39:45+00:00",
    "commented_code": "}\n }\n \n+const UNKNOWN_SHA: &str = \"0000000000000000000000000000000000000000\";\n+\n+#[derive(Debug, Deserialize, Clone)]\n+struct GitHubCommit {\n+    id: String,\n+}\n+\n+#[derive(Debug, Deserialize, Default)]\n+struct GitHubEvent {\n+    #[serde(default)]\n+    before: String,\n+\n+    #[serde(default)]\n+    commits: Vec<GitHubCommit>,\n+}\n+\n+impl GitHubEvent {\n+    fn get_first_commit_id(&self) -> Option<String> {\n+        if self.commits.is_empty() {\n+            // commits can be empty when you push a branch with no commits\n+            return None;\n+        }\n+\n+        if self.commits.len() > 2048 {\n+            // GitHub API limit for number of commits shown in this field\n+            return None;\n+        }\n+\n+        // Extract the base ref from the push event\n+        if let Some(first_commit) = self.commits.first() {\n+            let id = &first_commit.id;\n+            return Some(format!(\"{id}^\"));\n+        }\n+\n+        // we don't have enough information to determine the base ref\n+        None",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1774066987",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9169,
        "pr_file": "crates/turborepo-scm/src/git.rs",
        "discussion_id": "1774066987",
        "commented_code": "@@ -81,6 +85,45 @@ impl SCM {\n     }\n }\n \n+const UNKNOWN_SHA: &str = \"0000000000000000000000000000000000000000\";\n+\n+#[derive(Debug, Deserialize, Clone)]\n+struct GitHubCommit {\n+    id: String,\n+}\n+\n+#[derive(Debug, Deserialize, Default)]\n+struct GitHubEvent {\n+    #[serde(default)]\n+    before: String,\n+\n+    #[serde(default)]\n+    commits: Vec<GitHubCommit>,\n+}\n+\n+impl GitHubEvent {\n+    fn get_first_commit_id(&self) -> Option<String> {\n+        if self.commits.is_empty() {\n+            // commits can be empty when you push a branch with no commits\n+            return None;\n+        }\n+\n+        if self.commits.len() > 2048 {\n+            // GitHub API limit for number of commits shown in this field\n+            return None;\n+        }\n+\n+        // Extract the base ref from the push event\n+        if let Some(first_commit) = self.commits.first() {\n+            let id = &first_commit.id;\n+            return Some(format!(\"{id}^\"));\n+        }\n+\n+        // we don't have enough information to determine the base ref\n+        None",
        "comment_created_at": "2024-09-24T20:39:45+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "Just a small change, `?` works on `Option` too\r\n```suggestion\r\n        let first_commit = self.commits.first()?; \r\n        let id = &first_commit.id;\r\n        Some(format!(\"{id}^\"))\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1774113284",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9169,
        "pr_file": "crates/turborepo-scm/src/git.rs",
        "discussion_id": "1774066987",
        "commented_code": "@@ -81,6 +85,45 @@ impl SCM {\n     }\n }\n \n+const UNKNOWN_SHA: &str = \"0000000000000000000000000000000000000000\";\n+\n+#[derive(Debug, Deserialize, Clone)]\n+struct GitHubCommit {\n+    id: String,\n+}\n+\n+#[derive(Debug, Deserialize, Default)]\n+struct GitHubEvent {\n+    #[serde(default)]\n+    before: String,\n+\n+    #[serde(default)]\n+    commits: Vec<GitHubCommit>,\n+}\n+\n+impl GitHubEvent {\n+    fn get_first_commit_id(&self) -> Option<String> {\n+        if self.commits.is_empty() {\n+            // commits can be empty when you push a branch with no commits\n+            return None;\n+        }\n+\n+        if self.commits.len() > 2048 {\n+            // GitHub API limit for number of commits shown in this field\n+            return None;\n+        }\n+\n+        // Extract the base ref from the push event\n+        if let Some(first_commit) = self.commits.first() {\n+            let id = &first_commit.id;\n+            return Some(format!(\"{id}^\"));\n+        }\n+\n+        // we don't have enough information to determine the base ref\n+        None",
        "comment_created_at": "2024-09-24T21:27:07+00:00",
        "comment_author": "dimitropoulos",
        "comment_body": "oh sweet, great find! yeah, I was using `?` a lot on the base function where this code was extracted from (`get_github_base_ref`).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1956432413",
    "pr_number": 9961,
    "pr_file": "crates/turborepo-ci/src/lib.rs",
    "created_at": "2025-02-14T16:38:46+00:00",
    "commented_code": "}\n \n     /// Gets user from CI environment variables\n-    /// We return an empty String instead of None because\n-    /// the Spaces API expects some sort of string in the user field.\n-    pub fn get_user() -> String {\n+    pub fn get_user() -> Option<String> {\n         let vendor = Vendor::infer();\n \n         vendor\n             .and_then(|v| v.username_env_var)\n             .and_then(|v| env::var(v).ok())\n-            .unwrap_or_default()",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1956432413",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9961,
        "pr_file": "crates/turborepo-ci/src/lib.rs",
        "discussion_id": "1956432413",
        "commented_code": "@@ -46,15 +46,12 @@ impl Vendor {\n     }\n \n     /// Gets user from CI environment variables\n-    /// We return an empty String instead of None because\n-    /// the Spaces API expects some sort of string in the user field.\n-    pub fn get_user() -> String {\n+    pub fn get_user() -> Option<String> {\n         let vendor = Vendor::infer();\n \n         vendor\n             .and_then(|v| v.username_env_var)\n             .and_then(|v| env::var(v).ok())\n-            .unwrap_or_default()",
        "comment_created_at": "2025-02-14T16:38:46+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Maybe keep this in case anyone is parsing summary/dry JSON and expecting the user to be present?",
        "pr_file_module": null
      },
      {
        "comment_id": "1960688301",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9961,
        "pr_file": "crates/turborepo-ci/src/lib.rs",
        "discussion_id": "1956432413",
        "commented_code": "@@ -46,15 +46,12 @@ impl Vendor {\n     }\n \n     /// Gets user from CI environment variables\n-    /// We return an empty String instead of None because\n-    /// the Spaces API expects some sort of string in the user field.\n-    pub fn get_user() -> String {\n+    pub fn get_user() -> Option<String> {\n         let vendor = Vendor::infer();\n \n         vendor\n             .and_then(|v| v.username_env_var)\n             .and_then(|v| env::var(v).ok())\n-            .unwrap_or_default()",
        "comment_created_at": "2025-02-18T22:36:24+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "It's kept on the output end, but I changed the type because I don't love default values as None in our codebase",
        "pr_file_module": null
      }
    ]
  }
]