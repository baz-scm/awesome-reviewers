[
  {
    "discussion_id": "2178193129",
    "pr_number": 10610,
    "pr_file": "crates/turborepo-lib/src/turbo_json/parser.rs",
    "created_at": "2025-07-01T17:40:37+00:00",
    "commented_code": "let json_string = serde_json::to_string(&value).expect(\"should be able to serialize\");\n         Self::parse(&json_string, \"turbo.json\")\n     }\n+\n+    /// Validates field placement to ensure root-only and package-only fields\n+    /// are used in the correct configuration types.\n+    ///\n+    /// This uses an allowlist approach - ALL fields must be explicitly\n+    /// categorized. When adding new fields to RawTurboJson, developers MUST\n+    /// add them to one of the allowlists below, forcing explicit\n+    /// categorization decisions.",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "2178193129",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10610,
        "pr_file": "crates/turborepo-lib/src/turbo_json/parser.rs",
        "discussion_id": "2178193129",
        "commented_code": "@@ -282,6 +305,164 @@ impl RawTurboJson {\n         let json_string = serde_json::to_string(&value).expect(\"should be able to serialize\");\n         Self::parse(&json_string, \"turbo.json\")\n     }\n+\n+    /// Validates field placement to ensure root-only and package-only fields\n+    /// are used in the correct configuration types.\n+    ///\n+    /// This uses an allowlist approach - ALL fields must be explicitly\n+    /// categorized. When adding new fields to RawTurboJson, developers MUST\n+    /// add them to one of the allowlists below, forcing explicit\n+    /// categorization decisions.",
        "comment_created_at": "2025-07-01T17:40:37+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "```suggestion\r\n    /// Validates field placement to ensure root-only and package-only fields\r\n    /// are used in the correct configuration types.\r\n    ///\r\n    /// This uses an allowlist approach - ALL fields must be explicitly\r\n    /// categorized.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1988009894",
    "pr_number": 10094,
    "pr_file": "crates/turborepo-lib/src/config/mod.rs",
    "created_at": "2025-03-10T20:55:17+00:00",
    "commented_code": "pub text: NamedSource<String>,\n }\n \n+#[derive(Debug, Error, Diagnostic)]\n+#[diagnostic(\n+    code(root_syntax_in_global_deps),\n+    url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab))\n+)]\n+#[error(\"$$ROOT$$ syntax is not allowed in globalDependencies\")]",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1988009894",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10094,
        "pr_file": "crates/turborepo-lib/src/config/mod.rs",
        "discussion_id": "1988009894",
        "commented_code": "@@ -60,6 +60,19 @@ pub struct UnnecessaryPackageTaskSyntaxError {\n     pub text: NamedSource<String>,\n }\n \n+#[derive(Debug, Error, Diagnostic)]\n+#[diagnostic(\n+    code(root_syntax_in_global_deps),\n+    url(\"{}/messages/{}\", TURBO_SITE, self.code().unwrap().to_string().to_case(Case::Kebab))\n+)]\n+#[error(\"$$ROOT$$ syntax is not allowed in globalDependencies\")]",
        "comment_created_at": "2025-03-10T20:55:17+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "```suggestion\r\n#[error(\"$$ROOT$$ syntax is not allowed in globalDependencies, since globalDependencies is already relative to the root of the Workspace.\")]\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993925541",
    "pr_number": 10094,
    "pr_file": "crates/turborepo-lib/src/config/mod.rs",
    "created_at": "2025-03-13T16:41:48+00:00",
    "commented_code": "},\n     #[error(\"Cannot load turbo.json for {0} in single package mode.\")]\n     InvalidTurboJsonLoad(PackageName),\n+    #[error(\"Cannot use '$TURBO_ROOT$' anywhere besides start of string.\")]",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1993925541",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10094,
        "pr_file": "crates/turborepo-lib/src/config/mod.rs",
        "discussion_id": "1993925541",
        "commented_code": "@@ -204,6 +204,13 @@ pub enum Error {\n     },\n     #[error(\"Cannot load turbo.json for {0} in single package mode.\")]\n     InvalidTurboJsonLoad(PackageName),\n+    #[error(\"Cannot use '$TURBO_ROOT$' anywhere besides start of string.\")]",
        "comment_created_at": "2025-03-13T16:41:48+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "```suggestion\r\n    #[error(\"\\\"$TURBO_ROOT$\\\" must be used at the start of glob.\")]\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1838805177",
    "pr_number": 9428,
    "pr_file": "crates/turborepo-lib/src/config/env.rs",
    "created_at": "2024-11-12T21:37:22+00:00",
    "commented_code": "let force = self.truthy_value(\"force\").flatten();\n         let remote_only = self.truthy_value(\"remote_only\").flatten();\n+        if remote_only.is_some() {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1838805177",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9428,
        "pr_file": "crates/turborepo-lib/src/config/env.rs",
        "discussion_id": "1838805177",
        "commented_code": "@@ -80,7 +81,19 @@ impl ResolvedConfigurationOptions for EnvVars {\n \n         let force = self.truthy_value(\"force\").flatten();\n         let remote_only = self.truthy_value(\"remote_only\").flatten();\n+        if remote_only.is_some() {",
        "comment_created_at": "2024-11-12T21:37:22+00:00",
        "comment_author": "tknickman",
        "comment_body": "Can we check for `TURBO_REMOTE_ONLY` and NOT `TURBO_CACHE`? Because we have to double set this on Vercel to get this to work without a deprecation warning ",
        "pr_file_module": null
      },
      {
        "comment_id": "1838806932",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9428,
        "pr_file": "crates/turborepo-lib/src/config/env.rs",
        "discussion_id": "1838805177",
        "commented_code": "@@ -80,7 +81,19 @@ impl ResolvedConfigurationOptions for EnvVars {\n \n         let force = self.truthy_value(\"force\").flatten();\n         let remote_only = self.truthy_value(\"remote_only\").flatten();\n+        if remote_only.is_some() {",
        "comment_created_at": "2024-11-12T21:39:00+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "We throw if you use legacy cache options with `TURBO_CACHE`:\r\n```\r\n[0 olszewski@chriss-mbp] /Users/olszewski/code/vercel/turborepo $ TURBO_REMOTE_CACHE_READ_ONLY=1 turbo_dev @turbo/types#lint --cache=remote:rw > /dev/null\r\n WARNING  No locally installed `turbo` found. Using version: 2.2.4-canary.9.\r\nturbo 2.2.4-canary.9\r\n\r\n WARNING  TURBO_REMOTE_CACHE_READ_ONLY is deprecated and will be removed in a future major version. Use TURBO_CACHE=remote:r\r\n  x Cannot set `cache` config and other cache options (`force`, `remoteOnly`,\r\n  | `remoteCacheReadOnly`) at the same time\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1803539194",
    "pr_number": 9249,
    "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
    "created_at": "2024-10-16T17:34:32+00:00",
    "commented_code": "+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+        }\n+    }\n+}\n+\n+// this is an internal structure (that's a partial of ConfigurationOptions) that\n+// we use to store\n+pub struct Output {\n+    /// maps to ConfigurationOptions.team_id\n+    pub team_id: Option<String>,\n+    // maps to ConfigurationOptions.team_slug\n+    pub team_slug: Option<String>,\n+    // maps to ConfigurationOptions.token\n+    pub token: Option<String>,\n+}\n+\n+impl Output {\n+    fn new() -> Self {\n+        Self {\n+            team_id: None,\n+            team_slug: None,\n+            token: None,\n+        }\n+    }\n+}\n+\n+// get Output from Input\n+impl From<Input> for Output {\n+    fn from(input: Input) -> Self {\n+        let mut output = Output::new();\n+\n+        // TURBO_TEAMID+TURBO_TOKEN\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAM.is_some() {\n+                // there can also be a TURBO_TEAM, so we'll use that as well\n+                output.team_slug = input.TURBO_TEAM;\n+            }",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1803539194",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 9249,
        "pr_file": "crates/turborepo-lib/src/config/override_env.rs",
        "discussion_id": "1803539194",
        "commented_code": "@@ -0,0 +1,493 @@\n+use std::{\n+    collections::HashMap,\n+    ffi::{OsStr, OsString},\n+};\n+\n+use super::{env::truth_env_var, ConfigurationOptions, Error, ResolvedConfigurationOptions};\n+use crate::turbo_json::UIMode;\n+\n+/*\n+Hi! If you're new here:\n+1. The general pattern is that:\n+  - ConfigurationOptions.token corresponds to TURBO_TOKEN or VERCEL_ARTIFACTS_TOKEN\n+  - ConfigurationOptions.team_id corresponds to TURBO_TEAMID or VERCEL_ARTIFACTS_OWNER\n+  - ConfigurationOptions.team_slug corresponds to TURBO_TEAM\n+1. We're ultimately poking around the env vars looking for _paris_ that make sense.\n+   Since we presume that users are the only ones sending TURBO_* and Vercel is the only one sending VERCEL_*, we can make some assumptions.  Namely, we assume that if we have one of VERCEL_ARTIFACTS_OWNER or VERCEL_ARTIFACTS_TOKEN we will always have both.\n+1. Watch out for mixing up `TURBO_TEAM` and `TURBO_TEAMID`.  Same for ConfigurationOptions.team_id and ConfigurationOptions.team_slug.\n+*/\n+\n+/// these correspond directly to the environment variables that this module\n+/// needs to do it's work\n+#[allow(non_snake_case)]\n+struct Input {\n+    TURBO_TEAM: Option<String>,\n+    TURBO_TEAMID: Option<String>,\n+    TURBO_TOKEN: Option<String>,\n+    VERCEL_ARTIFACTS_OWNER: Option<String>,\n+    VERCEL_ARTIFACTS_TOKEN: Option<String>,\n+}\n+\n+impl Input {\n+    fn new() -> Self {\n+        Self {\n+            TURBO_TEAM: None,\n+            TURBO_TEAMID: None,\n+            TURBO_TOKEN: None,\n+            VERCEL_ARTIFACTS_OWNER: None,\n+            VERCEL_ARTIFACTS_TOKEN: None,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a HashMap<OsString, OsString>> for Input {\n+    fn from(environment: &'a HashMap<OsString, OsString>) -> Self {\n+        Self {\n+            TURBO_TEAM: environment\n+                .get(OsStr::new(\"turbo_team\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TEAMID: environment\n+                .get(OsStr::new(\"turbo_teamid\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            TURBO_TOKEN: environment\n+                .get(OsStr::new(\"turbo_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_OWNER: environment\n+                .get(OsStr::new(\"vercel_artifacts_owner\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+            VERCEL_ARTIFACTS_TOKEN: environment\n+                .get(OsStr::new(\"vercel_artifacts_token\"))\n+                .map(|s| s.to_str().unwrap().to_string()),\n+        }\n+    }\n+}\n+\n+// this is an internal structure (that's a partial of ConfigurationOptions) that\n+// we use to store\n+pub struct Output {\n+    /// maps to ConfigurationOptions.team_id\n+    pub team_id: Option<String>,\n+    // maps to ConfigurationOptions.team_slug\n+    pub team_slug: Option<String>,\n+    // maps to ConfigurationOptions.token\n+    pub token: Option<String>,\n+}\n+\n+impl Output {\n+    fn new() -> Self {\n+        Self {\n+            team_id: None,\n+            team_slug: None,\n+            token: None,\n+        }\n+    }\n+}\n+\n+// get Output from Input\n+impl From<Input> for Output {\n+    fn from(input: Input) -> Self {\n+        let mut output = Output::new();\n+\n+        // TURBO_TEAMID+TURBO_TOKEN\n+        if input.TURBO_TEAMID.is_some() && input.TURBO_TOKEN.is_some() {\n+            output.team_id = input.TURBO_TEAMID;\n+            output.token = input.TURBO_TOKEN;\n+\n+            if input.TURBO_TEAM.is_some() {\n+                // there can also be a TURBO_TEAM, so we'll use that as well\n+                output.team_slug = input.TURBO_TEAM;\n+            }",
        "comment_created_at": "2024-10-16T17:34:32+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "```suggestion\r\n            // there can also be a TURBO_TEAM, so we'll use that as well\r\n            output.team_slug = input.TURBO_TEAM;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1676337571",
    "pr_number": 8728,
    "pr_file": "crates/turborepo-lib/src/turbo_json/mod.rs",
    "created_at": "2024-07-12T18:46:14+00:00",
    "commented_code": "assert_eq!(json.ui, expected);\n     }\n \n+    #[test_case(r#\"{ \"daemon\": true }\"#, Some(true) ; \"daemon_on\")]\n+    #[test_case(r#\"{ \"daemon\": false }\"#, Some(false) ; \"daemon_off\")]\n+    #[test_case(r#\"{}\"#, None ; \"missing\")]\n+    fn test_daemon(json: &str, expected: Option<bool>) {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1676337571",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8728,
        "pr_file": "crates/turborepo-lib/src/turbo_json/mod.rs",
        "discussion_id": "1676337571",
        "commented_code": "@@ -1075,6 +1077,14 @@ mod tests {\n         assert_eq!(json.ui, expected);\n     }\n \n+    #[test_case(r#\"{ \"daemon\": true }\"#, Some(true) ; \"daemon_on\")]\n+    #[test_case(r#\"{ \"daemon\": false }\"#, Some(false) ; \"daemon_off\")]\n+    #[test_case(r#\"{}\"#, None ; \"missing\")]\n+    fn test_daemon(json: &str, expected: Option<bool>) {",
        "comment_created_at": "2024-07-12T18:46:14+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "So something I missed: when we add new keys/fields to `turbo.json` we should always test both deserialization and serialization. When we don't we often create issues ([most recent issue caused by me forgetting to test this](https://github.com/vercel/turbo/issues/8311))",
        "pr_file_module": null
      },
      {
        "comment_id": "1677850540",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8728,
        "pr_file": "crates/turborepo-lib/src/turbo_json/mod.rs",
        "discussion_id": "1676337571",
        "commented_code": "@@ -1075,6 +1077,14 @@ mod tests {\n         assert_eq!(json.ui, expected);\n     }\n \n+    #[test_case(r#\"{ \"daemon\": true }\"#, Some(true) ; \"daemon_on\")]\n+    #[test_case(r#\"{ \"daemon\": false }\"#, Some(false) ; \"daemon_off\")]\n+    #[test_case(r#\"{}\"#, None ; \"missing\")]\n+    fn test_daemon(json: &str, expected: Option<bool>) {",
        "comment_created_at": "2024-07-15T13:39:40+00:00",
        "comment_author": "dimitropoulos",
        "comment_body": "sounds good! updated in https://github.com/vercel/turbo/pull/8728/commits/9065d956ad5d42abb1fd9744a98a2be105b01b9a",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1609041638",
    "pr_number": 8182,
    "pr_file": "crates/turborepo-lib/src/task_hash.rs",
    "created_at": "2024-05-21T23:07:31+00:00",
    "commented_code": "pub fn env(\n         &self,\n         task_id: &TaskId,\n-        task_env_mode: ResolvedEnvMode,\n+        task_env_mode: EnvMode,\n         task_definition: &TaskDefinition,\n         global_env: &EnvironmentVariableMap,\n     ) -> Result<EnvironmentVariableMap, Error> {\n         match task_env_mode {\n-            ResolvedEnvMode::Strict => {\n+            EnvMode::Strict => {\n                 let mut pass_through_env = EnvironmentVariableMap::default();\n                 let default_env_var_pass_through_map =\n                     self.env_at_execution_start.from_wildcards(&[\n                         \"SHELL\",\n                         // Command Prompt casing of env variables\n+                        \"APPDATA\",",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1609041638",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8182,
        "pr_file": "crates/turborepo-lib/src/task_hash.rs",
        "discussion_id": "1609041638",
        "commented_code": "@@ -448,22 +449,24 @@ impl<'a> TaskHasher<'a> {\n     pub fn env(\n         &self,\n         task_id: &TaskId,\n-        task_env_mode: ResolvedEnvMode,\n+        task_env_mode: EnvMode,\n         task_definition: &TaskDefinition,\n         global_env: &EnvironmentVariableMap,\n     ) -> Result<EnvironmentVariableMap, Error> {\n         match task_env_mode {\n-            ResolvedEnvMode::Strict => {\n+            EnvMode::Strict => {\n                 let mut pass_through_env = EnvironmentVariableMap::default();\n                 let default_env_var_pass_through_map =\n                     self.env_at_execution_start.from_wildcards(&[\n                         \"SHELL\",\n                         // Command Prompt casing of env variables\n+                        \"APPDATA\",",
        "comment_created_at": "2024-05-21T23:07:31+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "This is necessary due to older versions of `pnpm` not having https://github.com/pnpm/npm-conf/pull/10 which results in `pnpm` crashing if `APPDATA` isn't defined.\r\n\r\nTechnically we could have users define this instead of baking it into `turbo` itself, but considering the popularity of `pnpm` and the amount of digging it took to find that PR, it seems nice to include it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1678448081",
    "pr_number": 8759,
    "pr_file": "crates/turborepo-lib/src/cli/mod.rs",
    "created_at": "2024-07-15T22:07:43+00:00",
    "commented_code": "/// Environment variable mode.\n     /// Use \"loose\" to pass the entire existing environment.\n     /// Use \"strict\" to use an allowlist specified in turbo.json.\n-    #[clap(long = \"env-mode\", default_value = \"strict\", num_args = 0..=1, default_missing_value = \"strict\")]\n-    pub env_mode: EnvMode,\n+    #[clap(long = \"env-mode\", num_args = 0..=1, default_missing_value = \"strict\")]",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1678448081",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8759,
        "pr_file": "crates/turborepo-lib/src/cli/mod.rs",
        "discussion_id": "1678448081",
        "commented_code": "@@ -682,8 +682,8 @@ pub struct ExecutionArgs {\n     /// Environment variable mode.\n     /// Use \"loose\" to pass the entire existing environment.\n     /// Use \"strict\" to use an allowlist specified in turbo.json.\n-    #[clap(long = \"env-mode\", default_value = \"strict\", num_args = 0..=1, default_missing_value = \"strict\")]\n-    pub env_mode: EnvMode,\n+    #[clap(long = \"env-mode\", num_args = 0..=1, default_missing_value = \"strict\")]",
        "comment_created_at": "2024-07-15T22:07:43+00:00",
        "comment_author": "NicholasLYang",
        "comment_body": "We no longer assume `Strict` when the flag is not here. This allows the config override logic to work correctly.",
        "pr_file_module": null
      }
    ]
  }
]