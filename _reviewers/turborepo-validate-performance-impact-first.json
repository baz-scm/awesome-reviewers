[
  {
    "discussion_id": "2019721774",
    "pr_number": 10247,
    "pr_file": "crates/turborepo-ui/src/tui/term_output.rs",
    "created_at": "2025-03-29T05:53:21+00:00",
    "commented_code": "Error,\n };\n \n-const SCROLLBACK_LEN: usize = 1024;\n+const SCROLLBACK_LEN: usize = 2048;",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "2019721774",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10247,
        "pr_file": "crates/turborepo-ui/src/tui/term_output.rs",
        "discussion_id": "2019721774",
        "commented_code": "@@ -7,7 +7,15 @@ use super::{\n     Error,\n };\n \n-const SCROLLBACK_LEN: usize = 1024;\n+const SCROLLBACK_LEN: usize = 2048;",
        "comment_created_at": "2025-03-29T05:53:21+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "Making sure to call extra attention here: Users mentioned they felt 1024 was too small, so I doubled it here. Not sure about if there's a reason I shouldn't do this or if a different value should be used. Just did this for the sake of discussion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2021123593",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10247,
        "pr_file": "crates/turborepo-ui/src/tui/term_output.rs",
        "discussion_id": "2019721774",
        "commented_code": "@@ -7,7 +7,15 @@ use super::{\n     Error,\n };\n \n-const SCROLLBACK_LEN: usize = 1024;\n+const SCROLLBACK_LEN: usize = 2048;",
        "comment_created_at": "2025-03-31T14:08:24+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "I think this is okay since https://github.com/vercel/turborepo/pull/9123 has been merged.\r\n\r\n`vt100` used to need to iterate through every scrollback row in order to render a visible row so 1024->2048 would be a noticeable perf hit. I will do a quick profile to check if there's a noticeable impact from this change.",
        "pr_file_module": null
      },
      {
        "comment_id": "2021313622",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 10247,
        "pr_file": "crates/turborepo-ui/src/tui/term_output.rs",
        "discussion_id": "2019721774",
        "commented_code": "@@ -7,7 +7,15 @@ use super::{\n     Error,\n };\n \n-const SCROLLBACK_LEN: usize = 1024;\n+const SCROLLBACK_LEN: usize = 2048;",
        "comment_created_at": "2025-03-31T15:56:46+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "Did a test and this is a :shipit: no noticeable perf change",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1402638408",
    "pr_number": 6148,
    "pr_file": "crates/turborepo-scm/src/package_deps.rs",
    "created_at": "2023-11-22T19:33:48+00:00",
    "commented_code": "use std::collections::HashMap;\n \n use itertools::{Either, Itertools};\n-use tracing::debug;\n+use tracing::{debug, warn};\n use turbopath::{AbsoluteSystemPath, AnchoredSystemPath, PathError, RelativeUnixPathBuf};\n \n use crate::{hash_object::hash_objects, Error, Git, SCM};\n \n pub type GitHashes = HashMap<RelativeUnixPathBuf, String>;\n \n+/// Precalculates workspace data where it makes sense to reduce overhead from\n+/// lazily calculating it on demand.\n+pub enum CachedPackageFileHasher<'a> {\n+    Manual,\n+    Git(GitCachedPackageFileHasher<'a>),\n+}\n+\n+impl<'a> CachedPackageFileHasher<'a> {\n+    /// When creating a new CachedPackageFileHasher with the git hashes, we\n+    /// precalculate and store a datastructure that maps package paths to\n+    /// hashes of the files in that package, and a list of files that\n+    /// changed. This saves having to call out to git for each package.\n+    pub fn new(\n+        scm: &'a SCM,\n+        repo_root: &AbsoluteSystemPath,\n+        package_roots: impl Iterator<Item = &'a AnchoredSystemPath>,\n+    ) -> Self {\n+        match scm {\n+            SCM::Git(git) => {\n+                let mut map: HashMap<&AnchoredSystemPath, (GitHashes, Vec<_>)> = Default::default();",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1402638408",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 6148,
        "pr_file": "crates/turborepo-scm/src/package_deps.rs",
        "discussion_id": "1402638408",
        "commented_code": "@@ -1,13 +1,209 @@\n use std::collections::HashMap;\n \n use itertools::{Either, Itertools};\n-use tracing::debug;\n+use tracing::{debug, warn};\n use turbopath::{AbsoluteSystemPath, AnchoredSystemPath, PathError, RelativeUnixPathBuf};\n \n use crate::{hash_object::hash_objects, Error, Git, SCM};\n \n pub type GitHashes = HashMap<RelativeUnixPathBuf, String>;\n \n+/// Precalculates workspace data where it makes sense to reduce overhead from\n+/// lazily calculating it on demand.\n+pub enum CachedPackageFileHasher<'a> {\n+    Manual,\n+    Git(GitCachedPackageFileHasher<'a>),\n+}\n+\n+impl<'a> CachedPackageFileHasher<'a> {\n+    /// When creating a new CachedPackageFileHasher with the git hashes, we\n+    /// precalculate and store a datastructure that maps package paths to\n+    /// hashes of the files in that package, and a list of files that\n+    /// changed. This saves having to call out to git for each package.\n+    pub fn new(\n+        scm: &'a SCM,\n+        repo_root: &AbsoluteSystemPath,\n+        package_roots: impl Iterator<Item = &'a AnchoredSystemPath>,\n+    ) -> Self {\n+        match scm {\n+            SCM::Git(git) => {\n+                let mut map: HashMap<&AnchoredSystemPath, (GitHashes, Vec<_>)> = Default::default();",
        "comment_created_at": "2023-11-22T19:33:48+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "```suggestion\r\n                let mut map: HashMap<&AnchoredSystemPath, (GitHashes, Vec<_>)> = HashMap::with_capacity({\r\n                    let (lower, upper) = package_roots.size_hint();\r\n                    upper.unwrap_or(lower)\r\n                });\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1663212825",
    "pr_number": 8650,
    "pr_file": "crates/turborepo-ui/src/tui/pane.rs",
    "created_at": "2024-07-02T21:58:33+00:00",
    "commented_code": "};\n use tracing::debug;\n use tui_term::widget::PseudoTerminal;\n-use turborepo_vt100 as vt100;\n \n-use super::{app::Direction, Error};\n+use super::{app::Direction, Error, TerminalOutput};\n \n const FOOTER_TEXT_ACTIVE: &str = \"Press`Ctrl-Z` to stop interacting.\";\n const FOOTER_TEXT_INACTIVE: &str = \"Press `Enter` to interact.\";\n \n-pub struct TerminalPane<W> {\n-    tasks: BTreeMap<String, TerminalOutput<W>>,\n-    displayed: Option<String>,\n+pub struct TerminalPane<'a, W> {\n+    displayed_task: &'a String,",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1663212825",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8650,
        "pr_file": "crates/turborepo-ui/src/tui/pane.rs",
        "discussion_id": "1663212825",
        "commented_code": "@@ -7,50 +7,40 @@ use ratatui::{\n };\n use tracing::debug;\n use tui_term::widget::PseudoTerminal;\n-use turborepo_vt100 as vt100;\n \n-use super::{app::Direction, Error};\n+use super::{app::Direction, Error, TerminalOutput};\n \n const FOOTER_TEXT_ACTIVE: &str = \"Press`Ctrl-Z` to stop interacting.\";\n const FOOTER_TEXT_INACTIVE: &str = \"Press `Enter` to interact.\";\n \n-pub struct TerminalPane<W> {\n-    tasks: BTreeMap<String, TerminalOutput<W>>,\n-    displayed: Option<String>,\n+pub struct TerminalPane<'a, W> {\n+    displayed_task: &'a String,",
        "comment_created_at": "2024-07-02T21:58:33+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "~~Nit~~ Learning opportunity:\r\nGenerally one should prefer `&str` to `&String` as the latter has to follow jump through memory twice:\r\n - first to dereference the `&String` to `String`\r\n - then to read the pointer in the `String` object that points to the actual bytes\r\n\r\n`&str` on the other hand only has the pointer to the actual bytes\r\n\r\nExceptions to the rule: You need to mutate the string",
        "pr_file_module": null
      },
      {
        "comment_id": "1664252371",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8650,
        "pr_file": "crates/turborepo-ui/src/tui/pane.rs",
        "discussion_id": "1663212825",
        "commented_code": "@@ -7,50 +7,40 @@ use ratatui::{\n };\n use tracing::debug;\n use tui_term::widget::PseudoTerminal;\n-use turborepo_vt100 as vt100;\n \n-use super::{app::Direction, Error};\n+use super::{app::Direction, Error, TerminalOutput};\n \n const FOOTER_TEXT_ACTIVE: &str = \"Press`Ctrl-Z` to stop interacting.\";\n const FOOTER_TEXT_INACTIVE: &str = \"Press `Enter` to interact.\";\n \n-pub struct TerminalPane<W> {\n-    tasks: BTreeMap<String, TerminalOutput<W>>,\n-    displayed: Option<String>,\n+pub struct TerminalPane<'a, W> {\n+    displayed_task: &'a String,",
        "comment_created_at": "2024-07-03T14:04:29+00:00",
        "comment_author": "anthonyshew",
        "comment_body": "Interesting, muchas gracias.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1664706692",
    "pr_number": 8650,
    "pr_file": "crates/turborepo-ui/src/tui/task.rs",
    "created_at": "2024-07-03T20:04:54+00:00",
    "commented_code": "}\n \n     pub fn count_all(&self) -> usize {\n-        self.task_names_in_displayed_order().len()\n+        self.task_names_in_displayed_order().count()\n     }\n \n-    pub fn task_names_in_displayed_order(&self) -> Vec<String> {\n-        let running_names = self\n-            .running\n-            .iter()\n-            .map(|task| task.name().to_string())\n-            .collect::<Vec<_>>();\n-        let planned_names = self\n-            .planned\n-            .iter()\n-            .map(|task| task.name().to_string())\n-            .collect::<Vec<_>>();\n-        let finished_names = self\n-            .finished\n-            .iter()\n-            .map(|task| task.name().to_string())\n-            .collect::<Vec<_>>();\n-\n-        [\n-            running_names.as_slice(),\n-            planned_names.as_slice(),\n-            finished_names.as_slice(),\n-        ]\n-        .concat()\n+    pub fn task_names_in_displayed_order(&self) -> impl Iterator<Item = &str> + '_ {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1664706692",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8650,
        "pr_file": "crates/turborepo-ui/src/tui/task.rs",
        "discussion_id": "1664706692",
        "commented_code": "@@ -108,32 +108,19 @@ impl TasksByStatus {\n     }\n \n     pub fn count_all(&self) -> usize {\n-        self.task_names_in_displayed_order().len()\n+        self.task_names_in_displayed_order().count()\n     }\n \n-    pub fn task_names_in_displayed_order(&self) -> Vec<String> {\n-        let running_names = self\n-            .running\n-            .iter()\n-            .map(|task| task.name().to_string())\n-            .collect::<Vec<_>>();\n-        let planned_names = self\n-            .planned\n-            .iter()\n-            .map(|task| task.name().to_string())\n-            .collect::<Vec<_>>();\n-        let finished_names = self\n-            .finished\n-            .iter()\n-            .map(|task| task.name().to_string())\n-            .collect::<Vec<_>>();\n-\n-        [\n-            running_names.as_slice(),\n-            planned_names.as_slice(),\n-            finished_names.as_slice(),\n-        ]\n-        .concat()\n+    pub fn task_names_in_displayed_order(&self) -> impl Iterator<Item = &str> + '_ {",
        "comment_created_at": "2024-07-03T20:04:54+00:00",
        "comment_author": "chris-olszewski",
        "comment_body": "This change means the function now returns an iterator over all task names instead of an vector of them. Beneficial to us as it results in far fewer allocations (4 vector allocations + 1 allocation per task) to zero allocations.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1664488130",
    "pr_number": 8657,
    "pr_file": "crates/turbo-tasks-auto-hash-map/src/map.rs",
    "created_at": "2024-07-03T16:49:16+00:00",
    "commented_code": "}\n         }\n     }\n+\n+    pub fn shrink_amortized(&mut self) {\n+        match self {\n+            AutoMap::List(list) => {\n+                if list.capacity() > list.len() * 2 {",
    "repo_full_name": "vercel/turborepo",
    "discussion_comments": [
      {
        "comment_id": "1664488130",
        "repo_full_name": "vercel/turborepo",
        "pr_number": 8657,
        "pr_file": "crates/turbo-tasks-auto-hash-map/src/map.rs",
        "discussion_id": "1664488130",
        "commented_code": "@@ -249,6 +249,25 @@ impl<K: Eq + Hash, V, H: BuildHasher + Default, const I: usize> AutoMap<K, V, H,\n             }\n         }\n     }\n+\n+    pub fn shrink_amortized(&mut self) {\n+        match self {\n+            AutoMap::List(list) => {\n+                if list.capacity() > list.len() * 2 {",
        "comment_created_at": "2024-07-03T16:49:16+00:00",
        "comment_author": "bgw",
        "comment_body": "Because HashMap and Vec grow by powers of two, this could lead to situations were we're frequently growing and shrinking the same list every time something is added and removed.\n\nIt's worse for memory, but better for time complexity to grow and shrink by different thresholds. E.g. If `list.capacity() > list.len() * 4` then shrink to `list.len() * 2`.\n\n> Many dynamic arrays also deallocate some of the underlying storage if its size drops below a certain threshold, such as 30% of the capacity. This threshold must be strictly smaller than 1/a in order to provide hysteresis (provide a stable band to avoid repeatedly growing and shrinking) and support mixed sequences of insertions and removals with amortized constant cost. \n\n-- https://en.wikipedia.org/wiki/Dynamic_array#Geometric_expansion_and_amortized_cost\n\nIf you think it's worth it, we could intercept inserts here and manipulate Vec/HashMap to achieve a different growth factor than 2. Many languages use 1.5. Python uses the very low value of 1.125 (!).\n\nIt also may be worth adding an arbitrary minimum size here where it's not worth shrinking the Vec below (e.g. 4, 8, or 10) to avoid excessive resizes of very small arrays.",
        "pr_file_module": null
      }
    ]
  }
]