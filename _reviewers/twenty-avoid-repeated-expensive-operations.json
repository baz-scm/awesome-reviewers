[
  {
    "discussion_id": "2337192931",
    "pr_number": 14386,
    "pr_file": "packages/twenty-front/src/modules/dashboards/widgets/graph/components/GraphWidgetLineChart.tsx",
    "created_at": "2025-09-10T15:46:33+00:00",
    "commented_code": "+import styled from '@emotion/styled';\n+import {\n+  ResponsiveLine,\n+  type LineSeries,\n+  type Point,\n+  type SliceTooltipProps,\n+} from '@nivo/line';\n+import { type ScaleLinearSpec, type ScaleSpec } from '@nivo/scales';\n+import { useId, useMemo } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type LineChartDataPoint = {\n+  x: number | string | Date;\n+  y: number | null;\n+  to?: string;\n+};\n+\n+type LineChartSeries = {\n+  id: string;\n+  label?: string;\n+  color?: GraphColor;\n+  data: LineChartDataPoint[];\n+  enableArea?: boolean;\n+};\n+\n+type GraphWidgetLineChartProps = {\n+  data: LineChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  enablePoints?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  enableArea?: boolean;\n+  stackedArea?: boolean;\n+  curve?:\n+    | 'linear'\n+    | 'monotoneX'\n+    | 'step'\n+    | 'stepBefore'\n+    | 'stepAfter'\n+    | 'natural';\n+  lineWidth?: number;\n+  enableSlices?: 'x' | 'y' | false;\n+  xScale?: ScaleSpec;\n+  yScale?: ScaleSpec;\n+} & GraphValueFormatOptions;\n+\n+const getYScaleWithStacking = (\n+  yScale: ScaleSpec | undefined,\n+  stackedArea: boolean | undefined,\n+): ScaleSpec => {\n+  if (!yScale || yScale.type === 'linear') {\n+    const linearScale: ScaleLinearSpec = {\n+      min: 0,\n+      max: 'auto',\n+      ...yScale,\n+      type: 'linear',\n+      stacked: stackedArea,\n+    };\n+    return linearScale;\n+  }\n+\n+  return yScale;\n+};\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g circle {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetLineChart = ({\n+  data,\n+  showLegend = true,\n+  showGrid = true,\n+  enablePoints = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  enableArea = false,\n+  stackedArea = false,\n+  curve = 'monotoneX',\n+  lineWidth = 2,\n+  enableSlices = 'x',\n+  xScale = { type: 'linear' },\n+  yScale = { type: 'linear', min: 0, max: 'auto' },\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetLineChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const enrichedSeries = useMemo(() => {\n+    return data.map((series, index) => {\n+      const colorScheme = getColorScheme(colorRegistry, series.color, index);\n+      const shouldEnableArea = series.enableArea ?? enableArea;\n+      const gradientId = `lineGradient-${id}-${instanceId}-${series.id}-${index}`;\n+\n+      return {\n+        ...series,\n+        colorScheme,\n+        gradientId,\n+        shouldEnableArea,\n+        label: series.label || series.id,\n+      };\n+    });\n+  }, [data, colorRegistry, id, instanceId, enableArea]);\n+\n+  const nivoData = data.map((series) => ({\n+    id: series.id,\n+    data: series.data.map((point) => ({\n+      x: point.x,\n+      y: point.y,\n+    })),\n+  }));\n+\n+  const defs = enrichedSeries\n+    .filter((series) => series.shouldEnableArea)\n+    .map((series) =>\n+      createGradientDef(\n+        series.colorScheme,\n+        series.gradientId,\n+        false,\n+        90,\n+        theme.name === 'light',\n+      ),\n+    );\n+\n+  const fill = enrichedSeries\n+    .filter((series) => series.shouldEnableArea)\n+    .map((series) => ({\n+      match: { id: series.id },\n+      id: series.gradientId,\n+    }));\n+\n+  const colors = enrichedSeries.map((series) => series.colorScheme.solid);\n+\n+  const handlePointClick = (point: Point<LineSeries>) => {\n+    const series = data.find((s) => s.id === point.seriesId);",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2337192931",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14386,
        "pr_file": "packages/twenty-front/src/modules/dashboards/widgets/graph/components/GraphWidgetLineChart.tsx",
        "discussion_id": "2337192931",
        "commented_code": "@@ -0,0 +1,372 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveLine,\n+  type LineSeries,\n+  type Point,\n+  type SliceTooltipProps,\n+} from '@nivo/line';\n+import { type ScaleLinearSpec, type ScaleSpec } from '@nivo/scales';\n+import { useId, useMemo } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type LineChartDataPoint = {\n+  x: number | string | Date;\n+  y: number | null;\n+  to?: string;\n+};\n+\n+type LineChartSeries = {\n+  id: string;\n+  label?: string;\n+  color?: GraphColor;\n+  data: LineChartDataPoint[];\n+  enableArea?: boolean;\n+};\n+\n+type GraphWidgetLineChartProps = {\n+  data: LineChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  enablePoints?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  enableArea?: boolean;\n+  stackedArea?: boolean;\n+  curve?:\n+    | 'linear'\n+    | 'monotoneX'\n+    | 'step'\n+    | 'stepBefore'\n+    | 'stepAfter'\n+    | 'natural';\n+  lineWidth?: number;\n+  enableSlices?: 'x' | 'y' | false;\n+  xScale?: ScaleSpec;\n+  yScale?: ScaleSpec;\n+} & GraphValueFormatOptions;\n+\n+const getYScaleWithStacking = (\n+  yScale: ScaleSpec | undefined,\n+  stackedArea: boolean | undefined,\n+): ScaleSpec => {\n+  if (!yScale || yScale.type === 'linear') {\n+    const linearScale: ScaleLinearSpec = {\n+      min: 0,\n+      max: 'auto',\n+      ...yScale,\n+      type: 'linear',\n+      stacked: stackedArea,\n+    };\n+    return linearScale;\n+  }\n+\n+  return yScale;\n+};\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g circle {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetLineChart = ({\n+  data,\n+  showLegend = true,\n+  showGrid = true,\n+  enablePoints = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  enableArea = false,\n+  stackedArea = false,\n+  curve = 'monotoneX',\n+  lineWidth = 2,\n+  enableSlices = 'x',\n+  xScale = { type: 'linear' },\n+  yScale = { type: 'linear', min: 0, max: 'auto' },\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetLineChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const enrichedSeries = useMemo(() => {\n+    return data.map((series, index) => {\n+      const colorScheme = getColorScheme(colorRegistry, series.color, index);\n+      const shouldEnableArea = series.enableArea ?? enableArea;\n+      const gradientId = `lineGradient-${id}-${instanceId}-${series.id}-${index}`;\n+\n+      return {\n+        ...series,\n+        colorScheme,\n+        gradientId,\n+        shouldEnableArea,\n+        label: series.label || series.id,\n+      };\n+    });\n+  }, [data, colorRegistry, id, instanceId, enableArea]);\n+\n+  const nivoData = data.map((series) => ({\n+    id: series.id,\n+    data: series.data.map((point) => ({\n+      x: point.x,\n+      y: point.y,\n+    })),\n+  }));\n+\n+  const defs = enrichedSeries\n+    .filter((series) => series.shouldEnableArea)\n+    .map((series) =>\n+      createGradientDef(\n+        series.colorScheme,\n+        series.gradientId,\n+        false,\n+        90,\n+        theme.name === 'light',\n+      ),\n+    );\n+\n+  const fill = enrichedSeries\n+    .filter((series) => series.shouldEnableArea)\n+    .map((series) => ({\n+      match: { id: series.id },\n+      id: series.gradientId,\n+    }));\n+\n+  const colors = enrichedSeries.map((series) => series.colorScheme.solid);\n+\n+  const handlePointClick = (point: Point<LineSeries>) => {\n+    const series = data.find((s) => s.id === point.seriesId);",
        "comment_created_at": "2025-09-10T15:46:33+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "data.find() is used in multiple places, to improve performance you could create a dataMap and call dataMap[id] instead",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2307625722",
    "pr_number": 14052,
    "pr_file": "packages/twenty-front/src/modules/dashboards/graphs/components/GraphWidgetBarChart.tsx",
    "created_at": "2025-08-28T14:38:54+00:00",
    "commented_code": "+import styled from '@emotion/styled';\n+import {\n+  ResponsiveBar,\n+  type BarCustomLayerProps,\n+  type BarDatum,\n+  type ComputedBarDatum,\n+  type ComputedDatum,\n+} from '@nivo/bar';\n+import { useId, useMemo, useState } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { type GraphColorScheme } from '../types/GraphColorScheme';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type BarChartDataItem = BarDatum & {\n+  to?: string;\n+};\n+\n+type BarChartSeries = {\n+  key: string;\n+  label?: string;\n+  color?: GraphColor;\n+};\n+\n+type GraphWidgetBarChartProps = {\n+  data: BarChartDataItem[];\n+  indexBy: string;\n+  keys: string[];\n+  series?: BarChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  showValues?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  layout?: 'vertical' | 'horizontal';\n+  groupMode?: 'grouped' | 'stacked';\n+  seriesLabels?: Record<string, string>;\n+} & GraphValueFormatOptions;\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g[transform] rect[fill^=\"url(#gradient-\"] {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetBarChart = ({\n+  data,\n+  indexBy,\n+  keys,\n+  series,\n+  showLegend = true,\n+  showGrid = true,\n+  showValues = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  layout = 'vertical',\n+  groupMode = 'grouped',\n+  seriesLabels,\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetBarChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+  const [hoveredBar, setHoveredBar] = useState<{\n+    key: string;\n+    indexValue: string | number;\n+  } | null>(null);\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const barConfigs = useMemo(() => {\n+    const configs: Array<{\n+      key: string;\n+      indexValue: string | number;\n+      gradientId: string;\n+      colorScheme: GraphColorScheme;\n+      isHovered: boolean;\n+    }> = [];\n+\n+    data.forEach((dataPoint, dataIndex) => {\n+      const indexValue = dataPoint[indexBy];\n+      keys.forEach((key, keyIndex) => {\n+        const seriesConfig = series?.find((s) => s.key === key);\n+        const colorScheme = getColorScheme(\n+          colorRegistry,\n+          seriesConfig?.color,\n+          keyIndex,\n+        );\n+        const isHovered =\n+          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n+        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n+\n+        configs.push({\n+          key,\n+          indexValue,\n+          gradientId,\n+          colorScheme,\n+          isHovered,\n+        });\n+      });\n+    });\n+\n+    return configs;\n+  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);\n+\n+  const enrichedKeys = useMemo(() => {\n+    return keys.map((key, index) => {\n+      const seriesConfig = series?.find((s) => s.key === key);",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2307625722",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14052,
        "pr_file": "packages/twenty-front/src/modules/dashboards/graphs/components/GraphWidgetBarChart.tsx",
        "discussion_id": "2307625722",
        "commented_code": "@@ -0,0 +1,406 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveBar,\n+  type BarCustomLayerProps,\n+  type BarDatum,\n+  type ComputedBarDatum,\n+  type ComputedDatum,\n+} from '@nivo/bar';\n+import { useId, useMemo, useState } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { type GraphColorScheme } from '../types/GraphColorScheme';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type BarChartDataItem = BarDatum & {\n+  to?: string;\n+};\n+\n+type BarChartSeries = {\n+  key: string;\n+  label?: string;\n+  color?: GraphColor;\n+};\n+\n+type GraphWidgetBarChartProps = {\n+  data: BarChartDataItem[];\n+  indexBy: string;\n+  keys: string[];\n+  series?: BarChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  showValues?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  layout?: 'vertical' | 'horizontal';\n+  groupMode?: 'grouped' | 'stacked';\n+  seriesLabels?: Record<string, string>;\n+} & GraphValueFormatOptions;\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g[transform] rect[fill^=\"url(#gradient-\"] {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetBarChart = ({\n+  data,\n+  indexBy,\n+  keys,\n+  series,\n+  showLegend = true,\n+  showGrid = true,\n+  showValues = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  layout = 'vertical',\n+  groupMode = 'grouped',\n+  seriesLabels,\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetBarChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+  const [hoveredBar, setHoveredBar] = useState<{\n+    key: string;\n+    indexValue: string | number;\n+  } | null>(null);\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const barConfigs = useMemo(() => {\n+    const configs: Array<{\n+      key: string;\n+      indexValue: string | number;\n+      gradientId: string;\n+      colorScheme: GraphColorScheme;\n+      isHovered: boolean;\n+    }> = [];\n+\n+    data.forEach((dataPoint, dataIndex) => {\n+      const indexValue = dataPoint[indexBy];\n+      keys.forEach((key, keyIndex) => {\n+        const seriesConfig = series?.find((s) => s.key === key);\n+        const colorScheme = getColorScheme(\n+          colorRegistry,\n+          seriesConfig?.color,\n+          keyIndex,\n+        );\n+        const isHovered =\n+          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n+        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n+\n+        configs.push({\n+          key,\n+          indexValue,\n+          gradientId,\n+          colorScheme,\n+          isHovered,\n+        });\n+      });\n+    });\n+\n+    return configs;\n+  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);\n+\n+  const enrichedKeys = useMemo(() => {\n+    return keys.map((key, index) => {\n+      const seriesConfig = series?.find((s) => s.key === key);",
        "comment_created_at": "2025-08-28T14:38:54+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "To optimize this here and inside the bar config computation, we could create a `seriesConfigMap` and call `seriesConfig?.[key]` instead of computing `.find` each time",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1943162748",
    "pr_number": 10032,
    "pr_file": "packages/twenty-front/src/modules/action-menu/actions/record-actions/components/RecordActionMenuEntriesSetter.tsx",
    "created_at": "2025-02-05T15:19:47+00:00",
    "commented_code": ");\n \n   const actionsToRegister = isDefined(viewType)\n-    ? Object.values(actionConfig ?? {}).filter((action) =>\n-        action.availableOn?.includes(viewType),\n-      )\n+    ? Object.values(actionConfig ?? {})\n+        .filter((action) => action.availableOn?.includes(viewType))\n+        .sort((a, b) => a.position - b.position)",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "1943162748",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 10032,
        "pr_file": "packages/twenty-front/src/modules/action-menu/actions/record-actions/components/RecordActionMenuEntriesSetter.tsx",
        "discussion_id": "1943162748",
        "commented_code": "@@ -57,9 +57,9 @@ export const RecordActionMenuEntriesSetter = () => {\n   );\n \n   const actionsToRegister = isDefined(viewType)\n-    ? Object.values(actionConfig ?? {}).filter((action) =>\n-        action.availableOn?.includes(viewType),\n-      )\n+    ? Object.values(actionConfig ?? {})\n+        .filter((action) => action.availableOn?.includes(viewType))\n+        .sort((a, b) => a.position - b.position)",
        "comment_created_at": "2025-02-05T15:19:47+00:00",
        "comment_author": "prastoin",
        "comment_body": "***Remark:*** I feel we're sorting something already sorted, if we wanna be safe maybe we could export an programmatically sorted `Record` by `position` instead of sorting it each time \ud83e\udd14  ? Please let me know\r\n",
        "pr_file_module": null
      }
    ]
  }
]