[
  {
    "discussion_id": "2354566709",
    "pr_number": 14414,
    "pr_file": "packages/twenty-front/src/modules/ai/components/ToolStepRenderer.tsx",
    "created_at": "2025-09-17T07:22:37+00:00",
    "commented_code": "+import { useTheme } from '@emotion/react';\n+import styled from '@emotion/styled';\n+import { useState } from 'react';\n+\n+import { IconChevronDown, IconChevronUp } from 'twenty-ui/display';\n+import { AnimatedExpandableContainer } from 'twenty-ui/layout';\n+\n+import { ShimmeringText } from '@/ai/components/ShimmeringText';\n+import type {\n+  ToolCallEvent,\n+  ToolEvent,\n+  ToolResultEvent,\n+} from '@/ai/types/streamTypes';\n+import { extractErrorMessage } from '@/ai/utils/extractErrorMessage';\n+import { getToolIcon } from '@/ai/utils/getToolIcon';\n+\n+const StyledContainer = styled.div`\n+  display: flex;\n+  flex-direction: column;\n+  gap: ${({ theme }) => theme.spacing(2)};\n+`;\n+\n+const StyledLoadingContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  gap: ${({ theme }) => theme.spacing(2)};\n+`;\n+\n+const StyledContentContainer = styled.div`\n+  background: ${({ theme }) => theme.background.transparent.lighter};\n+  border-radius: ${({ theme }) => theme.border.radius.sm};\n+  padding: ${({ theme }) => theme.spacing(3)};\n+  border: 1px solid ${({ theme }) => theme.border.color.light};\n+`;\n+\n+const StyledToggleButton = styled.div<{ isExpandable: boolean }>`\n+  align-items: center;\n+  background: none;\n+  border: none;\n+  cursor: ${({ isExpandable }) => (isExpandable ? 'pointer' : 'auto')};\n+  display: flex;\n+  color: ${({ theme }) => theme.font.color.tertiary};\n+  gap: ${({ theme }) => theme.spacing(1)};\n+  padding: ${({ theme }) => theme.spacing(1)} 0;\n+  transition: color ${({ theme }) => theme.animation.duration.normal}s;\n+\n+  &:hover {\n+    color: ${({ theme }) => theme.font.color.secondary};\n+  }\n+`;\n+\n+const StyledDisplayMessage = styled.span`\n+  color: ${({ theme }) => theme.font.color.tertiary};\n+  font-size: ${({ theme }) => theme.font.size.md};\n+  font-weight: ${({ theme }) => theme.font.weight.medium};\n+`;\n+\n+const StyledPre = styled.pre`\n+  margin-top: ${({ theme }) => theme.spacing(1)};\n+  white-space: pre-wrap;\n+`;\n+\n+const StyledIconTextContainer = styled.div`\n+  display: flex;\n+  align-items: center;\n+  gap: ${({ theme }) => theme.spacing(1)};\n+\n+  svg {\n+    min-width: ${({ theme }) => theme.icon.size.sm}px;\n+  }\n+`;\n+\n+export const ToolStepRenderer = ({ events }: { events: ToolEvent[] }) => {\n+  const theme = useTheme();\n+  const [isExpanded, setIsExpanded] = useState(false);\n+\n+  const toolCall = events[0] as ToolCallEvent | undefined;\n+  const toolResult = events.find(\n+    (event): event is ToolResultEvent => event.type === 'tool-result',\n+  );\n+\n+  if (!toolCall) {\n+    return null;\n+  }\n+\n+  const toolOutput = toolResult?.result as ToolResultEvent['result'];\n+  const isStandardizedFormat =\n+    toolOutput && typeof toolOutput === 'object' && 'success' in toolOutput;\n+\n+  const hasResult = isStandardizedFormat\n+    ? Boolean(toolOutput.result)\n+    : Boolean(toolResult?.result);\n+  const hasError = isStandardizedFormat ? Boolean(toolOutput.error) : false;\n+  const isExpandable = hasResult || hasError;\n+\n+  if (!toolResult) {\n+    return (\n+      <StyledContainer>\n+        <StyledLoadingContainer>\n+          <ShimmeringText>\n+            <StyledDisplayMessage>\n+              {toolCall.args.loadingMessage}\n+            </StyledDisplayMessage>\n+          </ShimmeringText>\n+        </StyledLoadingContainer>\n+      </StyledContainer>\n+    );\n+  }\n+\n+  const displayMessage =\n+    toolResult?.result &&\n+    typeof toolResult.result === 'object' &&\n+    'message' in toolResult.result\n+      ? (toolResult.result as { message: string }).message\n+      : undefined;\n+\n+  const ToolIcon = getToolIcon(toolCall.toolName);\n+\n+  return (\n+    <StyledContainer>\n+      <StyledToggleButton\n+        onClick={() => setIsExpanded(!isExpanded)}\n+        isExpandable={isExpandable}\n+      >\n+        <StyledIconTextContainer>\n+          <ToolIcon size={theme.icon.size.sm} />\n+          <StyledDisplayMessage>{displayMessage}</StyledDisplayMessage>\n+        </StyledIconTextContainer>\n+        {isExpandable &&\n+          (isExpanded ? (\n+            <IconChevronUp size={theme.icon.size.sm} />\n+          ) : (\n+            <IconChevronDown size={theme.icon.size.sm} />\n+          ))}\n+      </StyledToggleButton>\n+\n+      {isExpandable && (\n+        <AnimatedExpandableContainer isExpanded={isExpanded}>\n+          <StyledContentContainer>\n+            {isStandardizedFormat ? (\n+              <>\n+                {hasError && <div>{extractErrorMessage(toolOutput.error)}</div>}\n+                {hasResult && (\n+                  <div>\n+                    <StyledPre>\n+                      {JSON.stringify(toolOutput.result, null, 2)}",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2354566709",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14414,
        "pr_file": "packages/twenty-front/src/modules/ai/components/ToolStepRenderer.tsx",
        "discussion_id": "2354566709",
        "commented_code": "@@ -0,0 +1,159 @@\n+import { useTheme } from '@emotion/react';\n+import styled from '@emotion/styled';\n+import { useState } from 'react';\n+\n+import { IconChevronDown, IconChevronUp } from 'twenty-ui/display';\n+import { AnimatedExpandableContainer } from 'twenty-ui/layout';\n+\n+import { ShimmeringText } from '@/ai/components/ShimmeringText';\n+import type {\n+  ToolCallEvent,\n+  ToolEvent,\n+  ToolResultEvent,\n+} from '@/ai/types/streamTypes';\n+import { extractErrorMessage } from '@/ai/utils/extractErrorMessage';\n+import { getToolIcon } from '@/ai/utils/getToolIcon';\n+\n+const StyledContainer = styled.div`\n+  display: flex;\n+  flex-direction: column;\n+  gap: ${({ theme }) => theme.spacing(2)};\n+`;\n+\n+const StyledLoadingContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  gap: ${({ theme }) => theme.spacing(2)};\n+`;\n+\n+const StyledContentContainer = styled.div`\n+  background: ${({ theme }) => theme.background.transparent.lighter};\n+  border-radius: ${({ theme }) => theme.border.radius.sm};\n+  padding: ${({ theme }) => theme.spacing(3)};\n+  border: 1px solid ${({ theme }) => theme.border.color.light};\n+`;\n+\n+const StyledToggleButton = styled.div<{ isExpandable: boolean }>`\n+  align-items: center;\n+  background: none;\n+  border: none;\n+  cursor: ${({ isExpandable }) => (isExpandable ? 'pointer' : 'auto')};\n+  display: flex;\n+  color: ${({ theme }) => theme.font.color.tertiary};\n+  gap: ${({ theme }) => theme.spacing(1)};\n+  padding: ${({ theme }) => theme.spacing(1)} 0;\n+  transition: color ${({ theme }) => theme.animation.duration.normal}s;\n+\n+  &:hover {\n+    color: ${({ theme }) => theme.font.color.secondary};\n+  }\n+`;\n+\n+const StyledDisplayMessage = styled.span`\n+  color: ${({ theme }) => theme.font.color.tertiary};\n+  font-size: ${({ theme }) => theme.font.size.md};\n+  font-weight: ${({ theme }) => theme.font.weight.medium};\n+`;\n+\n+const StyledPre = styled.pre`\n+  margin-top: ${({ theme }) => theme.spacing(1)};\n+  white-space: pre-wrap;\n+`;\n+\n+const StyledIconTextContainer = styled.div`\n+  display: flex;\n+  align-items: center;\n+  gap: ${({ theme }) => theme.spacing(1)};\n+\n+  svg {\n+    min-width: ${({ theme }) => theme.icon.size.sm}px;\n+  }\n+`;\n+\n+export const ToolStepRenderer = ({ events }: { events: ToolEvent[] }) => {\n+  const theme = useTheme();\n+  const [isExpanded, setIsExpanded] = useState(false);\n+\n+  const toolCall = events[0] as ToolCallEvent | undefined;\n+  const toolResult = events.find(\n+    (event): event is ToolResultEvent => event.type === 'tool-result',\n+  );\n+\n+  if (!toolCall) {\n+    return null;\n+  }\n+\n+  const toolOutput = toolResult?.result as ToolResultEvent['result'];\n+  const isStandardizedFormat =\n+    toolOutput && typeof toolOutput === 'object' && 'success' in toolOutput;\n+\n+  const hasResult = isStandardizedFormat\n+    ? Boolean(toolOutput.result)\n+    : Boolean(toolResult?.result);\n+  const hasError = isStandardizedFormat ? Boolean(toolOutput.error) : false;\n+  const isExpandable = hasResult || hasError;\n+\n+  if (!toolResult) {\n+    return (\n+      <StyledContainer>\n+        <StyledLoadingContainer>\n+          <ShimmeringText>\n+            <StyledDisplayMessage>\n+              {toolCall.args.loadingMessage}\n+            </StyledDisplayMessage>\n+          </ShimmeringText>\n+        </StyledLoadingContainer>\n+      </StyledContainer>\n+    );\n+  }\n+\n+  const displayMessage =\n+    toolResult?.result &&\n+    typeof toolResult.result === 'object' &&\n+    'message' in toolResult.result\n+      ? (toolResult.result as { message: string }).message\n+      : undefined;\n+\n+  const ToolIcon = getToolIcon(toolCall.toolName);\n+\n+  return (\n+    <StyledContainer>\n+      <StyledToggleButton\n+        onClick={() => setIsExpanded(!isExpanded)}\n+        isExpandable={isExpandable}\n+      >\n+        <StyledIconTextContainer>\n+          <ToolIcon size={theme.icon.size.sm} />\n+          <StyledDisplayMessage>{displayMessage}</StyledDisplayMessage>\n+        </StyledIconTextContainer>\n+        {isExpandable &&\n+          (isExpanded ? (\n+            <IconChevronUp size={theme.icon.size.sm} />\n+          ) : (\n+            <IconChevronDown size={theme.icon.size.sm} />\n+          ))}\n+      </StyledToggleButton>\n+\n+      {isExpandable && (\n+        <AnimatedExpandableContainer isExpanded={isExpanded}>\n+          <StyledContentContainer>\n+            {isStandardizedFormat ? (\n+              <>\n+                {hasError && <div>{extractErrorMessage(toolOutput.error)}</div>}\n+                {hasResult && (\n+                  <div>\n+                    <StyledPre>\n+                      {JSON.stringify(toolOutput.result, null, 2)}",
        "comment_created_at": "2025-09-17T07:22:37+00:00",
        "comment_author": "FelixMalfait",
        "comment_body": "This part is hard to read with the nesting and naming, toolOutput.result != toolResult.result? What does isStandardized mean? Try to be verbose and explicit, split your code, avoid nested ternaries ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2336965300",
    "pr_number": 14385,
    "pr_file": "packages/twenty-front/src/modules/object-record/record-board/record-board-column/components/RecordBoardColumnNewRecordButton.tsx",
    "created_at": "2025-09-10T14:28:23+00:00",
    "commented_code": "return null;\n   }\n \n+  if (hasAnySoftDeleteFitler === true) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2336965300",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14385,
        "pr_file": "packages/twenty-front/src/modules/object-record/record-board/record-board-column/components/RecordBoardColumnNewRecordButton.tsx",
        "discussion_id": "2336965300",
        "commented_code": "@@ -46,6 +49,10 @@ export const RecordBoardColumnNewRecordButton = () => {\n     return null;\n   }\n \n+  if (hasAnySoftDeleteFitler === true) {",
        "comment_created_at": "2025-09-10T14:28:23+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "no need to === for booleans",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2346050294",
    "pr_number": 14415,
    "pr_file": "packages/twenty-front/src/modules/settings/roles/components/SettingsRolesList.tsx",
    "created_at": "2025-09-13T08:12:29+00:00",
    "commented_code": "sortByAscString(a.label, b.label),\n   );\n \n-  const filteredRoles = useMemo(() => {\n-    return sortedSettingsAllRoles\n-      .filter((role) => {\n-        switch (activeTabId) {\n-          case ROLES_LIST_TABS.TABS_IDS.USER_ROLES:\n-            return role.canBeAssignedToUsers;\n-          case ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES:\n-            return role.canBeAssignedToAgents;\n-          case ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES:\n-            return role.canBeAssignedToApiKeys;\n-          default:\n-            return role.canBeAssignedToUsers;\n-        }\n-      })\n-      .filter((role) =>\n-        role.label?.toLowerCase().includes(searchTerm.toLowerCase()),\n-      );\n-  }, [sortedSettingsAllRoles, activeTabId, searchTerm]);\n+  const filteredRoles = sortedSettingsAllRoles.filter((role) => {\n+    let matchesTab = false;\n+\n+    if (activeTabId === ROLES_LIST_TABS.TABS_IDS.USER_ROLES) {\n+      matchesTab = role.canBeAssignedToUsers;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES) {\n+      matchesTab = role.canBeAssignedToAgents;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES) {\n+      matchesTab = role.canBeAssignedToApiKeys;\n+    } else {\n+      matchesTab = role.canBeAssignedToUsers;\n+    }",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2346050294",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14415,
        "pr_file": "packages/twenty-front/src/modules/settings/roles/components/SettingsRolesList.tsx",
        "discussion_id": "2346050294",
        "commented_code": "@@ -56,24 +56,23 @@ export const SettingsRolesList = () => {\n     sortByAscString(a.label, b.label),\n   );\n \n-  const filteredRoles = useMemo(() => {\n-    return sortedSettingsAllRoles\n-      .filter((role) => {\n-        switch (activeTabId) {\n-          case ROLES_LIST_TABS.TABS_IDS.USER_ROLES:\n-            return role.canBeAssignedToUsers;\n-          case ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES:\n-            return role.canBeAssignedToAgents;\n-          case ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES:\n-            return role.canBeAssignedToApiKeys;\n-          default:\n-            return role.canBeAssignedToUsers;\n-        }\n-      })\n-      .filter((role) =>\n-        role.label?.toLowerCase().includes(searchTerm.toLowerCase()),\n-      );\n-  }, [sortedSettingsAllRoles, activeTabId, searchTerm]);\n+  const filteredRoles = sortedSettingsAllRoles.filter((role) => {\n+    let matchesTab = false;\n+\n+    if (activeTabId === ROLES_LIST_TABS.TABS_IDS.USER_ROLES) {\n+      matchesTab = role.canBeAssignedToUsers;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES) {\n+      matchesTab = role.canBeAssignedToAgents;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES) {\n+      matchesTab = role.canBeAssignedToApiKeys;\n+    } else {\n+      matchesTab = role.canBeAssignedToUsers;\n+    }",
        "comment_created_at": "2025-09-13T08:12:29+00:00",
        "comment_author": "abdulrahmancodes",
        "comment_body": "@SaurabhJain708 Curious why you switched from switch-case to if-else here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2346510424",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14415,
        "pr_file": "packages/twenty-front/src/modules/settings/roles/components/SettingsRolesList.tsx",
        "discussion_id": "2346050294",
        "commented_code": "@@ -56,24 +56,23 @@ export const SettingsRolesList = () => {\n     sortByAscString(a.label, b.label),\n   );\n \n-  const filteredRoles = useMemo(() => {\n-    return sortedSettingsAllRoles\n-      .filter((role) => {\n-        switch (activeTabId) {\n-          case ROLES_LIST_TABS.TABS_IDS.USER_ROLES:\n-            return role.canBeAssignedToUsers;\n-          case ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES:\n-            return role.canBeAssignedToAgents;\n-          case ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES:\n-            return role.canBeAssignedToApiKeys;\n-          default:\n-            return role.canBeAssignedToUsers;\n-        }\n-      })\n-      .filter((role) =>\n-        role.label?.toLowerCase().includes(searchTerm.toLowerCase()),\n-      );\n-  }, [sortedSettingsAllRoles, activeTabId, searchTerm]);\n+  const filteredRoles = sortedSettingsAllRoles.filter((role) => {\n+    let matchesTab = false;\n+\n+    if (activeTabId === ROLES_LIST_TABS.TABS_IDS.USER_ROLES) {\n+      matchesTab = role.canBeAssignedToUsers;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES) {\n+      matchesTab = role.canBeAssignedToAgents;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES) {\n+      matchesTab = role.canBeAssignedToApiKeys;\n+    } else {\n+      matchesTab = role.canBeAssignedToUsers;\n+    }",
        "comment_created_at": "2025-09-13T12:14:17+00:00",
        "comment_author": "SaurabhJain708",
        "comment_body": "I initially wrote it with if/else while building the logic and forgot to refactor to switch-case. Since the behavior is identical, I left it as is, but I can update it to switch-case if that\u2019s preferred.",
        "pr_file_module": null
      },
      {
        "comment_id": "2346944886",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14415,
        "pr_file": "packages/twenty-front/src/modules/settings/roles/components/SettingsRolesList.tsx",
        "discussion_id": "2346050294",
        "commented_code": "@@ -56,24 +56,23 @@ export const SettingsRolesList = () => {\n     sortByAscString(a.label, b.label),\n   );\n \n-  const filteredRoles = useMemo(() => {\n-    return sortedSettingsAllRoles\n-      .filter((role) => {\n-        switch (activeTabId) {\n-          case ROLES_LIST_TABS.TABS_IDS.USER_ROLES:\n-            return role.canBeAssignedToUsers;\n-          case ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES:\n-            return role.canBeAssignedToAgents;\n-          case ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES:\n-            return role.canBeAssignedToApiKeys;\n-          default:\n-            return role.canBeAssignedToUsers;\n-        }\n-      })\n-      .filter((role) =>\n-        role.label?.toLowerCase().includes(searchTerm.toLowerCase()),\n-      );\n-  }, [sortedSettingsAllRoles, activeTabId, searchTerm]);\n+  const filteredRoles = sortedSettingsAllRoles.filter((role) => {\n+    let matchesTab = false;\n+\n+    if (activeTabId === ROLES_LIST_TABS.TABS_IDS.USER_ROLES) {\n+      matchesTab = role.canBeAssignedToUsers;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES) {\n+      matchesTab = role.canBeAssignedToAgents;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES) {\n+      matchesTab = role.canBeAssignedToApiKeys;\n+    } else {\n+      matchesTab = role.canBeAssignedToUsers;\n+    }",
        "comment_created_at": "2025-09-13T20:39:12+00:00",
        "comment_author": "abdulrahmancodes",
        "comment_body": "Yeah, would be great if you could use switch-case instead",
        "pr_file_module": null
      },
      {
        "comment_id": "2347052987",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14415,
        "pr_file": "packages/twenty-front/src/modules/settings/roles/components/SettingsRolesList.tsx",
        "discussion_id": "2346050294",
        "commented_code": "@@ -56,24 +56,23 @@ export const SettingsRolesList = () => {\n     sortByAscString(a.label, b.label),\n   );\n \n-  const filteredRoles = useMemo(() => {\n-    return sortedSettingsAllRoles\n-      .filter((role) => {\n-        switch (activeTabId) {\n-          case ROLES_LIST_TABS.TABS_IDS.USER_ROLES:\n-            return role.canBeAssignedToUsers;\n-          case ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES:\n-            return role.canBeAssignedToAgents;\n-          case ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES:\n-            return role.canBeAssignedToApiKeys;\n-          default:\n-            return role.canBeAssignedToUsers;\n-        }\n-      })\n-      .filter((role) =>\n-        role.label?.toLowerCase().includes(searchTerm.toLowerCase()),\n-      );\n-  }, [sortedSettingsAllRoles, activeTabId, searchTerm]);\n+  const filteredRoles = sortedSettingsAllRoles.filter((role) => {\n+    let matchesTab = false;\n+\n+    if (activeTabId === ROLES_LIST_TABS.TABS_IDS.USER_ROLES) {\n+      matchesTab = role.canBeAssignedToUsers;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.AGENT_ROLES) {\n+      matchesTab = role.canBeAssignedToAgents;\n+    } else if (activeTabId === ROLES_LIST_TABS.TABS_IDS.API_KEY_ROLES) {\n+      matchesTab = role.canBeAssignedToApiKeys;\n+    } else {\n+      matchesTab = role.canBeAssignedToUsers;\n+    }",
        "comment_created_at": "2025-09-14T01:10:37+00:00",
        "comment_author": "SaurabhJain708",
        "comment_body": "Done, I reverted back to switch case logic. Thanks a lot for review ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2330756189",
    "pr_number": 14055,
    "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
    "created_at": "2025-09-08T16:26:22+00:00",
    "commented_code": "// Do nothing, validation will happen on blur\n     }\n   };\n+  const resetBodyStateValue = (bodyTypeValue: BodyType) => {\n+    if (\n+      bodyTypeValue === BODY_TYPES.FORM_DATA ||",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2330756189",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2330756189",
        "commented_code": "@@ -93,15 +129,74 @@ export const BodyInput = ({\n       // Do nothing, validation will happen on blur\n     }\n   };\n+  const resetBodyStateValue = (bodyTypeValue: BodyType) => {\n+    if (\n+      bodyTypeValue === BODY_TYPES.FORM_DATA ||",
        "comment_created_at": "2025-09-08T16:26:22+00:00",
        "comment_author": "abdulrahmancodes",
        "comment_body": "nit: Maybe simplify the condition by grouping or using an array check for readability",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2337235626",
    "pr_number": 14386,
    "pr_file": "packages/twenty-front/src/modules/dashboards/widgets/graph/components/GraphWidgetLineChart.tsx",
    "created_at": "2025-09-10T16:04:21+00:00",
    "commented_code": "+import styled from '@emotion/styled';\n+import {\n+  ResponsiveLine,\n+  type LineSeries,\n+  type Point,\n+  type SliceTooltipProps,\n+} from '@nivo/line';\n+import { type ScaleLinearSpec, type ScaleSpec } from '@nivo/scales';\n+import { useId, useMemo } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type LineChartDataPoint = {\n+  x: number | string | Date;\n+  y: number | null;\n+  to?: string;\n+};\n+\n+type LineChartSeries = {\n+  id: string;\n+  label?: string;\n+  color?: GraphColor;\n+  data: LineChartDataPoint[];\n+  enableArea?: boolean;\n+};\n+\n+type GraphWidgetLineChartProps = {\n+  data: LineChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  enablePoints?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  enableArea?: boolean;\n+  stackedArea?: boolean;\n+  curve?:\n+    | 'linear'\n+    | 'monotoneX'\n+    | 'step'\n+    | 'stepBefore'\n+    | 'stepAfter'\n+    | 'natural';\n+  lineWidth?: number;\n+  enableSlices?: 'x' | 'y' | false;\n+  xScale?: ScaleSpec;\n+  yScale?: ScaleSpec;\n+} & GraphValueFormatOptions;\n+\n+const getYScaleWithStacking = (\n+  yScale: ScaleSpec | undefined,\n+  stackedArea: boolean | undefined,\n+): ScaleSpec => {\n+  if (!yScale || yScale.type === 'linear') {\n+    const linearScale: ScaleLinearSpec = {\n+      min: 0,\n+      max: 'auto',\n+      ...yScale,\n+      type: 'linear',\n+      stacked: stackedArea,\n+    };\n+    return linearScale;\n+  }\n+\n+  return yScale;\n+};\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g circle {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetLineChart = ({",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2337235626",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14386,
        "pr_file": "packages/twenty-front/src/modules/dashboards/widgets/graph/components/GraphWidgetLineChart.tsx",
        "discussion_id": "2337235626",
        "commented_code": "@@ -0,0 +1,372 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveLine,\n+  type LineSeries,\n+  type Point,\n+  type SliceTooltipProps,\n+} from '@nivo/line';\n+import { type ScaleLinearSpec, type ScaleSpec } from '@nivo/scales';\n+import { useId, useMemo } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type LineChartDataPoint = {\n+  x: number | string | Date;\n+  y: number | null;\n+  to?: string;\n+};\n+\n+type LineChartSeries = {\n+  id: string;\n+  label?: string;\n+  color?: GraphColor;\n+  data: LineChartDataPoint[];\n+  enableArea?: boolean;\n+};\n+\n+type GraphWidgetLineChartProps = {\n+  data: LineChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  enablePoints?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  enableArea?: boolean;\n+  stackedArea?: boolean;\n+  curve?:\n+    | 'linear'\n+    | 'monotoneX'\n+    | 'step'\n+    | 'stepBefore'\n+    | 'stepAfter'\n+    | 'natural';\n+  lineWidth?: number;\n+  enableSlices?: 'x' | 'y' | false;\n+  xScale?: ScaleSpec;\n+  yScale?: ScaleSpec;\n+} & GraphValueFormatOptions;\n+\n+const getYScaleWithStacking = (\n+  yScale: ScaleSpec | undefined,\n+  stackedArea: boolean | undefined,\n+): ScaleSpec => {\n+  if (!yScale || yScale.type === 'linear') {\n+    const linearScale: ScaleLinearSpec = {\n+      min: 0,\n+      max: 'auto',\n+      ...yScale,\n+      type: 'linear',\n+      stacked: stackedArea,\n+    };\n+    return linearScale;\n+  }\n+\n+  return yScale;\n+};\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g circle {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetLineChart = ({",
        "comment_created_at": "2025-09-10T16:04:21+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "I think that a lot of the computation done at the top of the component could be extracted in hooks/functions to make the component more readable. But this is also true for every other chart widget.\nMaybe something like `useLineChartData`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2337267569",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14386,
        "pr_file": "packages/twenty-front/src/modules/dashboards/widgets/graph/components/GraphWidgetLineChart.tsx",
        "discussion_id": "2337235626",
        "commented_code": "@@ -0,0 +1,372 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveLine,\n+  type LineSeries,\n+  type Point,\n+  type SliceTooltipProps,\n+} from '@nivo/line';\n+import { type ScaleLinearSpec, type ScaleSpec } from '@nivo/scales';\n+import { useId, useMemo } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type LineChartDataPoint = {\n+  x: number | string | Date;\n+  y: number | null;\n+  to?: string;\n+};\n+\n+type LineChartSeries = {\n+  id: string;\n+  label?: string;\n+  color?: GraphColor;\n+  data: LineChartDataPoint[];\n+  enableArea?: boolean;\n+};\n+\n+type GraphWidgetLineChartProps = {\n+  data: LineChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  enablePoints?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  enableArea?: boolean;\n+  stackedArea?: boolean;\n+  curve?:\n+    | 'linear'\n+    | 'monotoneX'\n+    | 'step'\n+    | 'stepBefore'\n+    | 'stepAfter'\n+    | 'natural';\n+  lineWidth?: number;\n+  enableSlices?: 'x' | 'y' | false;\n+  xScale?: ScaleSpec;\n+  yScale?: ScaleSpec;\n+} & GraphValueFormatOptions;\n+\n+const getYScaleWithStacking = (\n+  yScale: ScaleSpec | undefined,\n+  stackedArea: boolean | undefined,\n+): ScaleSpec => {\n+  if (!yScale || yScale.type === 'linear') {\n+    const linearScale: ScaleLinearSpec = {\n+      min: 0,\n+      max: 'auto',\n+      ...yScale,\n+      type: 'linear',\n+      stacked: stackedArea,\n+    };\n+    return linearScale;\n+  }\n+\n+  return yScale;\n+};\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g circle {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetLineChart = ({",
        "comment_created_at": "2025-09-10T16:18:35+00:00",
        "comment_author": "ehconitin",
        "comment_body": "I will raise a separate PR for this refactor to keep conflicts as low as possible for your work! I kept it in components since every component has its own way of displaying data -- but yes, we could definitely extract these into something like useLineChartData, useBarChartData, etc, and the utils in the same way too!\r\n\r\nCould definitely be improved! agree\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2339368929",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14386,
        "pr_file": "packages/twenty-front/src/modules/dashboards/widgets/graph/components/GraphWidgetLineChart.tsx",
        "discussion_id": "2337235626",
        "commented_code": "@@ -0,0 +1,372 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveLine,\n+  type LineSeries,\n+  type Point,\n+  type SliceTooltipProps,\n+} from '@nivo/line';\n+import { type ScaleLinearSpec, type ScaleSpec } from '@nivo/scales';\n+import { useId, useMemo } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type LineChartDataPoint = {\n+  x: number | string | Date;\n+  y: number | null;\n+  to?: string;\n+};\n+\n+type LineChartSeries = {\n+  id: string;\n+  label?: string;\n+  color?: GraphColor;\n+  data: LineChartDataPoint[];\n+  enableArea?: boolean;\n+};\n+\n+type GraphWidgetLineChartProps = {\n+  data: LineChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  enablePoints?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  enableArea?: boolean;\n+  stackedArea?: boolean;\n+  curve?:\n+    | 'linear'\n+    | 'monotoneX'\n+    | 'step'\n+    | 'stepBefore'\n+    | 'stepAfter'\n+    | 'natural';\n+  lineWidth?: number;\n+  enableSlices?: 'x' | 'y' | false;\n+  xScale?: ScaleSpec;\n+  yScale?: ScaleSpec;\n+} & GraphValueFormatOptions;\n+\n+const getYScaleWithStacking = (\n+  yScale: ScaleSpec | undefined,\n+  stackedArea: boolean | undefined,\n+): ScaleSpec => {\n+  if (!yScale || yScale.type === 'linear') {\n+    const linearScale: ScaleLinearSpec = {\n+      min: 0,\n+      max: 'auto',\n+      ...yScale,\n+      type: 'linear',\n+      stacked: stackedArea,\n+    };\n+    return linearScale;\n+  }\n+\n+  return yScale;\n+};\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g circle {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetLineChart = ({",
        "comment_created_at": "2025-09-11T08:18:09+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "Okay let's do that in a separate PR then",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2316681387",
    "pr_number": 14239,
    "pr_file": "packages/twenty-front/src/pages/settings/ai/forms/components/SettingsAIAgentForm.tsx",
    "created_at": "2025-09-02T17:04:07+00:00",
    "commented_code": "field: keyof SettingsAIAgentFormValues,\n     value: SettingsAIAgentFormValues[keyof SettingsAIAgentFormValues],\n   ) => void;\n+  disabled: boolean;\n };\n \n export const SettingsAIAgentForm = ({\n   formValues,\n   onFieldChange,\n+  disabled,\n }: SettingsAIAgentFormProps) => {\n   const { t } = useLingui();\n \n   const modelOptions = useAiModelOptions();\n   const { data: rolesData } = useGetRolesQuery();\n \n   const rolesOptions =\n-    rolesData?.getRoles?.map((role) => ({\n-      label: role.label,\n-      value: role.id,\n-    })) || [];\n+    rolesData?.getRoles?.reduce<Array<{ label: string; value: string }>>(\n+      (acc, role) => {\n+        if (role.canBeAssignedToAgents) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2316681387",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14239,
        "pr_file": "packages/twenty-front/src/pages/settings/ai/forms/components/SettingsAIAgentForm.tsx",
        "discussion_id": "2316681387",
        "commented_code": "@@ -39,22 +39,32 @@ type SettingsAIAgentFormProps = {\n     field: keyof SettingsAIAgentFormValues,\n     value: SettingsAIAgentFormValues[keyof SettingsAIAgentFormValues],\n   ) => void;\n+  disabled: boolean;\n };\n \n export const SettingsAIAgentForm = ({\n   formValues,\n   onFieldChange,\n+  disabled,\n }: SettingsAIAgentFormProps) => {\n   const { t } = useLingui();\n \n   const modelOptions = useAiModelOptions();\n   const { data: rolesData } = useGetRolesQuery();\n \n   const rolesOptions =\n-    rolesData?.getRoles?.map((role) => ({\n-      label: role.label,\n-      value: role.id,\n-    })) || [];\n+    rolesData?.getRoles?.reduce<Array<{ label: string; value: string }>>(\n+      (acc, role) => {\n+        if (role.canBeAssignedToAgents) {",
        "comment_created_at": "2025-09-02T17:04:07+00:00",
        "comment_author": "FelixMalfait",
        "comment_body": "Prefer early returns to condition nesting",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2318315603",
    "pr_number": 14251,
    "pr_file": "packages/twenty-front/src/modules/command-menu/pages/page-layout/components/CommandMenuPageLayoutWidgetTypeSelect.tsx",
    "created_at": "2025-09-03T09:06:49+00:00",
    "commented_code": "pageTitle: 'Select Graph Type',\n         pageIcon: IconChartPie,\n       });\n+    } else if (widgetType === WidgetType.IFRAME) {\n+      navigateCommandMenu({\n+        page: CommandMenuPages.PageLayoutIframeConfig,\n+        pageTitle: 'Configure iFrame',\n+        pageIcon: IconFrame,\n+      });",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2318315603",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14251,
        "pr_file": "packages/twenty-front/src/modules/command-menu/pages/page-layout/components/CommandMenuPageLayoutWidgetTypeSelect.tsx",
        "discussion_id": "2318315603",
        "commented_code": "@@ -62,6 +62,12 @@ export const CommandMenuPageLayoutWidgetTypeSelect = () => {\n         pageTitle: 'Select Graph Type',\n         pageIcon: IconChartPie,\n       });\n+    } else if (widgetType === WidgetType.IFRAME) {\n+      navigateCommandMenu({\n+        page: CommandMenuPages.PageLayoutIframeConfig,\n+        pageTitle: 'Configure iFrame',\n+        pageIcon: IconFrame,\n+      });",
        "comment_created_at": "2025-09-03T09:06:49+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "Use a switch statement instead:\n\n```\nswitch (widgetType) {\n      case WidgetType.GRAPH:\n        navigateCommandMenu({\n          page: CommandMenuPages.PageLayoutGraphTypeSelect,\n          pageTitle: 'Select Graph Type',\n          pageIcon: IconChartPie,\n        });\n        break;\n      case WidgetType.IFRAME:\n        navigateCommandMenu({\n          page: CommandMenuPages.PageLayoutIframeConfig,\n          pageTitle: 'Configure iFrame',\n          pageIcon: IconFrame,\n        });\n        break;\n      default:\n        setPageLayoutDraggedArea(null);\n        break;\n    }\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2307591361",
    "pr_number": 14052,
    "pr_file": "packages/twenty-front/src/modules/dashboards/graphs/components/GraphWidgetBarChart.tsx",
    "created_at": "2025-08-28T14:27:31+00:00",
    "commented_code": "+import styled from '@emotion/styled';\n+import {\n+  ResponsiveBar,\n+  type BarCustomLayerProps,\n+  type BarDatum,\n+  type ComputedBarDatum,\n+  type ComputedDatum,\n+} from '@nivo/bar';\n+import { useId, useMemo, useState } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { type GraphColorScheme } from '../types/GraphColorScheme';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type BarChartDataItem = BarDatum & {\n+  to?: string;\n+};\n+\n+type BarChartSeries = {\n+  key: string;\n+  label?: string;\n+  color?: GraphColor;\n+};\n+\n+type GraphWidgetBarChartProps = {\n+  data: BarChartDataItem[];\n+  indexBy: string;\n+  keys: string[];\n+  series?: BarChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  showValues?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  layout?: 'vertical' | 'horizontal';\n+  groupMode?: 'grouped' | 'stacked';\n+  seriesLabels?: Record<string, string>;\n+} & GraphValueFormatOptions;\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g[transform] rect[fill^=\"url(#gradient-\"] {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetBarChart = ({\n+  data,\n+  indexBy,\n+  keys,\n+  series,\n+  showLegend = true,\n+  showGrid = true,\n+  showValues = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  layout = 'vertical',\n+  groupMode = 'grouped',\n+  seriesLabels,\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetBarChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+  const [hoveredBar, setHoveredBar] = useState<{\n+    key: string;\n+    indexValue: string | number;\n+  } | null>(null);\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const barConfigs = useMemo(() => {\n+    const configs: Array<{\n+      key: string;\n+      indexValue: string | number;\n+      gradientId: string;\n+      colorScheme: GraphColorScheme;\n+      isHovered: boolean;\n+    }> = [];\n+\n+    data.forEach((dataPoint, dataIndex) => {\n+      const indexValue = dataPoint[indexBy];\n+      keys.forEach((key, keyIndex) => {\n+        const seriesConfig = series?.find((s) => s.key === key);\n+        const colorScheme = getColorScheme(\n+          colorRegistry,\n+          seriesConfig?.color,\n+          keyIndex,\n+        );\n+        const isHovered =\n+          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n+        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n+\n+        configs.push({\n+          key,\n+          indexValue,\n+          gradientId,\n+          colorScheme,\n+          isHovered,\n+        });\n+      });\n+    });\n+\n+    return configs;\n+  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2307591361",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14052,
        "pr_file": "packages/twenty-front/src/modules/dashboards/graphs/components/GraphWidgetBarChart.tsx",
        "discussion_id": "2307591361",
        "commented_code": "@@ -0,0 +1,406 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveBar,\n+  type BarCustomLayerProps,\n+  type BarDatum,\n+  type ComputedBarDatum,\n+  type ComputedDatum,\n+} from '@nivo/bar';\n+import { useId, useMemo, useState } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { type GraphColorScheme } from '../types/GraphColorScheme';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type BarChartDataItem = BarDatum & {\n+  to?: string;\n+};\n+\n+type BarChartSeries = {\n+  key: string;\n+  label?: string;\n+  color?: GraphColor;\n+};\n+\n+type GraphWidgetBarChartProps = {\n+  data: BarChartDataItem[];\n+  indexBy: string;\n+  keys: string[];\n+  series?: BarChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  showValues?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  layout?: 'vertical' | 'horizontal';\n+  groupMode?: 'grouped' | 'stacked';\n+  seriesLabels?: Record<string, string>;\n+} & GraphValueFormatOptions;\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g[transform] rect[fill^=\"url(#gradient-\"] {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetBarChart = ({\n+  data,\n+  indexBy,\n+  keys,\n+  series,\n+  showLegend = true,\n+  showGrid = true,\n+  showValues = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  layout = 'vertical',\n+  groupMode = 'grouped',\n+  seriesLabels,\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetBarChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+  const [hoveredBar, setHoveredBar] = useState<{\n+    key: string;\n+    indexValue: string | number;\n+  } | null>(null);\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const barConfigs = useMemo(() => {\n+    const configs: Array<{\n+      key: string;\n+      indexValue: string | number;\n+      gradientId: string;\n+      colorScheme: GraphColorScheme;\n+      isHovered: boolean;\n+    }> = [];\n+\n+    data.forEach((dataPoint, dataIndex) => {\n+      const indexValue = dataPoint[indexBy];\n+      keys.forEach((key, keyIndex) => {\n+        const seriesConfig = series?.find((s) => s.key === key);\n+        const colorScheme = getColorScheme(\n+          colorRegistry,\n+          seriesConfig?.color,\n+          keyIndex,\n+        );\n+        const isHovered =\n+          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n+        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n+\n+        configs.push({\n+          key,\n+          indexValue,\n+          gradientId,\n+          colorScheme,\n+          isHovered,\n+        });\n+      });\n+    });\n+\n+    return configs;\n+  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);",
        "comment_created_at": "2025-08-28T14:27:31+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "You could use flatmap here instead of nested forEach for better readability:\n\n\n```suggestion\n   const barConfigs = useMemo((): BarConfig[] => {\n    return data.flatMap((dataPoint, dataIndex) => {\n      const indexValue = dataPoint[indexBy];\n      return keys.map((key, keyIndex): BarConfig => {\n        const seriesConfig = series?.find((s) => s.key === key);\n        const colorScheme = getColorScheme(\n          colorRegistry,\n          seriesConfig?.color,\n          keyIndex,\n        );\n        const isHovered =\n          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n\n        return {\n          key,\n          indexValue,\n          gradientId,\n          colorScheme,\n          isHovered,\n        };\n      });\n    });\n  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2307597144",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14052,
        "pr_file": "packages/twenty-front/src/modules/dashboards/graphs/components/GraphWidgetBarChart.tsx",
        "discussion_id": "2307591361",
        "commented_code": "@@ -0,0 +1,406 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveBar,\n+  type BarCustomLayerProps,\n+  type BarDatum,\n+  type ComputedBarDatum,\n+  type ComputedDatum,\n+} from '@nivo/bar';\n+import { useId, useMemo, useState } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { type GraphColorScheme } from '../types/GraphColorScheme';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type BarChartDataItem = BarDatum & {\n+  to?: string;\n+};\n+\n+type BarChartSeries = {\n+  key: string;\n+  label?: string;\n+  color?: GraphColor;\n+};\n+\n+type GraphWidgetBarChartProps = {\n+  data: BarChartDataItem[];\n+  indexBy: string;\n+  keys: string[];\n+  series?: BarChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  showValues?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  layout?: 'vertical' | 'horizontal';\n+  groupMode?: 'grouped' | 'stacked';\n+  seriesLabels?: Record<string, string>;\n+} & GraphValueFormatOptions;\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g[transform] rect[fill^=\"url(#gradient-\"] {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetBarChart = ({\n+  data,\n+  indexBy,\n+  keys,\n+  series,\n+  showLegend = true,\n+  showGrid = true,\n+  showValues = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  layout = 'vertical',\n+  groupMode = 'grouped',\n+  seriesLabels,\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetBarChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+  const [hoveredBar, setHoveredBar] = useState<{\n+    key: string;\n+    indexValue: string | number;\n+  } | null>(null);\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const barConfigs = useMemo(() => {\n+    const configs: Array<{\n+      key: string;\n+      indexValue: string | number;\n+      gradientId: string;\n+      colorScheme: GraphColorScheme;\n+      isHovered: boolean;\n+    }> = [];\n+\n+    data.forEach((dataPoint, dataIndex) => {\n+      const indexValue = dataPoint[indexBy];\n+      keys.forEach((key, keyIndex) => {\n+        const seriesConfig = series?.find((s) => s.key === key);\n+        const colorScheme = getColorScheme(\n+          colorRegistry,\n+          seriesConfig?.color,\n+          keyIndex,\n+        );\n+        const isHovered =\n+          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n+        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n+\n+        configs.push({\n+          key,\n+          indexValue,\n+          gradientId,\n+          colorScheme,\n+          isHovered,\n+        });\n+      });\n+    });\n+\n+    return configs;\n+  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);",
        "comment_created_at": "2025-08-28T14:29:29+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "We can also create a type for BarConfig:\n\n```\ntype BarConfig = {\n  key: string;\n  indexValue: string | number;\n  gradientId: string;\n  colorScheme: GraphColorScheme;\n  isHovered: boolean;\n};\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2307616104",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14052,
        "pr_file": "packages/twenty-front/src/modules/dashboards/graphs/components/GraphWidgetBarChart.tsx",
        "discussion_id": "2307591361",
        "commented_code": "@@ -0,0 +1,406 @@\n+import styled from '@emotion/styled';\n+import {\n+  ResponsiveBar,\n+  type BarCustomLayerProps,\n+  type BarDatum,\n+  type ComputedBarDatum,\n+  type ComputedDatum,\n+} from '@nivo/bar';\n+import { useId, useMemo, useState } from 'react';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { useTheme } from '@emotion/react';\n+import { type GraphColor } from '../types/GraphColor';\n+import { type GraphColorScheme } from '../types/GraphColorScheme';\n+import { createGradientDef } from '../utils/createGradientDef';\n+import { createGraphColorRegistry } from '../utils/createGraphColorRegistry';\n+import { getColorScheme } from '../utils/getColorScheme';\n+import {\n+  formatGraphValue,\n+  type GraphValueFormatOptions,\n+} from '../utils/graphFormatters';\n+import { GraphWidgetLegend } from './GraphWidgetLegend';\n+import { GraphWidgetTooltip } from './GraphWidgetTooltip';\n+\n+type BarChartDataItem = BarDatum & {\n+  to?: string;\n+};\n+\n+type BarChartSeries = {\n+  key: string;\n+  label?: string;\n+  color?: GraphColor;\n+};\n+\n+type GraphWidgetBarChartProps = {\n+  data: BarChartDataItem[];\n+  indexBy: string;\n+  keys: string[];\n+  series?: BarChartSeries[];\n+  showLegend?: boolean;\n+  showGrid?: boolean;\n+  showValues?: boolean;\n+  xAxisLabel?: string;\n+  yAxisLabel?: string;\n+  id: string;\n+  layout?: 'vertical' | 'horizontal';\n+  groupMode?: 'grouped' | 'stacked';\n+  seriesLabels?: Record<string, string>;\n+} & GraphValueFormatOptions;\n+\n+const StyledContainer = styled.div`\n+  align-items: center;\n+  display: flex;\n+  flex-direction: column;\n+  height: 100%;\n+  justify-content: center;\n+  width: 100%;\n+`;\n+\n+const StyledChartContainer = styled.div<{ $isClickable?: boolean }>`\n+  flex: 1;\n+  position: relative;\n+  width: 100%;\n+\n+  ${({ $isClickable }) =>\n+    $isClickable &&\n+    `\n+    svg g[transform] rect[fill^=\"url(#gradient-\"] {\n+      cursor: pointer;\n+    }\n+  `}\n+`;\n+\n+export const GraphWidgetBarChart = ({\n+  data,\n+  indexBy,\n+  keys,\n+  series,\n+  showLegend = true,\n+  showGrid = true,\n+  showValues = false,\n+  xAxisLabel,\n+  yAxisLabel,\n+  id,\n+  layout = 'vertical',\n+  groupMode = 'grouped',\n+  seriesLabels,\n+  displayType,\n+  decimals,\n+  prefix,\n+  suffix,\n+  customFormatter,\n+}: GraphWidgetBarChartProps) => {\n+  const theme = useTheme();\n+  const instanceId = useId();\n+  const [hoveredBar, setHoveredBar] = useState<{\n+    key: string;\n+    indexValue: string | number;\n+  } | null>(null);\n+\n+  const colorRegistry = createGraphColorRegistry(theme);\n+\n+  const formatOptions: GraphValueFormatOptions = {\n+    displayType,\n+    decimals,\n+    prefix,\n+    suffix,\n+    customFormatter,\n+  };\n+\n+  const barConfigs = useMemo(() => {\n+    const configs: Array<{\n+      key: string;\n+      indexValue: string | number;\n+      gradientId: string;\n+      colorScheme: GraphColorScheme;\n+      isHovered: boolean;\n+    }> = [];\n+\n+    data.forEach((dataPoint, dataIndex) => {\n+      const indexValue = dataPoint[indexBy];\n+      keys.forEach((key, keyIndex) => {\n+        const seriesConfig = series?.find((s) => s.key === key);\n+        const colorScheme = getColorScheme(\n+          colorRegistry,\n+          seriesConfig?.color,\n+          keyIndex,\n+        );\n+        const isHovered =\n+          hoveredBar?.key === key && hoveredBar?.indexValue === indexValue;\n+        const gradientId = `gradient-${id}-${instanceId}-${key}-${dataIndex}-${keyIndex}`;\n+\n+        configs.push({\n+          key,\n+          indexValue,\n+          gradientId,\n+          colorScheme,\n+          isHovered,\n+        });\n+      });\n+    });\n+\n+    return configs;\n+  }, [data, indexBy, keys, colorRegistry, hoveredBar, id, instanceId, series]);",
        "comment_created_at": "2025-08-28T14:36:00+00:00",
        "comment_author": "bosiraphael",
        "comment_body": "I think we don't need `isHovered` inside the BarConfig, it retriggers  the computation of the barConfigs every time the hovered state changes, we could just check `hoveredBar?.key === bar.key` instead of `bar.isHovered`",
        "pr_file_module": null
      }
    ]
  }
]