[
  {
    "discussion_id": "2349142274",
    "pr_number": 14414,
    "pr_file": "packages/twenty-server/src/engine/metadata-modules/agent/agent-execution.service.ts",
    "created_at": "2025-09-15T14:11:03+00:00",
    "commented_code": "}\n   }\n \n+  private mapMessagesToCoreMessages(\n+    messages: AgentChatMessageEntity[],\n+  ): CoreMessage[] {\n+    return messages\n+      .map(({ role, streamData, content }) => {\n+        if (role === AgentChatMessageRole.USER) {\n+          return {\n+            role: 'user' as const,\n+            content,\n+          };\n+        } else {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2349142274",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14414,
        "pr_file": "packages/twenty-server/src/engine/metadata-modules/agent/agent-execution.service.ts",
        "discussion_id": "2349142274",
        "commented_code": "@@ -250,6 +261,28 @@ export class AgentExecutionService {\n     }\n   }\n \n+  private mapMessagesToCoreMessages(\n+    messages: AgentChatMessageEntity[],\n+  ): CoreMessage[] {\n+    return messages\n+      .map(({ role, streamData, content }) => {\n+        if (role === AgentChatMessageRole.USER) {\n+          return {\n+            role: 'user' as const,\n+            content,\n+          };\n+        } else {",
        "comment_created_at": "2025-09-15T14:11:03+00:00",
        "comment_author": "FelixMalfait",
        "comment_body": "nit: avoid if/else structure which are harder to read, here you do a return so the else can just be removed ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2352592549",
    "pr_number": 14530,
    "pr_file": "packages/twenty-server/src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/group-by-input/object-metadata-group-by-gql-input-type.generator.ts",
    "created_at": "2025-09-16T13:51:20+00:00",
    "commented_code": "+import { Injectable, Logger } from '@nestjs/common';\n+\n+import {\n+  GraphQLBoolean,\n+  GraphQLInputFieldConfigMap,\n+  GraphQLInputObjectType,\n+  isInputObjectType,\n+} from 'graphql';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { GqlInputTypeDefinitionKind } from 'src/engine/api/graphql/workspace-schema-builder/enums/gql-input-type-definition-kind.enum';\n+import { RelationFieldMetadataGqlInputTypeGenerator } from 'src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/relation-field-metadata-gql-type.generator';\n+import { TypeMapperService } from 'src/engine/api/graphql/workspace-schema-builder/services/type-mapper.service';\n+import { GqlTypesStorage } from 'src/engine/api/graphql/workspace-schema-builder/storages/gql-types.storage';\n+import { computeCompositeFieldInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-composite-field-input-type-key.util';\n+import { computeObjectMetadataInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-object-metadata-input-type.util';\n+import { isFieldMetadataRelationOrMorphRelation } from 'src/engine/api/graphql/workspace-schema-builder/utils/is-field-metadata-relation-or-morph-relation.utils';\n+import { FieldMetadataEntity } from 'src/engine/metadata-modules/field-metadata/field-metadata.entity';\n+import { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\n+import { ObjectMetadataEntity } from 'src/engine/metadata-modules/object-metadata/object-metadata.entity';\n+import { pascalCase } from 'src/utils/pascal-case';\n+\n+@Injectable()\n+export class ObjectMetadataGroupByGqlInputTypeGenerator {\n+  private readonly logger = new Logger(\n+    ObjectMetadataGroupByGqlInputTypeGenerator.name,\n+  );\n+  constructor(\n+    private readonly gqlTypesStorage: GqlTypesStorage,\n+    private readonly relationFieldMetadataGqlInputTypeGenerator: RelationFieldMetadataGqlInputTypeGenerator,\n+    private readonly typeMapperService: TypeMapperService,\n+  ) {}\n+\n+  public buildAndStore(objectMetadata: ObjectMetadataEntity) {\n+    const inputType = new GraphQLInputObjectType({\n+      name: `${pascalCase(objectMetadata.nameSingular)}${GqlInputTypeDefinitionKind.GroupBy.toString()}Input`,\n+      description: objectMetadata.description,\n+      fields: () => this.generateFields(objectMetadata),\n+    }) as GraphQLInputObjectType;\n+\n+    const key = computeObjectMetadataInputTypeKey(\n+      objectMetadata.nameSingular,\n+      GqlInputTypeDefinitionKind.GroupBy,\n+    );\n+\n+    this.gqlTypesStorage.addGqlType(key, inputType);\n+  }\n+\n+  private generateFields(\n+    objectMetadata: ObjectMetadataEntity,\n+  ): GraphQLInputFieldConfigMap {\n+    const allGeneratedFields: GraphQLInputFieldConfigMap = {};\n+\n+    for (const fieldMetadata of objectMetadata.fields) {\n+      const generatedField = isFieldMetadataRelationOrMorphRelation(\n+        fieldMetadata,\n+      )\n+        ? this.relationFieldMetadataGqlInputTypeGenerator.generateSimpleRelationFieldGroupByInputType(\n+            fieldMetadata,\n+          )\n+        : this.generateField(fieldMetadata);\n+\n+      Object.assign(allGeneratedFields, generatedField);\n+    }\n+\n+    return allGeneratedFields;\n+  }\n+\n+  private generateField(fieldMetadata: FieldMetadataEntity) {\n+    let type: GraphQLInputObjectType | typeof GraphQLBoolean | undefined;\n+\n+    if (isCompositeFieldMetadataType(fieldMetadata.type)) {\n+      const key = computeCompositeFieldInputTypeKey(\n+        fieldMetadata.type,\n+        GqlInputTypeDefinitionKind.GroupBy,\n+      );\n+\n+      const compositeType = this.gqlTypesStorage.getGqlTypeByKey(key);\n+\n+      if (!isDefined(compositeType) || !isInputObjectType(compositeType)) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2352592549",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14530,
        "pr_file": "packages/twenty-server/src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/group-by-input/object-metadata-group-by-gql-input-type.generator.ts",
        "discussion_id": "2352592549",
        "commented_code": "@@ -0,0 +1,101 @@\n+import { Injectable, Logger } from '@nestjs/common';\n+\n+import {\n+  GraphQLBoolean,\n+  GraphQLInputFieldConfigMap,\n+  GraphQLInputObjectType,\n+  isInputObjectType,\n+} from 'graphql';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { GqlInputTypeDefinitionKind } from 'src/engine/api/graphql/workspace-schema-builder/enums/gql-input-type-definition-kind.enum';\n+import { RelationFieldMetadataGqlInputTypeGenerator } from 'src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/relation-field-metadata-gql-type.generator';\n+import { TypeMapperService } from 'src/engine/api/graphql/workspace-schema-builder/services/type-mapper.service';\n+import { GqlTypesStorage } from 'src/engine/api/graphql/workspace-schema-builder/storages/gql-types.storage';\n+import { computeCompositeFieldInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-composite-field-input-type-key.util';\n+import { computeObjectMetadataInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-object-metadata-input-type.util';\n+import { isFieldMetadataRelationOrMorphRelation } from 'src/engine/api/graphql/workspace-schema-builder/utils/is-field-metadata-relation-or-morph-relation.utils';\n+import { FieldMetadataEntity } from 'src/engine/metadata-modules/field-metadata/field-metadata.entity';\n+import { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\n+import { ObjectMetadataEntity } from 'src/engine/metadata-modules/object-metadata/object-metadata.entity';\n+import { pascalCase } from 'src/utils/pascal-case';\n+\n+@Injectable()\n+export class ObjectMetadataGroupByGqlInputTypeGenerator {\n+  private readonly logger = new Logger(\n+    ObjectMetadataGroupByGqlInputTypeGenerator.name,\n+  );\n+  constructor(\n+    private readonly gqlTypesStorage: GqlTypesStorage,\n+    private readonly relationFieldMetadataGqlInputTypeGenerator: RelationFieldMetadataGqlInputTypeGenerator,\n+    private readonly typeMapperService: TypeMapperService,\n+  ) {}\n+\n+  public buildAndStore(objectMetadata: ObjectMetadataEntity) {\n+    const inputType = new GraphQLInputObjectType({\n+      name: `${pascalCase(objectMetadata.nameSingular)}${GqlInputTypeDefinitionKind.GroupBy.toString()}Input`,\n+      description: objectMetadata.description,\n+      fields: () => this.generateFields(objectMetadata),\n+    }) as GraphQLInputObjectType;\n+\n+    const key = computeObjectMetadataInputTypeKey(\n+      objectMetadata.nameSingular,\n+      GqlInputTypeDefinitionKind.GroupBy,\n+    );\n+\n+    this.gqlTypesStorage.addGqlType(key, inputType);\n+  }\n+\n+  private generateFields(\n+    objectMetadata: ObjectMetadataEntity,\n+  ): GraphQLInputFieldConfigMap {\n+    const allGeneratedFields: GraphQLInputFieldConfigMap = {};\n+\n+    for (const fieldMetadata of objectMetadata.fields) {\n+      const generatedField = isFieldMetadataRelationOrMorphRelation(\n+        fieldMetadata,\n+      )\n+        ? this.relationFieldMetadataGqlInputTypeGenerator.generateSimpleRelationFieldGroupByInputType(\n+            fieldMetadata,\n+          )\n+        : this.generateField(fieldMetadata);\n+\n+      Object.assign(allGeneratedFields, generatedField);\n+    }\n+\n+    return allGeneratedFields;\n+  }\n+\n+  private generateField(fieldMetadata: FieldMetadataEntity) {\n+    let type: GraphQLInputObjectType | typeof GraphQLBoolean | undefined;\n+\n+    if (isCompositeFieldMetadataType(fieldMetadata.type)) {\n+      const key = computeCompositeFieldInputTypeKey(\n+        fieldMetadata.type,\n+        GqlInputTypeDefinitionKind.GroupBy,\n+      );\n+\n+      const compositeType = this.gqlTypesStorage.getGqlTypeByKey(key);\n+\n+      if (!isDefined(compositeType) || !isInputObjectType(compositeType)) {",
        "comment_created_at": "2025-09-16T13:51:20+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "polish: use early return and subfunctions",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2348753040",
    "pr_number": 14426,
    "pr_file": "packages/twenty-server/src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/create-input/object-metadata-create-gql-input-type.generator.ts",
    "created_at": "2025-09-15T11:51:55+00:00",
    "commented_code": "+import { Injectable, Logger } from '@nestjs/common';\n+\n+import { isDefined } from 'class-validator';\n+import {\n+  GraphQLEnumType,\n+  GraphQLInputFieldConfigMap,\n+  GraphQLInputObjectType,\n+  GraphQLScalarType,\n+  isEnumType,\n+  isInputObjectType,\n+  isObjectType,\n+} from 'graphql';\n+\n+import { GqlInputTypeDefinitionKind } from 'src/engine/api/graphql/workspace-schema-builder/enums/gql-input-type-definition-kind.enum';\n+import { RelationFieldMetadataGqlInputTypeGenerator } from 'src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/relation-field-metadata-gql-type.generator';\n+import { TypeMapperService } from 'src/engine/api/graphql/workspace-schema-builder/services/type-mapper.service';\n+import { GqlTypesStorage } from 'src/engine/api/graphql/workspace-schema-builder/storages/gql-types.storage';\n+import { computeFieldInputTypeOptions } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-field-input-type-options.util';\n+import { computeCompositeFieldInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-composite-field-input-type-key.util';\n+import { computeEnumFieldGqlTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-enum-field-gql-type-key.util';\n+import { computeObjectMetadataInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-object-metadata-input-type.util';\n+import { isFieldMetadataRelationOrMorphRelation } from 'src/engine/api/graphql/workspace-schema-builder/utils/is-field-metadata-relation-or-morph-relation.utils';\n+import { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\n+import { isEnumFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-enum-field-metadata-type.util';\n+import { ObjectMetadataEntity } from 'src/engine/metadata-modules/object-metadata/object-metadata.entity';\n+import { pascalCase } from 'src/utils/pascal-case';\n+\n+@Injectable()\n+export class ObjectMetadataCreateGqlInputTypeGenerator {\n+  private readonly logger = new Logger(\n+    ObjectMetadataCreateGqlInputTypeGenerator.name,\n+  );\n+  constructor(\n+    private readonly gqlTypesStorage: GqlTypesStorage,\n+    private readonly relationFieldMetadataGqlInputTypeGenerator: RelationFieldMetadataGqlInputTypeGenerator,\n+    private readonly typeMapperService: TypeMapperService,\n+  ) {}\n+\n+  public buildAndStore(objectMetadata: ObjectMetadataEntity) {\n+    const inputType = new GraphQLInputObjectType({\n+      name: `${pascalCase(objectMetadata.nameSingular)}${GqlInputTypeDefinitionKind.Create.toString()}Input`,\n+      description: objectMetadata.description,\n+      fields: () => this.generateFields(objectMetadata),\n+    }) as GraphQLInputObjectType;\n+\n+    const key = computeObjectMetadataInputTypeKey(\n+      objectMetadata.nameSingular,\n+      GqlInputTypeDefinitionKind.Create,\n+    );\n+\n+    this.gqlTypesStorage.addGqlType(key, inputType);\n+  }\n+\n+  private generateFields(\n+    objectMetadata: ObjectMetadataEntity,\n+  ): GraphQLInputFieldConfigMap {\n+    const allGeneratedFields: GraphQLInputFieldConfigMap = {};\n+\n+    for (const fieldMetadata of objectMetadata.fields) {\n+      const typeOptions = computeFieldInputTypeOptions(\n+        fieldMetadata,\n+        GqlInputTypeDefinitionKind.Create,\n+      );\n+\n+      let generatedFields;\n+\n+      if (isFieldMetadataRelationOrMorphRelation(fieldMetadata)) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2348753040",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14426,
        "pr_file": "packages/twenty-server/src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/create-input/object-metadata-create-gql-input-type.generator.ts",
        "discussion_id": "2348753040",
        "commented_code": "@@ -0,0 +1,155 @@\n+import { Injectable, Logger } from '@nestjs/common';\n+\n+import { isDefined } from 'class-validator';\n+import {\n+  GraphQLEnumType,\n+  GraphQLInputFieldConfigMap,\n+  GraphQLInputObjectType,\n+  GraphQLScalarType,\n+  isEnumType,\n+  isInputObjectType,\n+  isObjectType,\n+} from 'graphql';\n+\n+import { GqlInputTypeDefinitionKind } from 'src/engine/api/graphql/workspace-schema-builder/enums/gql-input-type-definition-kind.enum';\n+import { RelationFieldMetadataGqlInputTypeGenerator } from 'src/engine/api/graphql/workspace-schema-builder/graphql-type-generators/input-types/relation-field-metadata-gql-type.generator';\n+import { TypeMapperService } from 'src/engine/api/graphql/workspace-schema-builder/services/type-mapper.service';\n+import { GqlTypesStorage } from 'src/engine/api/graphql/workspace-schema-builder/storages/gql-types.storage';\n+import { computeFieldInputTypeOptions } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-field-input-type-options.util';\n+import { computeCompositeFieldInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-composite-field-input-type-key.util';\n+import { computeEnumFieldGqlTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-enum-field-gql-type-key.util';\n+import { computeObjectMetadataInputTypeKey } from 'src/engine/api/graphql/workspace-schema-builder/utils/compute-stored-gql-type-key-utils/compute-object-metadata-input-type.util';\n+import { isFieldMetadataRelationOrMorphRelation } from 'src/engine/api/graphql/workspace-schema-builder/utils/is-field-metadata-relation-or-morph-relation.utils';\n+import { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\n+import { isEnumFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-enum-field-metadata-type.util';\n+import { ObjectMetadataEntity } from 'src/engine/metadata-modules/object-metadata/object-metadata.entity';\n+import { pascalCase } from 'src/utils/pascal-case';\n+\n+@Injectable()\n+export class ObjectMetadataCreateGqlInputTypeGenerator {\n+  private readonly logger = new Logger(\n+    ObjectMetadataCreateGqlInputTypeGenerator.name,\n+  );\n+  constructor(\n+    private readonly gqlTypesStorage: GqlTypesStorage,\n+    private readonly relationFieldMetadataGqlInputTypeGenerator: RelationFieldMetadataGqlInputTypeGenerator,\n+    private readonly typeMapperService: TypeMapperService,\n+  ) {}\n+\n+  public buildAndStore(objectMetadata: ObjectMetadataEntity) {\n+    const inputType = new GraphQLInputObjectType({\n+      name: `${pascalCase(objectMetadata.nameSingular)}${GqlInputTypeDefinitionKind.Create.toString()}Input`,\n+      description: objectMetadata.description,\n+      fields: () => this.generateFields(objectMetadata),\n+    }) as GraphQLInputObjectType;\n+\n+    const key = computeObjectMetadataInputTypeKey(\n+      objectMetadata.nameSingular,\n+      GqlInputTypeDefinitionKind.Create,\n+    );\n+\n+    this.gqlTypesStorage.addGqlType(key, inputType);\n+  }\n+\n+  private generateFields(\n+    objectMetadata: ObjectMetadataEntity,\n+  ): GraphQLInputFieldConfigMap {\n+    const allGeneratedFields: GraphQLInputFieldConfigMap = {};\n+\n+    for (const fieldMetadata of objectMetadata.fields) {\n+      const typeOptions = computeFieldInputTypeOptions(\n+        fieldMetadata,\n+        GqlInputTypeDefinitionKind.Create,\n+      );\n+\n+      let generatedFields;\n+\n+      if (isFieldMetadataRelationOrMorphRelation(fieldMetadata)) {",
        "comment_created_at": "2025-09-15T11:51:55+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "this could be refactored in a simpler way with early returns of sub function (let avoid if else + let)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2319022278",
    "pr_number": 14202,
    "pr_file": "packages/twenty-server/src/engine/metadata-modules/field-metadata/services/field-metadata-related-records.service.ts",
    "created_at": "2025-09-03T13:40:48+00:00",
    "commented_code": "return differences;\n   }\n \n-  private async getFieldMetadataViewWithRelation(\n-    fieldMetadata: SelectOrMultiSelectFieldMetadataEntity,\n-    relation: keyof Pick<ViewWorkspaceEntity, 'viewGroups' | 'viewFilters'>,\n-  ): Promise<ViewWorkspaceEntity[]> {\n-    const viewRepository =\n-      await this.twentyORMGlobalManager.getRepositoryForWorkspace<ViewWorkspaceEntity>(\n-        fieldMetadata.workspaceId,\n-        'view',\n-      );\n-\n-    return viewRepository.find({\n-      where: {\n-        [relation]: {\n-          fieldMetadataId: fieldMetadata.id,\n-        },\n-      },\n-      relations: [relation],\n-    });\n-  }\n-\n-  private getMaxPosition(viewGroups: ViewGroupWorkspaceEntity[]): number {\n+  private getMaxPosition(viewGroups: ViewGroupEntity[]): number {\n     return viewGroups.reduce((max, group) => Math.max(max, group.position), 0);\n   }\n \n   async createViewAndViewFields(\n     createdFieldMetadatas: FieldMetadataEntity[],\n     workspaceId: string,\n   ) {\n-    const workspaceDataSource =\n-      await this.twentyORMGlobalManager.getDataSourceForWorkspace({\n-        workspaceId,\n-      });\n+    const views = await this.viewService.findByObjectMetadataId(\n+      workspaceId,\n+      createdFieldMetadatas[0].objectMetadataId,\n+    );\n \n-    await workspaceDataSource.transaction(\n-      async (workspaceEntityManager: WorkspaceEntityManager) => {\n-        const viewsRepository = workspaceEntityManager.getRepository('view', {\n-          shouldBypassPermissionChecks: true,\n-        });\n+    if (views.length === 0) {\n+      return;\n+    }\n \n-        const viewFieldsRepository = workspaceEntityManager.getRepository(\n-          'viewField',\n-          {\n-            shouldBypassPermissionChecks: true,\n-          },\n+    for (const view of views) {\n+      for (const createdFieldMetadata of createdFieldMetadatas) {\n+        const isVisible =\n+          view.viewFields.length < settings.maxVisibleViewFields;\n+\n+        const createdFieldIsAlreadyInView = view.viewFields.some(\n+          (existingViewField) =>\n+            existingViewField.fieldMetadataId === createdFieldMetadata.id,\n         );\n \n-        for (const createdFieldMetadata of createdFieldMetadatas) {\n-          const views = await viewsRepository.find({\n-            where: {\n-              objectMetadataId: createdFieldMetadata.objectMetadataId,\n-            },\n+        if (!createdFieldIsAlreadyInView) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2319022278",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14202,
        "pr_file": "packages/twenty-server/src/engine/metadata-modules/field-metadata/services/field-metadata-related-records.service.ts",
        "discussion_id": "2319022278",
        "commented_code": "@@ -306,97 +299,54 @@ export class FieldMetadataRelatedRecordsService {\n     return differences;\n   }\n \n-  private async getFieldMetadataViewWithRelation(\n-    fieldMetadata: SelectOrMultiSelectFieldMetadataEntity,\n-    relation: keyof Pick<ViewWorkspaceEntity, 'viewGroups' | 'viewFilters'>,\n-  ): Promise<ViewWorkspaceEntity[]> {\n-    const viewRepository =\n-      await this.twentyORMGlobalManager.getRepositoryForWorkspace<ViewWorkspaceEntity>(\n-        fieldMetadata.workspaceId,\n-        'view',\n-      );\n-\n-    return viewRepository.find({\n-      where: {\n-        [relation]: {\n-          fieldMetadataId: fieldMetadata.id,\n-        },\n-      },\n-      relations: [relation],\n-    });\n-  }\n-\n-  private getMaxPosition(viewGroups: ViewGroupWorkspaceEntity[]): number {\n+  private getMaxPosition(viewGroups: ViewGroupEntity[]): number {\n     return viewGroups.reduce((max, group) => Math.max(max, group.position), 0);\n   }\n \n   async createViewAndViewFields(\n     createdFieldMetadatas: FieldMetadataEntity[],\n     workspaceId: string,\n   ) {\n-    const workspaceDataSource =\n-      await this.twentyORMGlobalManager.getDataSourceForWorkspace({\n-        workspaceId,\n-      });\n+    const views = await this.viewService.findByObjectMetadataId(\n+      workspaceId,\n+      createdFieldMetadatas[0].objectMetadataId,\n+    );\n \n-    await workspaceDataSource.transaction(\n-      async (workspaceEntityManager: WorkspaceEntityManager) => {\n-        const viewsRepository = workspaceEntityManager.getRepository('view', {\n-          shouldBypassPermissionChecks: true,\n-        });\n+    if (views.length === 0) {\n+      return;\n+    }\n \n-        const viewFieldsRepository = workspaceEntityManager.getRepository(\n-          'viewField',\n-          {\n-            shouldBypassPermissionChecks: true,\n-          },\n+    for (const view of views) {\n+      for (const createdFieldMetadata of createdFieldMetadatas) {\n+        const isVisible =\n+          view.viewFields.length < settings.maxVisibleViewFields;\n+\n+        const createdFieldIsAlreadyInView = view.viewFields.some(\n+          (existingViewField) =>\n+            existingViewField.fieldMetadataId === createdFieldMetadata.id,\n         );\n \n-        for (const createdFieldMetadata of createdFieldMetadatas) {\n-          const views = await viewsRepository.find({\n-            where: {\n-              objectMetadataId: createdFieldMetadata.objectMetadataId,\n-            },\n+        if (!createdFieldIsAlreadyInView) {",
        "comment_created_at": "2025-09-03T13:40:48+00:00",
        "comment_author": "prastoin",
        "comment_body": "***Polish:*** early return/continue",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328548958",
    "pr_number": 14340,
    "pr_file": "packages/twenty-server/src/engine/core-modules/auth/auth.resolver.ts",
    "created_at": "2025-09-07T07:09:52+00:00",
    "commented_code": "userId: user.id,\n         workspaceId,\n       });\n-\n-    await this.twoFactorAuthenticationService.validateTwoFactorAuthenticationRequirement(\n-      workspace,\n-      currentUserWorkspace.twoFactorAuthenticationMethods,\n-    );\n+      \n+    if (isImpersonation === true) {\n+      this.logger.log(\n+        `Impersonation token exchange attempt for ${email} by ${impersonatorUserId}`,\n+        'AuthResolver.getAuthTokensFromLoginToken',\n+      );\n+      if (workspace.allowImpersonation !== true) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2328548958",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14340,
        "pr_file": "packages/twenty-server/src/engine/core-modules/auth/auth.resolver.ts",
        "discussion_id": "2328548958",
        "commented_code": "@@ -567,11 +574,48 @@ export class AuthResolver {\n         userId: user.id,\n         workspaceId,\n       });\n-\n-    await this.twoFactorAuthenticationService.validateTwoFactorAuthenticationRequirement(\n-      workspace,\n-      currentUserWorkspace.twoFactorAuthenticationMethods,\n-    );\n+      \n+    if (isImpersonation === true) {\n+      this.logger.log(\n+        `Impersonation token exchange attempt for ${email} by ${impersonatorUserId}`,\n+        'AuthResolver.getAuthTokensFromLoginToken',\n+      );\n+      if (workspace.allowImpersonation !== true) {",
        "comment_created_at": "2025-09-07T07:09:52+00:00",
        "comment_author": "FelixMalfait",
        "comment_body": "We try to avoid nested if structures, and also avoid else {} statements, when possible (because they are hard to follow). Usually it's more elegant to use ifs with an early return / exception thrown",
        "pr_file_module": null
      },
      {
        "comment_id": "2328570649",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14340,
        "pr_file": "packages/twenty-server/src/engine/core-modules/auth/auth.resolver.ts",
        "discussion_id": "2328548958",
        "commented_code": "@@ -567,11 +574,48 @@ export class AuthResolver {\n         userId: user.id,\n         workspaceId,\n       });\n-\n-    await this.twoFactorAuthenticationService.validateTwoFactorAuthenticationRequirement(\n-      workspace,\n-      currentUserWorkspace.twoFactorAuthenticationMethods,\n-    );\n+      \n+    if (isImpersonation === true) {\n+      this.logger.log(\n+        `Impersonation token exchange attempt for ${email} by ${impersonatorUserId}`,\n+        'AuthResolver.getAuthTokensFromLoginToken',\n+      );\n+      if (workspace.allowImpersonation !== true) {",
        "comment_created_at": "2025-09-07T08:19:21+00:00",
        "comment_author": "harshit078",
        "comment_body": "Got it, I'll remove nested if and else and introduce a more flat approach.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2354551868",
    "pr_number": 14414,
    "pr_file": "packages/twenty-front/src/modules/ai/utils/extractErrorMessage.ts",
    "created_at": "2025-09-17T07:17:06+00:00",
    "commented_code": "+import { isDefined } from 'twenty-shared/utils';\n+\n+export const extractErrorMessage = (error: unknown): string => {\n+  if (typeof error === 'string') {\n+    return error;\n+  }\n+\n+  if (!isDefined(error) || typeof error !== 'object') {\n+    return 'An unexpected error occurred';\n+  }\n+\n+  if ('message' in error && typeof error.message === 'string') {\n+    return error.message;\n+  }\n+\n+  if (\n+    'error' in error &&\n+    isDefined(error.error) &&\n+    typeof error.error === 'object' &&\n+    'message' in error.error &&\n+    typeof error.error.message === 'string'\n+  ) {\n+    return error.error.message;\n+  }\n+\n+  if (",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2354551868",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14414,
        "pr_file": "packages/twenty-front/src/modules/ai/utils/extractErrorMessage.ts",
        "discussion_id": "2354551868",
        "commented_code": "@@ -0,0 +1,40 @@\n+import { isDefined } from 'twenty-shared/utils';\n+\n+export const extractErrorMessage = (error: unknown): string => {\n+  if (typeof error === 'string') {\n+    return error;\n+  }\n+\n+  if (!isDefined(error) || typeof error !== 'object') {\n+    return 'An unexpected error occurred';\n+  }\n+\n+  if ('message' in error && typeof error.message === 'string') {\n+    return error.message;\n+  }\n+\n+  if (\n+    'error' in error &&\n+    isDefined(error.error) &&\n+    typeof error.error === 'object' &&\n+    'message' in error.error &&\n+    typeof error.error.message === 'string'\n+  ) {\n+    return error.error.message;\n+  }\n+\n+  if (",
        "comment_created_at": "2025-09-17T07:17:06+00:00",
        "comment_author": "FelixMalfait",
        "comment_body": "This is very hard to read  and understand! Please can sub-utils such as `isDeepNestedError` etc",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2309559260",
    "pr_number": 14145,
    "pr_file": "packages/twenty-server/src/modules/workflow/workflow-executor/utils/get-all-step-ids-in-loop.util.ts",
    "created_at": "2025-08-29T08:40:51+00:00",
    "commented_code": "+import { isWorkflowIteratorAction } from 'src/modules/workflow/workflow-executor/workflow-actions/iterator/guards/is-workflow-iterator-action.guard';\n+import { type WorkflowIteratorActionInput } from 'src/modules/workflow/workflow-executor/workflow-actions/iterator/types/workflow-iterator-action-settings.type';\n+import {\n+  type WorkflowAction,\n+  WorkflowActionType,\n+} from 'src/modules/workflow/workflow-executor/workflow-actions/types/workflow-action.type';\n+\n+export const getAllStepIdsInLoop = ({\n+  iteratorStepId,\n+  initialLoopStepIds,\n+  steps,\n+}: {\n+  iteratorStepId: string;\n+  initialLoopStepIds: string[];\n+  steps: WorkflowAction[];\n+}): string[] => {\n+  const allStepIdsInLoop = new Set<string>();\n+  const visitedStepIds = new Set<string>();\n+\n+  const traverseSteps = (stepIds: string[]): void => {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2309559260",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14145,
        "pr_file": "packages/twenty-server/src/modules/workflow/workflow-executor/utils/get-all-step-ids-in-loop.util.ts",
        "discussion_id": "2309559260",
        "commented_code": "@@ -0,0 +1,72 @@\n+import { isWorkflowIteratorAction } from 'src/modules/workflow/workflow-executor/workflow-actions/iterator/guards/is-workflow-iterator-action.guard';\n+import { type WorkflowIteratorActionInput } from 'src/modules/workflow/workflow-executor/workflow-actions/iterator/types/workflow-iterator-action-settings.type';\n+import {\n+  type WorkflowAction,\n+  WorkflowActionType,\n+} from 'src/modules/workflow/workflow-executor/workflow-actions/types/workflow-action.type';\n+\n+export const getAllStepIdsInLoop = ({\n+  iteratorStepId,\n+  initialLoopStepIds,\n+  steps,\n+}: {\n+  iteratorStepId: string;\n+  initialLoopStepIds: string[];\n+  steps: WorkflowAction[];\n+}): string[] => {\n+  const allStepIdsInLoop = new Set<string>();\n+  const visitedStepIds = new Set<string>();\n+\n+  const traverseSteps = (stepIds: string[]): void => {",
        "comment_created_at": "2025-08-29T08:40:51+00:00",
        "comment_author": "martmull",
        "comment_body": "Lets use a pure function by moving this in the root of the file. I think this kind of state dependant method is difficult to read and error prone",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293154927",
    "pr_number": 14014,
    "pr_file": "packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts",
    "created_at": "2025-08-22T09:04:53+00:00",
    "commented_code": "+import { CAPTURE_ALL_VARIABLE_TAG_INNER_REGEX } from '@/workflow/workflow-variables/constants/CaptureAllVariableTagInnerRegex';\n+import { type VariableSearchResult } from '@/workflow/workflow-variables/hooks/useSearchVariable';\n+import {\n+  type RecordFieldNodeValue,\n+  type RecordOutputSchemaV2,\n+} from '@/workflow/workflow-variables/types/RecordOutputSchemaV2';\n+import { isRecordOutputSchemaV2 } from '@/workflow/workflow-variables/utils/isRecordOutputSchemaV2';\n+import { type FieldMetadataType } from 'twenty-shared/types';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+const getRecordObjectLabel = (\n+  recordSchema: RecordOutputSchemaV2,\n+): string | undefined => {\n+  return recordSchema.object.label;\n+};\n+\n+class FieldAccessor {\n+  static getLabel(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.label;\n+    }\n+    return schema[fieldKey]?.label;\n+  }\n+\n+  static getFieldMetadataId(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.fieldMetadataId;\n+    }\n+    return schema[fieldKey]?.fieldMetadataId;\n+  }\n+\n+  static getFieldMetadataType(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): FieldMetadataType | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.type;\n+    }\n+    return schema[fieldKey]?.type;\n+  }\n+\n+  static isCompositeSubField(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return false; // Record schemas don't have composite sub-fields at the top level\n+    }\n+    return schema[fieldKey]?.isCompositeSubField ?? false;\n+  }\n+\n+  static getFieldValue(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): RecordFieldNodeValue | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.value;\n+    }\n+    return schema[fieldKey]?.value;\n+  }\n+\n+  static hasField(fieldKey: string, schema: RecordFieldNodeValue): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return isDefined(schema.fields[fieldKey]);\n+    }\n+    return isDefined(schema[fieldKey]);\n+  }\n+}\n+\n+const navigateToTargetField = (",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2293154927",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14014,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts",
        "discussion_id": "2293154927",
        "commented_code": "@@ -0,0 +1,247 @@\n+import { CAPTURE_ALL_VARIABLE_TAG_INNER_REGEX } from '@/workflow/workflow-variables/constants/CaptureAllVariableTagInnerRegex';\n+import { type VariableSearchResult } from '@/workflow/workflow-variables/hooks/useSearchVariable';\n+import {\n+  type RecordFieldNodeValue,\n+  type RecordOutputSchemaV2,\n+} from '@/workflow/workflow-variables/types/RecordOutputSchemaV2';\n+import { isRecordOutputSchemaV2 } from '@/workflow/workflow-variables/utils/isRecordOutputSchemaV2';\n+import { type FieldMetadataType } from 'twenty-shared/types';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+const getRecordObjectLabel = (\n+  recordSchema: RecordOutputSchemaV2,\n+): string | undefined => {\n+  return recordSchema.object.label;\n+};\n+\n+class FieldAccessor {\n+  static getLabel(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.label;\n+    }\n+    return schema[fieldKey]?.label;\n+  }\n+\n+  static getFieldMetadataId(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.fieldMetadataId;\n+    }\n+    return schema[fieldKey]?.fieldMetadataId;\n+  }\n+\n+  static getFieldMetadataType(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): FieldMetadataType | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.type;\n+    }\n+    return schema[fieldKey]?.type;\n+  }\n+\n+  static isCompositeSubField(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return false; // Record schemas don't have composite sub-fields at the top level\n+    }\n+    return schema[fieldKey]?.isCompositeSubField ?? false;\n+  }\n+\n+  static getFieldValue(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): RecordFieldNodeValue | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.value;\n+    }\n+    return schema[fieldKey]?.value;\n+  }\n+\n+  static hasField(fieldKey: string, schema: RecordFieldNodeValue): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return isDefined(schema.fields[fieldKey]);\n+    }\n+    return isDefined(schema[fieldKey]);\n+  }\n+}\n+\n+const navigateToTargetField = (",
        "comment_created_at": "2025-08-22T09:04:53+00:00",
        "comment_author": "Weiko",
        "comment_body": "```diff\r\ndiff --git a/packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts b/packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts\r\nindex 9e947b1bca..ae0e96d825 100644\r\n--- a/packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts\r\n+++ b/packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts\r\n@@ -5,7 +5,6 @@ import {\r\n   type RecordOutputSchemaV2,\r\n } from '@/workflow/workflow-variables/types/RecordOutputSchemaV2';\r\n import { isRecordOutputSchemaV2 } from '@/workflow/workflow-variables/utils/isRecordOutputSchemaV2';\r\n-import { type FieldMetadataType } from 'twenty-shared/types';\r\n import { isDefined } from 'twenty-shared/utils';\r\n \r\n const getRecordObjectLabel = (\r\n@@ -14,64 +13,11 @@ const getRecordObjectLabel = (\r\n   return recordSchema.object.label;\r\n };\r\n \r\n-class FieldAccessor {\r\n-  static getLabel(\r\n-    fieldKey: string,\r\n-    schema: RecordFieldNodeValue,\r\n-  ): string | undefined {\r\n-    if (isRecordOutputSchemaV2(schema)) {\r\n-      return schema.fields[fieldKey]?.label;\r\n-    }\r\n-    return schema[fieldKey]?.label;\r\n-  }\r\n-\r\n-  static getFieldMetadataId(\r\n-    fieldKey: string,\r\n-    schema: RecordFieldNodeValue,\r\n-  ): string | undefined {\r\n-    if (isRecordOutputSchemaV2(schema)) {\r\n-      return schema.fields[fieldKey]?.fieldMetadataId;\r\n-    }\r\n-    return schema[fieldKey]?.fieldMetadataId;\r\n-  }\r\n-\r\n-  static getFieldMetadataType(\r\n-    fieldKey: string,\r\n-    schema: RecordFieldNodeValue,\r\n-  ): FieldMetadataType | undefined {\r\n-    if (isRecordOutputSchemaV2(schema)) {\r\n-      return schema.fields[fieldKey]?.type;\r\n-    }\r\n-    return schema[fieldKey]?.type;\r\n-  }\r\n-\r\n-  static isCompositeSubField(\r\n-    fieldKey: string,\r\n-    schema: RecordFieldNodeValue,\r\n-  ): boolean {\r\n-    if (isRecordOutputSchemaV2(schema)) {\r\n-      return false; // Record schemas don't have composite sub-fields at the top level\r\n-    }\r\n-    return schema[fieldKey]?.isCompositeSubField ?? false;\r\n-  }\r\n-\r\n-  static getFieldValue(\r\n-    fieldKey: string,\r\n-    schema: RecordFieldNodeValue,\r\n-  ): RecordFieldNodeValue | undefined {\r\n-    if (isRecordOutputSchemaV2(schema)) {\r\n-      return schema.fields[fieldKey]?.value;\r\n-    }\r\n-    return schema[fieldKey]?.value;\r\n-  }\r\n-\r\n-  static hasField(fieldKey: string, schema: RecordFieldNodeValue): boolean {\r\n-    if (isRecordOutputSchemaV2(schema)) {\r\n-      return isDefined(schema.fields[fieldKey]);\r\n-    }\r\n-    return isDefined(schema[fieldKey]);\r\n-  }\r\n-}\r\n+const getFieldFromSchema = (fieldKey: string, schema: RecordFieldNodeValue) => {\r\n+  return isRecordOutputSchemaV2(schema)\r\n+    ? schema.fields[fieldKey]\r\n+    : schema[fieldKey];\r\n+};\r\n \r\n const navigateToTargetField = (\r\n   startingSchema: RecordOutputSchemaV2,\r\n@@ -81,19 +27,17 @@ const navigateToTargetField = (\r\n   const pathLabels: string[] = [];\r\n \r\n   for (const pathSegment of pathSegments) {\r\n-    if (\r\n-      !isDefined(currentSchema) ||\r\n-      !FieldAccessor.hasField(pathSegment, currentSchema)\r\n-    ) {\r\n-      return null; // Path not found\r\n+    const field = getFieldFromSchema(pathSegment, currentSchema);\r\n+\r\n+    if (!isDefined(field)) {\r\n+      return null;\r\n     }\r\n \r\n-    const fieldLabel = FieldAccessor.getLabel(pathSegment, currentSchema);\r\n-    if (isDefined(fieldLabel)) {\r\n-      pathLabels.push(fieldLabel);\r\n+    if (isDefined(field.label)) {\r\n+      pathLabels.push(field.label);\r\n     }\r\n \r\n-    const nextSchema = FieldAccessor.getFieldValue(pathSegment, currentSchema);\r\n+    const nextSchema = field.value;\r\n     if (!isDefined(nextSchema)) {\r\n       return null; // Dead end in path\r\n     }\r\n@@ -111,11 +55,13 @@ const buildVariableResult = (\r\n   targetFieldName: string,\r\n   isFullRecord: boolean,\r\n ): VariableSearchResult => {\r\n+  const targetField = getFieldFromSchema(targetFieldName, targetSchema);\r\n+\r\n   // Determine the variable label based on whether we want the full record or a specific field\r\n   const variableLabel =\r\n     isFullRecord && isRecordOutputSchemaV2(targetSchema)\r\n       ? getRecordObjectLabel(targetSchema)\r\n-      : FieldAccessor.getLabel(targetFieldName, targetSchema);\r\n+      : targetField.label;\r\n \r\n   if (!variableLabel) {\r\n     return {\r\n@@ -129,23 +75,18 @@ const buildVariableResult = (\r\n   const fullPathSegments = [stepName, ...pathLabels, variableLabel];\r\n   const variablePathLabel = fullPathSegments.join(' > ');\r\n \r\n+  const compositeFieldSubFieldName = isRecordOutputSchemaV2(targetSchema)\r\n+    ? undefined\r\n+    : targetSchema[targetFieldName]?.isCompositeSubField\r\n+      ? targetFieldName\r\n+      : undefined;\r\n+\r\n   return {\r\n     variableLabel,\r\n     variablePathLabel,\r\n-    variableType: FieldAccessor.getFieldMetadataType(\r\n-      targetFieldName,\r\n-      targetSchema,\r\n-    ),\r\n-    fieldMetadataId: FieldAccessor.getFieldMetadataId(\r\n-      targetFieldName,\r\n-      targetSchema,\r\n-    ),\r\n-    compositeFieldSubFieldName: FieldAccessor.isCompositeSubField(\r\n-      targetFieldName,\r\n-      targetSchema,\r\n-    )\r\n-      ? targetFieldName\r\n-      : undefined,\r\n+    variableType: targetField.type,\r\n+    fieldMetadataId: targetField.fieldMetadataId,\r\n+    compositeFieldSubFieldName,\r\n   };\r\n };\r\n ```",
        "pr_file_module": null
      },
      {
        "comment_id": "2293155331",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14014,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts",
        "discussion_id": "2293154927",
        "commented_code": "@@ -0,0 +1,247 @@\n+import { CAPTURE_ALL_VARIABLE_TAG_INNER_REGEX } from '@/workflow/workflow-variables/constants/CaptureAllVariableTagInnerRegex';\n+import { type VariableSearchResult } from '@/workflow/workflow-variables/hooks/useSearchVariable';\n+import {\n+  type RecordFieldNodeValue,\n+  type RecordOutputSchemaV2,\n+} from '@/workflow/workflow-variables/types/RecordOutputSchemaV2';\n+import { isRecordOutputSchemaV2 } from '@/workflow/workflow-variables/utils/isRecordOutputSchemaV2';\n+import { type FieldMetadataType } from 'twenty-shared/types';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+const getRecordObjectLabel = (\n+  recordSchema: RecordOutputSchemaV2,\n+): string | undefined => {\n+  return recordSchema.object.label;\n+};\n+\n+class FieldAccessor {\n+  static getLabel(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.label;\n+    }\n+    return schema[fieldKey]?.label;\n+  }\n+\n+  static getFieldMetadataId(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.fieldMetadataId;\n+    }\n+    return schema[fieldKey]?.fieldMetadataId;\n+  }\n+\n+  static getFieldMetadataType(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): FieldMetadataType | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.type;\n+    }\n+    return schema[fieldKey]?.type;\n+  }\n+\n+  static isCompositeSubField(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return false; // Record schemas don't have composite sub-fields at the top level\n+    }\n+    return schema[fieldKey]?.isCompositeSubField ?? false;\n+  }\n+\n+  static getFieldValue(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): RecordFieldNodeValue | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.value;\n+    }\n+    return schema[fieldKey]?.value;\n+  }\n+\n+  static hasField(fieldKey: string, schema: RecordFieldNodeValue): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return isDefined(schema.fields[fieldKey]);\n+    }\n+    return isDefined(schema[fieldKey]);\n+  }\n+}\n+\n+const navigateToTargetField = (",
        "comment_created_at": "2025-08-22T09:05:03+00:00",
        "comment_author": "Weiko",
        "comment_body": "Wdyt?",
        "pr_file_module": null
      },
      {
        "comment_id": "2293311132",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14014,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-variables/utils/searchVariableThroughRecordOutputSchema.ts",
        "discussion_id": "2293154927",
        "commented_code": "@@ -0,0 +1,247 @@\n+import { CAPTURE_ALL_VARIABLE_TAG_INNER_REGEX } from '@/workflow/workflow-variables/constants/CaptureAllVariableTagInnerRegex';\n+import { type VariableSearchResult } from '@/workflow/workflow-variables/hooks/useSearchVariable';\n+import {\n+  type RecordFieldNodeValue,\n+  type RecordOutputSchemaV2,\n+} from '@/workflow/workflow-variables/types/RecordOutputSchemaV2';\n+import { isRecordOutputSchemaV2 } from '@/workflow/workflow-variables/utils/isRecordOutputSchemaV2';\n+import { type FieldMetadataType } from 'twenty-shared/types';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+const getRecordObjectLabel = (\n+  recordSchema: RecordOutputSchemaV2,\n+): string | undefined => {\n+  return recordSchema.object.label;\n+};\n+\n+class FieldAccessor {\n+  static getLabel(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.label;\n+    }\n+    return schema[fieldKey]?.label;\n+  }\n+\n+  static getFieldMetadataId(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): string | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.fieldMetadataId;\n+    }\n+    return schema[fieldKey]?.fieldMetadataId;\n+  }\n+\n+  static getFieldMetadataType(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): FieldMetadataType | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.type;\n+    }\n+    return schema[fieldKey]?.type;\n+  }\n+\n+  static isCompositeSubField(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return false; // Record schemas don't have composite sub-fields at the top level\n+    }\n+    return schema[fieldKey]?.isCompositeSubField ?? false;\n+  }\n+\n+  static getFieldValue(\n+    fieldKey: string,\n+    schema: RecordFieldNodeValue,\n+  ): RecordFieldNodeValue | undefined {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return schema.fields[fieldKey]?.value;\n+    }\n+    return schema[fieldKey]?.value;\n+  }\n+\n+  static hasField(fieldKey: string, schema: RecordFieldNodeValue): boolean {\n+    if (isRecordOutputSchemaV2(schema)) {\n+      return isDefined(schema.fields[fieldKey]);\n+    }\n+    return isDefined(schema[fieldKey]);\n+  }\n+}\n+\n+const navigateToTargetField = (",
        "comment_created_at": "2025-08-22T10:13:26+00:00",
        "comment_author": "thomtrp",
        "comment_body": "you are right, way more simple. Thank you!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2346146374",
    "pr_number": 14403,
    "pr_file": "packages/twenty-front/src/modules/localization/utils/detectNumberFormat.ts",
    "created_at": "2025-09-13T08:56:01+00:00",
    "commented_code": "+import { NumberFormat } from '@/localization/constants/NumberFormat';\n+\n+export const detectNumberFormat = (): NumberFormat => {\n+  try {\n+    const language = navigator.language;\n+\n+    if (language.startsWith('en')) {\n+      return NumberFormat.COMMAS_AND_DOT;\n+    }\n+    if (language.startsWith('fr')) {\n+      return NumberFormat.SPACES_AND_COMMA;\n+    }\n+    if (language.startsWith('de')) {\n+      return NumberFormat.SPACES_AND_DOT;\n+    }\n+\n+    return NumberFormat.COMMAS_AND_DOT;\n+  } catch {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2346146374",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14403,
        "pr_file": "packages/twenty-front/src/modules/localization/utils/detectNumberFormat.ts",
        "discussion_id": "2346146374",
        "commented_code": "@@ -0,0 +1,21 @@\n+import { NumberFormat } from '@/localization/constants/NumberFormat';\n+\n+export const detectNumberFormat = (): NumberFormat => {\n+  try {\n+    const language = navigator.language;\n+\n+    if (language.startsWith('en')) {\n+      return NumberFormat.COMMAS_AND_DOT;\n+    }\n+    if (language.startsWith('fr')) {\n+      return NumberFormat.SPACES_AND_COMMA;\n+    }\n+    if (language.startsWith('de')) {\n+      return NumberFormat.SPACES_AND_DOT;\n+    }\n+\n+    return NumberFormat.COMMAS_AND_DOT;\n+  } catch {",
        "comment_created_at": "2025-09-13T08:56:01+00:00",
        "comment_author": "FelixMalfait",
        "comment_body": "This shouldn't be a try/catch. Maybe you wanted to do a switch instead?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2344316935",
    "pr_number": 14453,
    "pr_file": "packages/twenty-server/src/engine/api/rest/core/query-builder/utils/compute-depth.utils.ts",
    "created_at": "2025-09-12T13:46:42+00:00",
    "commented_code": "import { type Request } from 'express';\n \n-const ALLOWED_DEPTH_VALUES = [0, 1, 2];\n+const ALLOWED_DEPTH_VALUES = [0, 1];",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2344316935",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14453,
        "pr_file": "packages/twenty-server/src/engine/api/rest/core/query-builder/utils/compute-depth.utils.ts",
        "discussion_id": "2344316935",
        "commented_code": "@@ -2,7 +2,7 @@ import { BadRequestException } from '@nestjs/common';\n \n import { type Request } from 'express';\n \n-const ALLOWED_DEPTH_VALUES = [0, 1, 2];\n+const ALLOWED_DEPTH_VALUES = [0, 1];",
        "comment_created_at": "2025-09-12T13:46:42+00:00",
        "comment_author": "Weiko",
        "comment_body": "I know it's not on you but that's a bit overkill for a number comparison\r\n```typescript\r\n![0, 1, MAX_DEPTH].includes(depth)\r\n```\r\nvs\r\n```typescript\r\ndepth > MAX_DEPTH\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301066350",
    "pr_number": 14055,
    "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/utils/getBodyTypeFromHeaders.ts",
    "created_at": "2025-08-26T13:49:13+00:00",
    "commented_code": "+import { isDefined } from 'twenty-shared/utils';\n+import {\n+  type BodyType,\n+  CONTENT_TYPE_VALUES_HTTP_REQUEST,\n+} from 'twenty-shared/workflow';\n+\n+export const getBodyTypeFromHeaders = (\n+  headers?: Record<string, string>,\n+): BodyType | null => {\n+  if (!isDefined(headers)) return null;\n+\n+  const headerEntries = Object.entries(headers);\n+\n+  for (let i = headerEntries.length - 1; i >= 0; i--) {\n+    const [key, val] = headerEntries[i];\n+    if (key.toLowerCase() === 'content-type') {\n+      const match = Object.entries(CONTENT_TYPE_VALUES_HTTP_REQUEST)\n+        .filter(([bodyTypeKey]) => bodyTypeKey !== 'None')\n+        .find(\n+          ([, contentTypeVal]) => val.trim().toLowerCase() === contentTypeVal,\n+        );\n+      if (isDefined(match)) {\n+        const [bodyTypeKey] = match;\n+        return bodyTypeKey as BodyType;\n+      }\n+    }\n+  }\n+\n+  return null;\n+};",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2301066350",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/utils/getBodyTypeFromHeaders.ts",
        "discussion_id": "2301066350",
        "commented_code": "@@ -0,0 +1,30 @@\n+import { isDefined } from 'twenty-shared/utils';\n+import {\n+  type BodyType,\n+  CONTENT_TYPE_VALUES_HTTP_REQUEST,\n+} from 'twenty-shared/workflow';\n+\n+export const getBodyTypeFromHeaders = (\n+  headers?: Record<string, string>,\n+): BodyType | null => {\n+  if (!isDefined(headers)) return null;\n+\n+  const headerEntries = Object.entries(headers);\n+\n+  for (let i = headerEntries.length - 1; i >= 0; i--) {\n+    const [key, val] = headerEntries[i];\n+    if (key.toLowerCase() === 'content-type') {\n+      const match = Object.entries(CONTENT_TYPE_VALUES_HTTP_REQUEST)\n+        .filter(([bodyTypeKey]) => bodyTypeKey !== 'None')\n+        .find(\n+          ([, contentTypeVal]) => val.trim().toLowerCase() === contentTypeVal,\n+        );\n+      if (isDefined(match)) {\n+        const [bodyTypeKey] = match;\n+        return bodyTypeKey as BodyType;\n+      }\n+    }\n+  }\n+\n+  return null;\n+};",
        "comment_created_at": "2025-08-26T13:49:13+00:00",
        "comment_author": "thomtrp",
        "comment_body": "rather than a loop, could you do a find? Something like:\r\n\r\n```\r\nexport const getBodyTypeFromHeaders = (\r\n  headers?: Record<string, string>\r\n): BodyType | null => {\r\n  if (! isDefined(headers)) return null;\r\n\r\n  const contentType = Object.entries(headers)\r\n    .find(([key]) => key.toLowerCase() === 'content-type')?.[1];\r\n\r\n  if (!isDefined(contentType)) return null;\r\n\r\n  const normalizedContentType = contentType.trim().toLowerCase();\r\n  \r\n  const match = Object.entries(CONTENT_TYPE_VALUES_HTTP_REQUEST)\r\n    .find(([bodyTypeKey, contentTypeVal]) => \r\n      bodyTypeKey !== 'None' && normalizedContentType === contentTypeVal\r\n    );\r\n\r\n  return isDefined(match) ? (match[0] as BodyType) : null;\r\n};\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2320588789",
    "pr_number": 14055,
    "pr_file": "packages/twenty-shared/src/workflow/utils/parseDataFromBodyType.ts",
    "created_at": "2025-09-04T01:28:49+00:00",
    "commented_code": "+import { BodyType } from '@/workflow/types/workflowHttpRequestStep';\n+\n+type InputData = Record<string, any> | string;\n+\n+const parseUrlEncoded = (data: InputData): string => {\n+  let parsed: InputData;\n+  if (typeof data === 'string') {\n+    try {\n+      parsed = JSON.parse(data);\n+    } catch {\n+      parsed = data;\n+    }\n+  } else {\n+    parsed = data;\n+  }",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2320588789",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-shared/src/workflow/utils/parseDataFromBodyType.ts",
        "discussion_id": "2320588789",
        "commented_code": "@@ -0,0 +1,67 @@\n+import { BodyType } from '@/workflow/types/workflowHttpRequestStep';\n+\n+type InputData = Record<string, any> | string;\n+\n+const parseUrlEncoded = (data: InputData): string => {\n+  let parsed: InputData;\n+  if (typeof data === 'string') {\n+    try {\n+      parsed = JSON.parse(data);\n+    } catch {\n+      parsed = data;\n+    }\n+  } else {\n+    parsed = data;\n+  }",
        "comment_created_at": "2025-09-04T01:28:49+00:00",
        "comment_author": "abdulrahmancodes",
        "comment_body": "Could we just do `let parsed = data` at the start and drop the else block?",
        "pr_file_module": null
      }
    ]
  }
]