[
  {
    "discussion_id": "2351735416",
    "pr_number": 14525,
    "pr_file": "packages/twenty-front/src/modules/workflow/workflow-diagram/workflow-edges/components/WorkflowDiagramDefaultEdgeEditable.tsx",
    "created_at": "2025-09-16T09:50:19+00:00",
    "commented_code": "parentStepId: source,\n       nextStepId: target,\n       position: { x: labelX, y: labelY },\n+      connectionOptions: isIteratorLoopEdge\n+        ? {\n+            connectedStepType: 'ITERATOR',\n+            settings: {\n+              isConnectedToLoop: true,\n+            },\n+          }\n+        : undefined,",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2351735416",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14525,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-diagram/workflow-edges/components/WorkflowDiagramDefaultEdgeEditable.tsx",
        "discussion_id": "2351735416",
        "commented_code": "@@ -93,6 +97,14 @@ export const WorkflowDiagramDefaultEdgeEditable = ({\n       parentStepId: source,\n       nextStepId: target,\n       position: { x: labelX, y: labelY },\n+      connectionOptions: isIteratorLoopEdge\n+        ? {\n+            connectedStepType: 'ITERATOR',\n+            settings: {\n+              isConnectedToLoop: true,\n+            },\n+          }\n+        : undefined,",
        "comment_created_at": "2025-09-16T09:50:19+00:00",
        "comment_author": "Devessier",
        "comment_body": "I'm unsure what the best way to pass these options to `startNodeCreation`.\r\n\r\nFirst, a safer way to determine if we are on an iterator loop edge would be to get the source node and ensure it's an iterator. Currently, I only check the `sourceHandleId`. Getting a reference to the source node in the edge component could be a bit heavy work.\r\n\r\nInstead, we might want to output that in `generateWorkflowDiagram`.\r\n\r\nI'm open to new ideas.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2298458285",
    "pr_number": 14055,
    "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
    "created_at": "2025-08-25T15:42:17+00:00",
    "commented_code": "const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2298458285",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-25T15:42:17+00:00",
        "comment_author": "thomtrp",
        "comment_body": "See this comment https://github.com/twentyhq/twenty/pull/13982#issuecomment-3214100211\r\n\r\nI thought bodyType would be directly calculated from headers and not stored. Is it possible?",
        "pr_file_module": null
      },
      {
        "comment_id": "2301813765",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-26T18:36:17+00:00",
        "comment_author": "omarNaifer12",
        "comment_body": "So what should we store to track the body type when the user selects from the dropdown? One solution, similar to using a bodyType enum is to use a unique internal key in the headers (not shown to the user and only used for calculation) and update its value whenever the user selects a new body type. This way we can differentiate between manual input and dropdown selection while keeping the tracking consistent.\r\n\r\nSee this comment https://github.com/twentyhq/twenty/pull/13982#issuecomment-3215016881\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2303745732",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-27T12:13:50+00:00",
        "comment_author": "thomtrp",
        "comment_body": "But when the user set the body type from the dropdown, it directly updates the headers right? When you pick `FormData` for example, headers will be updated with `content-type: multipart/form-data`. Why do you need another storage?\r\n\r\nOn fetch, you parse the headers to retrieve the body type. If not set, you use the default one.\r\nOn body type picking, you perform an update with the correct header associated.\r\n\r\nThis way you do not maintain both headers and body type (or an internal key). The only source of truth is the header. Would that work?",
        "pr_file_module": null
      },
      {
        "comment_id": "2303830874",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-27T12:47:28+00:00",
        "comment_author": "omarNaifer12",
        "comment_body": "Yes, this works if we don\u2019t allow the user to edit headers manually. But I\u2019m not sure it will work if the user manually writes a Content-Type header with the value multipart/form-data. How can I differentiate between the case where the user typed it manually and when it was set automatically from the body type dropdown?",
        "pr_file_module": null
      },
      {
        "comment_id": "2304280969",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-27T15:10:16+00:00",
        "comment_author": "thomtrp",
        "comment_body": "Checking postman, it seems that auto-generated triggers such as content-type are not editable. Let's do something similar",
        "pr_file_module": null
      },
      {
        "comment_id": "2304283791",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-27T15:10:54+00:00",
        "comment_author": "thomtrp",
        "comment_body": "Based on body type, we can decide whether content-type is disabled or not :)",
        "pr_file_module": null
      },
      {
        "comment_id": "2304284277",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-27T15:11:03+00:00",
        "comment_author": "thomtrp",
        "comment_body": "sounds good to you?",
        "pr_file_module": null
      },
      {
        "comment_id": "2306044817",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14055,
        "pr_file": "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/http-request-action/components/BodyInput.tsx",
        "discussion_id": "2298458285",
        "commented_code": "@@ -27,33 +27,48 @@ const StyledContainer = styled.div`\n const StyledSelectDropdown = styled(Select)`\n   margin-bottom: ${({ theme }) => theme.spacing(2)};\n `;\n+const StyledNoBodyMessage = styled.div`\n+  font-size: 14px;\n+  padding: ${({ theme }) => theme.spacing(2)};\n+  text-align: left;\n+  opacity: 1;\n+`;\n \n type BodyInputProps = {\n   label?: string;\n   defaultValue?: HttpRequestBody | string;\n-  onChange: (value?: string) => void;\n+  onChange: (value?: string, isBodyType?: boolean) => void;\n   readonly?: boolean;\n+  bodyType?: BodyType;\n };\n \n export const BodyInput = ({\n   defaultValue,\n   onChange,\n   readonly,\n+  bodyType,",
        "comment_created_at": "2025-08-28T03:12:18+00:00",
        "comment_author": "omarNaifer12",
        "comment_body": "Do you mean we should prevent the user from typing the content-type header manually, and instead have it controlled by the selected body type so it still appears in the input but can\u2019t be edited?",
        "pr_file_module": null
      }
    ]
  }
]