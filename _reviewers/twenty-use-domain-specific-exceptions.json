[
  {
    "discussion_id": "2332513287",
    "pr_number": 14360,
    "pr_file": "packages/twenty-server/src/engine/core-modules/auth/strategies/jwt.auth.strategy.ts",
    "created_at": "2025-09-09T08:34:21+00:00",
    "commented_code": "private async validateAccessToken(\n     payload: AccessTokenJwtPayload,\n   ): Promise<AuthContext> {\n-    let user: User | null = null;\n-    const workspace = await this.workspaceRepository.findOneBy({\n-      id: payload.workspaceId,\n-    });\n+    const userId = payload.sub ?? payload.userId;\n \n-    if (!workspace) {\n+    if (!payload.workspaceId || !isUUID(payload.workspaceId)) {\n       throw new AuthException(\n-        'Workspace not found',\n-        AuthExceptionCode.WORKSPACE_NOT_FOUND,\n+        'Invalid token',\n+        AuthExceptionCode.FORBIDDEN_EXCEPTION,\n       );\n     }\n \n-    const userId = payload.sub ?? payload.userId;\n-\n-    if (!userId) {\n+    if (!userId || !isUUID(userId)) {\n       throw new AuthException(\n-        'User not found',\n-        AuthExceptionCode.USER_NOT_FOUND,\n+        'Invalid token',\n+        AuthExceptionCode.FORBIDDEN_EXCEPTION,\n       );\n     }\n \n-    user = await this.userRepository.findOne({\n-      where: { id: userId },\n-    });\n-\n-    if (!payload.userWorkspaceId) {\n+    if (!payload.userWorkspaceId || !isUUID(payload.userWorkspaceId)) {\n       throw new AuthException(\n         'UserWorkspace not found',\n         AuthExceptionCode.USER_WORKSPACE_NOT_FOUND,\n       );\n     }\n \n+    if (payload.isImpersonating === true) {\n+      if (\n+        payload.impersonationType !== ImpersonationTokenTypeEnum.WORKSPACE &&\n+        payload.impersonationType !== ImpersonationTokenTypeEnum.SERVER\n+      ) {\n+        throw new AuthException(\n+          'Invalid impersonation token',\n+          AuthExceptionCode.FORBIDDEN_EXCEPTION,\n+        );\n+      }\n+\n+      if (\n+        !payload.originalUserWorkspaceId ||\n+        !isUUID(payload.originalUserWorkspaceId) ||\n+        !payload.impersonatorUserWorkspaceId ||\n+        !isUUID(payload.impersonatorUserWorkspaceId)\n+      ) {\n+        throw new AuthException(\n+          'Invalid impersonation token',\n+          AuthExceptionCode.FORBIDDEN_EXCEPTION,\n+        );\n+      }\n+\n+      if (payload.impersonationType === ImpersonationTokenTypeEnum.WORKSPACE) {\n+        if (payload.originalUserWorkspaceId !== payload.userWorkspaceId) {\n+          throw new AuthException(\n+            'Invalid impersonation token',",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2332513287",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14360,
        "pr_file": "packages/twenty-server/src/engine/core-modules/auth/strategies/jwt.auth.strategy.ts",
        "discussion_id": "2332513287",
        "commented_code": "@@ -107,42 +109,75 @@ export class JwtAuthStrategy extends PassportStrategy(Strategy, 'jwt') {\n   private async validateAccessToken(\n     payload: AccessTokenJwtPayload,\n   ): Promise<AuthContext> {\n-    let user: User | null = null;\n-    const workspace = await this.workspaceRepository.findOneBy({\n-      id: payload.workspaceId,\n-    });\n+    const userId = payload.sub ?? payload.userId;\n \n-    if (!workspace) {\n+    if (!payload.workspaceId || !isUUID(payload.workspaceId)) {\n       throw new AuthException(\n-        'Workspace not found',\n-        AuthExceptionCode.WORKSPACE_NOT_FOUND,\n+        'Invalid token',\n+        AuthExceptionCode.FORBIDDEN_EXCEPTION,\n       );\n     }\n \n-    const userId = payload.sub ?? payload.userId;\n-\n-    if (!userId) {\n+    if (!userId || !isUUID(userId)) {\n       throw new AuthException(\n-        'User not found',\n-        AuthExceptionCode.USER_NOT_FOUND,\n+        'Invalid token',\n+        AuthExceptionCode.FORBIDDEN_EXCEPTION,\n       );\n     }\n \n-    user = await this.userRepository.findOne({\n-      where: { id: userId },\n-    });\n-\n-    if (!payload.userWorkspaceId) {\n+    if (!payload.userWorkspaceId || !isUUID(payload.userWorkspaceId)) {\n       throw new AuthException(\n         'UserWorkspace not found',\n         AuthExceptionCode.USER_WORKSPACE_NOT_FOUND,\n       );\n     }\n \n+    if (payload.isImpersonating === true) {\n+      if (\n+        payload.impersonationType !== ImpersonationTokenTypeEnum.WORKSPACE &&\n+        payload.impersonationType !== ImpersonationTokenTypeEnum.SERVER\n+      ) {\n+        throw new AuthException(\n+          'Invalid impersonation token',\n+          AuthExceptionCode.FORBIDDEN_EXCEPTION,\n+        );\n+      }\n+\n+      if (\n+        !payload.originalUserWorkspaceId ||\n+        !isUUID(payload.originalUserWorkspaceId) ||\n+        !payload.impersonatorUserWorkspaceId ||\n+        !isUUID(payload.impersonatorUserWorkspaceId)\n+      ) {\n+        throw new AuthException(\n+          'Invalid impersonation token',\n+          AuthExceptionCode.FORBIDDEN_EXCEPTION,\n+        );\n+      }\n+\n+      if (payload.impersonationType === ImpersonationTokenTypeEnum.WORKSPACE) {\n+        if (payload.originalUserWorkspaceId !== payload.userWorkspaceId) {\n+          throw new AuthException(\n+            'Invalid impersonation token',",
        "comment_created_at": "2025-09-09T08:34:21+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "we should throw more explicit exception message + use userFriendlyMessage",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2326782096",
    "pr_number": 14307,
    "pr_file": "packages/twenty-server/src/engine/core-modules/dns-manager/services/dns-manager.service.ts",
    "created_at": "2025-09-06T10:07:10+00:00",
    "commented_code": "+/* @license Enterprise */\n+import { Injectable } from '@nestjs/common';\n+\n+import Cloudflare from 'cloudflare';\n+import { type CustomHostnameCreateParams } from 'cloudflare/resources/custom-hostnames/custom-hostnames';\n+import { isDefined } from 'twenty-shared/utils';\n+import { t } from '@lingui/core/macro';\n+import { Phase } from 'cloudflare/resources/rulesets/rulesets';\n+import { PhaseGetResponse } from 'cloudflare/src/resources/rulesets/phases/phases';\n+import { RewriteRule } from 'cloudflare/src/resources/rulesets/rules';\n+\n+import {\n+  DnsManagerException,\n+  DnsManagerExceptionCode,\n+} from 'src/engine/core-modules/dns-manager/exceptions/dns-manager.exception';\n+import { DomainManagerService } from 'src/engine/core-modules/domain-manager/services/domain-manager.service';\n+import { dnsManagerValidator } from 'src/engine/core-modules/dns-manager/validator/cloudflare.validate';\n+import { TwentyConfigService } from 'src/engine/core-modules/twenty-config/twenty-config.service';\n+import { type HostnameValidRecords } from 'src/engine/core-modules/dns-manager/dtos/hostname-valid-records';\n+\n+const PUBLIC_DOMAIN_HEADER_NAME = 'X-Twenty-Public-Domain';\n+\n+@Injectable()\n+export class DnsManagerService {\n+  cloudflareClient?: Cloudflare;\n+\n+  constructor(\n+    private readonly twentyConfigService: TwentyConfigService,\n+    private readonly domainManagerService: DomainManagerService,\n+  ) {\n+    if (this.twentyConfigService.get('CLOUDFLARE_API_KEY')) {\n+      this.cloudflareClient = new Cloudflare({\n+        apiToken: this.twentyConfigService.get('CLOUDFLARE_API_KEY'),\n+      });\n+    }\n+  }\n+\n+  private get sslParams(): CustomHostnameCreateParams['ssl'] {\n+    return {\n+      method: 'txt',\n+      type: 'dv',\n+      settings: {\n+        http2: 'on',\n+        min_tls_version: '1.2',\n+        tls_1_3: 'on',\n+        ciphers: ['ECDHE-RSA-AES128-GCM-SHA256', 'AES128-SHA'],\n+        early_hints: 'on',\n+      },\n+      bundle_method: 'ubiquitous',\n+      wildcard: false,\n+    };\n+  }\n+\n+  async registerHostname(customDomain: string) {\n+    dnsManagerValidator.isCloudflareInstanceDefined(this.cloudflareClient);\n+\n+    if (isDefined(await this.getHostnameDetails(customDomain))) {\n+      throw new DnsManagerException(\n+        'Hostname already registered',\n+        DnsManagerExceptionCode.HOSTNAME_ALREADY_REGISTERED,\n+        { userFriendlyMessage: 'Domain is already registered' },\n+      );\n+    }\n+\n+    return this.cloudflareClient.customHostnames.create({\n+      zone_id: this.twentyConfigService.get('CLOUDFLARE_ZONE_ID'),\n+      hostname: customDomain,\n+      ssl: this.sslParams,\n+    });\n+  }\n+\n+  async getHostnameDetails(\n+    hostname: string,\n+  ): Promise<HostnameValidRecords | undefined> {\n+    dnsManagerValidator.isCloudflareInstanceDefined(this.cloudflareClient);\n+\n+    const response = await this.cloudflareClient.customHostnames.list({\n+      zone_id: this.twentyConfigService.get('CLOUDFLARE_ZONE_ID'),\n+      hostname: hostname,\n+    });\n+\n+    if (response.result.length === 0) {\n+      return undefined;\n+    }\n+\n+    if (response.result.length === 1) {\n+      const { hostname, id, ssl, verification_errors, created_at } =\n+        response.result[0];\n+      // @ts-expect-error - type definition doesn't reflect the real API\n+      const dcvRecords = ssl?.dcv_delegation_records?.[0];\n+\n+      return {\n+        id: id,\n+        customDomain: hostname,\n+        records: [\n+          {\n+            validationType: 'redirection' as const,\n+            type: 'cname',\n+            status:\n+              // wait 10s before starting the real check\n+              created_at &&\n+              new Date().getTime() - new Date(created_at).getTime() < 1000 * 10\n+                ? 'pending'\n+                : verification_errors?.[0] ===\n+                    'custom hostname does not CNAME to this zone.'\n+                  ? 'error'\n+                  : 'success',\n+            key: hostname,\n+            value: this.domainManagerService.getBaseUrl().hostname,\n+          },\n+          {\n+            validationType: 'ssl' as const,\n+            type: 'cname',\n+            status:\n+              !ssl.status || ssl.status.startsWith('pending')\n+                ? 'pending'\n+                : ssl.status === 'active'\n+                  ? 'success'\n+                  : ssl.status,\n+            key: dcvRecords?.cname ?? `_acme-challenge.${hostname}`,\n+            value:\n+              dcvRecords?.cname_target ??\n+              `${hostname}.${this.twentyConfigService.get('CLOUDFLARE_DCV_DELEGATION_ID')}.dcv.cloudflare.com`,\n+          },\n+        ],\n+      };\n+    }\n+\n+    // should never happen. error 5xx\n+    throw new Error('More than one custom hostname found in cloudflare');",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2326782096",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14307,
        "pr_file": "packages/twenty-server/src/engine/core-modules/dns-manager/services/dns-manager.service.ts",
        "discussion_id": "2326782096",
        "commented_code": "@@ -0,0 +1,277 @@\n+/* @license Enterprise */\n+import { Injectable } from '@nestjs/common';\n+\n+import Cloudflare from 'cloudflare';\n+import { type CustomHostnameCreateParams } from 'cloudflare/resources/custom-hostnames/custom-hostnames';\n+import { isDefined } from 'twenty-shared/utils';\n+import { t } from '@lingui/core/macro';\n+import { Phase } from 'cloudflare/resources/rulesets/rulesets';\n+import { PhaseGetResponse } from 'cloudflare/src/resources/rulesets/phases/phases';\n+import { RewriteRule } from 'cloudflare/src/resources/rulesets/rules';\n+\n+import {\n+  DnsManagerException,\n+  DnsManagerExceptionCode,\n+} from 'src/engine/core-modules/dns-manager/exceptions/dns-manager.exception';\n+import { DomainManagerService } from 'src/engine/core-modules/domain-manager/services/domain-manager.service';\n+import { dnsManagerValidator } from 'src/engine/core-modules/dns-manager/validator/cloudflare.validate';\n+import { TwentyConfigService } from 'src/engine/core-modules/twenty-config/twenty-config.service';\n+import { type HostnameValidRecords } from 'src/engine/core-modules/dns-manager/dtos/hostname-valid-records';\n+\n+const PUBLIC_DOMAIN_HEADER_NAME = 'X-Twenty-Public-Domain';\n+\n+@Injectable()\n+export class DnsManagerService {\n+  cloudflareClient?: Cloudflare;\n+\n+  constructor(\n+    private readonly twentyConfigService: TwentyConfigService,\n+    private readonly domainManagerService: DomainManagerService,\n+  ) {\n+    if (this.twentyConfigService.get('CLOUDFLARE_API_KEY')) {\n+      this.cloudflareClient = new Cloudflare({\n+        apiToken: this.twentyConfigService.get('CLOUDFLARE_API_KEY'),\n+      });\n+    }\n+  }\n+\n+  private get sslParams(): CustomHostnameCreateParams['ssl'] {\n+    return {\n+      method: 'txt',\n+      type: 'dv',\n+      settings: {\n+        http2: 'on',\n+        min_tls_version: '1.2',\n+        tls_1_3: 'on',\n+        ciphers: ['ECDHE-RSA-AES128-GCM-SHA256', 'AES128-SHA'],\n+        early_hints: 'on',\n+      },\n+      bundle_method: 'ubiquitous',\n+      wildcard: false,\n+    };\n+  }\n+\n+  async registerHostname(customDomain: string) {\n+    dnsManagerValidator.isCloudflareInstanceDefined(this.cloudflareClient);\n+\n+    if (isDefined(await this.getHostnameDetails(customDomain))) {\n+      throw new DnsManagerException(\n+        'Hostname already registered',\n+        DnsManagerExceptionCode.HOSTNAME_ALREADY_REGISTERED,\n+        { userFriendlyMessage: 'Domain is already registered' },\n+      );\n+    }\n+\n+    return this.cloudflareClient.customHostnames.create({\n+      zone_id: this.twentyConfigService.get('CLOUDFLARE_ZONE_ID'),\n+      hostname: customDomain,\n+      ssl: this.sslParams,\n+    });\n+  }\n+\n+  async getHostnameDetails(\n+    hostname: string,\n+  ): Promise<HostnameValidRecords | undefined> {\n+    dnsManagerValidator.isCloudflareInstanceDefined(this.cloudflareClient);\n+\n+    const response = await this.cloudflareClient.customHostnames.list({\n+      zone_id: this.twentyConfigService.get('CLOUDFLARE_ZONE_ID'),\n+      hostname: hostname,\n+    });\n+\n+    if (response.result.length === 0) {\n+      return undefined;\n+    }\n+\n+    if (response.result.length === 1) {\n+      const { hostname, id, ssl, verification_errors, created_at } =\n+        response.result[0];\n+      // @ts-expect-error - type definition doesn't reflect the real API\n+      const dcvRecords = ssl?.dcv_delegation_records?.[0];\n+\n+      return {\n+        id: id,\n+        customDomain: hostname,\n+        records: [\n+          {\n+            validationType: 'redirection' as const,\n+            type: 'cname',\n+            status:\n+              // wait 10s before starting the real check\n+              created_at &&\n+              new Date().getTime() - new Date(created_at).getTime() < 1000 * 10\n+                ? 'pending'\n+                : verification_errors?.[0] ===\n+                    'custom hostname does not CNAME to this zone.'\n+                  ? 'error'\n+                  : 'success',\n+            key: hostname,\n+            value: this.domainManagerService.getBaseUrl().hostname,\n+          },\n+          {\n+            validationType: 'ssl' as const,\n+            type: 'cname',\n+            status:\n+              !ssl.status || ssl.status.startsWith('pending')\n+                ? 'pending'\n+                : ssl.status === 'active'\n+                  ? 'success'\n+                  : ssl.status,\n+            key: dcvRecords?.cname ?? `_acme-challenge.${hostname}`,\n+            value:\n+              dcvRecords?.cname_target ??\n+              `${hostname}.${this.twentyConfigService.get('CLOUDFLARE_DCV_DELEGATION_ID')}.dcv.cloudflare.com`,\n+          },\n+        ],\n+      };\n+    }\n+\n+    // should never happen. error 5xx\n+    throw new Error('More than one custom hostname found in cloudflare');",
        "comment_created_at": "2025-09-06T10:07:10+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "**polish:** we should introduce CustomExceptions for this DnsManager module",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952626638",
    "pr_number": 10155,
    "pr_file": "packages/twenty-server/src/engine/core-modules/billing/billing.controller.ts",
    "created_at": "2025-02-12T13:16:50+00:00",
    "commented_code": "} catch (error) {\n       if (error instanceof BillingException) {\n         res.status(404).end();\n+      } else {\n+        res.status(500).end();",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "1952626638",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 10155,
        "pr_file": "packages/twenty-server/src/engine/core-modules/billing/billing.controller.ts",
        "discussion_id": "1952626638",
        "commented_code": "@@ -63,6 +63,8 @@ export class BillingController {\n     } catch (error) {\n       if (error instanceof BillingException) {\n         res.status(404).end();\n+      } else {\n+        res.status(500).end();",
        "comment_created_at": "2025-02-12T13:16:50+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "I'm not sure about this try catch:\r\n- agree with the logic that if we don't know the error we should throw a 500\r\n- however ideally we should try to know as much as we can the errors (in your PR description, you mention a timeout on stripe end => ok so if this happens what behavior do we want? we probably want to detect it at the right place in the code, emit a BillingException.StripeAPITimeout and then handle it here to return a 400 rather than a 500 or a 404\r\n\r\nNot a blocker for this PR, I think returning a 500 is still an improvement :p\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2260906212",
    "pr_number": 13661,
    "pr_file": "packages/twenty-server/src/engine/metadata-modules/object-metadata/utils/object-metadata-graphql-api-exception-handler.util.ts",
    "created_at": "2025-08-07T16:56:27+00:00",
    "commented_code": "}\n   }\n \n+  if (error instanceof QueryFailedError) {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2260906212",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 13661,
        "pr_file": "packages/twenty-server/src/engine/metadata-modules/object-metadata/utils/object-metadata-graphql-api-exception-handler.util.ts",
        "discussion_id": "2260906212",
        "commented_code": "@@ -38,5 +40,28 @@ export const objectMetadataGraphqlApiExceptionHandler = (error: Error) => {\n     }\n   }\n \n+  if (error instanceof QueryFailedError) {",
        "comment_created_at": "2025-08-07T16:56:27+00:00",
        "comment_author": "charlesBochet",
        "comment_body": "A. This does not seem to be the right place:\r\n1) this is the graphql error handling and we want this to be catched also when we call the service from controllers, or commands, etc... That's why we have  ObjectMetadataExceptions that are triggered internally by object metadata services\r\n2) We actually already have a ObjectMetadataExceptionCode.OBJECT_ALREADY_EXISTS, so we should look into that and do something similar I believe we arelady have a list of existing system fields that we should avoid.\r\n\r\nB. Regarding the way we catch it, catching the typeormException is not the best IMO, we can catch it before the making the query because we already kwow object field names. I believe we already have this somewhere\r\n\r\nC. I'm confused why this is part of ObjectMetadata logic? should be tied to FieldMetadata logic?\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2330639066",
    "pr_number": 14298,
    "pr_file": "packages/twenty-front/src/pages/settings/data-model/utils/compute-metadata-name-from-label.utils.ts",
    "created_at": "2025-09-08T15:42:22+00:00",
    "commented_code": null,
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2330639066",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14298,
        "pr_file": "packages/twenty-front/src/pages/settings/data-model/utils/compute-metadata-name-from-label.utils.ts",
        "discussion_id": "2330639066",
        "commented_code": null,
        "comment_created_at": "2025-09-08T15:42:22+00:00",
        "comment_author": "animesh65432",
        "comment_body": "@charlesBochet I think the application crashed when the user pressed any special character at the beginning, since formattedString is empty. In the if condition, when the length equals 0, we throw an error, which causes the application to crash. I believe this should be handled by the backend or what do you think",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2336002506",
    "pr_number": 14383,
    "pr_file": "packages/twenty-server/src/engine/core-modules/view/services/flat-view-field-validator.service.ts",
    "created_at": "2025-09-10T08:35:10+00:00",
    "commented_code": "+import { Injectable } from '@nestjs/common';\n+\n+import { t } from '@lingui/core/macro';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { ViewExceptionCode } from 'src/engine/core-modules/view/exceptions/view.exception';\n+import { FailedFlatViewFieldValidation } from 'src/engine/core-modules/view/types/failed-flat-view-field-validation.type';\n+import { FlatViewFieldMaps } from 'src/engine/core-modules/view/types/flat-view-field-maps.type';\n+import { FlatViewField } from 'src/engine/core-modules/view/types/flat-view-field.type';\n+import { FlatViewMaps } from 'src/engine/core-modules/view/types/flat-view-maps.type';\n+import { FlatObjectMetadataMaps } from 'src/engine/metadata-modules/flat-object-metadata-maps/types/flat-object-metadata-maps.type';\n+\n+@Injectable()\n+export class FlatViewFieldValidatorService {\n+  constructor() {}\n+\n+  public validateFlatViewFieldUpdate({\n+    _existingFlatViewFieldMaps,\n+    updatedFlatViewField,\n+  }: {\n+    _existingFlatViewFieldMaps: FlatViewFieldMaps;\n+    updatedFlatViewField: FlatViewField;\n+  }): FailedFlatViewFieldValidation {\n+    return {\n+      type: 'update_view_field',\n+      viewFieldLevelErrors: [],\n+      failedViewFieldValidationMinimalInformation: {\n+        viewFieldId: updatedFlatViewField.id,\n+        viewId: updatedFlatViewField.viewId,\n+        fieldMetadataId: updatedFlatViewField.fieldMetadataId,\n+      },\n+    };\n+  }\n+\n+  public validateFlatViewFieldDeletion({\n+    _existingFlatViewFieldMaps,\n+    viewFieldIdToDelete,\n+  }: {\n+    _existingFlatViewFieldMaps: FlatViewFieldMaps;\n+    viewFieldIdToDelete: string;\n+  }): FailedFlatViewFieldValidation {\n+    return {",
    "repo_full_name": "twentyhq/twenty",
    "discussion_comments": [
      {
        "comment_id": "2336002506",
        "repo_full_name": "twentyhq/twenty",
        "pr_number": 14383,
        "pr_file": "packages/twenty-server/src/engine/core-modules/view/services/flat-view-field-validator.service.ts",
        "discussion_id": "2336002506",
        "commented_code": "@@ -0,0 +1,117 @@\n+import { Injectable } from '@nestjs/common';\n+\n+import { t } from '@lingui/core/macro';\n+import { isDefined } from 'twenty-shared/utils';\n+\n+import { ViewExceptionCode } from 'src/engine/core-modules/view/exceptions/view.exception';\n+import { FailedFlatViewFieldValidation } from 'src/engine/core-modules/view/types/failed-flat-view-field-validation.type';\n+import { FlatViewFieldMaps } from 'src/engine/core-modules/view/types/flat-view-field-maps.type';\n+import { FlatViewField } from 'src/engine/core-modules/view/types/flat-view-field.type';\n+import { FlatViewMaps } from 'src/engine/core-modules/view/types/flat-view-maps.type';\n+import { FlatObjectMetadataMaps } from 'src/engine/metadata-modules/flat-object-metadata-maps/types/flat-object-metadata-maps.type';\n+\n+@Injectable()\n+export class FlatViewFieldValidatorService {\n+  constructor() {}\n+\n+  public validateFlatViewFieldUpdate({\n+    _existingFlatViewFieldMaps,\n+    updatedFlatViewField,\n+  }: {\n+    _existingFlatViewFieldMaps: FlatViewFieldMaps;\n+    updatedFlatViewField: FlatViewField;\n+  }): FailedFlatViewFieldValidation {\n+    return {\n+      type: 'update_view_field',\n+      viewFieldLevelErrors: [],\n+      failedViewFieldValidationMinimalInformation: {\n+        viewFieldId: updatedFlatViewField.id,\n+        viewId: updatedFlatViewField.viewId,\n+        fieldMetadataId: updatedFlatViewField.fieldMetadataId,\n+      },\n+    };\n+  }\n+\n+  public validateFlatViewFieldDeletion({\n+    _existingFlatViewFieldMaps,\n+    viewFieldIdToDelete,\n+  }: {\n+    _existingFlatViewFieldMaps: FlatViewFieldMaps;\n+    viewFieldIdToDelete: string;\n+  }): FailedFlatViewFieldValidation {\n+    return {",
        "comment_created_at": "2025-09-10T08:35:10+00:00",
        "comment_author": "prastoin",
        "comment_body": "***Remark:*** validate that field to delete exists",
        "pr_file_module": null
      }
    ]
  }
]