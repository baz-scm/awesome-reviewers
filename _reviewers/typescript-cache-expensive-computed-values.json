[
  {
    "discussion_id": "1821195407",
    "pr_number": 56941,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2024-10-29T16:44:00+00:00",
    "commented_code": "}\r\n     }\r\n \r\n+    // When checking an arrow expression such as `(x) => exp`, then `node` is the expression `exp`.\r\n+    // Otherwise, `node` is a return statement.\r\n+    function checkReturnExpression(\r\n+        container: SignatureDeclaration,\r\n+        unwrappedReturnType: Type,\r\n+        node: ReturnStatement | Expression,\r\n+        expr: Expression | undefined,\r\n+        exprType: Type,\r\n+        inConditionalExpression = false,\r\n+    ): void {\r\n+        const excludeJSDocTypeAssertions = isInJSFile(node);\r\n+        const functionFlags = getFunctionFlags(container);\r\n+        if (expr) {\r\n+            const unwrappedExpr = skipParentheses(expr, excludeJSDocTypeAssertions);\r\n+            if (isConditionalExpression(unwrappedExpr)) {\r\n+                return checkConditionalReturnExpression(container, unwrappedReturnType, node, unwrappedExpr);\r\n+            }\r\n+        }\r\n+        const effectiveExpr = expr && getEffectiveCheckNode(expr); // The effective expression for diagnostics purposes.\r\n+\r\n+        const inReturnStatement = node.kind === SyntaxKind.ReturnStatement;\r\n+        const unwrappedExprType = functionFlags & FunctionFlags.Async\r\n+            ? checkAwaitedType(\r\n+                exprType,\r\n+                /*withAlias*/ false,\r\n+                node,\r\n+                Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,\r\n+            )\r\n+            : exprType;\r\n+\r\n+        const errorNode = inReturnStatement && !inConditionalExpression ? node : effectiveExpr;\r\n+        if (!(unwrappedReturnType.flags & (TypeFlags.IndexedAccess | TypeFlags.Conditional)) || !couldContainTypeVariables(unwrappedReturnType)) {\r\n+            checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, errorNode, effectiveExpr);\r\n+            return;\r\n+        }\r\n+        // Check if type of return expression is assignable to original return type;\r\n+        // If so, we don't need to narrow, even if we could.\r\n+        if (checkTypeAssignableTo(unwrappedExprType, unwrappedReturnType, /*errorNode*/ undefined)) {\r\n+            return;\r\n+        }\r\n+\r\n+        const allTypeParameters = appendTypeParameters(getOuterTypeParameters(container, /*includeThisTypes*/ false), getEffectiveTypeParameterDeclarations(container as DeclarationWithTypeParameters));\r\n+        const narrowableTypeParameters = allTypeParameters && getNarrowableTypeParameters(allTypeParameters);\r\n+\r\n+        if (\r\n+            !narrowableTypeParameters ||\r\n+            !narrowableTypeParameters.length ||\r\n+            !isNarrowableReturnType(unwrappedReturnType as ConditionalType | IndexedAccessType)\r\n+        ) {\r\n+            checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, errorNode, effectiveExpr);\r\n+            return;\r\n+        }\r\n+\r\n+        // There are two cases for obtaining a position in the control-flow graph on which references will be analyzed:",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1821195407",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 56941,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1821195407",
        "commented_code": "@@ -45578,6 +45637,297 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n         }\r\n     }\r\n \r\n+    // When checking an arrow expression such as `(x) => exp`, then `node` is the expression `exp`.\r\n+    // Otherwise, `node` is a return statement.\r\n+    function checkReturnExpression(\r\n+        container: SignatureDeclaration,\r\n+        unwrappedReturnType: Type,\r\n+        node: ReturnStatement | Expression,\r\n+        expr: Expression | undefined,\r\n+        exprType: Type,\r\n+        inConditionalExpression = false,\r\n+    ): void {\r\n+        const excludeJSDocTypeAssertions = isInJSFile(node);\r\n+        const functionFlags = getFunctionFlags(container);\r\n+        if (expr) {\r\n+            const unwrappedExpr = skipParentheses(expr, excludeJSDocTypeAssertions);\r\n+            if (isConditionalExpression(unwrappedExpr)) {\r\n+                return checkConditionalReturnExpression(container, unwrappedReturnType, node, unwrappedExpr);\r\n+            }\r\n+        }\r\n+        const effectiveExpr = expr && getEffectiveCheckNode(expr); // The effective expression for diagnostics purposes.\r\n+\r\n+        const inReturnStatement = node.kind === SyntaxKind.ReturnStatement;\r\n+        const unwrappedExprType = functionFlags & FunctionFlags.Async\r\n+            ? checkAwaitedType(\r\n+                exprType,\r\n+                /*withAlias*/ false,\r\n+                node,\r\n+                Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,\r\n+            )\r\n+            : exprType;\r\n+\r\n+        const errorNode = inReturnStatement && !inConditionalExpression ? node : effectiveExpr;\r\n+        if (!(unwrappedReturnType.flags & (TypeFlags.IndexedAccess | TypeFlags.Conditional)) || !couldContainTypeVariables(unwrappedReturnType)) {\r\n+            checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, errorNode, effectiveExpr);\r\n+            return;\r\n+        }\r\n+        // Check if type of return expression is assignable to original return type;\r\n+        // If so, we don't need to narrow, even if we could.\r\n+        if (checkTypeAssignableTo(unwrappedExprType, unwrappedReturnType, /*errorNode*/ undefined)) {\r\n+            return;\r\n+        }\r\n+\r\n+        const allTypeParameters = appendTypeParameters(getOuterTypeParameters(container, /*includeThisTypes*/ false), getEffectiveTypeParameterDeclarations(container as DeclarationWithTypeParameters));\r\n+        const narrowableTypeParameters = allTypeParameters && getNarrowableTypeParameters(allTypeParameters);\r\n+\r\n+        if (\r\n+            !narrowableTypeParameters ||\r\n+            !narrowableTypeParameters.length ||\r\n+            !isNarrowableReturnType(unwrappedReturnType as ConditionalType | IndexedAccessType)\r\n+        ) {\r\n+            checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, errorNode, effectiveExpr);\r\n+            return;\r\n+        }\r\n+\r\n+        // There are two cases for obtaining a position in the control-flow graph on which references will be analyzed:\r",
        "comment_created_at": "2024-10-29T16:44:00+00:00",
        "comment_author": "sandersn",
        "comment_body": "the narrowPosition/FlowNode early return looks cheaper to calculate than the narrowableTypeParameters one. I'd put it first of the two.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2040738974",
    "pr_number": 61535,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2025-04-12T20:53:22+00:00",
    "commented_code": "error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);\r\n             return errorType;\r\n         }\r\n+        const index = findActiveMapper(mapper);\r\n+        if (index === -1) {\r\n+            pushActiveMapper(mapper);\r\n+        }\r\n+        const key = type.id + getAliasId(aliasSymbol, aliasTypeArguments);\r\n+        const mapperCache = activeTypeMappersCaches[index !== -1 ? index : activeTypeMappersCount - 1];\r\n+        const cached = mapperCache.get(key);\r\n+        if (cached) {\r\n+            return cached;\r\n+        }",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2040738974",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61535,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "2040738974",
        "commented_code": "@@ -20371,10 +20375,26 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n             error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);\r\n             return errorType;\r\n         }\r\n+        const index = findActiveMapper(mapper);\r\n+        if (index === -1) {\r\n+            pushActiveMapper(mapper);\r\n+        }\r\n+        const key = type.id + getAliasId(aliasSymbol, aliasTypeArguments);\r\n+        const mapperCache = activeTypeMappersCaches[index !== -1 ? index : activeTypeMappersCount - 1];\r\n+        const cached = mapperCache.get(key);\r\n+        if (cached) {\r\n+            return cached;\r\n+        }\r",
        "comment_created_at": "2025-04-12T20:53:22+00:00",
        "comment_author": "JoostK",
        "comment_body": "Since `key` and `mapperCache` aren't used for initial occurrences of mappers, computing the key can be avoided:\r\n\r\n```suggestion\r\n        let key: string | undefined;\r\n        let mapperCache: Map<string, Type> | undefined;\r\n        if (index === -1) {\r\n            pushActiveMapper(mapper);\r\n        } else {\r\n            key = type.id + getAliasId(aliasSymbol, aliasTypeArguments);\r\n            mapperCache = activeTypeMappersCaches[index];\r\n            const cached = mapperCache.get(key);\r\n            if (cached) {\r\n                return cached;\r\n            }\r\n        }\r\n```\r\n\r\nLikely also needs some updates below because of the `undefined`s.\r\n\r\nI also wonder if it's worth making the allocation of the `Map` lazy (and/or to keep it around if it's empty)",
        "pr_file_module": null
      },
      {
        "comment_id": "2040740028",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61535,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "2040738974",
        "commented_code": "@@ -20371,10 +20375,26 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n             error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);\r\n             return errorType;\r\n         }\r\n+        const index = findActiveMapper(mapper);\r\n+        if (index === -1) {\r\n+            pushActiveMapper(mapper);\r\n+        }\r\n+        const key = type.id + getAliasId(aliasSymbol, aliasTypeArguments);\r\n+        const mapperCache = activeTypeMappersCaches[index !== -1 ? index : activeTypeMappersCount - 1];\r\n+        const cached = mapperCache.get(key);\r\n+        if (cached) {\r\n+            return cached;\r\n+        }\r",
        "comment_created_at": "2025-04-12T21:00:17+00:00",
        "comment_author": "JoostK",
        "comment_body": "Or possibly only push if the type could potentially recurse (depending on the type flags), although I suspect that delaying the allocation of `Map` should be similar in perf; the push/pop operations themselves should be rather cheap.",
        "pr_file_module": null
      },
      {
        "comment_id": "2047514022",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61535,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "2040738974",
        "commented_code": "@@ -20371,10 +20375,26 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n             error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);\r\n             return errorType;\r\n         }\r\n+        const index = findActiveMapper(mapper);\r\n+        if (index === -1) {\r\n+            pushActiveMapper(mapper);\r\n+        }\r\n+        const key = type.id + getAliasId(aliasSymbol, aliasTypeArguments);\r\n+        const mapperCache = activeTypeMappersCaches[index !== -1 ? index : activeTypeMappersCount - 1];\r\n+        const cached = mapperCache.get(key);\r\n+        if (cached) {\r\n+            return cached;\r\n+        }\r",
        "comment_created_at": "2025-04-16T18:44:40+00:00",
        "comment_author": "Andarist",
        "comment_body": "Thanks for the suggestions. I'm not sure if this PR is going to make it though - so, for now, I'm refraining from making any changes to it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1893227070",
    "pr_number": 60812,
    "pr_file": "src/compiler/path.ts",
    "created_at": "2024-12-19T22:41:51+00:00",
    "commented_code": "}\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const simple = simpleNormalizePath(path);\r\n+    if (simple !== undefined) {\r\n+        return simple;\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r\n+    let index = rootLength;\r\n+    let segmentStart = index;\r\n+    let normalizedUpTo = index;\r\n+    let seenNonDotDotSegment = rootLength !== 0;\r\n+    while (index < path.length) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1893227070",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60812,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1893227070",
        "commented_code": "@@ -624,12 +624,115 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n }\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const simple = simpleNormalizePath(path);\r\n+    if (simple !== undefined) {\r\n+        return simple;\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r\n+    let index = rootLength;\r\n+    let segmentStart = index;\r\n+    let normalizedUpTo = index;\r\n+    let seenNonDotDotSegment = rootLength !== 0;\r\n+    while (index < path.length) {\r",
        "comment_created_at": "2024-12-19T22:41:51+00:00",
        "comment_author": "rbuckton",
        "comment_body": "Since `path.length` doesn't change, it may be more efficient to store it in a local and reuse that rather than look it up each time (both here and elsewhere in the function).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1681320089",
    "pr_number": 59004,
    "pr_file": "src/services/refactors/moveToFile.ts",
    "created_at": "2024-07-17T16:04:32+00:00",
    "commented_code": "function forEachReference(node: Node, checker: TypeChecker, enclosingRange: TextRange | undefined, onReference: (s: Symbol, isValidTypeOnlyUseSite: boolean) => void) {\r\n     node.forEachChild(function cb(node) {\r\n         if (isIdentifier(node) && !isDeclarationName(node)) {\r\n-            if (enclosingRange && !rangeContainsRange(enclosingRange, node)) {\r\n+            if (enclosingRange && !rangeContainsRange(enclosingRange, { pos: node.getStart(), end: node.getEnd() })) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1681320089",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 59004,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1681320089",
        "commented_code": "@@ -964,7 +964,7 @@ function inferNewFileName(importsFromNewFile: Map<Symbol, unknown>, movedSymbols\n function forEachReference(node: Node, checker: TypeChecker, enclosingRange: TextRange | undefined, onReference: (s: Symbol, isValidTypeOnlyUseSite: boolean) => void) {\r\n     node.forEachChild(function cb(node) {\r\n         if (isIdentifier(node) && !isDeclarationName(node)) {\r\n-            if (enclosingRange && !rangeContainsRange(enclosingRange, node)) {\r\n+            if (enclosingRange && !rangeContainsRange(enclosingRange, { pos: node.getStart(), end: node.getEnd() })) {\r",
        "comment_created_at": "2024-07-17T16:04:32+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "```suggestion\r\n            if (enclosingRange && !rangeContainsRange(enclosingRange, createTextRangeFromNode(node, sourceFile))) {\r\n\r\n```\r\n\r\nAnd declare `sourceFile` outside the recursive function so it doesn\u2019t have to be retrieved with a parent walk each time",
        "pr_file_module": null
      }
    ]
  }
]