[
  {
    "discussion_id": "2226282693",
    "pr_number": 62113,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2025-07-23T17:58:49+00:00",
    "commented_code": "return diagnostic;\r\n     }\r\n \r\n+    function getVerbatimModuleSyntaxErrorMessage(node: Node): DiagnosticMessage {\r\n+        const sourceFile = getSourceFileOfNode(node);\r\n+        const fileName = sourceFile.fileName;",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2226282693",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 62113,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "2226282693",
        "commented_code": "@@ -2510,6 +2510,19 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n         return diagnostic;\r\n     }\r\n \r\n+    function getVerbatimModuleSyntaxErrorMessage(node: Node): DiagnosticMessage {\r\n+        const sourceFile = getSourceFileOfNode(node);\r\n+        const fileName = sourceFile.fileName;\r",
        "comment_created_at": "2025-07-23T17:58:49+00:00",
        "comment_author": "Copilot",
        "comment_body": "The function lacks documentation explaining its purpose, parameters, and return value. Add a JSDoc comment describing when each error message variant is used.\n```suggestion\n    /**\n     * Returns a diagnostic message indicating that ECMAScript imports and exports\n     * cannot be used in a CommonJS file under `verbatimModuleSyntax`.\n     *\n     * @param node - The AST node where the error occurred.\n     * @returns A `DiagnosticMessage` explaining the error. If the file has a `.cts` or `.cjs` extension,\n     *          a specific error message for CommonJS files is returned. Otherwise, a more general\n     *          error message with suggestions for resolving the issue is returned.\n     */\n    function getVerbatimModuleSyntaxErrorMessage(node: Node): DiagnosticMessage {\n        const sourceFile = getSourceFileOfNode(node);\n        const fileName = sourceFile.fileName;\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2117876672",
    "pr_number": 61788,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2025-05-31T13:58:53+00:00",
    "commented_code": "const symbol = getResolvedSymbol(expr);\r\n                 if (isConstantVariable(symbol)) {\r\n                     const declaration = symbol.valueDeclaration!;\r\n+                    let initializer = getCandidateVariableDeclarationInitializer(declaration);\r\n                     // Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'\r\n-                    if (\r\n-                        isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer) &&\r\n-                        isMatchingReference(reference, declaration.initializer.expression)\r\n-                    ) {\r\n-                        return declaration.initializer;\r\n+                    if (initializer && isAccessExpression(initializer) && isMatchingReference(reference, initializer.expression)) {\r\n+                        return initializer;\r\n                     }\r\n                     // Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'\r\n                     if (isBindingElement(declaration) && !declaration.initializer) {\r\n-                        const parent = declaration.parent.parent;\r\n-                        if (\r\n-                            isVariableDeclaration(parent) && !parent.type && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) &&\r\n-                            isMatchingReference(reference, parent.initializer)\r\n-                        ) {\r\n+                        initializer = getCandidateVariableDeclarationInitializer(declaration.parent.parent);\r\n+                        if (initializer && (isIdentifier(initializer) || isAccessExpression(initializer)) && isMatchingReference(reference, initializer)) {\r\n                             return declaration;\r\n                         }\r\n                     }\r\n                 }\r\n             }\r\n             return undefined;\r\n+\r\n+            function getCandidateVariableDeclarationInitializer(node: Node) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2117876672",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61788,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "2117876672",
        "commented_code": "@@ -29247,26 +29247,25 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n                 const symbol = getResolvedSymbol(expr);\r\n                 if (isConstantVariable(symbol)) {\r\n                     const declaration = symbol.valueDeclaration!;\r\n+                    let initializer = getCandidateVariableDeclarationInitializer(declaration);\r\n                     // Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'\r\n-                    if (\r\n-                        isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer) &&\r\n-                        isMatchingReference(reference, declaration.initializer.expression)\r\n-                    ) {\r\n-                        return declaration.initializer;\r\n+                    if (initializer && isAccessExpression(initializer) && isMatchingReference(reference, initializer.expression)) {\r\n+                        return initializer;\r\n                     }\r\n                     // Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'\r\n                     if (isBindingElement(declaration) && !declaration.initializer) {\r\n-                        const parent = declaration.parent.parent;\r\n-                        if (\r\n-                            isVariableDeclaration(parent) && !parent.type && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) &&\r\n-                            isMatchingReference(reference, parent.initializer)\r\n-                        ) {\r\n+                        initializer = getCandidateVariableDeclarationInitializer(declaration.parent.parent);\r\n+                        if (initializer && (isIdentifier(initializer) || isAccessExpression(initializer)) && isMatchingReference(reference, initializer)) {\r\n                             return declaration;\r\n                         }\r\n                     }\r\n                 }\r\n             }\r\n             return undefined;\r\n+\r\n+            function getCandidateVariableDeclarationInitializer(node: Node) {\r",
        "comment_created_at": "2025-05-31T13:58:53+00:00",
        "comment_author": "Copilot",
        "comment_body": "Add a JSDoc comment above this helper to explain that it skips parentheses and returns an initializer only for untyped variable declarations.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1919333439",
    "pr_number": 60757,
    "pr_file": "src/compiler/types.ts",
    "created_at": "2025-01-16T22:42:32+00:00",
    "commented_code": "export interface ImportClause extends NamedDeclaration {\r\n     readonly kind: SyntaxKind.ImportClause;\r\n     readonly parent: ImportDeclaration | JSDocImportTag;\r\n-    readonly isTypeOnly: boolean;\r\n+    /** @deprecated */ readonly isTypeOnly: boolean;",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1919333439",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60757,
        "pr_file": "src/compiler/types.ts",
        "discussion_id": "1919333439",
        "commented_code": "@@ -3711,11 +3718,14 @@ export type NamedExportBindings =\n export interface ImportClause extends NamedDeclaration {\r\n     readonly kind: SyntaxKind.ImportClause;\r\n     readonly parent: ImportDeclaration | JSDocImportTag;\r\n-    readonly isTypeOnly: boolean;\r\n+    /** @deprecated */ readonly isTypeOnly: boolean;\r",
        "comment_created_at": "2025-01-16T22:42:32+00:00",
        "comment_author": "rbuckton",
        "comment_body": "```suggestion\r\n    /** @deprecated Use `phaseModifier` instead. */\r\n    readonly isTypeOnly: boolean;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2127109025",
    "pr_number": 61814,
    "pr_file": "src/compiler/factory/utilities.ts",
    "created_at": "2025-06-04T17:34:10+00:00",
    "commented_code": "const impliedModuleKind = getImpliedNodeFormatForEmitWorker(sourceFile, compilerOptions);\r\n         const helpers = getImportedHelpers(sourceFile);\r\n         if (\r\n-            (moduleKind >= ModuleKind.ES2015 && moduleKind <= ModuleKind.ESNext) ||\r\n-            impliedModuleKind === ModuleKind.ESNext ||\r\n-            impliedModuleKind === undefined && moduleKind === ModuleKind.Preserve\r\n+            impliedModuleKind !== ModuleKind.CommonJS &&\r\n+            ((moduleKind >= ModuleKind.ES2015 && moduleKind <= ModuleKind.ESNext) ||\r\n+                impliedModuleKind === ModuleKind.ESNext ||\r\n+                impliedModuleKind === undefined && moduleKind === ModuleKind.Preserve)\r\n         ) {\r\n             // When we emit as an ES module, generate an `import` declaration that uses named imports for helpers.",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2127109025",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61814,
        "pr_file": "src/compiler/factory/utilities.ts",
        "discussion_id": "2127109025",
        "commented_code": "@@ -700,9 +700,10 @@ export function createExternalHelpersImportDeclarationIfNeeded(nodeFactory: Node\n         const impliedModuleKind = getImpliedNodeFormatForEmitWorker(sourceFile, compilerOptions);\r\n         const helpers = getImportedHelpers(sourceFile);\r\n         if (\r\n-            (moduleKind >= ModuleKind.ES2015 && moduleKind <= ModuleKind.ESNext) ||\r\n-            impliedModuleKind === ModuleKind.ESNext ||\r\n-            impliedModuleKind === undefined && moduleKind === ModuleKind.Preserve\r\n+            impliedModuleKind !== ModuleKind.CommonJS &&\r\n+            ((moduleKind >= ModuleKind.ES2015 && moduleKind <= ModuleKind.ESNext) ||\r\n+                impliedModuleKind === ModuleKind.ESNext ||\r\n+                impliedModuleKind === undefined && moduleKind === ModuleKind.Preserve)\r\n         ) {\r\n             // When we emit as an ES module, generate an `import` declaration that uses named imports for helpers.\r",
        "comment_created_at": "2025-06-04T17:34:10+00:00",
        "comment_author": "Copilot",
        "comment_body": "It would be beneficial to add a comment explaining why checking against 'ModuleKind.CommonJS' is necessary here, as the new condition logic could be confusing to future maintainers.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2067083105",
    "pr_number": 61596,
    "pr_file": "src/lib/es5.d.ts",
    "created_at": "2025-04-29T18:10:12+00:00",
    "commented_code": "* @param text A valid JSON string.\r\n      * @param reviver A function that transforms the results. This function is called for each member of the object.\r\n      * If a member contains nested objects, the nested objects are transformed before the parent object is.\r\n+     * @throws {SyntaxError} If `text` is not valid JSON.\r\n      */\r\n     parse(text: string, reviver?: (this: any, key: string, value: any) => any): any;\r\n     /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      * @param replacer A function that transforms the results.\r\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n+     * @throws {TypeError} If a circular reference is found or a BigInt value is encountered.",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2067083105",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61596,
        "pr_file": "src/lib/es5.d.ts",
        "discussion_id": "2067083105",
        "commented_code": "@@ -1140,20 +1140,23 @@ interface JSON {\n      * @param text A valid JSON string.\r\n      * @param reviver A function that transforms the results. This function is called for each member of the object.\r\n      * If a member contains nested objects, the nested objects are transformed before the parent object is.\r\n+     * @throws {SyntaxError} If `text` is not valid JSON.\r\n      */\r\n     parse(text: string, reviver?: (this: any, key: string, value: any) => any): any;\r\n     /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      * @param replacer A function that transforms the results.\r\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n+     * @throws {TypeError} If a circular reference is found or a BigInt value is encountered.\r",
        "comment_created_at": "2025-04-29T18:10:12+00:00",
        "comment_author": "sandersn",
        "comment_body": "What do you think about this wording?\r\n```suggestion\r\n     * @throws {TypeError} If a circular reference or a BigInt value is found.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2069771936",
    "pr_number": 61636,
    "pr_file": "src/compiler/binder.ts",
    "created_at": "2025-05-01T02:13:54+00:00",
    "commented_code": "let excludes = SymbolFlags.None;\r\n         // Method-like\r\n         if (isFunctionLikeDeclaration(getAssignedExpandoInitializer(declaration)!)) {\r\n-            includes = SymbolFlags.Method;\r\n-            excludes = SymbolFlags.MethodExcludes;\r\n+            if (isPrototypeProperty) {\r\n+                includes = SymbolFlags.Method;\r\n+                excludes = SymbolFlags.MethodExcludes;\r\n+            }\r\n+            else {\r\n+                includes = SymbolFlags.Method | SymbolFlags.Property;\r\n+                excludes = SymbolFlags.PropertyExcludes;\r\n+            }\r\n         }",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2069771936",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61636,
        "pr_file": "src/compiler/binder.ts",
        "discussion_id": "2069771936",
        "commented_code": "@@ -3491,8 +3491,14 @@ function createBinder(): (file: SourceFile, options: CompilerOptions) => void {\n         let excludes = SymbolFlags.None;\r\n         // Method-like\r\n         if (isFunctionLikeDeclaration(getAssignedExpandoInitializer(declaration)!)) {\r\n-            includes = SymbolFlags.Method;\r\n-            excludes = SymbolFlags.MethodExcludes;\r\n+            if (isPrototypeProperty) {\r\n+                includes = SymbolFlags.Method;\r\n+                excludes = SymbolFlags.MethodExcludes;\r\n+            }\r\n+            else {\r\n+                includes = SymbolFlags.Method | SymbolFlags.Property;\r\n+                excludes = SymbolFlags.PropertyExcludes;\r\n+            }\r\n         }\r",
        "comment_created_at": "2025-05-01T02:13:54+00:00",
        "comment_author": "Copilot",
        "comment_body": "Consider adding a comment explaining why function-like initializers assigned to prototype properties are bound only with SymbolFlags.Method, while non-prototype assignments combine both Method and Property flags. This will make the intent clear for future maintainers.\n```suggestion\n        if (isFunctionLikeDeclaration(getAssignedExpandoInitializer(declaration)!)) {\n            // Prototype properties are treated as methods because they are part of the class's prototype,\n            // which defines shared behavior for all instances. Non-prototype assignments, however, are treated\n            // as both methods and properties to account for their dual nature in JavaScript, where they can\n            // behave like properties but also be callable like methods.\n            if (isPrototypeProperty) {\n                includes = SymbolFlags.Method;\n                excludes = SymbolFlags.MethodExcludes;\n            }\n            else {\n                includes = SymbolFlags.Method | SymbolFlags.Property;\n                excludes = SymbolFlags.PropertyExcludes;\n            }\n        }\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2072189225",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61636,
        "pr_file": "src/compiler/binder.ts",
        "discussion_id": "2069771936",
        "commented_code": "@@ -3491,8 +3491,14 @@ function createBinder(): (file: SourceFile, options: CompilerOptions) => void {\n         let excludes = SymbolFlags.None;\r\n         // Method-like\r\n         if (isFunctionLikeDeclaration(getAssignedExpandoInitializer(declaration)!)) {\r\n-            includes = SymbolFlags.Method;\r\n-            excludes = SymbolFlags.MethodExcludes;\r\n+            if (isPrototypeProperty) {\r\n+                includes = SymbolFlags.Method;\r\n+                excludes = SymbolFlags.MethodExcludes;\r\n+            }\r\n+            else {\r\n+                includes = SymbolFlags.Method | SymbolFlags.Property;\r\n+                excludes = SymbolFlags.PropertyExcludes;\r\n+            }\r\n         }\r",
        "comment_created_at": "2025-05-02T21:57:30+00:00",
        "comment_author": "sandersn",
        "comment_body": "Copilot, we are waaaaaaay past any kind of intent being clear to *anybody* in this code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1387257283",
    "pr_number": 48889,
    "pr_file": "src/compiler/tsbuildPublic.ts",
    "created_at": "2023-11-08T22:14:26+00:00",
    "commented_code": ");\r\n     }\r\n \r\n+    function getPackageJsonsFromConfig(state: SolutionBuilderState, resolved: ResolvedConfigFileName, parsed: ParsedCommandLine): string[] {\r\n+        const result: string[] = [getPackageJsonPathFromConfig(state, resolved)];\r\n+        parsed.projectReferences?.forEach(ref => result.push(getPackageJsonPathFromConfig(state, resolveProjectName(state, ref.path))));\r\n+        return result;\r\n+    }\r\n+\r\n+    function getPackageJsonPathFromConfig(state: SolutionBuilderState, resolved: ResolvedConfigFileName) {\r\n+        const { resolvedPackageJsonPaths } = state;\r\n+        const path = resolvedPackageJsonPaths.get(resolved);\r\n+        if (path !== undefined) return path;\r\n+\r\n+        const packageJsonPath = combinePaths(getDirectoryPath(resolved), \"package.json\");\r\n+        resolvedPackageJsonPaths.set(resolved, packageJsonPath);\r\n+        return packageJsonPath;\r\n+    }\r\n+\r\n     function watchPackageJsonFiles(state: SolutionBuilderState, resolved: ResolvedConfigFileName, resolvedPath: ResolvedConfigFilePath, parsed: ParsedCommandLine) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1387257283",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 48889,
        "pr_file": "src/compiler/tsbuildPublic.ts",
        "discussion_id": "1387257283",
        "commented_code": "@@ -2164,23 +2167,44 @@ namespace ts {\n         );\r\n     }\r\n \r\n+    function getPackageJsonsFromConfig(state: SolutionBuilderState, resolved: ResolvedConfigFileName, parsed: ParsedCommandLine): string[] {\r\n+        const result: string[] = [getPackageJsonPathFromConfig(state, resolved)];\r\n+        parsed.projectReferences?.forEach(ref => result.push(getPackageJsonPathFromConfig(state, resolveProjectName(state, ref.path))));\r\n+        return result;\r\n+    }\r\n+\r\n+    function getPackageJsonPathFromConfig(state: SolutionBuilderState, resolved: ResolvedConfigFileName) {\r\n+        const { resolvedPackageJsonPaths } = state;\r\n+        const path = resolvedPackageJsonPaths.get(resolved);\r\n+        if (path !== undefined) return path;\r\n+\r\n+        const packageJsonPath = combinePaths(getDirectoryPath(resolved), \"package.json\");\r\n+        resolvedPackageJsonPaths.set(resolved, packageJsonPath);\r\n+        return packageJsonPath;\r\n+    }\r\n+\r\n     function watchPackageJsonFiles(state: SolutionBuilderState, resolved: ResolvedConfigFileName, resolvedPath: ResolvedConfigFilePath, parsed: ParsedCommandLine) {\r",
        "comment_created_at": "2023-11-08T22:14:26+00:00",
        "comment_author": "Mifrill",
        "comment_body": "Could you please specify the return type for this function?",
        "pr_file_module": null
      }
    ]
  }
]