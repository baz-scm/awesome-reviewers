[
  {
    "discussion_id": "348159109",
    "pr_number": 35206,
    "pr_file": "src/compiler/moduleNameResolver.ts",
    "created_at": "2019-11-19T20:50:13+00:00",
    "commented_code": "/**\r\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\r\n-     * Returns undefined if there are none.\r\n      */\r\n-    function getDefaultTypeRoots(currentDirectory: string, host: { directoryExists?: (directoryName: string) => boolean }): string[] | undefined {\r\n+    function getNodeModulesTypeRoots(currentDirectory: string, host: { directoryExists?: (directoryName: string) => boolean }) {\r\n         if (!host.directoryExists) {\r\n             return [combinePaths(currentDirectory, nodeModulesAtTypes)];\r\n             // And if it doesn't exist, tough.\r\n         }\r\n \r\n-        let typeRoots: string[] | undefined;\r\n+        const typeRoots: string[] = [];\r\n         forEachAncestorDirectory(normalizePath(currentDirectory), directory => {\r\n             const atTypes = combinePaths(directory, nodeModulesAtTypes);\r\n             if (host.directoryExists!(atTypes)) {\r\n-                (typeRoots || (typeRoots = [])).push(atTypes);\r\n+                typeRoots.push(atTypes);\r\n             }\r\n             return undefined;\r\n         });\r\n+\r\n         return typeRoots;\r\n     }\r\n     const nodeModulesAtTypes = combinePaths(\"node_modules\", \"@types\");\r\n \r\n+    function getPnpTypeRoots(currentDirectory: string) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "348159109",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 35206,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "348159109",
        "commented_code": "@@ -259,26 +259,56 @@ namespace ts {\n \r\n     /**\r\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\r\n-     * Returns undefined if there are none.\r\n      */\r\n-    function getDefaultTypeRoots(currentDirectory: string, host: { directoryExists?: (directoryName: string) => boolean }): string[] | undefined {\r\n+    function getNodeModulesTypeRoots(currentDirectory: string, host: { directoryExists?: (directoryName: string) => boolean }) {\r\n         if (!host.directoryExists) {\r\n             return [combinePaths(currentDirectory, nodeModulesAtTypes)];\r\n             // And if it doesn't exist, tough.\r\n         }\r\n \r\n-        let typeRoots: string[] | undefined;\r\n+        const typeRoots: string[] = [];\r\n         forEachAncestorDirectory(normalizePath(currentDirectory), directory => {\r\n             const atTypes = combinePaths(directory, nodeModulesAtTypes);\r\n             if (host.directoryExists!(atTypes)) {\r\n-                (typeRoots || (typeRoots = [])).push(atTypes);\r\n+                typeRoots.push(atTypes);\r\n             }\r\n             return undefined;\r\n         });\r\n+\r\n         return typeRoots;\r\n     }\r\n     const nodeModulesAtTypes = combinePaths(\"node_modules\", \"@types\");\r\n \r\n+    function getPnpTypeRoots(currentDirectory: string) {\r",
        "comment_created_at": "2019-11-19T20:50:13+00:00",
        "comment_author": "arcanis",
        "comment_body": "Under PnP environments, the packages are installed like this:\r\n\r\n```\r\n/project/.yarn/cache/@types-foo-1.0.0.zip/node_modules/@types/foo/package.json\r\n/project/.yarn/cache/@types-bar-1.0.0.zip/node_modules/@types/bar/package.json\r\n/project/.yarn/cache/@types-baz-1.0.0.zip/node_modules/@types/baz/package.json\r\n```\r\n\r\nThis function obtains the location of all `@types` dependencies, then retrieve their parent directories to build up to a list of N type roots which each contain a single package (instead of a single type roots that contains N packages as you'd get with typical installs).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "348160967",
    "pr_number": 35206,
    "pr_file": "src/compiler/moduleNameResolver.ts",
    "created_at": "2019-11-19T20:53:48+00:00",
    "commented_code": "}\r\n                 let result: Resolved | undefined;\r\n                 if (!isExternalModuleNameRelative(typeReferenceDirectiveName)) {\r\n-                    const searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\r\n+                    const searchResult = isPnpAvailable()\r\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\r\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "348160967",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 35206,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "348160967",
        "commented_code": "@@ -374,7 +404,10 @@ namespace ts {\n                 }\r\n                 let result: Resolved | undefined;\r\n                 if (!isExternalModuleNameRelative(typeReferenceDirectiveName)) {\r\n-                    const searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\r\n+                    const searchResult = isPnpAvailable()\r\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\r\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\r",
        "comment_created_at": "2019-11-19T20:53:48+00:00",
        "comment_author": "arcanis",
        "comment_body": "This only affects projects using PnP projects (because of the `isPnpAvailable` check).\r\n\r\nThe reason I went with a branch rather than a fallback is because I'm worried of potential resolution corruptions that would happen if for example someone installs a project with Yarn 1 (which would generate a node_modules) then Yarn 2. In this situation, a fallback could get passing results that would fail on pure Yarn 2 systems (because of hoisting).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "683139533",
    "pr_number": 35206,
    "pr_file": "src/server/project.ts",
    "created_at": "2021-08-05T05:28:36+00:00",
    "commented_code": "}\r\n \r\n         updateReferences(refs: readonly ProjectReference[] | undefined) {\r\n+            // @ts-ignore\r\n+            if (process.versions.pnp) {\r\n+                // With Plug'n'Play, dependencies that list peer dependencies\r\n+                // are \"virtualized\": they are resolved to a unique (virtual)\r\n+                // path that the underlying filesystem layer then resolve back\r\n+                // to the original location.\r\n+                //\r\n+                // When a workspace depends on another workspace with peer\r\n+                // dependencies, this other workspace will thus be resolved to\r\n+                // a unique path that won't match what the initial project has\r\n+                // listed in its `references` field, and TS thus won't leverage\r\n+                // the reference at all.\r\n+                //\r\n+                // To avoid that, we compute here the virtualized paths for the\r\n+                // user-provided references in our references by directly querying\r\n+                // the PnP API. This way users don't have to know the virtual paths,\r\n+                // but we still support them just fine even through references.\r\n+\r\n+                const pnpApi = require(\"pnpapi\");\r\n+                const basePath = this.getCurrentDirectory();\r\n+\r\n+                const getPnpPath = (path: string) => {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "683139533",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 35206,
        "pr_file": "src/server/project.ts",
        "discussion_id": "683139533",
        "commented_code": "@@ -2212,6 +2212,40 @@ namespace ts.server {\n         }\r\n \r\n         updateReferences(refs: readonly ProjectReference[] | undefined) {\r\n+            // @ts-ignore\r\n+            if (process.versions.pnp) {\r\n+                // With Plug'n'Play, dependencies that list peer dependencies\r\n+                // are \"virtualized\": they are resolved to a unique (virtual)\r\n+                // path that the underlying filesystem layer then resolve back\r\n+                // to the original location.\r\n+                //\r\n+                // When a workspace depends on another workspace with peer\r\n+                // dependencies, this other workspace will thus be resolved to\r\n+                // a unique path that won't match what the initial project has\r\n+                // listed in its `references` field, and TS thus won't leverage\r\n+                // the reference at all.\r\n+                //\r\n+                // To avoid that, we compute here the virtualized paths for the\r\n+                // user-provided references in our references by directly querying\r\n+                // the PnP API. This way users don't have to know the virtual paths,\r\n+                // but we still support them just fine even through references.\r\n+\r\n+                const pnpApi = require(\"pnpapi\");\r\n+                const basePath = this.getCurrentDirectory();\r\n+\r\n+                const getPnpPath = (path: string) => {\r",
        "comment_created_at": "2021-08-05T05:28:36+00:00",
        "comment_author": "sushruth",
        "comment_body": "EDIT: the suggestion below is wrong and was based on wrong assumptions. After some more analysis I have proposed a better solution here - https://github.com/arcanis/TypeScript/pull/10\r\n\r\n## Note - information below is false and I am only keeping it for history.\r\n\r\n@arcanis - This function is causing tsconfig references to fail to load right now in yarn `3.0.0`. pnpApi always seems to return the project root when `path` is absolute and lies within the `workspace:.` path. This is causing tsconfig.json files with referenced config json files within the workspace, to be invalid, only in tsserver somehow.\r\n\r\nI tried and succeeded in fixing this issue locally by unplugging typescript and making a slight modification to this function -\r\n\r\n```ts\r\nconst getPnpPath = (path: string) => {\r\n    if (pathIsAbsolute(path)) return path; // intended compiled code - `if (ts.pathIsAbsolute(path)) return path;`\r\n    try {\r\n        const targetLocator = pnpApi.findPackageLocator(`${path}/`);\r\n        return pnpApi.resolveToUnqualified(targetLocator.name, `${basePath}/`);\r\n    } catch {\r\n        // something went wrong with the resolution, try not to fail\r\n        return path;\r\n    }\r\n};\r\n```\r\n\r\nplease consider making this change or add a better solution for this issue\r\n\r\nThanks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "833540082",
    "pr_number": 48386,
    "pr_file": "src/compiler/moduleNameResolver.ts",
    "created_at": "2022-03-23T17:28:07+00:00",
    "commented_code": "}\r\n         const conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? [\"node\", \"import\", \"types\"] : [\"node\", \"require\", \"types\"] : [];\r\n         const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled, failedLookupLocations, packageJsonInfoCache: cache, features, conditions };\r\n-        let resolved = primaryLookup();\r\n+        const loader: ResolutionKindSpecificLoader = (extensions, candidate, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n+        const optional = tryLoadModuleUsingOptionalResolutionSettings(Extensions.DtsOnly, typeReferenceDirectiveName, containingDirectory || \"\", loader, moduleResolutionState);",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "833540082",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 48386,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "833540082",
        "commented_code": "@@ -354,7 +354,10 @@ namespace ts {\n         }\r\n         const conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? [\"node\", \"import\", \"types\"] : [\"node\", \"require\", \"types\"] : [];\r\n         const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled, failedLookupLocations, packageJsonInfoCache: cache, features, conditions };\r\n-        let resolved = primaryLookup();\r\n+        const loader: ResolutionKindSpecificLoader = (extensions, candidate, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n+        const optional = tryLoadModuleUsingOptionalResolutionSettings(Extensions.DtsOnly, typeReferenceDirectiveName, containingDirectory || \"\", loader, moduleResolutionState);\r",
        "comment_created_at": "2022-03-23T17:28:07+00:00",
        "comment_author": "sheetalkamat",
        "comment_body": "Well paths uses baseUrl.. And then `tryLoadModuleUsingOptionalResolutionSettings` has some baseUrl and rootDirs logic as well.. wouldnt we want typeRoots instead of baseUrl and probably rootDirs as well for type reference directive \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "833620823",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 48386,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "833540082",
        "commented_code": "@@ -354,7 +354,10 @@ namespace ts {\n         }\r\n         const conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? [\"node\", \"import\", \"types\"] : [\"node\", \"require\", \"types\"] : [];\r\n         const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled, failedLookupLocations, packageJsonInfoCache: cache, features, conditions };\r\n-        let resolved = primaryLookup();\r\n+        const loader: ResolutionKindSpecificLoader = (extensions, candidate, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n+        const optional = tryLoadModuleUsingOptionalResolutionSettings(Extensions.DtsOnly, typeReferenceDirectiveName, containingDirectory || \"\", loader, moduleResolutionState);\r",
        "comment_created_at": "2022-03-23T18:56:03+00:00",
        "comment_author": "weswigham",
        "comment_body": "I don't think that's the case? Generally, the model we all have is that `///<reference types=` resolves exactly like an `import` statement does. An import statement uses the full `tryLoadModuleUsingOptionalResolutionSettings` function, so I think we also should use it here.\r\n\r\n(Plus, `typeRoots` is already explicitly handled when looking up `@types` names inside `primaryLookup`)",
        "pr_file_module": null
      },
      {
        "comment_id": "833622998",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 48386,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "833540082",
        "commented_code": "@@ -354,7 +354,10 @@ namespace ts {\n         }\r\n         const conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? [\"node\", \"import\", \"types\"] : [\"node\", \"require\", \"types\"] : [];\r\n         const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled, failedLookupLocations, packageJsonInfoCache: cache, features, conditions };\r\n-        let resolved = primaryLookup();\r\n+        const loader: ResolutionKindSpecificLoader = (extensions, candidate, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n+        const optional = tryLoadModuleUsingOptionalResolutionSettings(Extensions.DtsOnly, typeReferenceDirectiveName, containingDirectory || \"\", loader, moduleResolutionState);\r",
        "comment_created_at": "2022-03-23T18:58:44+00:00",
        "comment_author": "weswigham",
        "comment_body": "I think the only \ud83e\udd37\u200d\u2640\ufe0f\u2753\ud83e\udd37\u200d\u2640\ufe0f kinda thing is weather a `typeRoots` resolution should have priority over a `paths`/`baseUrl` one or not. I'd argue that `paths` and `baseUrl` are more specific compiler options, so should have priority (hence this placement).",
        "pr_file_module": null
      },
      {
        "comment_id": "833712365",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 48386,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "833540082",
        "commented_code": "@@ -354,7 +354,10 @@ namespace ts {\n         }\r\n         const conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? [\"node\", \"import\", \"types\"] : [\"node\", \"require\", \"types\"] : [];\r\n         const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled, failedLookupLocations, packageJsonInfoCache: cache, features, conditions };\r\n-        let resolved = primaryLookup();\r\n+        const loader: ResolutionKindSpecificLoader = (extensions, candidate, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n+        const optional = tryLoadModuleUsingOptionalResolutionSettings(Extensions.DtsOnly, typeReferenceDirectiveName, containingDirectory || \"\", loader, moduleResolutionState);\r",
        "comment_created_at": "2022-03-23T20:51:58+00:00",
        "comment_author": "sheetalkamat",
        "comment_body": "But typeRoots also is in compilerOption and i think is set when user prefers to resolve type reference directive from certain location.. When not set i agree that it baseUrl makes sense",
        "pr_file_module": null
      },
      {
        "comment_id": "833770837",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 48386,
        "pr_file": "src/compiler/moduleNameResolver.ts",
        "discussion_id": "833540082",
        "commented_code": "@@ -354,7 +354,10 @@ namespace ts {\n         }\r\n         const conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? [\"node\", \"import\", \"types\"] : [\"node\", \"require\", \"types\"] : [];\r\n         const moduleResolutionState: ModuleResolutionState = { compilerOptions: options, host, traceEnabled, failedLookupLocations, packageJsonInfoCache: cache, features, conditions };\r\n-        let resolved = primaryLookup();\r\n+        const loader: ResolutionKindSpecificLoader = (extensions, candidate, onlyRecordFailures, state) => nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true);\r\n+        const optional = tryLoadModuleUsingOptionalResolutionSettings(Extensions.DtsOnly, typeReferenceDirectiveName, containingDirectory || \"\", loader, moduleResolutionState);\r",
        "comment_created_at": "2022-03-23T22:25:12+00:00",
        "comment_author": "weswigham",
        "comment_body": "Yeah, but `typeRoots` a list of potential directories, while `paths` is exact matches and `baseUrl` is a single directory. That's why `paths` > `baseUrl` > `typeRoots` makes sense to me. (`typeRoots` will never conflict with `rootDirs` as it were because `typeRoots` are only relevant for non-relative names, while `rootDirs` are only relevant for relative names)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1774227251",
    "pr_number": 60039,
    "pr_file": "src/compiler/program.ts",
    "created_at": "2024-09-24T23:45:39+00:00",
    "commented_code": "/** @internal Prefer `program.getImpliedNodeFormatForEmit` when possible. */\r\n export function getImpliedNodeFormatForEmitWorker(sourceFile: Pick<SourceFile, \"fileName\" | \"impliedNodeFormat\" | \"packageJsonScope\">, options: CompilerOptions): ResolutionMode {\r\n     const moduleKind = getEmitModuleKind(options);\r\n-    if (ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext) {\r\n-        return sourceFile.impliedNodeFormat;\r\n-    }\r\n     if (\r\n-        sourceFile.impliedNodeFormat === ModuleKind.CommonJS\r\n-        && (sourceFile.packageJsonScope?.contents.packageJsonContent.type === \"commonjs\"\r\n-            || fileExtensionIsOneOf(sourceFile.fileName, [Extension.Cjs, Extension.Cts]))\r\n+        ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext\r\n+        || fileExtensionIsOneOf(sourceFile.fileName, [Extension.Cts, Extension.Dcts, Extension.Cjs, Extension.Mts, Extension.Dmts, Extension.Mjs])\r\n+        || pathContainsNodeModules(sourceFile.fileName)",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1774227251",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60039,
        "pr_file": "src/compiler/program.ts",
        "discussion_id": "1774227251",
        "commented_code": "@@ -5254,24 +5249,13 @@ export function getEmitModuleFormatOfFileWorker(sourceFile: Pick<SourceFile, \"fi\n /** @internal Prefer `program.getImpliedNodeFormatForEmit` when possible. */\r\n export function getImpliedNodeFormatForEmitWorker(sourceFile: Pick<SourceFile, \"fileName\" | \"impliedNodeFormat\" | \"packageJsonScope\">, options: CompilerOptions): ResolutionMode {\r\n     const moduleKind = getEmitModuleKind(options);\r\n-    if (ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext) {\r\n-        return sourceFile.impliedNodeFormat;\r\n-    }\r\n     if (\r\n-        sourceFile.impliedNodeFormat === ModuleKind.CommonJS\r\n-        && (sourceFile.packageJsonScope?.contents.packageJsonContent.type === \"commonjs\"\r\n-            || fileExtensionIsOneOf(sourceFile.fileName, [Extension.Cjs, Extension.Cts]))\r\n+        ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext\r\n+        || fileExtensionIsOneOf(sourceFile.fileName, [Extension.Cts, Extension.Dcts, Extension.Cjs, Extension.Mts, Extension.Dmts, Extension.Mjs])\r\n+        || pathContainsNodeModules(sourceFile.fileName)\r",
        "comment_created_at": "2024-09-24T23:45:39+00:00",
        "comment_author": "sheetalkamat",
        "comment_body": "wouldn't this be problem for files that are symlinks from node_modules to path without node_modules?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1804355417",
    "pr_number": 57718,
    "pr_file": "src/harness/vfsUtil.ts",
    "created_at": "2024-10-17T08:40:03+00:00",
    "commented_code": "for (const key of Object.keys(files)) {\r\n             const value = normalizeFileSetEntry(files[key]);\r\n             const path = dirname ? vpath.resolve(dirname, key) : key;\r\n-            vpath.validate(path, vpath.ValidationFlags.Absolute);\r\n+            vpath.validate(path, vpath.ValidationFlags.Absolute | vpath.ValidationFlags.AllowWildcard);",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1804355417",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 57718,
        "pr_file": "src/harness/vfsUtil.ts",
        "discussion_id": "1804355417",
        "commented_code": "@@ -1148,7 +1148,7 @@ export class FileSystem {\n         for (const key of Object.keys(files)) {\r\n             const value = normalizeFileSetEntry(files[key]);\r\n             const path = dirname ? vpath.resolve(dirname, key) : key;\r\n-            vpath.validate(path, vpath.ValidationFlags.Absolute);\r\n+            vpath.validate(path, vpath.ValidationFlags.Absolute | vpath.ValidationFlags.AllowWildcard);\r",
        "comment_created_at": "2024-10-17T08:40:03+00:00",
        "comment_author": "Andarist",
        "comment_body": "I have no idea if this is completely correct. I added it to make [pathCompletionsPackageJsonImportsSrcNoDistWildcard6](https://github.com/microsoft/TypeScript/blob/a80cdfaf5aee37250ae5cfae3d374f8773bd1dd4/tests/cases/fourslash/server/pathCompletionsPackageJsonImportsSrcNoDistWildcard6.ts) pass as it's using `?` in the component path component. \r\n\r\nI have added that test based on the existing [pathCompletionsPackageJsonExportsWildcard6](https://github.com/microsoft/TypeScript/blob/b8e4ed8aeb0b228f544c5736908c31f136a9f7e3/tests/cases/fourslash/pathCompletionsPackageJsonExportsWildcard6.ts). The difference is that the test I have added is a `fourslash/server` test and it follows a slightly different codepath.\r\n\r\nThe existing one validates here:\r\nhttps://github.com/microsoft/TypeScript/blob/b8e4ed8aeb0b228f544c5736908c31f136a9f7e3/src/harness/vfsUtil.ts#L1104-L1108\r\n\r\nAnd the `ValidationFlags.AllowWildcard` was added there [here](https://github.com/microsoft/TypeScript/pull/24076/files#diff-effd49d37f377e1f194f7ceaddf609b1d5eb60744ad741cf4e43e11e6878f79dR872-R873)\r\n\r\nOn the other hand, the `fourslash/server` validates here, where I'm adding this comment. This codepath was added as part of https://github.com/microsoft/TypeScript/pull/20763 - which proceeds the PR that introduced `ValidationFlags.AllowWildcard`. So perhaps this was just a harmless omission in that newer PR. I don't know why this is a flag in the first place though so \ud83e\udd37\u200d\u2642\ufe0f ",
        "pr_file_module": null
      },
      {
        "comment_id": "1805000742",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 57718,
        "pr_file": "src/harness/vfsUtil.ts",
        "discussion_id": "1804355417",
        "commented_code": "@@ -1148,7 +1148,7 @@ export class FileSystem {\n         for (const key of Object.keys(files)) {\r\n             const value = normalizeFileSetEntry(files[key]);\r\n             const path = dirname ? vpath.resolve(dirname, key) : key;\r\n-            vpath.validate(path, vpath.ValidationFlags.Absolute);\r\n+            vpath.validate(path, vpath.ValidationFlags.Absolute | vpath.ValidationFlags.AllowWildcard);\r",
        "comment_created_at": "2024-10-17T15:30:40+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "@rbuckton can you advise?",
        "pr_file_module": null
      }
    ]
  }
]