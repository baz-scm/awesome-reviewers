[
  {
    "discussion_id": "1134367886",
    "pr_number": 50951,
    "pr_file": "src/compiler/utilitiesPublic.ts",
    "created_at": "2023-03-13T17:26:43+00:00",
    "commented_code": "}\r\n }\r\n \r\n-function getJSDocParameterTagsWorker(param: ParameterDeclaration, noCache?: boolean): readonly JSDocParameterTag[] {\r\n-    if (param.name) {\r\n-        if (isIdentifier(param.name)) {\r\n-            const name = param.name.escapedText;\r\n-            return getJSDocTagsWorker(param.parent, noCache).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);\r\n+function getJSDocParameterTagsWorker(node: ParameterDeclaration | BindingElement, noCache?: boolean): readonly JSDocParameterTag[] {\r\n+    const declaration = getRootDeclaration(node);\r\n+    if (isParameter(declaration)) {\r\n+        const name = node.name;",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1134367886",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 50951,
        "pr_file": "src/compiler/utilitiesPublic.ts",
        "discussion_id": "1134367886",
        "commented_code": "@@ -956,19 +957,22 @@ export function getModifiers(node: HasModifiers): readonly Modifier[] | undefine\n     }\r\n }\r\n \r\n-function getJSDocParameterTagsWorker(param: ParameterDeclaration, noCache?: boolean): readonly JSDocParameterTag[] {\r\n-    if (param.name) {\r\n-        if (isIdentifier(param.name)) {\r\n-            const name = param.name.escapedText;\r\n-            return getJSDocTagsWorker(param.parent, noCache).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);\r\n+function getJSDocParameterTagsWorker(node: ParameterDeclaration | BindingElement, noCache?: boolean): readonly JSDocParameterTag[] {\r\n+    const declaration = getRootDeclaration(node);\r\n+    if (isParameter(declaration)) {\r\n+        const name = node.name;\r",
        "comment_created_at": "2023-03-13T17:26:43+00:00",
        "comment_author": "gabritto",
        "comment_body": "I think you need to account for the case where `node` is a `BindingElement` with a `propertyName`, because then the actual name of the parameter that should be used in the jsdoc annotation is the `propertyName`, not the `name`. Like in this example:\r\n\r\n```ts\r\n/**\r\n * @param a ...\r\n */\r\nfunction foo({ a: newA }) {...}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1134421018",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 50951,
        "pr_file": "src/compiler/utilitiesPublic.ts",
        "discussion_id": "1134367886",
        "commented_code": "@@ -956,19 +957,22 @@ export function getModifiers(node: HasModifiers): readonly Modifier[] | undefine\n     }\r\n }\r\n \r\n-function getJSDocParameterTagsWorker(param: ParameterDeclaration, noCache?: boolean): readonly JSDocParameterTag[] {\r\n-    if (param.name) {\r\n-        if (isIdentifier(param.name)) {\r\n-            const name = param.name.escapedText;\r\n-            return getJSDocTagsWorker(param.parent, noCache).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);\r\n+function getJSDocParameterTagsWorker(node: ParameterDeclaration | BindingElement, noCache?: boolean): readonly JSDocParameterTag[] {\r\n+    const declaration = getRootDeclaration(node);\r\n+    if (isParameter(declaration)) {\r\n+        const name = node.name;\r",
        "comment_created_at": "2023-03-13T18:02:31+00:00",
        "comment_author": "a-tarasyuk",
        "comment_body": "I think `name` refers to [renamed identifier](https://ts-ast-viewer.com/#code/GYVwdgxgLglg9mABMMAKA3oghgLkWAUwHcBBRAXwEpF1yg)",
        "pr_file_module": null
      },
      {
        "comment_id": "1134433500",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 50951,
        "pr_file": "src/compiler/utilitiesPublic.ts",
        "discussion_id": "1134367886",
        "commented_code": "@@ -956,19 +957,22 @@ export function getModifiers(node: HasModifiers): readonly Modifier[] | undefine\n     }\r\n }\r\n \r\n-function getJSDocParameterTagsWorker(param: ParameterDeclaration, noCache?: boolean): readonly JSDocParameterTag[] {\r\n-    if (param.name) {\r\n-        if (isIdentifier(param.name)) {\r\n-            const name = param.name.escapedText;\r\n-            return getJSDocTagsWorker(param.parent, noCache).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);\r\n+function getJSDocParameterTagsWorker(node: ParameterDeclaration | BindingElement, noCache?: boolean): readonly JSDocParameterTag[] {\r\n+    const declaration = getRootDeclaration(node);\r\n+    if (isParameter(declaration)) {\r\n+        const name = node.name;\r",
        "comment_created_at": "2023-03-13T18:11:42+00:00",
        "comment_author": "gabritto",
        "comment_body": "Yes, in the example above, `name` is `newA` and `propertyName` is `a`. So I think the @param annotation should use `a` instead of `newA`, right? So it should be using the `propertyName` identifier in that case, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "1134570537",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 50951,
        "pr_file": "src/compiler/utilitiesPublic.ts",
        "discussion_id": "1134367886",
        "commented_code": "@@ -956,19 +957,22 @@ export function getModifiers(node: HasModifiers): readonly Modifier[] | undefine\n     }\r\n }\r\n \r\n-function getJSDocParameterTagsWorker(param: ParameterDeclaration, noCache?: boolean): readonly JSDocParameterTag[] {\r\n-    if (param.name) {\r\n-        if (isIdentifier(param.name)) {\r\n-            const name = param.name.escapedText;\r\n-            return getJSDocTagsWorker(param.parent, noCache).filter((tag): tag is JSDocParameterTag => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);\r\n+function getJSDocParameterTagsWorker(node: ParameterDeclaration | BindingElement, noCache?: boolean): readonly JSDocParameterTag[] {\r\n+    const declaration = getRootDeclaration(node);\r\n+    if (isParameter(declaration)) {\r\n+        const name = node.name;\r",
        "comment_created_at": "2023-03-13T20:17:30+00:00",
        "comment_author": "a-tarasyuk",
        "comment_body": "I thought we needed to use a new name :(. Fixed. Thanks for the help.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1776007557",
    "pr_number": 59661,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2024-09-25T21:21:40+00:00",
    "commented_code": "errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString);\r\n     }\r\n \r\n+    function reportErrorsFromWideningWithContextualSignature(declaration: FunctionLikeDeclaration, wideningKind: WideningKind) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1776007557",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 59661,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1776007557",
        "commented_code": "@@ -25535,12 +25535,40 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n         errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString);\r\n     }\r\n \r\n+    function reportErrorsFromWideningWithContextualSignature(declaration: FunctionLikeDeclaration, wideningKind: WideningKind) {\r",
        "comment_created_at": "2024-09-25T21:21:40+00:00",
        "comment_author": "jakebailey",
        "comment_body": "Rename to `shouldReportErrorsFromWideningWithContextualSignature` given this returns a boolean, it doesn't actually report?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1799812783",
    "pr_number": 60173,
    "pr_file": "src/services/refactors/moveToFile.ts",
    "created_at": "2024-10-14T16:41:05+00:00",
    "commented_code": "}\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1799812783",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-14T16:41:05+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "I'm having trouble wrapping my head around this function, I think because it takes a symbol but only uses it for its name. Do the function name and parameters need to be tweaked a bit to better reflect what this is trying to accomplish?",
        "pr_file_module": null
      },
      {
        "comment_id": "1799910332",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-14T18:05:07+00:00",
        "comment_author": "iisaduan",
        "comment_body": "Is there another way to check if a symbol refers to a global, and can be checked reliably after symbol merging/through aliasing? I guess this function doesn't need a Symbol to be passed in as it currently is, but I couldn't think of a better way to do this check for globals.\r\n\r\nThe old code was checking if there was _any_ global symbol with that name that was a type without seeing first if there was a local symbol with that name. The function name seems alright to me since it's checking if, at this node, the symbol refers to a global type.",
        "pr_file_module": null
      },
      {
        "comment_id": "1799920893",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-14T18:16:46+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "> The function name seems alright to me since it's checking if, at this node, **the symbol** refers to a global type\r\n\r\nIt’s checking if _a given name_ refers to a global type; it’s not really checking anything about _the symbol_ that’s being passed in. If you wanted to check whether the symbol itself is a type that is accessible as a global at a particular location, you might check for equality between the `symbol` and the `resolveName` result. But I’m not sure that’s relevant here.\r\n\r\nBut the line added here seems to allow for a false negative of the simple question “does this name refer to a global type.” Just because a name resolves to a local value doesn’t mean it doesn’t also resolve to a global type at the same location:\r\n\r\n```ts\r\nconst Event = {};\r\nlet e: Event; // <--\r\n```\r\n\r\nIf you pass in the node for the `Event` type, `isGlobalType` will return false. That feels like the wrong answer just reading the function name, even if it has the desired behavior for Move To File (does it?).",
        "pr_file_module": null
      },
      {
        "comment_id": "1799961078",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-14T19:00:49+00:00",
        "comment_author": "iisaduan",
        "comment_body": "> But the line added here seems to allow for a false negative of the simple question “does this name refer to a global type.” Just because a name resolves to a local value doesn’t mean it doesn’t also resolve to a global type at the same location:\r\n\r\nThe correct check to have here is if the _symbol_ refers to a global type or not, and the previous check did not do that (and seems like the previous check wanted to check the symbol, given that they took a symbol instead of just the name).\r\n\r\n> even if it has the desired behavior for Move To File (does it?).\r\n\r\nIt makes sense to me that if we try to move a symbol that references a local definition, but also happens to have an unrelated global definition, that we keep the reference in the new location as the same symbol that was in the original file. Otherwise, the code in the new file can be broken, like in the bug report above.  I spoke to @navya9singh about this, and we concluded that we should generate the import to keep the original reference. Also, other codefixes keep local references across files, even if the symbol resolves to a global (added test to show this).",
        "pr_file_module": null
      },
      {
        "comment_id": "1800221856",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-14T23:17:18+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "@andrewbranch am I correct that you're mostly not a fan of the function doing the following?\r\n\r\n1. taking a `Symbol` instead of a `string` (since all it needs is the name of the symbol)\r\n2. being named `isGlobalType`, since a type might not actually be declared in the global scope (so e.g. `cannotResolveTypeAt` would be a \"better\" name)",
        "pr_file_module": null
      },
      {
        "comment_id": "1800253008",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-15T00:06:29+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "Yes - I didn't recontextualize myself with the broader problem enough to tell whether the implementation/behavior is wrong; I can just tell from reading the function in isolation that something is a little fishy (specifically, your points above).",
        "pr_file_module": null
      },
      {
        "comment_id": "1800260126",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60173,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1799812783",
        "commented_code": "@@ -946,7 +946,8 @@ export function getUsageInfo(oldFile: SourceFile, toMove: readonly Statement[],\n     }\r\n }\r\n \r\n-function isGlobalType(checker: TypeChecker, symbol: Symbol) {\r\n+function isGlobalType(checker: TypeChecker, location: Node, symbol: Symbol) {\r\n+    if (checker.resolveName(symbol.name, location, SymbolFlags.All, /*excludeGlobals*/ true)) return false;\r\n     return !!checker.resolveName(symbol.name, /*location*/ undefined, SymbolFlags.Type, /*excludeGlobals*/ false);\r",
        "comment_created_at": "2024-10-15T00:18:36+00:00",
        "comment_author": "iisaduan",
        "comment_body": "@DanielRosenwasser @andrewbranch How do you feel about the new behavior? I can find a better way to do this check and/or rename the function if the new behavior makes sense. \r\n\r\nI can change the first part of this function to `skipAlias` (which in checker is `resolveSymbol`), but I think I'm confused because I've looked through the existing code, and I don't know how else to perform the second part of this check to find if there is a global without using the name resolver.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1657637813",
    "pr_number": 59004,
    "pr_file": "src/services/codefixes/importFixes.ts",
    "created_at": "2024-06-27T18:35:04+00:00",
    "commented_code": "}\r\n     }\r\n \r\n+    function addImportForExternalModuleSymbol(symbol: Symbol, originalSymbol: Symbol, isValidTypeOnlyUseSite: boolean) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1657637813",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 59004,
        "pr_file": "src/services/codefixes/importFixes.ts",
        "discussion_id": "1657637813",
        "commented_code": "@@ -356,6 +357,24 @@ function createImportAdderWorker(sourceFile: SourceFile | FutureSourceFile, prog\n         }\r\n     }\r\n \r\n+    function addImportForExternalModuleSymbol(symbol: Symbol, originalSymbol: Symbol, isValidTypeOnlyUseSite: boolean) {\r",
        "comment_created_at": "2024-06-27T18:35:04+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "`symbol`/`originalSymbol` are confusing names here. It looks like `originalSymbol` is the actual module symbol, and `symbol` is just an existing alias for the module that’s only being used to see what name to use. Instead, try just passing in the module symbol and the name you want to use?",
        "pr_file_module": null
      }
    ]
  }
]