[
  {
    "discussion_id": "1821254454",
    "pr_number": 56941,
    "pr_file": "tests/cases/compiler/unusedLocalsInRecursiveReturn.ts",
    "created_at": "2024-10-29T17:14:09+00:00",
    "commented_code": "+// @strict: true\r\n+// @noEmit: true\r\n+// @noUnusedLocals: true\r\n+\r\n+function recursive(arg: string, other: string) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1821254454",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 56941,
        "pr_file": "tests/cases/compiler/unusedLocalsInRecursiveReturn.ts",
        "discussion_id": "1821254454",
        "commented_code": "@@ -0,0 +1,8 @@\n+// @strict: true\r\n+// @noEmit: true\r\n+// @noUnusedLocals: true\r\n+\r\n+function recursive(arg: string, other: string) {\r",
        "comment_created_at": "2024-10-29T17:14:09+00:00",
        "comment_author": "sandersn",
        "comment_body": "this looks like it's testing something else",
        "pr_file_module": null
      },
      {
        "comment_id": "1821278233",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 56941,
        "pr_file": "tests/cases/compiler/unusedLocalsInRecursiveReturn.ts",
        "discussion_id": "1821254454",
        "commented_code": "@@ -0,0 +1,8 @@\n+// @strict: true\r\n+// @noEmit: true\r\n+// @noUnusedLocals: true\r\n+\r\n+function recursive(arg: string, other: string) {\r",
        "comment_created_at": "2024-10-29T17:31:12+00:00",
        "comment_author": "gabritto",
        "comment_body": "In an earlier version, I was not unconditionally checking the return expression in `checkReturnStatement`. However, the expression should be checked even if we don't need to know its type, because it may contain errors and because we need to compute information for whether variables are used or not. The test shows the latter, and it's adapted from a break in the extended tests.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1039755787",
    "pr_number": 51511,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2022-12-05T15:37:48+00:00",
    "commented_code": "}\r\n \r\n     function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {\r\n+        const contextualType = getContextualType(node, /*contextFlags*/ undefined);\r\n+        const isContextualTypeDependent =",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1039755787",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 51511,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1039755787",
        "commented_code": "@@ -28417,6 +28417,96 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n     }\r\n \r\n     function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {\r\n+        const contextualType = getContextualType(node, /*contextFlags*/ undefined);\r\n+        const isContextualTypeDependent =\r",
        "comment_created_at": "2022-12-05T15:37:48+00:00",
        "comment_author": "Andarist",
        "comment_body": "Have you tried using `couldContainTypeVariables`? A comment for this function mentions this:\r\n```\r\n    // Return true if the given type could possibly reference a type parameter for which\r\n    // we perform type inference (i.e. a type parameter of a generic function). We cache\r\n    // results for union and intersection types for performance reasons.\r\n```\r\n\r\nIt sounds like **maybe** you could reuse it",
        "pr_file_module": null
      },
      {
        "comment_id": "1039867776",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 51511,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1039755787",
        "commented_code": "@@ -28417,6 +28417,96 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n     }\r\n \r\n     function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {\r\n+        const contextualType = getContextualType(node, /*contextFlags*/ undefined);\r\n+        const isContextualTypeDependent =\r",
        "comment_created_at": "2022-12-05T17:13:54+00:00",
        "comment_author": "devanshj",
        "comment_body": "No because here we don't want to check if `X` has any type parameter, we want to check if `X` has a `T` type parameter. So using `isContextualTypeDependent = couldContainTypeVariable(contextualType.immediateConstraint)` would make it `true` for even `T extends F<U>` (`U` being some other type parameter) when it should have been `false` (as it's not `T extends F<T>`).",
        "pr_file_module": null
      },
      {
        "comment_id": "1039875379",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 51511,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1039755787",
        "commented_code": "@@ -28417,6 +28417,96 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n     }\r\n \r\n     function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {\r\n+        const contextualType = getContextualType(node, /*contextFlags*/ undefined);\r\n+        const isContextualTypeDependent =\r",
        "comment_created_at": "2022-12-05T17:20:03+00:00",
        "comment_author": "Andarist",
        "comment_body": "Right, but then perhaps that function could be extended with an optional argument, and this way you could limit the results to be based on the specific type param.",
        "pr_file_module": null
      },
      {
        "comment_id": "1039910613",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 51511,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1039755787",
        "commented_code": "@@ -28417,6 +28417,96 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n     }\r\n \r\n     function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {\r\n+        const contextualType = getContextualType(node, /*contextFlags*/ undefined);\r\n+        const isContextualTypeDependent =\r",
        "comment_created_at": "2022-12-05T17:57:50+00:00",
        "comment_author": "devanshj",
        "comment_body": "I thought about that but I think that's quite non-trivial because it's implemented keeping in mind that we're checking against any type parameter... So for example caching is a big part of this, right now because we're checking for any type parameter the cache is implemented simply as a `CouldContainTypeVariables` flag, but if we want to cache for `couldContainTypeVariables(type, typeParameters)` or even `couldContainTypeVariable(type, typeParameter)` it would require a lot of ceremony.\n\nEdit: I think you could implement `couldContainTypeVariable(type, typeParameter)`'s cache by simply memoizing via ids of the arguments, so it's not much of a ceremony, but I'm not convinced I want to change this already existing abstraction for my use-case. Might reconsider in future.",
        "pr_file_module": null
      },
      {
        "comment_id": "1061067753",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 51511,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1039755787",
        "commented_code": "@@ -28417,6 +28417,96 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n     }\r\n \r\n     function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {\r\n+        const contextualType = getContextualType(node, /*contextFlags*/ undefined);\r\n+        const isContextualTypeDependent =\r",
        "comment_created_at": "2023-01-04T01:08:27+00:00",
        "comment_author": "devanshj",
        "comment_body": "Btw I realised the implementation is seriouly true to it's name \"couldContainTypeVariable\" and not \"containsTypeVariable\". This function doesn't definitively checks if the type as a type parameter, it just kinda bets, for example if it's an anonymous object type it just bets it has a type parameter and doesn't check furthur inside it. So if it returns `true` that means the type either has a type parameter or doesn't have a type parameter, but if it return `false` then it the type definately doesn't have a type parameter. So one can write bailouts like `if (!couldContainTypeVariable(type)) return` can gain some optimization and still not give bad results.\r\n\r\nSo there's no way I can use this function here as I want a definitive result. And extending it's implementation to give a definitive result might not be trivial and definitately more complex and slow than the ast check I'm doing here.\r\n\r\nFun fact: While working on #52088 I overlooked the \"could\" in it's name knowing perfectly what it means and relied on it which produced bad results, finally when I looked at the implementation I saw that it really takes the \"could\" in it's name seriously :P",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "895043839",
    "pr_number": 49236,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2022-06-11T16:30:35+00:00",
    "commented_code": "}\r\n                     }\r\n                 }\r\n+                if (type && type!==anyType && isPropertyAccessExpression(callExpression.expression)){\r\n+                    // if (myDebug){\r\n+                    //     consoleLog(`narrowTypeByCallExpression[dbg,in]: ==== `);\r\n+                    // }\r\n+                    const tmpSymbol = getSymbolOfNameOrPropertyAccessExpression(callExpression.expression);\r\n+                    const declaration = tmpSymbol ? tmpSymbol.declarations? tmpSymbol.declarations[0] : undefined : undefined;\r\n+                    const funcNode = declaration && (declaration as any).type\r\n+                        && (declaration as any).type.kind === SyntaxKind.FunctionType\r\n+                        ? (declaration as any).type as FunctionDeclaration : undefined;\r\n+                    const funcRtnType = funcNode?.type ? getTypeOfNode(funcNode.type) : undefined;",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "895043839",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 49236,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "895043839",
        "commented_code": "@@ -25284,6 +25284,55 @@ namespace ts {\n                         }\r\n                     }\r\n                 }\r\n+                if (type && type!==anyType && isPropertyAccessExpression(callExpression.expression)){\r\n+                    // if (myDebug){\r\n+                    //     consoleLog(`narrowTypeByCallExpression[dbg,in]: ==== `);\r\n+                    // }\r\n+                    const tmpSymbol = getSymbolOfNameOrPropertyAccessExpression(callExpression.expression);\r\n+                    const declaration = tmpSymbol ? tmpSymbol.declarations? tmpSymbol.declarations[0] : undefined : undefined;\r\n+                    const funcNode = declaration && (declaration as any).type\r\n+                        && (declaration as any).type.kind === SyntaxKind.FunctionType\r\n+                        ? (declaration as any).type as FunctionDeclaration : undefined;\r\n+                    const funcRtnType = funcNode?.type ? getTypeOfNode(funcNode.type) : undefined;\r",
        "comment_created_at": "2022-06-11T16:30:35+00:00",
        "comment_author": "craigphicks",
        "comment_body": "Notice that the function return type `funcRtnType` is not being narrowed by the function argument types.  \r\n - In case of no arguments (as in the original bug post) this is not an issue.   \r\n - In the case where there are arguments, the argument types (evaluated as the point of alias definition), should be used along with the signature information to narrow the return type `funcRtnType`.  \r\n - Therefore, this \"fix\" is not complete until implementing the narrowing of  `funcRtnType`. \r\n - Nevertheless, as is, it resolves the posted bug. So the question is, merge this intermediate fix or wait until the narrowed `funcRtnType` is implemented?\r\n \r\n  @ahejlsberg what do you think?  ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1890954896",
    "pr_number": 60812,
    "pr_file": "src/compiler/path.ts",
    "created_at": "2024-12-18T23:36:09+00:00",
    "commented_code": "}\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1890954896",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60812,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890954896",
        "commented_code": "@@ -624,27 +624,103 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n }\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r",
        "comment_created_at": "2024-12-18T23:36:09+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "You should just use `lastIndexOf` to see if `altDirectorySeparator` occurs. That way you can avoid creating a substring for `root` at all.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1890980098",
    "pr_number": 60812,
    "pr_file": "src/compiler/path.ts",
    "created_at": "2024-12-19T00:17:32+00:00",
    "commented_code": "}\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const simple = simpleNormalizePath(path);\r\n+    if (simple !== undefined) {\r\n+        return simple;\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r\n+    let index = rootLength;\r\n+    let segmentStart = index;\r\n+    let normalizedUpTo = index;\r\n+    let seenNonDotDotSegment = rootLength !== 0;\r\n+    while (index < path.length) {\r\n+        // At beginning of segment\r\n+        segmentStart = index;\r\n+        let ch = path.charCodeAt(index);\r\n+        while (isAnyDirectorySeparator(ch) && index + 1 < path.length) {\r\n+            index++;\r\n+            ch = path.charCodeAt(index);\r\n+        }\r\n+        if (index > segmentStart) {\r\n+            if (normalized === undefined) {\r\n+                // Seen superfluous separator\r\n+                normalized = path.substring(0, segmentStart - 1);\r\n+            }\r\n+            segmentStart = index;\r\n+        }\r\n+        // Past any superfluous separators\r\n+        const sepIndex = path.indexOf(directorySeparator, index + 1);\r\n+        const altSepIndex = path.indexOf(altDirectorySeparator, index + 1);",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1890980098",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60812,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890980098",
        "commented_code": "@@ -624,12 +624,115 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n }\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const simple = simpleNormalizePath(path);\r\n+    if (simple !== undefined) {\r\n+        return simple;\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r\n+    let index = rootLength;\r\n+    let segmentStart = index;\r\n+    let normalizedUpTo = index;\r\n+    let seenNonDotDotSegment = rootLength !== 0;\r\n+    while (index < path.length) {\r\n+        // At beginning of segment\r\n+        segmentStart = index;\r\n+        let ch = path.charCodeAt(index);\r\n+        while (isAnyDirectorySeparator(ch) && index + 1 < path.length) {\r\n+            index++;\r\n+            ch = path.charCodeAt(index);\r\n+        }\r\n+        if (index > segmentStart) {\r\n+            if (normalized === undefined) {\r\n+                // Seen superfluous separator\r\n+                normalized = path.substring(0, segmentStart - 1);\r\n+            }\r\n+            segmentStart = index;\r\n+        }\r\n+        // Past any superfluous separators\r\n+        const sepIndex = path.indexOf(directorySeparator, index + 1);\r\n+        const altSepIndex = path.indexOf(altDirectorySeparator, index + 1);\r",
        "comment_created_at": "2024-12-19T00:17:32+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "This is quadratic because you have to find at least one of the other kinds of slashes over and over. You should just tight-loop on `!isAnyDirectorySeparator`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1893233381",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60812,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890980098",
        "commented_code": "@@ -624,12 +624,115 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n }\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const simple = simpleNormalizePath(path);\r\n+    if (simple !== undefined) {\r\n+        return simple;\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r\n+    let index = rootLength;\r\n+    let segmentStart = index;\r\n+    let normalizedUpTo = index;\r\n+    let seenNonDotDotSegment = rootLength !== 0;\r\n+    while (index < path.length) {\r\n+        // At beginning of segment\r\n+        segmentStart = index;\r\n+        let ch = path.charCodeAt(index);\r\n+        while (isAnyDirectorySeparator(ch) && index + 1 < path.length) {\r\n+            index++;\r\n+            ch = path.charCodeAt(index);\r\n+        }\r\n+        if (index > segmentStart) {\r\n+            if (normalized === undefined) {\r\n+                // Seen superfluous separator\r\n+                normalized = path.substring(0, segmentStart - 1);\r\n+            }\r\n+            segmentStart = index;\r\n+        }\r\n+        // Past any superfluous separators\r\n+        const sepIndex = path.indexOf(directorySeparator, index + 1);\r\n+        const altSepIndex = path.indexOf(altDirectorySeparator, index + 1);\r",
        "comment_created_at": "2024-12-19T22:51:36+00:00",
        "comment_author": "rbuckton",
        "comment_body": "or use `findIndex(path, isAnyDirectorySeparator, index + 1)`",
        "pr_file_module": null
      },
      {
        "comment_id": "1894295817",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60812,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890980098",
        "commented_code": "@@ -624,12 +624,115 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n }\r\n \r\n /** @internal */\r\n-export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+export function getNormalizedAbsolutePath(path: string, currentDirectory: string | undefined): string {\r\n+    let rootLength = getRootLength(path);\r\n+    if (rootLength === 0 && currentDirectory) {\r\n+        path = combinePaths(currentDirectory, path);\r\n+        rootLength = getRootLength(path);\r\n+    }\r\n+    const simple = simpleNormalizePath(path);\r\n+    if (simple !== undefined) {\r\n+        return simple;\r\n+    }\r\n+    const root = path.substring(0, rootLength);\r\n+    const normalizedRoot = root && normalizeSlashes(root);\r\n+    // `normalized` is only initialized once `path` is determined to be non-normalized\r\n+    let normalized = normalizedRoot === root ? undefined : normalizedRoot;\r\n+    let index = rootLength;\r\n+    let segmentStart = index;\r\n+    let normalizedUpTo = index;\r\n+    let seenNonDotDotSegment = rootLength !== 0;\r\n+    while (index < path.length) {\r\n+        // At beginning of segment\r\n+        segmentStart = index;\r\n+        let ch = path.charCodeAt(index);\r\n+        while (isAnyDirectorySeparator(ch) && index + 1 < path.length) {\r\n+            index++;\r\n+            ch = path.charCodeAt(index);\r\n+        }\r\n+        if (index > segmentStart) {\r\n+            if (normalized === undefined) {\r\n+                // Seen superfluous separator\r\n+                normalized = path.substring(0, segmentStart - 1);\r\n+            }\r\n+            segmentStart = index;\r\n+        }\r\n+        // Past any superfluous separators\r\n+        const sepIndex = path.indexOf(directorySeparator, index + 1);\r\n+        const altSepIndex = path.indexOf(altDirectorySeparator, index + 1);\r",
        "comment_created_at": "2024-12-20T19:09:32+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "My only concern with `findIndex` is that it might not optimize well it passed in both arrays and strings. Maybe I'm superstitious.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1941562671",
    "pr_number": 61107,
    "pr_file": "src/services/refactors/moveToFile.ts",
    "created_at": "2025-02-04T17:01:55+00:00",
    "commented_code": "if (symbol.valueDeclaration && getSourceFileOfNode(symbol.valueDeclaration).path === sourceFile.path) {\r\n                 existingLocals.add(symbol);\r\n             }\r\n+            else if (!symbol.valueDeclaration && symbol.parent?.valueDeclaration && getSourceFileOfNode(symbol.parent.valueDeclaration).path === sourceFile.path) {",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1941562671",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61107,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1941562671",
        "commented_code": "@@ -1148,6 +1148,9 @@ export function getExistingLocals(sourceFile: SourceFile, statements: readonly S\n             if (symbol.valueDeclaration && getSourceFileOfNode(symbol.valueDeclaration).path === sourceFile.path) {\r\n                 existingLocals.add(symbol);\r\n             }\r\n+            else if (!symbol.valueDeclaration && symbol.parent?.valueDeclaration && getSourceFileOfNode(symbol.parent.valueDeclaration).path === sourceFile.path) {\r",
        "comment_created_at": "2025-02-04T17:01:55+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "I don’t think this is right. I'm not sure we ever should have been using `valueDeclaration` at all.",
        "pr_file_module": null
      },
      {
        "comment_id": "1943406058",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61107,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1941562671",
        "commented_code": "@@ -1148,6 +1148,9 @@ export function getExistingLocals(sourceFile: SourceFile, statements: readonly S\n             if (symbol.valueDeclaration && getSourceFileOfNode(symbol.valueDeclaration).path === sourceFile.path) {\r\n                 existingLocals.add(symbol);\r\n             }\r\n+            else if (!symbol.valueDeclaration && symbol.parent?.valueDeclaration && getSourceFileOfNode(symbol.parent.valueDeclaration).path === sourceFile.path) {\r",
        "comment_created_at": "2025-02-05T17:49:14+00:00",
        "comment_author": "navya9singh",
        "comment_body": "Why do you think using `valueDeclaration` is wrong? Also, another way I had thought of was to do something like this \r\n`\r\nif (symbol.declarations && some(symbol.declarations, d => getSourceFileOfNode(d).path === sourceFile.path)) {\r\n                 existingLocals.add(symbol);\r\n   }`\r\nbut this again would go into another loop and check for each declaration which might probably end up taking even more time. Another way could be to do something like findAllReferences. I'm not exactly clear on what happens there but possible some way of comparing text to see which symbols already exist in a file. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1943699114",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61107,
        "pr_file": "src/services/refactors/moveToFile.ts",
        "discussion_id": "1941562671",
        "commented_code": "@@ -1148,6 +1148,9 @@ export function getExistingLocals(sourceFile: SourceFile, statements: readonly S\n             if (symbol.valueDeclaration && getSourceFileOfNode(symbol.valueDeclaration).path === sourceFile.path) {\r\n                 existingLocals.add(symbol);\r\n             }\r\n+            else if (!symbol.valueDeclaration && symbol.parent?.valueDeclaration && getSourceFileOfNode(symbol.parent.valueDeclaration).path === sourceFile.path) {\r",
        "comment_created_at": "2025-02-05T21:42:25+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "`valueDeclaration` only includes _value-meaning declarations_, and the failing test case here makes it clear why that’s not sufficient. I think looking at `symbol.declarations` is correct.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1890608542",
    "pr_number": 60755,
    "pr_file": "src/compiler/path.ts",
    "created_at": "2024-12-18T17:33:49+00:00",
    "commented_code": "/** @internal */\r\n export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+    fileName = normalizeSlashes(fileName);\r\n+\r\n+    if (isNotNormalizedOrAbsolute(fileName)) {\r\n+        return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1890608542",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60755,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890608542",
        "commented_code": "@@ -625,7 +625,28 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n \r\n /** @internal */\r\n export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+    fileName = normalizeSlashes(fileName);\r\n+\r\n+    if (isNotNormalizedOrAbsolute(fileName)) {\r\n+        return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r",
        "comment_created_at": "2024-12-18T17:33:49+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "If `fileName` is already absolute, we could just call `normalizePath` on it, which has already been optimized.\r\n\r\nI also wonder about both `getNormalizedAbsolutePath` and `normalizePath`, whether it’s better to index through the string, building a new one if needed, rather than doing the two array allocations involved in `getPathFromPathComponents(reducePathComponents(getPathComponents(path)))`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1890779146",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60755,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890608542",
        "commented_code": "@@ -625,7 +625,28 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n \r\n /** @internal */\r\n export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+    fileName = normalizeSlashes(fileName);\r\n+\r\n+    if (isNotNormalizedOrAbsolute(fileName)) {\r\n+        return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r",
        "comment_created_at": "2024-12-18T20:08:41+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "I absolutely agree on that part, I think that iterating through each non-normalized component would be way better.",
        "pr_file_module": null
      },
      {
        "comment_id": "1890809189",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60755,
        "pr_file": "src/compiler/path.ts",
        "discussion_id": "1890608542",
        "commented_code": "@@ -625,7 +625,28 @@ export function getNormalizedPathComponents(path: string, currentDirectory: stri\n \r\n /** @internal */\r\n export function getNormalizedAbsolutePath(fileName: string, currentDirectory: string | undefined): string {\r\n-    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r\n+    fileName = normalizeSlashes(fileName);\r\n+\r\n+    if (isNotNormalizedOrAbsolute(fileName)) {\r\n+        return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));\r",
        "comment_created_at": "2024-12-18T20:39:28+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "Narrator: it was way better\r\n\r\n<img width=\"958\" alt=\"image\" src=\"https://github.com/user-attachments/assets/a7c0804e-8c00-4b45-9c67-94c92e31d288\" />\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1606475894",
    "pr_number": 58571,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2024-05-20T09:02:32+00:00",
    "commented_code": "return propType && getConstituentTypeForKeyType(unionType, propType);\r\n     }\r\n \r\n+    function getMatchingUnionConstituentForArrayLiteral(unionType: UnionType, node: ArrayLiteralExpression) {\r\n+        const resolvedElements = node.elements.map(el => getContextFreeTypeOfExpression(el));\r\n+        for (const type of unionType.types) {\r\n+            if (!isTupleType(type)) continue;\r\n+            const unionElements = getElementTypes(type);\r\n+            if (unionElements.length !== resolvedElements.length) continue;",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1606475894",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 58571,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1606475894",
        "commented_code": "@@ -26900,6 +26900,20 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n         return propType && getConstituentTypeForKeyType(unionType, propType);\r\n     }\r\n \r\n+    function getMatchingUnionConstituentForArrayLiteral(unionType: UnionType, node: ArrayLiteralExpression) {\r\n+        const resolvedElements = node.elements.map(el => getContextFreeTypeOfExpression(el));\r\n+        for (const type of unionType.types) {\r\n+            if (!isTupleType(type)) continue;\r\n+            const unionElements = getElementTypes(type);\r\n+            if (unionElements.length !== resolvedElements.length) continue;\r",
        "comment_created_at": "2024-05-20T09:02:32+00:00",
        "comment_author": "Andarist",
        "comment_body": "This is not quite right. You need to experiment more with this and try to create multiple test cases mixing tuples with different fixed sizes and also the ones with variadic sizes. It would probably be the easiest to only reason about the *leading* fixed elements.",
        "pr_file_module": null
      },
      {
        "comment_id": "1615019023",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 58571,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1606475894",
        "commented_code": "@@ -26900,6 +26900,20 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n         return propType && getConstituentTypeForKeyType(unionType, propType);\r\n     }\r\n \r\n+    function getMatchingUnionConstituentForArrayLiteral(unionType: UnionType, node: ArrayLiteralExpression) {\r\n+        const resolvedElements = node.elements.map(el => getContextFreeTypeOfExpression(el));\r\n+        for (const type of unionType.types) {\r\n+            if (!isTupleType(type)) continue;\r\n+            const unionElements = getElementTypes(type);\r\n+            if (unionElements.length !== resolvedElements.length) continue;\r",
        "comment_created_at": "2024-05-26T04:18:47+00:00",
        "comment_author": "rynobax",
        "comment_body": "https://github.com/microsoft/TypeScript/pull/58571/commits/79a4a79d1b3cb2567642d7e5bc40e276c1bfc23a\r\n\r\ni didn't see an obvious way to determine the number of leading elements so i removed that early exit",
        "pr_file_module": null
      }
    ]
  }
]