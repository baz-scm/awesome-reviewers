[
  {
    "discussion_id": "2155604555",
    "pr_number": 61901,
    "pr_file": "src/compiler/utilities.ts",
    "created_at": "2025-06-18T22:19:24+00:00",
    "commented_code": "export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "2155604555",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T22:19:24+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "Maybe I'm missing something, but wouldn't it be better to strictly parse, and if that fails, use our parser to report errors and work resiliently? It's better for the language service to still do _something_ right if you're in the middle of editing `package.json`.\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2155613167",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T22:22:02+00:00",
        "comment_author": "jakebailey",
        "comment_body": "This code cannot report errors, it's called in places where doing so is impossible.\r\n\r\nThe behavior in this PR matches Corsa, FWIW.\r\n\r\n> It's better for the language service to still do something right if you're in the middle of editing package.json.\r\n\r\nThe current code doesn't do this; the only syntax errors it allows are trailing commas and comments. Any other problem just means this func would have returned `undefined`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2155646662",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T22:39:56+00:00",
        "comment_author": "andrewbranch",
        "comment_body": "N.B. you don't get any TS Server updates as you type in package.json files; only after you save (via file watchers). I think fault-tolerant package.json parsing would be nice to have in your own package.json files, but it definitely seems unnecessary for those whose realpath is in node_modules, as those are almost definitely machine written.",
        "pr_file_module": null
      },
      {
        "comment_id": "2155674585",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T22:55:10+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "Fair, though I definitely have played around with a 3rd party `package.json` if the types are potentially wrong before I've gone off to send a PR.\r\n\r\nI think my preference would still be for TS to do the resilient thing in the slow path, and find a way to bring that to Corsa eventually. The tests can stay as-is, and I won't block the PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "2155681866",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T22:58:24+00:00",
        "comment_author": "jakebailey",
        "comment_body": "I don't really want to write the code in this PR to make this resilient or try and report errors (I'm not even sure if such a thing is going to be possible at all; the module resolver is not in the business of error reporting I don't think).\r\n\r\nAre you saying that's fine, or do you want me to revert all but the test changes (which are needed to correctly test Corsa)?",
        "pr_file_module": null
      },
      {
        "comment_id": "2155708114",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T23:20:22+00:00",
        "comment_author": "DanielRosenwasser",
        "comment_body": "I'm saying that you could do something like\n\n```suggestion\n    // Try strictly parsing first, then fall back to our (slower)\n    // parser that is resilient to comments/trailing commas.\n    // package.json files should never have these, but we\n    // have no way to communicate these issues in the first place.\n    let result = tryParseJson(jsonText);\n    if (result === undefined) {\n        const looseResult = parseConfigFileTextToJson(path, jsonText);\n        if (!looseResult.error) {\n            result = looseResult.config;\n        }\n    }\n    return result;\n```\n\nThat gets you speed in the common case, and falls back to something workable. The tests should probably all be fixed up like you've done. They weren't really written with recoverability in mind, though maybe there should be one test with an intentionally malformed `package.json`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2155711231",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 61901,
        "pr_file": "src/compiler/utilities.ts",
        "discussion_id": "2155604555",
        "commented_code": "@@ -7715,9 +7714,7 @@ export function base64decode(host: { base64decode?(input: string): string; } | u\n export function readJsonOrUndefined(path: string, hostOrText: { readFile(fileName: string): string | undefined; } | string): object | undefined {\r\n     const jsonText = isString(hostOrText) ? hostOrText : hostOrText.readFile(path);\r\n     if (!jsonText) return undefined;\r\n-    // gracefully handle if readFile fails or returns not JSON\r\n-    const result = parseConfigFileTextToJson(path, jsonText);\r\n-    return !result.error ? result.config : undefined;\r\n+    return tryParseJson(jsonText);\r",
        "comment_created_at": "2025-06-18T23:24:04+00:00",
        "comment_author": "jakebailey",
        "comment_body": "The point of this PR was to ensure tests passed in a way that meant we could check Corsa (where such recovery is not possible without inventing a Go-compatible JSON parser via our APIs); doing what you suggest would I guess keep the perf benefit here (not what I was even trying to do) but at the cost of not actually checking the tests for strictness.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1890192374",
    "pr_number": 60799,
    "pr_file": "src/compiler/checker.ts",
    "created_at": "2024-12-18T12:54:58+00:00",
    "commented_code": ": exprType;\r\n \r\n         const effectiveExpr = expr && getEffectiveCheckNode(expr); // The effective expression for diagnostics purposes.\r\n-        const errorNode = inReturnStatement && !inConditionalExpression ? node : effectiveExpr;\r\n+        const errorNode =\r\n+          inConditionalExpression ? effectiveExpr :\r\n+          inReturnStatement ? node :\r\n+          isArrowFunction(node.parent) && node.parent.type !== undefined ? node.parent.type :",
    "repo_full_name": "microsoft/TypeScript",
    "discussion_comments": [
      {
        "comment_id": "1890192374",
        "repo_full_name": "microsoft/TypeScript",
        "pr_number": 60799,
        "pr_file": "src/compiler/checker.ts",
        "discussion_id": "1890192374",
        "commented_code": "@@ -45798,7 +45798,11 @@ export function createTypeChecker(host: TypeCheckerHost): TypeChecker {\n             : exprType;\r\n \r\n         const effectiveExpr = expr && getEffectiveCheckNode(expr); // The effective expression for diagnostics purposes.\r\n-        const errorNode = inReturnStatement && !inConditionalExpression ? node : effectiveExpr;\r\n+        const errorNode =\r\n+          inConditionalExpression ? effectiveExpr :\r\n+          inReturnStatement ? node :\r\n+          isArrowFunction(node.parent) && node.parent.type !== undefined ? node.parent.type :\r",
        "comment_created_at": "2024-12-18T12:54:58+00:00",
        "comment_author": "OliverJAsh",
        "comment_body": "Alternatively we could position the error on `=>`:\r\n\r\nIf the span highlights the return type, it might suggest an issue with the return type rather than the returned value/expression. `=>` on the other hand would suggest it could be an issue with either the return type _or_ the value. This would be synonymous to the behaviour with block body arrow functions where we highlight the `return` keyboard.\r\n\r\nHowever, the error might be harder to see, because `=>` is only 2 characters. I would personally be fine with this.",
        "pr_file_module": null
      }
    ]
  }
]