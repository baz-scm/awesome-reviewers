[
  {
    "discussion_id": "1983183157",
    "pr_number": 3954,
    "pr_file": "app2/src/routes/transfer/ucs03/+page.svelte",
    "created_at": "2025-03-06T11:25:40+00:00",
    "commented_code": "+<script lang=\"ts\">\n+import { RawIntentsStoreSvelte } from \"../raw-intents-store.svelte\"\n+import Button from \"$lib/components/ui/Button.svelte\"\n+import Sections from \"$lib/components/ui/Sections.svelte\"\n+import SectionTitle from \"$lib/components/ui/SectionTitle.svelte\"\n+import { ucs03ZkgmAbi } from \"$lib/abi/ucs03\"\n+import {\n+  TransferSubmission,\n+  nextState,\n+  hasFailedExit,\n+  isComplete,\n+  type TransactionEvmParams\n+} from \"$lib/services/transfer-ucs03-evm\"\n+import { sepolia } from \"viem/chains\"\n+import { getAccount } from \"@wagmi/core\"\n+import { wagmiConfig } from \"$lib/wallet/evm/wagmi-config\"\n+import { getAddress, type Hex, toHex } from \"viem\"\n+import { bech32AddressToHex } from \"@unionlabs/client\"\n+import { Effect } from \"effect\"\n+\n+export const rawIntents = new RawIntentsStoreSvelte()\n+\n+/**\n+ * generates salts to be used on transfer submission\n+ * used to prevent transfer hash colissions\n+ */\n+export function generateSalt(): Hex {\n+  const rawSalt = new Uint8Array(32)\n+  crypto.getRandomValues(rawSalt)\n+  return toHex(rawSalt)\n+}\n+\n+/* Hack to be able to JSON.stringify BigInt */\n+interface BigInt {\n+  toJSON: () => string\n+}\n+\n+BigInt[\"prototype\"].toJSON = function () {\n+  return this.toString()\n+}\n+\n+let transferState = $state<TransferSubmission>(TransferSubmission.Pending())\n+\n+const submit = Effect.promise(async () => {\n+  const account = getAccount(wagmiConfig)\n+\n+  if (!(account.isConnected && account.address)) {\n+    console.error(\"Wallet not connected - please connect your wallet first\")\n+    return\n+  }\n+\n+  console.log(\"Using connected address:\", account.address)\n+\n+  const receiver = \"union10z7xxj2m8q3f7j58uxmff38ws9u8m0vmne2key\"\n+  const formattedReceiver = receiver.startsWith(\"0x\")\n+    ? getAddress(receiver)\n+    : getAddress(bech32AddressToHex({ address: receiver }))\n+\n+  let currentTransactionParams: TransactionEvmParams = {\n+    account: account.address,\n+    abi: ucs03ZkgmAbi,\n+    chain: sepolia,\n+    functionName: \"transferV2\",\n+    address: \"0x84f074c15513f15baea0fbed3ec42f0bd1fb3efa\", // ucs03address\n+    value: BigInt(0.0080085 * 10 ** 18),\n+    args: {\n+      sourceChainId: 11155111,\n+      baseToken: \"0x1c7d4b196cb0c7b01d743fbc6116a902379c7238\",\n+      baseAmount: 100n,\n+      quoteToken:\n+        \"0x756e696f6e313370786b747532686b387073656b7361616b6135346e677879666d706a6c6a726c65683363633873787671346478616c76747471646d64677635\",\n+      quoteAmount: 100n,\n+      receiver: formattedReceiver,\n+      sourceChannelId: 9,\n+      wethQuoteToken:\n+        \"0x756e696f6e31686373343677677033637775723679336c7a733638706b776765687930636777766e637472747a7932666e3630343772346561717a34646b6c6c\",\n+      timeoutHeight: 0n,\n+      timeoutTimestamp: \"0x000000000000000000000000000000000000000000000000fffffffffffffffa\",\n+      salt: generateSalt()\n+    }\n+  }",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1983183157",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3954,
        "pr_file": "app2/src/routes/transfer/ucs03/+page.svelte",
        "discussion_id": "1983183157",
        "commented_code": "@@ -0,0 +1,127 @@\n+<script lang=\"ts\">\n+import { RawIntentsStoreSvelte } from \"../raw-intents-store.svelte\"\n+import Button from \"$lib/components/ui/Button.svelte\"\n+import Sections from \"$lib/components/ui/Sections.svelte\"\n+import SectionTitle from \"$lib/components/ui/SectionTitle.svelte\"\n+import { ucs03ZkgmAbi } from \"$lib/abi/ucs03\"\n+import {\n+  TransferSubmission,\n+  nextState,\n+  hasFailedExit,\n+  isComplete,\n+  type TransactionEvmParams\n+} from \"$lib/services/transfer-ucs03-evm\"\n+import { sepolia } from \"viem/chains\"\n+import { getAccount } from \"@wagmi/core\"\n+import { wagmiConfig } from \"$lib/wallet/evm/wagmi-config\"\n+import { getAddress, type Hex, toHex } from \"viem\"\n+import { bech32AddressToHex } from \"@unionlabs/client\"\n+import { Effect } from \"effect\"\n+\n+export const rawIntents = new RawIntentsStoreSvelte()\n+\n+/**\n+ * generates salts to be used on transfer submission\n+ * used to prevent transfer hash colissions\n+ */\n+export function generateSalt(): Hex {\n+  const rawSalt = new Uint8Array(32)\n+  crypto.getRandomValues(rawSalt)\n+  return toHex(rawSalt)\n+}\n+\n+/* Hack to be able to JSON.stringify BigInt */\n+interface BigInt {\n+  toJSON: () => string\n+}\n+\n+BigInt[\"prototype\"].toJSON = function () {\n+  return this.toString()\n+}\n+\n+let transferState = $state<TransferSubmission>(TransferSubmission.Pending())\n+\n+const submit = Effect.promise(async () => {\n+  const account = getAccount(wagmiConfig)\n+\n+  if (!(account.isConnected && account.address)) {\n+    console.error(\"Wallet not connected - please connect your wallet first\")\n+    return\n+  }\n+\n+  console.log(\"Using connected address:\", account.address)\n+\n+  const receiver = \"union10z7xxj2m8q3f7j58uxmff38ws9u8m0vmne2key\"\n+  const formattedReceiver = receiver.startsWith(\"0x\")\n+    ? getAddress(receiver)\n+    : getAddress(bech32AddressToHex({ address: receiver }))\n+\n+  let currentTransactionParams: TransactionEvmParams = {\n+    account: account.address,\n+    abi: ucs03ZkgmAbi,\n+    chain: sepolia,\n+    functionName: \"transferV2\",\n+    address: \"0x84f074c15513f15baea0fbed3ec42f0bd1fb3efa\", // ucs03address\n+    value: BigInt(0.0080085 * 10 ** 18),\n+    args: {\n+      sourceChainId: 11155111,\n+      baseToken: \"0x1c7d4b196cb0c7b01d743fbc6116a902379c7238\",\n+      baseAmount: 100n,\n+      quoteToken:\n+        \"0x756e696f6e313370786b747532686b387073656b7361616b6135346e677879666d706a6c6a726c65683363633873787671346478616c76747471646d64677635\",\n+      quoteAmount: 100n,\n+      receiver: formattedReceiver,\n+      sourceChannelId: 9,\n+      wethQuoteToken:\n+        \"0x756e696f6e31686373343677677033637775723679336c7a733638706b776765687930636777766e637472747a7932666e3630343772346561717a34646b6c6c\",\n+      timeoutHeight: 0n,\n+      timeoutTimestamp: \"0x000000000000000000000000000000000000000000000000fffffffffffffffa\",\n+      salt: generateSalt()\n+    }\n+  }",
        "comment_created_at": "2025-03-06T11:25:40+00:00",
        "comment_author": "cor",
        "comment_body": "```jsonc\r\n{\r\n  sourceChain: Chain, // wagmi chain\r\n  ucs03address: Address,\r\n  value: BigInt,\r\n  baseToken: Address,\r\n  baseAmount: BigInt,\r\n  quoteToken: Hex,\r\n  quoteAmount: BigInt,\r\n  receiver: Hex,\r\n  sourceChannelId: ChannelId,\r\n  wethQuoteToken: BigInt, // do we put fetching of this in the statemachine?\r\n  timeoutHeight: BigInt,\r\n  timeoutTimestamp: Hex\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1966301074",
    "pr_number": 3838,
    "pr_file": "app/src/lib/components/transfers-table/transfers-table.svelte",
    "created_at": "2025-02-21T22:58:40+00:00",
    "commented_code": "return (\n     $transfers?.data\n-      ?.filter(\n-        transfer =>\n+      ?.filter(transfer => {\n+        const quoteAmount = transfer.token?.quote?.amount\n+        const parsedAmount = quoteAmount ? Number.parseInt(quoteAmount, 16) : Number.NaN\n+\n+        return (\n           enabledChainIds.includes(transfer.source.chainId) &&\n-          enabledChainIds.includes(transfer.destination.chainId)\n-      )\n+          enabledChainIds.includes(transfer.destination.chainId) &&\n+          !Number.isNaN(parsedAmount) &&\n+          parsedAmount !== 0\n+        )\n+      })",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1966301074",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3838,
        "pr_file": "app/src/lib/components/transfers-table/transfers-table.svelte",
        "discussion_id": "1966301074",
        "commented_code": "@@ -26,11 +26,17 @@ const transfersDataStore = derived([transfers, page], ([$transfers, $page]) => {\n \n   return (\n     $transfers?.data\n-      ?.filter(\n-        transfer =>\n+      ?.filter(transfer => {\n+        const quoteAmount = transfer.token?.quote?.amount\n+        const parsedAmount = quoteAmount ? Number.parseInt(quoteAmount, 16) : Number.NaN\n+\n+        return (\n           enabledChainIds.includes(transfer.source.chainId) &&\n-          enabledChainIds.includes(transfer.destination.chainId)\n-      )\n+          enabledChainIds.includes(transfer.destination.chainId) &&\n+          !Number.isNaN(parsedAmount) &&\n+          parsedAmount !== 0\n+        )\n+      })",
        "comment_created_at": "2025-02-21T22:58:40+00:00",
        "comment_author": "cor",
        "comment_body": "We should not do this in the rendering portion, but rather in the GraphQL query",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1827710322",
    "pr_number": 3193,
    "pr_file": "move/move-ibc/sources/dispatch_ibc.move",
    "created_at": "2024-11-04T13:12:13+00:00",
    "commented_code": "+module ibc::ibc_dispatch {\n+    use std::signer;\n+    use std::vector;\n+    use aptos_std::smart_table::{Self, SmartTable};\n+    use aptos_std::table::{Self, Table};\n+    use std::block;\n+    use std::from_bcs;\n+    use std::event;\n+    use std::bcs;\n+    use std::object;\n+    use std::string::{Self, String, utf8};\n+    use std::hash;\n+    use std::timestamp;\n+    use std::option::{Self, Option};\n+\n+    use std::string_utils;\n+    use ibc::commitment;\n+    use ibc::light_client;\n+    use ibc::connection_end::{Self, ConnectionEnd};\n+    use ibc::channel::{Self, Channel};\n+    use ibc::packet::{Self, Packet};\n+\n+    const IBC_APP_SEED: vector<u8> = b\"union-ibc-app-v1\";\n+    const COMMITMENT_MAGIC: vector<u8> = x\"0100000000000000000000000000000000000000000000000000000000000000\";\n+    const COMMITMENT_NULL: vector<u8> = x\"0000000000000000000000000000000000000000000000000000000000000000\";\n+\n+    const CLIENT_TYPE_COMETBLS: vector<u8> = b\"cometbls\";\n+\n+    const CHAN_STATE_UNINITIALIZED: u8 = 0;\n+    const CHAN_STATE_INIT: u8 = 1;\n+    const CHAN_STATE_TRYOPEN: u8 = 2;\n+    const CHAN_STATE_OPEN: u8 = 3;\n+    const CHAN_STATE_CLOSED: u8 = 4;\n+\n+    const CHAN_ORDERING_NONE: u8 = 0;\n+    const CHAN_ORDERING_UNORDERED: u8 = 1;\n+    const CHAN_ORDERING_ORDERED: u8 = 2;\n+\n+    const CONN_STATE_UNSPECIFIED: u64 = 0;\n+    const CONN_STATE_INIT: u64 = 1;\n+    const CONN_STATE_TRYOPEN: u64 = 2;\n+    const CONN_STATE_OPEN: u64 = 3;\n+\n+    const VAULT_SEED: vector<u8> = b\"IBC_VAULT_SEED\";\n+\n+    const E_NOT_ENOUGH_PERMISSIONS_TO_INITIALIZE: u64 = 1001;\n+    const E_CLIENT_NOT_FOUND: u64 = 1002;\n+    const E_VERSION_MUST_BE_UNSET: u64 = 1006;\n+    const E_UNSUPPORTED_VERSION: u64 = 1007;\n+    const E_INVALID_CONNECTION_STATE: u64 = 1008;\n+    const E_CONNECTION_ALREADY_EXISTS: u64 = 1009;\n+    const E_CONN_NOT_SINGLE_HOP: u64 = 1011;\n+    const E_CONN_NOT_SINGLE_VERSION: u64 = 1012;\n+    const E_UNSUPPORTED_FEATURE: u64 = 1013;\n+    const E_PORT_ID_MUST_BE_LOWERCASE: u64 = 1015;\n+    const E_INVALID_CHANNEL_STATE: u64 = 1016;\n+    const E_COUNTERPARTY_CHANNEL_NOT_EMPTY: u64 = 1017;\n+    const E_INVALID_TIMEOUT_HEIGHT: u64 = 1018;\n+    const E_LATEST_TIMESTAMP_NOT_FOUND: u64 = 1019;\n+    const E_UNAUTHORIZED: u64 = 1020;\n+    const E_INVALID_TIMEOUT_TIMESTAMP: u64 = 1021;\n+    const E_LATEST_HEIGHT_NOT_FOUND: u64 = 1022;\n+    const E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH: u64 = 1023;\n+    const E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH: u64 = 1022;\n+    const E_TIMESTAMP_TIMEOUT: u64 = 1023;\n+    const E_HEIGHT_TIMEOUT: u64 = 1024;\n+    const E_PACKET_ALREADY_RECEIVED: u64 = 1025;\n+    const E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH: u64 = 1026;\n+    const E_UNKNOWN_CHANNEL_ORDERING: u64 = 1027;\n+    const E_CONNECTION_DOES_NOT_EXIST: u64 = 1028;\n+    const E_ACKNOWLEDGEMENT_IS_EMPTY: u64 = 1028;\n+    const E_ACKNOWLEDGEMENT_ALREADY_EXISTS: u64 = 1029;\n+    const E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH: u64 = 1030;\n+    const E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH: u64 = 1031;\n+    const E_PACKET_COMMITMENT_NOT_FOUND: u64 = 1032;\n+    const E_INVALID_PACKET_COMMITMENT: u64 = 1033;\n+    const E_TIMESTAMP_TIMEOUT_NOT_REACHED: u64 = 1034;\n+    const E_TIMEOUT_HEIGHT_NOT_REACHED: u64 = 1035;\n+    const E_INVALID_UPDATE: u64 = 1036;\n+    const E_NEXT_SEQUENCE_MUST_BE_GREATER_THAN_TIMEOUT_SEQUENCE: u64 = 1037;\n+    const E_CLIENT_NOT_ACTIVE: u64 = 1038;\n+    const E_UNKNOWN_CLIENT_TYPE: u64 = 1039;\n+    const E_NOT_ENOUGH_PACKETS: u64 = 1040;\n+    const E_PACKET_NOT_RECEIVED: u64 = 1041;\n+    const E_ACK_ALREADY_EXIST: u64 = 1042;\n+    const E_CANNOT_INTENT_ORDERED: u64 = 1043;\n+    const E_TIMEOUT_MUST_BE_SET: u64 = 1044;\n+    const E_PACKET_SEQUENCE_ACK_SEQUENCE_MISMATCH: u64 = 1045;\n+\n+    #[event]\n+    struct ClientCreatedEvent has copy, drop, store {\n+        client_id: u32,\n+        client_type: String,\n+        consensus_height: u64\n+    }\n+\n+    #[event]\n+    struct ClientUpdated has copy, drop, store {\n+        client_id: u32,\n+        client_type: String,\n+        height: u64\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenInit has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32\n+    }\n+\n+    #[event]\n+    struct ChannelOpenInit has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        connection_id: u32,\n+        version: vector<u8>\n+    }\n+\n+    #[event]\n+    struct ChannelOpenTry has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        connection_id: u32,\n+        version: vector<u8>\n+    }\n+\n+    #[event]\n+    struct ChannelOpenAck has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ChannelOpenConfirm has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenTry has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenAck has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenConfirm has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32\n+    }\n+\n+    #[event]\n+    struct SendPacket has drop, store {\n+        sequence: u64,\n+        source_channel: u32,\n+        destination_channel: u32,\n+        data: vector<u8>,\n+        timeout_height: u64,\n+        timeout_timestamp: u64\n+    }\n+\n+    #[event]\n+    struct RecvPacket has drop, store {\n+        packet: Packet\n+    }\n+\n+    #[event]\n+    struct RecvIntentPacket has drop, store {\n+        packet: Packet\n+    }\n+\n+    #[event]\n+    struct TimeoutPacket has drop, store {\n+        packet: Packet\n+    }\n+\n+    #[event]\n+    struct WriteAcknowledgement has drop, store {\n+        packet: Packet,\n+        acknowledgement: vector<u8>\n+    }\n+\n+    #[event]\n+    struct AcknowledgePacket has drop, store {\n+        packet: Packet,\n+        acknowledgement: vector<u8>\n+    }\n+\n+    #[event]\n+    struct SubmitMisbehaviour has drop, store {\n+        client_id: u32,\n+        client_type: String\n+    }\n+\n+    struct Port<T: key + store + drop> has key, copy, drop, store {\n+        port_id: address\n+    }\n+\n+    use aptos_framework::function_info;\n+    use aptos_framework::function_info::FunctionInfo;\n+\n+    // use ibc::ping_pong_app;\n+    // use ibc::dynamic_dispatch_app2;\n+    use ibc::dispatcher;\n+    use ibc::engine;\n+\n+    struct RecvPacketParams has copy, drop, store {\n+        packet: Packet\n+    }\n+\n+    struct RecvIntentPacketParams has copy, drop, store {\n+        packet: Packet\n+    }\n+\n+    struct AcknowledgePacketParams has copy, drop, store {\n+        packet: Packet,\n+        acknowledgement: vector<u8>\n+    }\n+\n+    struct TimeoutPacketParams has copy, drop, store {\n+        packet: Packet\n+    }\n+\n+    struct ChannelOpenInitParams has copy, drop, store {\n+        ordering: u8,\n+        connection_id: u32,\n+        channel_id: u32,\n+        version: vector<u8>\n+    }\n+\n+    struct ChannelOpenTryParams has copy, drop, store {\n+        ordering: u8,\n+        connection_id: u32,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        version: vector<u8>,\n+        counterparty_version: vector<u8>\n+    }\n+\n+    struct ChannelOpenAckParams has copy, drop, store {\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        counterparty_version: vector<u8>\n+    }\n+\n+    struct ChannelOpenConfirmParams has copy, drop, store {\n+        channel_id: u32\n+    }\n+\n+    struct ChannelCloseInitParams has copy, drop, store {\n+        channel_id: u32\n+    }\n+\n+    struct ChannelCloseConfirmParams has copy, drop, store {\n+        channel_id: u32\n+    }\n+\n+    struct DynamicDispatchParam has copy, store, drop, key {\n+        recv_packet_param: option::Option<RecvPacketParams>,\n+        recv_intent_packet_param: option::Option<RecvIntentPacketParams>,\n+        acknowledge_packet_param: option::Option<AcknowledgePacketParams>,\n+        timeout_packet_param: option::Option<TimeoutPacketParams>,\n+        channel_open_init_param: option::Option<ChannelOpenInitParams>,\n+        channel_open_try_param: option::Option<ChannelOpenTryParams>,\n+        channel_open_ack_param: option::Option<ChannelOpenAckParams>,\n+        channel_open_confirm_param: option::Option<ChannelOpenConfirmParams>,\n+        channel_close_init_param: option::Option<ChannelCloseInitParams>,\n+        channel_close_confirm_param: option::Option<ChannelCloseConfirmParams>\n+    }\n+\n+    public fun recv_packet_param(param: &DynamicDispatchParam):\n+        option::Option<RecvPacketParams> {\n+        param.recv_packet_param\n+    }\n+\n+    public fun recv_intent_packet_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<RecvIntentPacketParams> {\n+        param.recv_intent_packet_param\n+    }\n+\n+    public fun acknowledge_packet_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<AcknowledgePacketParams> {\n+        param.acknowledge_packet_param\n+    }\n+\n+    public fun timeout_packet_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<TimeoutPacketParams> {\n+        param.timeout_packet_param\n+    }\n+\n+    public fun channel_open_init_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenInitParams> {\n+        param.channel_open_init_param\n+    }\n+\n+    public fun channel_open_try_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenTryParams> {\n+        param.channel_open_try_param\n+    }\n+\n+    public fun channel_open_ack_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenAckParams> {\n+        param.channel_open_ack_param\n+    }\n+\n+    public fun channel_open_confirm_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenConfirmParams> {\n+        param.channel_open_confirm_param\n+    }\n+\n+    public fun channel_close_init_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelCloseInitParams> {\n+        param.channel_close_init_param\n+    }\n+\n+    public fun channel_close_confirm_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelCloseConfirmParams> {\n+        param.channel_close_confirm_param\n+    }\n+\n+    // Getter for RecvPacketParams\n+    public fun get_packet_from_recv_param(param: &RecvPacketParams): &Packet {\n+        &param.packet\n+    }\n+\n+    // Getter for RecvPacketParams\n+    public fun get_packet_from_recv_intent_param(\n+        param: &RecvIntentPacketParams\n+    ): &Packet {\n+        &param.packet\n+    }\n+\n+    // Getters for AcknowledgePacketParams\n+    public fun get_packet_from_ack_param(param: &AcknowledgePacketParams): &Packet {\n+        &param.packet\n+    }\n+\n+    public fun get_acknowledgement_from_ack_param(\n+        param: &AcknowledgePacketParams\n+    ): &vector<u8> {\n+        &param.acknowledgement\n+    }\n+\n+    // Getter for TimeoutPacketParams\n+    public fun get_packet_from_timeout_param(param: &TimeoutPacketParams): &Packet {\n+        &param.packet\n+    }\n+\n+    // Getters for ChannelOpenInitParams\n+    public fun get_ordering_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): u8 {\n+        param.ordering\n+    }\n+\n+    public fun get_connection_id_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): u32 {\n+        param.connection_id\n+    }\n+\n+    public fun get_channel_id_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun get_version_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): &vector<u8> {\n+        &param.version\n+    }\n+\n+    // Getters for ChannelOpenTryParams\n+    public fun get_ordering_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u8 {\n+        param.ordering\n+    }\n+\n+    public fun get_connection_id_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u32 {\n+        param.connection_id\n+    }\n+\n+    public fun get_channel_id_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun get_counterparty_channel_id_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u32 {\n+        param.counterparty_channel_id\n+    }\n+\n+    public fun get_version_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): &vector<u8> {\n+        &param.version\n+    }\n+\n+    public fun get_counterparty_version_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): &vector<u8> {\n+        &param.counterparty_version\n+    }\n+\n+    // Getters for ChannelOpenAckParams\n+    public fun get_channel_id_from_channel_open_ack_param(\n+        param: &ChannelOpenAckParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun get_counterparty_channel_id_from_channel_open_ack_param(\n+        param: &ChannelOpenAckParams\n+    ): u32 {\n+        param.counterparty_channel_id\n+    }\n+\n+    public fun get_counterparty_version_from_channel_open_ack_param(\n+        param: &ChannelOpenAckParams\n+    ): &vector<u8> {\n+        &param.counterparty_version\n+    }\n+\n+    // Getter for ChannelOpenConfirmParams\n+    public fun get_channel_id_from_channel_open_confirm_param(\n+        param: &ChannelOpenConfirmParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    // Getter for ChannelCloseInitParams\n+    public fun get_channel_id_from_channel_close_init_param(\n+        param: &ChannelCloseInitParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    // Getter for ChannelCloseConfirmParams\n+    public fun get_channel_id_from_channel_close_confirm_param(\n+        param: &ChannelCloseConfirmParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun new_dynamic_dispatch_param(\n+        recv_packet_param: option::Option<RecvPacketParams>,\n+        recv_intent_packet_param: option::Option<RecvIntentPacketParams>,\n+        acknowledge_packet_param: option::Option<AcknowledgePacketParams>,\n+        timeout_packet_param: option::Option<TimeoutPacketParams>,\n+        channel_open_init_param: option::Option<ChannelOpenInitParams>,\n+        channel_open_try_param: option::Option<ChannelOpenTryParams>,\n+        channel_open_ack_param: option::Option<ChannelOpenAckParams>,\n+        channel_open_confirm_param: option::Option<ChannelOpenConfirmParams>,\n+        channel_close_init_param: option::Option<ChannelCloseInitParams>,\n+        channel_close_confirm_param: option::Option<ChannelCloseConfirmParams>\n+    ): DynamicDispatchParam {\n+        DynamicDispatchParam {\n+            recv_packet_param,\n+            recv_intent_packet_param,\n+            acknowledge_packet_param,\n+            timeout_packet_param,\n+            channel_open_init_param,\n+            channel_open_try_param,\n+            channel_open_ack_param,\n+            channel_open_confirm_param,\n+            channel_close_init_param,\n+            channel_close_confirm_param\n+        }\n+    }\n+\n+    public fun register_application<T: key + store + drop>(\n+        ibc_app: &signer, cb: FunctionInfo, type: T\n+    ) acquires SignerRef { // pingpongapp bunu cagiracak\n+        dispatcher::register<T>(cb, type, bcs::to_bytes(&signer::address_of(ibc_app)));\n+        move_to(\n+            &get_ibc_signer(),\n+            Port<T> { port_id: signer::address_of(ibc_app) }\n+        );\n+    }\n+\n+    // Resource to hold the global state\n+    struct IBCStore has key {\n+        client_impls: SmartTable<String, address>,\n+        client_registry: SmartTable<String, address>,\n+        commitments: Table<vector<u8>, vector<u8>>,\n+        connections: SmartTable<u32, ConnectionEnd>,\n+        channels: SmartTable<u32, Channel>\n+    }\n+\n+    struct SignerRef has key {\n+        self_ref: object::ExtendRef\n+    }\n+\n+    // Initializes the IBCStore resource in the signer's account\n+    fun init_module(account: &signer) {\n+        assert!(\n+            signer::address_of(account) == @ibc, E_NOT_ENOUGH_PERMISSIONS_TO_INITIALIZE\n+        );\n+        let vault_constructor_ref = &object::create_named_object(account, VAULT_SEED);\n+        let vault_signer = &object::generate_signer(vault_constructor_ref);\n+\n+        let store = IBCStore {\n+            client_registry: smart_table::new(),\n+            commitments: table::new(),\n+            client_impls: smart_table::new(),\n+            connections: smart_table::new(),\n+            channels: smart_table::new()\n+        };\n+\n+        move_to(vault_signer, store);\n+\n+        move_to(\n+            vault_signer,\n+            SignerRef { self_ref: object::generate_extend_ref(vault_constructor_ref) }\n+        );\n+    }\n+\n+    /// Create a client with an initial client and consensus state\n+    public entry fun create_client(\n+        client_type: String, client_state: vector<u8>, consensus_state: vector<u8>\n+    ) acquires IBCStore, SignerRef {\n+        // NOTE(aeryz): At this point, we don't need to have a routing mechanism because it will introduce\n+        // additional gas cost. We should only enforce the use of `cometbls` for the `client_type`\n+        assert!(string::bytes(&client_type) == &b\"cometbls\", E_UNKNOWN_CLIENT_TYPE);\n+\n+        let client_id = generate_client_identifier();\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let (client_state, consensus_state) =\n+            light_client::create_client(\n+                &get_ibc_signer(),\n+                client_id,\n+                // from_bcs::to_bytes(client_state),\n+                // from_bcs::to_bytes(consensus_state),\n+                client_state,\n+                consensus_state\n+            );\n+\n+        // TODO(aeryz): fetch these status from proper exported consts\n+        assert!(light_client::status(client_id) == 0, E_CLIENT_NOT_ACTIVE);\n+\n+        // Update commitments\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::client_state_commitment_key(client_id),\n+            client_state\n+        );\n+\n+        let latest_height = light_client::latest_height(client_id);\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::consensus_state_commitment_key(client_id, latest_height),\n+            consensus_state\n+        );\n+\n+        event::emit(\n+            ClientCreatedEvent { client_id, client_type, consensus_height: latest_height }\n+        );\n+    }\n+\n+    public entry fun connection_open_init(\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32\n+    ) acquires IBCStore {\n+        let connection_id = generate_connection_identifier();\n+\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let connection =\n+            connection_end::new(\n+                CONN_STATE_INIT,\n+                client_id,\n+                counterparty_client_id,\n+                0,\n+                client_type,\n+                counterparty_client_type\n+            );\n+\n+        smart_table::upsert(&mut store.connections, connection_id, connection);\n+\n+        commit_connection(connection_id, connection);\n+\n+        event::emit(\n+            ConnectionOpenInit {\n+                connection_id: connection_id,\n+                client_type: client_type,\n+                client_id: client_id,\n+                counterparty_client_type: counterparty_client_type,\n+                counterparty_client_id: counterparty_client_id\n+            }\n+        )\n+    }\n+\n+    public entry fun connection_open_try(\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        proof_init: vector<u8>,\n+        proof_height: u64\n+    ) acquires IBCStore {\n+        let connection_id = generate_connection_identifier();\n+\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let connection =\n+            smart_table::borrow_mut_with_default(\n+                &mut store.connections,\n+                connection_id,\n+                connection_end::new(\n+                    CONN_STATE_TRYOPEN,\n+                    client_id,\n+                    counterparty_client_id,\n+                    counterparty_connection_id,\n+                    client_type,\n+                    counterparty_client_type\n+                )\n+            );\n+\n+        // Create the expected connection\n+        let expected_connection =\n+            connection_end::new(\n+                CONN_STATE_INIT,\n+                counterparty_client_id,\n+                client_id,\n+                0, // counterparty_connection_id\n+                counterparty_client_type,\n+                utf8(b\"\")\n+            );\n+\n+        // Verify the connection state\n+        let err =\n+            verify_connection_state(\n+                connection,\n+                proof_height,\n+                proof_init,\n+                counterparty_connection_id,\n+                expected_connection\n+            );\n+        assert!(err == 0, err);\n+\n+        event::emit(\n+            ConnectionOpenTry {\n+                connection_id,\n+                client_type,\n+                client_id: client_id,\n+                counterparty_client_id: counterparty_client_id,\n+                counterparty_client_type: counterparty_client_type,\n+                counterparty_connection_id: counterparty_connection_id\n+            }\n+        );\n+\n+        commit_connection(connection_id, *connection);\n+    }\n+\n+    public entry fun connection_open_ack(\n+        connection_id: u32,\n+        counterparty_connection_id: u32,\n+        proof_try: vector<u8>,\n+        proof_height: u64\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            smart_table::contains(&store.connections, connection_id),\n+            E_CONNECTION_DOES_NOT_EXIST\n+        );\n+\n+        let connection = smart_table::borrow_mut(&mut store.connections, connection_id);\n+        assert!(\n+            connection_end::state(connection) == CONN_STATE_INIT,\n+            E_INVALID_CONNECTION_STATE\n+        );\n+\n+        // Create the expected connection\n+        let expected_connection =\n+            connection_end::new(\n+                CONN_STATE_TRYOPEN,\n+                connection_end::counterparty_client_id(connection),\n+                connection_end::client_id(connection),\n+                connection_id,\n+                *connection_end::counterparty_client_type(connection),\n+                *connection_end::client_type(connection)\n+            );\n+\n+        // Verify the connection state\n+        let err =\n+            verify_connection_state(\n+                connection,\n+                proof_height,\n+                proof_try,\n+                counterparty_connection_id,\n+                expected_connection\n+            );\n+        assert!(err == 0, err);\n+\n+        connection_end::set_state(connection, CONN_STATE_TRYOPEN);\n+        connection_end::set_counterparty_connection_id(\n+            connection, counterparty_connection_id\n+        );\n+\n+        event::emit(\n+            ConnectionOpenAck {\n+                connection_id,\n+                client_type: *connection_end::client_type(connection),\n+                client_id: connection_end::client_id(connection),\n+                counterparty_client_id: connection_end::counterparty_client_id(\n+                    connection\n+                ),\n+                counterparty_connection_id: connection_end::counterparty_connection_id(\n+                    connection\n+                ),\n+                counterparty_client_type: *connection_end::counterparty_client_type(\n+                    connection\n+                )\n+            }\n+        );\n+\n+        commit_connection(connection_id, *connection);\n+    }\n+\n+    public entry fun connection_open_confirm(\n+        connection_id: u32, proof_ack: vector<u8>, proof_height: u64\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            smart_table::contains(&store.connections, connection_id),\n+            E_CONNECTION_DOES_NOT_EXIST\n+        );\n+\n+        let connection = smart_table::borrow_mut(&mut store.connections, connection_id);\n+        assert!(\n+            connection_end::state(connection) == CONN_STATE_TRYOPEN,\n+            E_INVALID_CONNECTION_STATE\n+        );\n+\n+        // Create the expected connection\n+        let expected_connection =\n+            connection_end::new(\n+                CONN_STATE_OPEN,\n+                connection_end::counterparty_client_id(connection),\n+                connection_end::client_id(connection),\n+                connection_id,\n+                *connection_end::counterparty_client_type(connection),\n+                *connection_end::client_type(connection)\n+            );\n+        let counterparty_connection_id =\n+            connection_end::counterparty_connection_id(connection);\n+\n+        // Verify the connection state\n+        let err =\n+            verify_connection_state(\n+                connection,\n+                proof_height,\n+                proof_ack,\n+                counterparty_connection_id,\n+                expected_connection\n+            );\n+        assert!(err == 0, err);\n+\n+        connection_end::set_state(connection, CONN_STATE_OPEN);\n+\n+        event::emit(\n+            ConnectionOpenAck {\n+                connection_id: connection_id,\n+                client_type: *connection_end::client_type(connection),\n+                client_id: connection_end::client_id(connection),\n+                counterparty_client_type: *connection_end::counterparty_client_type(\n+                    connection\n+                ),\n+                counterparty_client_id: connection_end::counterparty_client_id(connection),\n+                counterparty_connection_id: connection_end::counterparty_connection_id(\n+                    connection\n+                )\n+            }\n+        );\n+\n+        commit_connection(connection_id, *connection);\n+    }\n+\n+    public entry fun update_client(\n+        client_id: u32, client_message: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            table::contains(\n+                &store.commitments,\n+                commitment::client_state_commitment_key(client_id)\n+            ),\n+            E_CLIENT_NOT_FOUND\n+        );\n+\n+        if (light_client::check_for_misbehaviour(client_id, client_message)) {\n+            event::emit(\n+                SubmitMisbehaviour {\n+                    client_id,\n+                    client_type: string::utf8(CLIENT_TYPE_COMETBLS)\n+                }\n+            );\n+            return\n+        };\n+\n+        let (client_state, consensus_states, heights) =\n+            light_client::update_client(client_id, client_message);\n+\n+        let heights_len = vector::length(&heights);\n+\n+        assert!(\n+            !vector::is_empty(&consensus_states)\n+                && !vector::is_empty(&heights)\n+                && heights_len == vector::length(&consensus_states),\n+            E_INVALID_UPDATE\n+        );\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::client_state_commitment_key(client_id),\n+            client_state\n+        );\n+\n+        let i = 0;\n+        while (i < heights_len) {\n+            let height = *vector::borrow(&heights, i);\n+\n+            table::upsert(\n+                &mut store.commitments,\n+                commitment::consensus_state_commitment_key(client_id, height),\n+                hash::sha2_256(*vector::borrow(&consensus_states, i))\n+            );\n+\n+            event::emit(\n+                ClientUpdated {\n+                    client_id,\n+                    // NOTE: This is currently enforced, if/when we refactor to be more general across clients then this will need to be modified accordingly\n+                    client_type: string::utf8(CLIENT_TYPE_COMETBLS),\n+                    height\n+                }\n+            );\n+\n+            i = i + 1;\n+        };\n+    }\n+\n+    public entry fun submit_misbehaviour(\n+        client_id: u32, misbehaviour: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            table::contains(\n+                &store.commitments,\n+                commitment::client_state_commitment_key(client_id)\n+            ),\n+            E_CLIENT_NOT_FOUND\n+        );\n+\n+        light_client::report_misbehaviour(client_id, misbehaviour);\n+\n+        event::emit(\n+            SubmitMisbehaviour {\n+                client_id,\n+                client_type: string::utf8(CLIENT_TYPE_COMETBLS)\n+            }\n+        );\n+    }\n+\n+    public entry fun channel_open_init<T: key + store + drop>(\n+        port_id: address,\n+        connection_id: u32,\n+        ordering: u8,\n+        version: vector<u8>\n+    ) acquires IBCStore, Port {\n+\n+        let port = borrow_global<Port<T>>(get_vault_addr());\n+        assert!(port.port_id == port_id, E_UNAUTHORIZED);\n+\n+        let port_id = address_to_string(port_id);\n+\n+        ensure_connection_state(connection_id);\n+\n+        let channel_id = generate_channel_identifier();\n+\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let channel = channel::default();\n+        channel::set_state(&mut channel, CHAN_STATE_INIT);\n+        channel::set_ordering(&mut channel, ordering);\n+        channel::set_connection_id(&mut channel, connection_id);\n+        channel::set_version(&mut channel, version);\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::next_sequence_send_commitment_key(channel_id),\n+            bcs::to_bytes(&1)\n+        );\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::next_sequence_recv_commitment_key(channel_id),\n+            bcs::to_bytes(&1)\n+        );\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::next_sequence_ack_commitment_key(channel_id),\n+            bcs::to_bytes(&1)\n+        );\n+\n+        commit_channel(channel_id, channel);\n+\n+        let dynamic_dispatch_param =",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1827710322",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3193,
        "pr_file": "move/move-ibc/sources/dispatch_ibc.move",
        "discussion_id": "1827710322",
        "commented_code": "@@ -0,0 +1,2444 @@\n+module ibc::ibc_dispatch {\n+    use std::signer;\n+    use std::vector;\n+    use aptos_std::smart_table::{Self, SmartTable};\n+    use aptos_std::table::{Self, Table};\n+    use std::block;\n+    use std::from_bcs;\n+    use std::event;\n+    use std::bcs;\n+    use std::object;\n+    use std::string::{Self, String, utf8};\n+    use std::hash;\n+    use std::timestamp;\n+    use std::option::{Self, Option};\n+\n+    use std::string_utils;\n+    use ibc::commitment;\n+    use ibc::light_client;\n+    use ibc::connection_end::{Self, ConnectionEnd};\n+    use ibc::channel::{Self, Channel};\n+    use ibc::packet::{Self, Packet};\n+\n+    const IBC_APP_SEED: vector<u8> = b\"union-ibc-app-v1\";\n+    const COMMITMENT_MAGIC: vector<u8> = x\"0100000000000000000000000000000000000000000000000000000000000000\";\n+    const COMMITMENT_NULL: vector<u8> = x\"0000000000000000000000000000000000000000000000000000000000000000\";\n+\n+    const CLIENT_TYPE_COMETBLS: vector<u8> = b\"cometbls\";\n+\n+    const CHAN_STATE_UNINITIALIZED: u8 = 0;\n+    const CHAN_STATE_INIT: u8 = 1;\n+    const CHAN_STATE_TRYOPEN: u8 = 2;\n+    const CHAN_STATE_OPEN: u8 = 3;\n+    const CHAN_STATE_CLOSED: u8 = 4;\n+\n+    const CHAN_ORDERING_NONE: u8 = 0;\n+    const CHAN_ORDERING_UNORDERED: u8 = 1;\n+    const CHAN_ORDERING_ORDERED: u8 = 2;\n+\n+    const CONN_STATE_UNSPECIFIED: u64 = 0;\n+    const CONN_STATE_INIT: u64 = 1;\n+    const CONN_STATE_TRYOPEN: u64 = 2;\n+    const CONN_STATE_OPEN: u64 = 3;\n+\n+    const VAULT_SEED: vector<u8> = b\"IBC_VAULT_SEED\";\n+\n+    const E_NOT_ENOUGH_PERMISSIONS_TO_INITIALIZE: u64 = 1001;\n+    const E_CLIENT_NOT_FOUND: u64 = 1002;\n+    const E_VERSION_MUST_BE_UNSET: u64 = 1006;\n+    const E_UNSUPPORTED_VERSION: u64 = 1007;\n+    const E_INVALID_CONNECTION_STATE: u64 = 1008;\n+    const E_CONNECTION_ALREADY_EXISTS: u64 = 1009;\n+    const E_CONN_NOT_SINGLE_HOP: u64 = 1011;\n+    const E_CONN_NOT_SINGLE_VERSION: u64 = 1012;\n+    const E_UNSUPPORTED_FEATURE: u64 = 1013;\n+    const E_PORT_ID_MUST_BE_LOWERCASE: u64 = 1015;\n+    const E_INVALID_CHANNEL_STATE: u64 = 1016;\n+    const E_COUNTERPARTY_CHANNEL_NOT_EMPTY: u64 = 1017;\n+    const E_INVALID_TIMEOUT_HEIGHT: u64 = 1018;\n+    const E_LATEST_TIMESTAMP_NOT_FOUND: u64 = 1019;\n+    const E_UNAUTHORIZED: u64 = 1020;\n+    const E_INVALID_TIMEOUT_TIMESTAMP: u64 = 1021;\n+    const E_LATEST_HEIGHT_NOT_FOUND: u64 = 1022;\n+    const E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH: u64 = 1023;\n+    const E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH: u64 = 1022;\n+    const E_TIMESTAMP_TIMEOUT: u64 = 1023;\n+    const E_HEIGHT_TIMEOUT: u64 = 1024;\n+    const E_PACKET_ALREADY_RECEIVED: u64 = 1025;\n+    const E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH: u64 = 1026;\n+    const E_UNKNOWN_CHANNEL_ORDERING: u64 = 1027;\n+    const E_CONNECTION_DOES_NOT_EXIST: u64 = 1028;\n+    const E_ACKNOWLEDGEMENT_IS_EMPTY: u64 = 1028;\n+    const E_ACKNOWLEDGEMENT_ALREADY_EXISTS: u64 = 1029;\n+    const E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH: u64 = 1030;\n+    const E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH: u64 = 1031;\n+    const E_PACKET_COMMITMENT_NOT_FOUND: u64 = 1032;\n+    const E_INVALID_PACKET_COMMITMENT: u64 = 1033;\n+    const E_TIMESTAMP_TIMEOUT_NOT_REACHED: u64 = 1034;\n+    const E_TIMEOUT_HEIGHT_NOT_REACHED: u64 = 1035;\n+    const E_INVALID_UPDATE: u64 = 1036;\n+    const E_NEXT_SEQUENCE_MUST_BE_GREATER_THAN_TIMEOUT_SEQUENCE: u64 = 1037;\n+    const E_CLIENT_NOT_ACTIVE: u64 = 1038;\n+    const E_UNKNOWN_CLIENT_TYPE: u64 = 1039;\n+    const E_NOT_ENOUGH_PACKETS: u64 = 1040;\n+    const E_PACKET_NOT_RECEIVED: u64 = 1041;\n+    const E_ACK_ALREADY_EXIST: u64 = 1042;\n+    const E_CANNOT_INTENT_ORDERED: u64 = 1043;\n+    const E_TIMEOUT_MUST_BE_SET: u64 = 1044;\n+    const E_PACKET_SEQUENCE_ACK_SEQUENCE_MISMATCH: u64 = 1045;\n+\n+    #[event]\n+    struct ClientCreatedEvent has copy, drop, store {\n+        client_id: u32,\n+        client_type: String,\n+        consensus_height: u64\n+    }\n+\n+    #[event]\n+    struct ClientUpdated has copy, drop, store {\n+        client_id: u32,\n+        client_type: String,\n+        height: u64\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenInit has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32\n+    }\n+\n+    #[event]\n+    struct ChannelOpenInit has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        connection_id: u32,\n+        version: vector<u8>\n+    }\n+\n+    #[event]\n+    struct ChannelOpenTry has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        connection_id: u32,\n+        version: vector<u8>\n+    }\n+\n+    #[event]\n+    struct ChannelOpenAck has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ChannelOpenConfirm has copy, drop, store {\n+        port_id: String,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenTry has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenAck has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32\n+    }\n+\n+    #[event]\n+    struct ConnectionOpenConfirm has copy, drop, store {\n+        connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32\n+    }\n+\n+    #[event]\n+    struct SendPacket has drop, store {\n+        sequence: u64,\n+        source_channel: u32,\n+        destination_channel: u32,\n+        data: vector<u8>,\n+        timeout_height: u64,\n+        timeout_timestamp: u64\n+    }\n+\n+    #[event]\n+    struct RecvPacket has drop, store {\n+        packet: Packet\n+    }\n+\n+    #[event]\n+    struct RecvIntentPacket has drop, store {\n+        packet: Packet\n+    }\n+\n+    #[event]\n+    struct TimeoutPacket has drop, store {\n+        packet: Packet\n+    }\n+\n+    #[event]\n+    struct WriteAcknowledgement has drop, store {\n+        packet: Packet,\n+        acknowledgement: vector<u8>\n+    }\n+\n+    #[event]\n+    struct AcknowledgePacket has drop, store {\n+        packet: Packet,\n+        acknowledgement: vector<u8>\n+    }\n+\n+    #[event]\n+    struct SubmitMisbehaviour has drop, store {\n+        client_id: u32,\n+        client_type: String\n+    }\n+\n+    struct Port<T: key + store + drop> has key, copy, drop, store {\n+        port_id: address\n+    }\n+\n+    use aptos_framework::function_info;\n+    use aptos_framework::function_info::FunctionInfo;\n+\n+    // use ibc::ping_pong_app;\n+    // use ibc::dynamic_dispatch_app2;\n+    use ibc::dispatcher;\n+    use ibc::engine;\n+\n+    struct RecvPacketParams has copy, drop, store {\n+        packet: Packet\n+    }\n+\n+    struct RecvIntentPacketParams has copy, drop, store {\n+        packet: Packet\n+    }\n+\n+    struct AcknowledgePacketParams has copy, drop, store {\n+        packet: Packet,\n+        acknowledgement: vector<u8>\n+    }\n+\n+    struct TimeoutPacketParams has copy, drop, store {\n+        packet: Packet\n+    }\n+\n+    struct ChannelOpenInitParams has copy, drop, store {\n+        ordering: u8,\n+        connection_id: u32,\n+        channel_id: u32,\n+        version: vector<u8>\n+    }\n+\n+    struct ChannelOpenTryParams has copy, drop, store {\n+        ordering: u8,\n+        connection_id: u32,\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        version: vector<u8>,\n+        counterparty_version: vector<u8>\n+    }\n+\n+    struct ChannelOpenAckParams has copy, drop, store {\n+        channel_id: u32,\n+        counterparty_channel_id: u32,\n+        counterparty_version: vector<u8>\n+    }\n+\n+    struct ChannelOpenConfirmParams has copy, drop, store {\n+        channel_id: u32\n+    }\n+\n+    struct ChannelCloseInitParams has copy, drop, store {\n+        channel_id: u32\n+    }\n+\n+    struct ChannelCloseConfirmParams has copy, drop, store {\n+        channel_id: u32\n+    }\n+\n+    struct DynamicDispatchParam has copy, store, drop, key {\n+        recv_packet_param: option::Option<RecvPacketParams>,\n+        recv_intent_packet_param: option::Option<RecvIntentPacketParams>,\n+        acknowledge_packet_param: option::Option<AcknowledgePacketParams>,\n+        timeout_packet_param: option::Option<TimeoutPacketParams>,\n+        channel_open_init_param: option::Option<ChannelOpenInitParams>,\n+        channel_open_try_param: option::Option<ChannelOpenTryParams>,\n+        channel_open_ack_param: option::Option<ChannelOpenAckParams>,\n+        channel_open_confirm_param: option::Option<ChannelOpenConfirmParams>,\n+        channel_close_init_param: option::Option<ChannelCloseInitParams>,\n+        channel_close_confirm_param: option::Option<ChannelCloseConfirmParams>\n+    }\n+\n+    public fun recv_packet_param(param: &DynamicDispatchParam):\n+        option::Option<RecvPacketParams> {\n+        param.recv_packet_param\n+    }\n+\n+    public fun recv_intent_packet_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<RecvIntentPacketParams> {\n+        param.recv_intent_packet_param\n+    }\n+\n+    public fun acknowledge_packet_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<AcknowledgePacketParams> {\n+        param.acknowledge_packet_param\n+    }\n+\n+    public fun timeout_packet_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<TimeoutPacketParams> {\n+        param.timeout_packet_param\n+    }\n+\n+    public fun channel_open_init_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenInitParams> {\n+        param.channel_open_init_param\n+    }\n+\n+    public fun channel_open_try_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenTryParams> {\n+        param.channel_open_try_param\n+    }\n+\n+    public fun channel_open_ack_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenAckParams> {\n+        param.channel_open_ack_param\n+    }\n+\n+    public fun channel_open_confirm_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelOpenConfirmParams> {\n+        param.channel_open_confirm_param\n+    }\n+\n+    public fun channel_close_init_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelCloseInitParams> {\n+        param.channel_close_init_param\n+    }\n+\n+    public fun channel_close_confirm_param(\n+        param: &DynamicDispatchParam\n+    ): option::Option<ChannelCloseConfirmParams> {\n+        param.channel_close_confirm_param\n+    }\n+\n+    // Getter for RecvPacketParams\n+    public fun get_packet_from_recv_param(param: &RecvPacketParams): &Packet {\n+        &param.packet\n+    }\n+\n+    // Getter for RecvPacketParams\n+    public fun get_packet_from_recv_intent_param(\n+        param: &RecvIntentPacketParams\n+    ): &Packet {\n+        &param.packet\n+    }\n+\n+    // Getters for AcknowledgePacketParams\n+    public fun get_packet_from_ack_param(param: &AcknowledgePacketParams): &Packet {\n+        &param.packet\n+    }\n+\n+    public fun get_acknowledgement_from_ack_param(\n+        param: &AcknowledgePacketParams\n+    ): &vector<u8> {\n+        &param.acknowledgement\n+    }\n+\n+    // Getter for TimeoutPacketParams\n+    public fun get_packet_from_timeout_param(param: &TimeoutPacketParams): &Packet {\n+        &param.packet\n+    }\n+\n+    // Getters for ChannelOpenInitParams\n+    public fun get_ordering_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): u8 {\n+        param.ordering\n+    }\n+\n+    public fun get_connection_id_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): u32 {\n+        param.connection_id\n+    }\n+\n+    public fun get_channel_id_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun get_version_from_channel_open_init_param(\n+        param: &ChannelOpenInitParams\n+    ): &vector<u8> {\n+        &param.version\n+    }\n+\n+    // Getters for ChannelOpenTryParams\n+    public fun get_ordering_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u8 {\n+        param.ordering\n+    }\n+\n+    public fun get_connection_id_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u32 {\n+        param.connection_id\n+    }\n+\n+    public fun get_channel_id_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun get_counterparty_channel_id_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): u32 {\n+        param.counterparty_channel_id\n+    }\n+\n+    public fun get_version_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): &vector<u8> {\n+        &param.version\n+    }\n+\n+    public fun get_counterparty_version_from_channel_open_try_param(\n+        param: &ChannelOpenTryParams\n+    ): &vector<u8> {\n+        &param.counterparty_version\n+    }\n+\n+    // Getters for ChannelOpenAckParams\n+    public fun get_channel_id_from_channel_open_ack_param(\n+        param: &ChannelOpenAckParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun get_counterparty_channel_id_from_channel_open_ack_param(\n+        param: &ChannelOpenAckParams\n+    ): u32 {\n+        param.counterparty_channel_id\n+    }\n+\n+    public fun get_counterparty_version_from_channel_open_ack_param(\n+        param: &ChannelOpenAckParams\n+    ): &vector<u8> {\n+        &param.counterparty_version\n+    }\n+\n+    // Getter for ChannelOpenConfirmParams\n+    public fun get_channel_id_from_channel_open_confirm_param(\n+        param: &ChannelOpenConfirmParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    // Getter for ChannelCloseInitParams\n+    public fun get_channel_id_from_channel_close_init_param(\n+        param: &ChannelCloseInitParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    // Getter for ChannelCloseConfirmParams\n+    public fun get_channel_id_from_channel_close_confirm_param(\n+        param: &ChannelCloseConfirmParams\n+    ): u32 {\n+        param.channel_id\n+    }\n+\n+    public fun new_dynamic_dispatch_param(\n+        recv_packet_param: option::Option<RecvPacketParams>,\n+        recv_intent_packet_param: option::Option<RecvIntentPacketParams>,\n+        acknowledge_packet_param: option::Option<AcknowledgePacketParams>,\n+        timeout_packet_param: option::Option<TimeoutPacketParams>,\n+        channel_open_init_param: option::Option<ChannelOpenInitParams>,\n+        channel_open_try_param: option::Option<ChannelOpenTryParams>,\n+        channel_open_ack_param: option::Option<ChannelOpenAckParams>,\n+        channel_open_confirm_param: option::Option<ChannelOpenConfirmParams>,\n+        channel_close_init_param: option::Option<ChannelCloseInitParams>,\n+        channel_close_confirm_param: option::Option<ChannelCloseConfirmParams>\n+    ): DynamicDispatchParam {\n+        DynamicDispatchParam {\n+            recv_packet_param,\n+            recv_intent_packet_param,\n+            acknowledge_packet_param,\n+            timeout_packet_param,\n+            channel_open_init_param,\n+            channel_open_try_param,\n+            channel_open_ack_param,\n+            channel_open_confirm_param,\n+            channel_close_init_param,\n+            channel_close_confirm_param\n+        }\n+    }\n+\n+    public fun register_application<T: key + store + drop>(\n+        ibc_app: &signer, cb: FunctionInfo, type: T\n+    ) acquires SignerRef { // pingpongapp bunu cagiracak\n+        dispatcher::register<T>(cb, type, bcs::to_bytes(&signer::address_of(ibc_app)));\n+        move_to(\n+            &get_ibc_signer(),\n+            Port<T> { port_id: signer::address_of(ibc_app) }\n+        );\n+    }\n+\n+    // Resource to hold the global state\n+    struct IBCStore has key {\n+        client_impls: SmartTable<String, address>,\n+        client_registry: SmartTable<String, address>,\n+        commitments: Table<vector<u8>, vector<u8>>,\n+        connections: SmartTable<u32, ConnectionEnd>,\n+        channels: SmartTable<u32, Channel>\n+    }\n+\n+    struct SignerRef has key {\n+        self_ref: object::ExtendRef\n+    }\n+\n+    // Initializes the IBCStore resource in the signer's account\n+    fun init_module(account: &signer) {\n+        assert!(\n+            signer::address_of(account) == @ibc, E_NOT_ENOUGH_PERMISSIONS_TO_INITIALIZE\n+        );\n+        let vault_constructor_ref = &object::create_named_object(account, VAULT_SEED);\n+        let vault_signer = &object::generate_signer(vault_constructor_ref);\n+\n+        let store = IBCStore {\n+            client_registry: smart_table::new(),\n+            commitments: table::new(),\n+            client_impls: smart_table::new(),\n+            connections: smart_table::new(),\n+            channels: smart_table::new()\n+        };\n+\n+        move_to(vault_signer, store);\n+\n+        move_to(\n+            vault_signer,\n+            SignerRef { self_ref: object::generate_extend_ref(vault_constructor_ref) }\n+        );\n+    }\n+\n+    /// Create a client with an initial client and consensus state\n+    public entry fun create_client(\n+        client_type: String, client_state: vector<u8>, consensus_state: vector<u8>\n+    ) acquires IBCStore, SignerRef {\n+        // NOTE(aeryz): At this point, we don't need to have a routing mechanism because it will introduce\n+        // additional gas cost. We should only enforce the use of `cometbls` for the `client_type`\n+        assert!(string::bytes(&client_type) == &b\"cometbls\", E_UNKNOWN_CLIENT_TYPE);\n+\n+        let client_id = generate_client_identifier();\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let (client_state, consensus_state) =\n+            light_client::create_client(\n+                &get_ibc_signer(),\n+                client_id,\n+                // from_bcs::to_bytes(client_state),\n+                // from_bcs::to_bytes(consensus_state),\n+                client_state,\n+                consensus_state\n+            );\n+\n+        // TODO(aeryz): fetch these status from proper exported consts\n+        assert!(light_client::status(client_id) == 0, E_CLIENT_NOT_ACTIVE);\n+\n+        // Update commitments\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::client_state_commitment_key(client_id),\n+            client_state\n+        );\n+\n+        let latest_height = light_client::latest_height(client_id);\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::consensus_state_commitment_key(client_id, latest_height),\n+            consensus_state\n+        );\n+\n+        event::emit(\n+            ClientCreatedEvent { client_id, client_type, consensus_height: latest_height }\n+        );\n+    }\n+\n+    public entry fun connection_open_init(\n+        client_type: String,\n+        client_id: u32,\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32\n+    ) acquires IBCStore {\n+        let connection_id = generate_connection_identifier();\n+\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let connection =\n+            connection_end::new(\n+                CONN_STATE_INIT,\n+                client_id,\n+                counterparty_client_id,\n+                0,\n+                client_type,\n+                counterparty_client_type\n+            );\n+\n+        smart_table::upsert(&mut store.connections, connection_id, connection);\n+\n+        commit_connection(connection_id, connection);\n+\n+        event::emit(\n+            ConnectionOpenInit {\n+                connection_id: connection_id,\n+                client_type: client_type,\n+                client_id: client_id,\n+                counterparty_client_type: counterparty_client_type,\n+                counterparty_client_id: counterparty_client_id\n+            }\n+        )\n+    }\n+\n+    public entry fun connection_open_try(\n+        counterparty_client_type: String,\n+        counterparty_client_id: u32,\n+        counterparty_connection_id: u32,\n+        client_type: String,\n+        client_id: u32,\n+        proof_init: vector<u8>,\n+        proof_height: u64\n+    ) acquires IBCStore {\n+        let connection_id = generate_connection_identifier();\n+\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let connection =\n+            smart_table::borrow_mut_with_default(\n+                &mut store.connections,\n+                connection_id,\n+                connection_end::new(\n+                    CONN_STATE_TRYOPEN,\n+                    client_id,\n+                    counterparty_client_id,\n+                    counterparty_connection_id,\n+                    client_type,\n+                    counterparty_client_type\n+                )\n+            );\n+\n+        // Create the expected connection\n+        let expected_connection =\n+            connection_end::new(\n+                CONN_STATE_INIT,\n+                counterparty_client_id,\n+                client_id,\n+                0, // counterparty_connection_id\n+                counterparty_client_type,\n+                utf8(b\"\")\n+            );\n+\n+        // Verify the connection state\n+        let err =\n+            verify_connection_state(\n+                connection,\n+                proof_height,\n+                proof_init,\n+                counterparty_connection_id,\n+                expected_connection\n+            );\n+        assert!(err == 0, err);\n+\n+        event::emit(\n+            ConnectionOpenTry {\n+                connection_id,\n+                client_type,\n+                client_id: client_id,\n+                counterparty_client_id: counterparty_client_id,\n+                counterparty_client_type: counterparty_client_type,\n+                counterparty_connection_id: counterparty_connection_id\n+            }\n+        );\n+\n+        commit_connection(connection_id, *connection);\n+    }\n+\n+    public entry fun connection_open_ack(\n+        connection_id: u32,\n+        counterparty_connection_id: u32,\n+        proof_try: vector<u8>,\n+        proof_height: u64\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            smart_table::contains(&store.connections, connection_id),\n+            E_CONNECTION_DOES_NOT_EXIST\n+        );\n+\n+        let connection = smart_table::borrow_mut(&mut store.connections, connection_id);\n+        assert!(\n+            connection_end::state(connection) == CONN_STATE_INIT,\n+            E_INVALID_CONNECTION_STATE\n+        );\n+\n+        // Create the expected connection\n+        let expected_connection =\n+            connection_end::new(\n+                CONN_STATE_TRYOPEN,\n+                connection_end::counterparty_client_id(connection),\n+                connection_end::client_id(connection),\n+                connection_id,\n+                *connection_end::counterparty_client_type(connection),\n+                *connection_end::client_type(connection)\n+            );\n+\n+        // Verify the connection state\n+        let err =\n+            verify_connection_state(\n+                connection,\n+                proof_height,\n+                proof_try,\n+                counterparty_connection_id,\n+                expected_connection\n+            );\n+        assert!(err == 0, err);\n+\n+        connection_end::set_state(connection, CONN_STATE_TRYOPEN);\n+        connection_end::set_counterparty_connection_id(\n+            connection, counterparty_connection_id\n+        );\n+\n+        event::emit(\n+            ConnectionOpenAck {\n+                connection_id,\n+                client_type: *connection_end::client_type(connection),\n+                client_id: connection_end::client_id(connection),\n+                counterparty_client_id: connection_end::counterparty_client_id(\n+                    connection\n+                ),\n+                counterparty_connection_id: connection_end::counterparty_connection_id(\n+                    connection\n+                ),\n+                counterparty_client_type: *connection_end::counterparty_client_type(\n+                    connection\n+                )\n+            }\n+        );\n+\n+        commit_connection(connection_id, *connection);\n+    }\n+\n+    public entry fun connection_open_confirm(\n+        connection_id: u32, proof_ack: vector<u8>, proof_height: u64\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            smart_table::contains(&store.connections, connection_id),\n+            E_CONNECTION_DOES_NOT_EXIST\n+        );\n+\n+        let connection = smart_table::borrow_mut(&mut store.connections, connection_id);\n+        assert!(\n+            connection_end::state(connection) == CONN_STATE_TRYOPEN,\n+            E_INVALID_CONNECTION_STATE\n+        );\n+\n+        // Create the expected connection\n+        let expected_connection =\n+            connection_end::new(\n+                CONN_STATE_OPEN,\n+                connection_end::counterparty_client_id(connection),\n+                connection_end::client_id(connection),\n+                connection_id,\n+                *connection_end::counterparty_client_type(connection),\n+                *connection_end::client_type(connection)\n+            );\n+        let counterparty_connection_id =\n+            connection_end::counterparty_connection_id(connection);\n+\n+        // Verify the connection state\n+        let err =\n+            verify_connection_state(\n+                connection,\n+                proof_height,\n+                proof_ack,\n+                counterparty_connection_id,\n+                expected_connection\n+            );\n+        assert!(err == 0, err);\n+\n+        connection_end::set_state(connection, CONN_STATE_OPEN);\n+\n+        event::emit(\n+            ConnectionOpenAck {\n+                connection_id: connection_id,\n+                client_type: *connection_end::client_type(connection),\n+                client_id: connection_end::client_id(connection),\n+                counterparty_client_type: *connection_end::counterparty_client_type(\n+                    connection\n+                ),\n+                counterparty_client_id: connection_end::counterparty_client_id(connection),\n+                counterparty_connection_id: connection_end::counterparty_connection_id(\n+                    connection\n+                )\n+            }\n+        );\n+\n+        commit_connection(connection_id, *connection);\n+    }\n+\n+    public entry fun update_client(\n+        client_id: u32, client_message: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            table::contains(\n+                &store.commitments,\n+                commitment::client_state_commitment_key(client_id)\n+            ),\n+            E_CLIENT_NOT_FOUND\n+        );\n+\n+        if (light_client::check_for_misbehaviour(client_id, client_message)) {\n+            event::emit(\n+                SubmitMisbehaviour {\n+                    client_id,\n+                    client_type: string::utf8(CLIENT_TYPE_COMETBLS)\n+                }\n+            );\n+            return\n+        };\n+\n+        let (client_state, consensus_states, heights) =\n+            light_client::update_client(client_id, client_message);\n+\n+        let heights_len = vector::length(&heights);\n+\n+        assert!(\n+            !vector::is_empty(&consensus_states)\n+                && !vector::is_empty(&heights)\n+                && heights_len == vector::length(&consensus_states),\n+            E_INVALID_UPDATE\n+        );\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::client_state_commitment_key(client_id),\n+            client_state\n+        );\n+\n+        let i = 0;\n+        while (i < heights_len) {\n+            let height = *vector::borrow(&heights, i);\n+\n+            table::upsert(\n+                &mut store.commitments,\n+                commitment::consensus_state_commitment_key(client_id, height),\n+                hash::sha2_256(*vector::borrow(&consensus_states, i))\n+            );\n+\n+            event::emit(\n+                ClientUpdated {\n+                    client_id,\n+                    // NOTE: This is currently enforced, if/when we refactor to be more general across clients then this will need to be modified accordingly\n+                    client_type: string::utf8(CLIENT_TYPE_COMETBLS),\n+                    height\n+                }\n+            );\n+\n+            i = i + 1;\n+        };\n+    }\n+\n+    public entry fun submit_misbehaviour(\n+        client_id: u32, misbehaviour: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        assert!(\n+            table::contains(\n+                &store.commitments,\n+                commitment::client_state_commitment_key(client_id)\n+            ),\n+            E_CLIENT_NOT_FOUND\n+        );\n+\n+        light_client::report_misbehaviour(client_id, misbehaviour);\n+\n+        event::emit(\n+            SubmitMisbehaviour {\n+                client_id,\n+                client_type: string::utf8(CLIENT_TYPE_COMETBLS)\n+            }\n+        );\n+    }\n+\n+    public entry fun channel_open_init<T: key + store + drop>(\n+        port_id: address,\n+        connection_id: u32,\n+        ordering: u8,\n+        version: vector<u8>\n+    ) acquires IBCStore, Port {\n+\n+        let port = borrow_global<Port<T>>(get_vault_addr());\n+        assert!(port.port_id == port_id, E_UNAUTHORIZED);\n+\n+        let port_id = address_to_string(port_id);\n+\n+        ensure_connection_state(connection_id);\n+\n+        let channel_id = generate_channel_identifier();\n+\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        let channel = channel::default();\n+        channel::set_state(&mut channel, CHAN_STATE_INIT);\n+        channel::set_ordering(&mut channel, ordering);\n+        channel::set_connection_id(&mut channel, connection_id);\n+        channel::set_version(&mut channel, version);\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::next_sequence_send_commitment_key(channel_id),\n+            bcs::to_bytes(&1)\n+        );\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::next_sequence_recv_commitment_key(channel_id),\n+            bcs::to_bytes(&1)\n+        );\n+\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment::next_sequence_ack_commitment_key(channel_id),\n+            bcs::to_bytes(&1)\n+        );\n+\n+        commit_channel(channel_id, channel);\n+\n+        let dynamic_dispatch_param =",
        "comment_created_at": "2024-11-04T13:12:13+00:00",
        "comment_author": "aeryz",
        "comment_body": "if we are not gonna be able to do this with `Any`, let's have helper functions such as:\r\n```move\r\nnew_channel_open_init_params(ordering, connection_id, channel_id, version)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1726954526",
    "pr_number": 2787,
    "pr_file": "site/src/content/docs/docs/integrations/api/graphql.mdx",
    "created_at": "2024-08-22T12:23:04+00:00",
    "commented_code": "+---\n+title: \"GraphQL\"\n+sidebar:\n+  order: 1\n+---\n+Unionlabs provides a hosted indexing service for all connected chains, served at [graphql.union.build](https://graphql.union.build/v1/graphql). \n+A [UI](https://cloud.hasura.io/public/graphiql?endpoint=https://graphql.union.build/v1/graphql) is also provided, which can be used \n+to explore all available data. This guide goes through the most useful queries and types.\n+\n+Although most HTTP clients can be used to query our API, we recommend [URQL](https://commerce.nearform.com/open-source/urql/). Our GraphQL schema can\n+be downloaded using [`graphqurl`](https://github.com/hasura/graphqurl) or [`graphql-inspector`](https://the-guild.dev/graphql/inspector):\n+\n+```bash title=\"introspecting the schema\"\n+export npm_config_yes=true\n+\n+# using graphqurl\n+npx graphqurl https://graphql.union.build/v1/graphql \\\n+  --introspect > schema.graphql\n+\n+# some clients require a JSON schema\n+npx graphqurl https://graphql.union.build/v1/graphql \\\n+  --introspect \\\n+  --format json > schema.json\n+\n+# using graphql-inspector\n+npx @graphql-inspector/cli \\\n+  introspect https://graphql.union.build/v1/graphql \\\n+  --write schema.graphql\n+```\n+\n+This schema can be used by API clients and editors like VSCode to provide a better developer experience.\n+\n+## Concepts\n+\n+The following definitions are used across the schema and documentation:\n+\n+- `source`: The chain or rollup where the packet is sent from, often prefixed such as `source_timestamp` or `source_transaction_hash`.\n+- `destination`: The chain or roll-up that receives the packet. \n+- `sender`: the contract or [EOA](https://ethereum.org/en/developers/docs/accounts/) that made the transfer.\n+- `receiver`: the contract or [EOA](https://ethereum.org/en/developers/docs/accounts/) that received the transfer.\n+\n+## Queries\n+\n+Below we have documented some common useful queries that are also leveraged in [app.union.build](https://app.union.build). For all queries, Union\n+provides caches to increase performance. Use the syntax `@cached(ttl: ${time_in_seconds})` to cache the query. The cache key, which is used \n+to map the query to the response, is computed by hashing:\n+\n+- the GraphQL query.\n+- the GraphQL operation name.\n+- the GraphQL variables of the query.\n+\n+Caching can dramatically improve performance. Always add at least `@cached(ttl: 1)` to cache data between different windows, tabs, or users.\n+\n+### Transfers\n+\n+Transfers facilitated by Union (either `ucs-relay-1` or `ics20-1`) are queryable using v1_transfers.\n+\n+```graphql\n+query GetLatest10Transfers @cached(ttl: 1) {\n+  v1_transfers(\n+    limit: 10,\n+    order_by: { source_timestamp: desc }\n+  ) {\n+    tokens {\n+      denom\n+      amount\n+    }\n+\t  sender\n+\t  receiver\n+  }\n+}\n+```\n+\n+It provides information on the sender, receiver, current stage of the transfer, and asset metadata.\n+\n+To query for specific addresses, add the `sender` and `receiver` to the where clause:\n+\n+```graphql\n+query GetAllUserTransfers @cached(ttl: 1) {\n+  v1_transfers(\n+    order_by: { source_timestamp: desc }, \n+    where: {\n+      _or: [\n+        { sender: { _eq: \"union1sw44hacrewvkuvm70zfxhwa9u6vm4f8yc8spqu\" }},  \n+        { receiver: { _eq: \"union1sw44hacrewvkuvm70zfxhwa9u6vm4f8yc8spqu\" }}\n+      ]\n+    }\n+  ) {\n+    tokens {\n+      denom\n+      amount\n+    }\n+    receiver\n+    sender\n+    source_chain { display_name }\n+    destination_chain { display_name }\n+  }\n+}\n+\n+```\n+Aggregate statistics about all transfers and packets are also available, such as the total amount of transfers and packets:\n+\n+```graphql\n+query {\n+ \tv1_statistics {\n+    name\n+    value\n+  }\n+}\n+```\n+\n+### Packets\n+\n+Packets, used in general message passing, can be tracked using v1_packets, similar to v1_transfers.\n+\n+```graphql\n+query GetLatest10Packets @cached(ttl: 1) {\n+  v1_packets(\n+    limit: 10,\n+    order_by: { source_timestamp: desc }\n+  ) {\n+    source_chain { display_name }\n+    destination_chain { display_name }\n+\t\tsource_data\n+\t\tsource_sequence\n+    destination_sequence\n+  }\n+}\n+```\n+\n+### Traces\n+\n+Both transfers and packets come with traces to track the progress of the message. There are four different trace types:\n+\n+- `SEND_PACKET`\n+- `LIGHTCLIENT_UPDATE`\n+- `RECEIVE_PACKET`\n+- `ACKNOWLEDGE_PACKET`\n+\n+For a specific transaction hash, you can obtain all traces of transfers and packets caused by this transaction (the `initiating_transaction_hash`) by querying\n+\n+```graphql\n+query GetTracesByHash @cached(ttl: 1) {\n+  v1_traces(\n+    where: {\n+      initiating_transaction_hash: {\n+        _eq: \"91C934788FD13D5325F5A1D9CF1634D1861E318D6DDD2C141E91CBE8A68A053D\"\n+      }\n+    }\n+  ) {\n+    type\n+    data\n+\t  transaction_hash\n+    chain { display_name }\n+  }\n+}\n+```\n+\n+The `v1_traces.data` field is dependent on the type and may contain chain-specific information as well. The `v1_transfers` and `v1_packets` \n+also have a relation to traces, to allow for all info of a specific transfer or packet.\n+\n+```graphql\n+query GetLatest10TransfersWithTraces @cached(ttl: 1) {\n+  v1_transfers(\n+    limit: 10,\n+    order_by: {\n+      source_timestamp: desc\n+    }\n+  ) {\n+    tokens {\n+      denom\n+      amount\n+    }\n+    receiver\n+    sender\n+    traces {\n+      type\n+      data\n+      transaction_hash\n+      chain { display_name }\n+    }\n+  }\n+}\n+```\n+\n+### Assets\n+\n+Unionlabs provides a curated registry of different assets across different chains, including the bridged asset info for Union's assets. \n+\n+```graphql\n+query GetAllSupportedAssets @cached(ttl: 1) {\n+  v1_assets {",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1726954526",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2787,
        "pr_file": "site/src/content/docs/docs/integrations/api/graphql.mdx",
        "discussion_id": "1726954526",
        "commented_code": "@@ -0,0 +1,216 @@\n+---\n+title: \"GraphQL\"\n+sidebar:\n+  order: 1\n+---\n+Unionlabs provides a hosted indexing service for all connected chains, served at [graphql.union.build](https://graphql.union.build/v1/graphql). \n+A [UI](https://cloud.hasura.io/public/graphiql?endpoint=https://graphql.union.build/v1/graphql) is also provided, which can be used \n+to explore all available data. This guide goes through the most useful queries and types.\n+\n+Although most HTTP clients can be used to query our API, we recommend [URQL](https://commerce.nearform.com/open-source/urql/). Our GraphQL schema can\n+be downloaded using [`graphqurl`](https://github.com/hasura/graphqurl) or [`graphql-inspector`](https://the-guild.dev/graphql/inspector):\n+\n+```bash title=\"introspecting the schema\"\n+export npm_config_yes=true\n+\n+# using graphqurl\n+npx graphqurl https://graphql.union.build/v1/graphql \\\n+  --introspect > schema.graphql\n+\n+# some clients require a JSON schema\n+npx graphqurl https://graphql.union.build/v1/graphql \\\n+  --introspect \\\n+  --format json > schema.json\n+\n+# using graphql-inspector\n+npx @graphql-inspector/cli \\\n+  introspect https://graphql.union.build/v1/graphql \\\n+  --write schema.graphql\n+```\n+\n+This schema can be used by API clients and editors like VSCode to provide a better developer experience.\n+\n+## Concepts\n+\n+The following definitions are used across the schema and documentation:\n+\n+- `source`: The chain or rollup where the packet is sent from, often prefixed such as `source_timestamp` or `source_transaction_hash`.\n+- `destination`: The chain or roll-up that receives the packet. \n+- `sender`: the contract or [EOA](https://ethereum.org/en/developers/docs/accounts/) that made the transfer.\n+- `receiver`: the contract or [EOA](https://ethereum.org/en/developers/docs/accounts/) that received the transfer.\n+\n+## Queries\n+\n+Below we have documented some common useful queries that are also leveraged in [app.union.build](https://app.union.build). For all queries, Union\n+provides caches to increase performance. Use the syntax `@cached(ttl: ${time_in_seconds})` to cache the query. The cache key, which is used \n+to map the query to the response, is computed by hashing:\n+\n+- the GraphQL query.\n+- the GraphQL operation name.\n+- the GraphQL variables of the query.\n+\n+Caching can dramatically improve performance. Always add at least `@cached(ttl: 1)` to cache data between different windows, tabs, or users.\n+\n+### Transfers\n+\n+Transfers facilitated by Union (either `ucs-relay-1` or `ics20-1`) are queryable using v1_transfers.\n+\n+```graphql\n+query GetLatest10Transfers @cached(ttl: 1) {\n+  v1_transfers(\n+    limit: 10,\n+    order_by: { source_timestamp: desc }\n+  ) {\n+    tokens {\n+      denom\n+      amount\n+    }\n+\t  sender\n+\t  receiver\n+  }\n+}\n+```\n+\n+It provides information on the sender, receiver, current stage of the transfer, and asset metadata.\n+\n+To query for specific addresses, add the `sender` and `receiver` to the where clause:\n+\n+```graphql\n+query GetAllUserTransfers @cached(ttl: 1) {\n+  v1_transfers(\n+    order_by: { source_timestamp: desc }, \n+    where: {\n+      _or: [\n+        { sender: { _eq: \"union1sw44hacrewvkuvm70zfxhwa9u6vm4f8yc8spqu\" }},  \n+        { receiver: { _eq: \"union1sw44hacrewvkuvm70zfxhwa9u6vm4f8yc8spqu\" }}\n+      ]\n+    }\n+  ) {\n+    tokens {\n+      denom\n+      amount\n+    }\n+    receiver\n+    sender\n+    source_chain { display_name }\n+    destination_chain { display_name }\n+  }\n+}\n+\n+```\n+Aggregate statistics about all transfers and packets are also available, such as the total amount of transfers and packets:\n+\n+```graphql\n+query {\n+ \tv1_statistics {\n+    name\n+    value\n+  }\n+}\n+```\n+\n+### Packets\n+\n+Packets, used in general message passing, can be tracked using v1_packets, similar to v1_transfers.\n+\n+```graphql\n+query GetLatest10Packets @cached(ttl: 1) {\n+  v1_packets(\n+    limit: 10,\n+    order_by: { source_timestamp: desc }\n+  ) {\n+    source_chain { display_name }\n+    destination_chain { display_name }\n+\t\tsource_data\n+\t\tsource_sequence\n+    destination_sequence\n+  }\n+}\n+```\n+\n+### Traces\n+\n+Both transfers and packets come with traces to track the progress of the message. There are four different trace types:\n+\n+- `SEND_PACKET`\n+- `LIGHTCLIENT_UPDATE`\n+- `RECEIVE_PACKET`\n+- `ACKNOWLEDGE_PACKET`\n+\n+For a specific transaction hash, you can obtain all traces of transfers and packets caused by this transaction (the `initiating_transaction_hash`) by querying\n+\n+```graphql\n+query GetTracesByHash @cached(ttl: 1) {\n+  v1_traces(\n+    where: {\n+      initiating_transaction_hash: {\n+        _eq: \"91C934788FD13D5325F5A1D9CF1634D1861E318D6DDD2C141E91CBE8A68A053D\"\n+      }\n+    }\n+  ) {\n+    type\n+    data\n+\t  transaction_hash\n+    chain { display_name }\n+  }\n+}\n+```\n+\n+The `v1_traces.data` field is dependent on the type and may contain chain-specific information as well. The `v1_transfers` and `v1_packets` \n+also have a relation to traces, to allow for all info of a specific transfer or packet.\n+\n+```graphql\n+query GetLatest10TransfersWithTraces @cached(ttl: 1) {\n+  v1_transfers(\n+    limit: 10,\n+    order_by: {\n+      source_timestamp: desc\n+    }\n+  ) {\n+    tokens {\n+      denom\n+      amount\n+    }\n+    receiver\n+    sender\n+    traces {\n+      type\n+      data\n+      transaction_hash\n+      chain { display_name }\n+    }\n+  }\n+}\n+```\n+\n+### Assets\n+\n+Unionlabs provides a curated registry of different assets across different chains, including the bridged asset info for Union's assets. \n+\n+```graphql\n+query GetAllSupportedAssets @cached(ttl: 1) {\n+  v1_assets {",
        "comment_created_at": "2024-08-22T12:23:04+00:00",
        "comment_author": "cor",
        "comment_body": "I recommend inverting this query; make chains toplevel, and then nest assets inside of them. Seeing them grouped by chain makes more intuitive sense",
        "pr_file_module": null
      }
    ]
  }
]