[
  {
    "discussion_id": "2060596026",
    "pr_number": 4429,
    "pr_file": "cosmwasm/osmosis-tokenfactory-token-minter/src/contract.rs",
    "created_at": "2025-04-25T17:03:55+00:00",
    "commented_code": "+use alloy::sol_types::SolValue;\n+use cosmwasm_schema::cw_serde;\n+use cosmwasm_std::{\n+    entry_point, to_json_binary, BankMsg, Binary, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n+    QueryRequest, Response, StdResult,\n+};\n+use ibc_union_spec::ChannelId;\n+use prost::Message;\n+use protos::{\n+    cosmos::bank::v1beta1::DenomUnit, osmosis::tokenfactory::v1beta1::MsgSetDenomMetadata,\n+};\n+use token_factory_api::{TokenFactoryMsg, TokenFactoryQuery};\n+use ucs03_zkgm_token_minter_api::{\n+    ExecuteMsg, LocalTokenMsg, MetadataResponse, PredictWrappedTokenResponse, QueryMsg,\n+    TokenMinterInitMsg, WrappedTokenMsg,\n+};\n+use unionlabs::{\n+    ethereum::keccak256,\n+    primitives::{encoding::Base58, H256, U256},\n+    prost::Name,\n+};\n+\n+pub const DEFAULT_DECIMALS: u8 = 6;\n+\n+use crate::{\n+    error::Error,\n+    state::{ADMIN, TOKEN_ADMIN},\n+};\n+\n+#[entry_point]\n+pub fn instantiate(\n+    deps: DepsMut,\n+    _: Env,\n+    info: MessageInfo,\n+    msg: TokenMinterInitMsg,\n+) -> Result<Response, Error> {\n+    let TokenMinterInitMsg::OsmosisTokenFactory { zkgm_admin } = msg else {\n+        return Err(Error::InvalidMinterConfig);\n+    };\n+    ADMIN.save(deps.storage, &info.sender)?;\n+    TOKEN_ADMIN.save(deps.storage, &zkgm_admin)?;\n+    Ok(Response::default())\n+}\n+\n+#[cw_serde]\n+pub struct MigrateMsg {}\n+\n+#[entry_point]\n+pub fn migrate(_: DepsMut, _: Env, _: MigrateMsg) -> StdResult<Response> {\n+    Ok(Response::new())\n+}\n+\n+fn deconstruct_factory_denom<'a>(env: &Env, denom: &'a str) -> Result<&'a str, Error> {\n+    let denom_parts = denom\n+        .split_once('/')\n+        .and_then(|(a, b)| b.split_once('/').map(|(b, c)| (a, b, c)));\n+\n+    match denom_parts {\n+        Some((\"factory\", addr, subdenom)) if addr == env.contract.address.as_str() => Ok(subdenom),\n+        _ => Err(Error::InvalidDenom(denom.to_string())),\n+    }\n+}\n+\n+#[entry_point]\n+pub fn execute(\n+    deps: DepsMut,\n+    env: Env,\n+    info: MessageInfo,\n+    msg: ExecuteMsg,\n+) -> Result<Response<TokenFactoryMsg>, Error> {\n+    if info.sender != ADMIN.load(deps.storage)? {\n+        return Err(Error::OnlyAdmin);\n+    }\n+\n+    let resp = match msg {\n+        ExecuteMsg::Wrapped(msg) => {\n+            let msgs = match msg {\n+                WrappedTokenMsg::CreateDenom {\n+                    subdenom: denom,\n+                    metadata,\n+                    ..\n+                } => {\n+                    let subdenom = deconstruct_factory_denom(&env, &denom)?;\n+\n+                    vec![\n+                        CosmosMsg::Custom(TokenFactoryMsg::CreateDenom {\n+                            subdenom: subdenom.to_owned(),\n+                        }),\n+                        #[allow(deprecated)]\n+                        CosmosMsg::Stargate {\n+                            type_url: MsgSetDenomMetadata::type_url(),\n+                            value: MsgSetDenomMetadata {\n+                                sender: env.contract.address.to_string(),\n+                                metadata: Some(protos::cosmos::bank::v1beta1::Metadata {\n+                                    description: \"\".to_string(),\n+                                    denom_units: vec![\n+                                        DenomUnit {\n+                                            denom: denom.clone(),\n+                                            exponent: 0,\n+                                            aliases: vec![metadata.symbol.clone()],\n+                                        },\n+                                        DenomUnit {\n+                                            denom: metadata.symbol.clone(),\n+                                            exponent: metadata.decimals.into(),",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2060596026",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4429,
        "pr_file": "cosmwasm/osmosis-tokenfactory-token-minter/src/contract.rs",
        "discussion_id": "2060596026",
        "commented_code": "@@ -0,0 +1,315 @@\n+use alloy::sol_types::SolValue;\n+use cosmwasm_schema::cw_serde;\n+use cosmwasm_std::{\n+    entry_point, to_json_binary, BankMsg, Binary, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n+    QueryRequest, Response, StdResult,\n+};\n+use ibc_union_spec::ChannelId;\n+use prost::Message;\n+use protos::{\n+    cosmos::bank::v1beta1::DenomUnit, osmosis::tokenfactory::v1beta1::MsgSetDenomMetadata,\n+};\n+use token_factory_api::{TokenFactoryMsg, TokenFactoryQuery};\n+use ucs03_zkgm_token_minter_api::{\n+    ExecuteMsg, LocalTokenMsg, MetadataResponse, PredictWrappedTokenResponse, QueryMsg,\n+    TokenMinterInitMsg, WrappedTokenMsg,\n+};\n+use unionlabs::{\n+    ethereum::keccak256,\n+    primitives::{encoding::Base58, H256, U256},\n+    prost::Name,\n+};\n+\n+pub const DEFAULT_DECIMALS: u8 = 6;\n+\n+use crate::{\n+    error::Error,\n+    state::{ADMIN, TOKEN_ADMIN},\n+};\n+\n+#[entry_point]\n+pub fn instantiate(\n+    deps: DepsMut,\n+    _: Env,\n+    info: MessageInfo,\n+    msg: TokenMinterInitMsg,\n+) -> Result<Response, Error> {\n+    let TokenMinterInitMsg::OsmosisTokenFactory { zkgm_admin } = msg else {\n+        return Err(Error::InvalidMinterConfig);\n+    };\n+    ADMIN.save(deps.storage, &info.sender)?;\n+    TOKEN_ADMIN.save(deps.storage, &zkgm_admin)?;\n+    Ok(Response::default())\n+}\n+\n+#[cw_serde]\n+pub struct MigrateMsg {}\n+\n+#[entry_point]\n+pub fn migrate(_: DepsMut, _: Env, _: MigrateMsg) -> StdResult<Response> {\n+    Ok(Response::new())\n+}\n+\n+fn deconstruct_factory_denom<'a>(env: &Env, denom: &'a str) -> Result<&'a str, Error> {\n+    let denom_parts = denom\n+        .split_once('/')\n+        .and_then(|(a, b)| b.split_once('/').map(|(b, c)| (a, b, c)));\n+\n+    match denom_parts {\n+        Some((\"factory\", addr, subdenom)) if addr == env.contract.address.as_str() => Ok(subdenom),\n+        _ => Err(Error::InvalidDenom(denom.to_string())),\n+    }\n+}\n+\n+#[entry_point]\n+pub fn execute(\n+    deps: DepsMut,\n+    env: Env,\n+    info: MessageInfo,\n+    msg: ExecuteMsg,\n+) -> Result<Response<TokenFactoryMsg>, Error> {\n+    if info.sender != ADMIN.load(deps.storage)? {\n+        return Err(Error::OnlyAdmin);\n+    }\n+\n+    let resp = match msg {\n+        ExecuteMsg::Wrapped(msg) => {\n+            let msgs = match msg {\n+                WrappedTokenMsg::CreateDenom {\n+                    subdenom: denom,\n+                    metadata,\n+                    ..\n+                } => {\n+                    let subdenom = deconstruct_factory_denom(&env, &denom)?;\n+\n+                    vec![\n+                        CosmosMsg::Custom(TokenFactoryMsg::CreateDenom {\n+                            subdenom: subdenom.to_owned(),\n+                        }),\n+                        #[allow(deprecated)]\n+                        CosmosMsg::Stargate {\n+                            type_url: MsgSetDenomMetadata::type_url(),\n+                            value: MsgSetDenomMetadata {\n+                                sender: env.contract.address.to_string(),\n+                                metadata: Some(protos::cosmos::bank::v1beta1::Metadata {\n+                                    description: \"\".to_string(),\n+                                    denom_units: vec![\n+                                        DenomUnit {\n+                                            denom: denom.clone(),\n+                                            exponent: 0,\n+                                            aliases: vec![metadata.symbol.clone()],\n+                                        },\n+                                        DenomUnit {\n+                                            denom: metadata.symbol.clone(),\n+                                            exponent: metadata.decimals.into(),",
        "comment_created_at": "2025-04-25T17:03:55+00:00",
        "comment_author": "benluelo",
        "comment_body": "please confirm this is correct @aeryz, it was hardcoded to 18 previously",
        "pr_file_module": null
      },
      {
        "comment_id": "2061208406",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4429,
        "pr_file": "cosmwasm/osmosis-tokenfactory-token-minter/src/contract.rs",
        "discussion_id": "2060596026",
        "commented_code": "@@ -0,0 +1,315 @@\n+use alloy::sol_types::SolValue;\n+use cosmwasm_schema::cw_serde;\n+use cosmwasm_std::{\n+    entry_point, to_json_binary, BankMsg, Binary, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n+    QueryRequest, Response, StdResult,\n+};\n+use ibc_union_spec::ChannelId;\n+use prost::Message;\n+use protos::{\n+    cosmos::bank::v1beta1::DenomUnit, osmosis::tokenfactory::v1beta1::MsgSetDenomMetadata,\n+};\n+use token_factory_api::{TokenFactoryMsg, TokenFactoryQuery};\n+use ucs03_zkgm_token_minter_api::{\n+    ExecuteMsg, LocalTokenMsg, MetadataResponse, PredictWrappedTokenResponse, QueryMsg,\n+    TokenMinterInitMsg, WrappedTokenMsg,\n+};\n+use unionlabs::{\n+    ethereum::keccak256,\n+    primitives::{encoding::Base58, H256, U256},\n+    prost::Name,\n+};\n+\n+pub const DEFAULT_DECIMALS: u8 = 6;\n+\n+use crate::{\n+    error::Error,\n+    state::{ADMIN, TOKEN_ADMIN},\n+};\n+\n+#[entry_point]\n+pub fn instantiate(\n+    deps: DepsMut,\n+    _: Env,\n+    info: MessageInfo,\n+    msg: TokenMinterInitMsg,\n+) -> Result<Response, Error> {\n+    let TokenMinterInitMsg::OsmosisTokenFactory { zkgm_admin } = msg else {\n+        return Err(Error::InvalidMinterConfig);\n+    };\n+    ADMIN.save(deps.storage, &info.sender)?;\n+    TOKEN_ADMIN.save(deps.storage, &zkgm_admin)?;\n+    Ok(Response::default())\n+}\n+\n+#[cw_serde]\n+pub struct MigrateMsg {}\n+\n+#[entry_point]\n+pub fn migrate(_: DepsMut, _: Env, _: MigrateMsg) -> StdResult<Response> {\n+    Ok(Response::new())\n+}\n+\n+fn deconstruct_factory_denom<'a>(env: &Env, denom: &'a str) -> Result<&'a str, Error> {\n+    let denom_parts = denom\n+        .split_once('/')\n+        .and_then(|(a, b)| b.split_once('/').map(|(b, c)| (a, b, c)));\n+\n+    match denom_parts {\n+        Some((\"factory\", addr, subdenom)) if addr == env.contract.address.as_str() => Ok(subdenom),\n+        _ => Err(Error::InvalidDenom(denom.to_string())),\n+    }\n+}\n+\n+#[entry_point]\n+pub fn execute(\n+    deps: DepsMut,\n+    env: Env,\n+    info: MessageInfo,\n+    msg: ExecuteMsg,\n+) -> Result<Response<TokenFactoryMsg>, Error> {\n+    if info.sender != ADMIN.load(deps.storage)? {\n+        return Err(Error::OnlyAdmin);\n+    }\n+\n+    let resp = match msg {\n+        ExecuteMsg::Wrapped(msg) => {\n+            let msgs = match msg {\n+                WrappedTokenMsg::CreateDenom {\n+                    subdenom: denom,\n+                    metadata,\n+                    ..\n+                } => {\n+                    let subdenom = deconstruct_factory_denom(&env, &denom)?;\n+\n+                    vec![\n+                        CosmosMsg::Custom(TokenFactoryMsg::CreateDenom {\n+                            subdenom: subdenom.to_owned(),\n+                        }),\n+                        #[allow(deprecated)]\n+                        CosmosMsg::Stargate {\n+                            type_url: MsgSetDenomMetadata::type_url(),\n+                            value: MsgSetDenomMetadata {\n+                                sender: env.contract.address.to_string(),\n+                                metadata: Some(protos::cosmos::bank::v1beta1::Metadata {\n+                                    description: \"\".to_string(),\n+                                    denom_units: vec![\n+                                        DenomUnit {\n+                                            denom: denom.clone(),\n+                                            exponent: 0,\n+                                            aliases: vec![metadata.symbol.clone()],\n+                                        },\n+                                        DenomUnit {\n+                                            denom: metadata.symbol.clone(),\n+                                            exponent: metadata.decimals.into(),",
        "comment_created_at": "2025-04-26T07:34:23+00:00",
        "comment_author": "aeryz",
        "comment_body": "We changed it to 6 few weeks ago when you were sleeping lol. The reasoning is the `DEFAULT_DECIMALS` is only used when you can't find the decimal info for the local token. And cosmos native tokens are usually 6 decimals. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1898649191",
    "pr_number": 3368,
    "pr_file": "voyager/plugins/client-update/state-lens/evm/src/main.rs",
    "created_at": "2024-12-27T17:59:20+00:00",
    "commented_code": "+use std::{collections::VecDeque, fmt::Debug};\n+\n+use alloy::{\n+    providers::{Provider, ProviderBuilder, RootProvider},\n+    transports::BoxTransport,\n+};\n+use call::FetchUpdateAfterL1Update;\n+use evm_state_lens_light_client_types::Header;\n+use ibc_union_spec::{ConsensusStatePath, IbcUnion};\n+use jsonrpsee::{\n+    core::{async_trait, RpcResult},\n+    Extensions,\n+};\n+use serde::{Deserialize, Serialize};\n+use tracing::instrument;\n+use unionlabs::ibc::core::commitment::merkle_proof::MerkleProof;\n+use voyager_message::{\n+    call::{Call, FetchUpdateHeaders, WaitForTrustedHeight},\n+    callback::AggregateMsgUpdateClientsFromOrderedHeaders,\n+    core::{ChainId, ClientType, IbcSpec, IbcSpecId, QueryHeight},\n+    data::{Data, DecodedHeaderMeta, OrderedHeaders},\n+    hook::UpdateHook,\n+    into_value,\n+    module::{PluginInfo, PluginServer},\n+    DefaultCmd, ExtensionsExt, Plugin, PluginMessage, RawClientId, VoyagerClient, VoyagerMessage,\n+};\n+use voyager_vm::{call, conc, data, pass::PassResult, promise, seq, BoxDynError, Op, Visit};\n+\n+use crate::{\n+    call::{FetchUpdate, ModuleCall},\n+    callback::ModuleCallback,\n+};\n+\n+pub mod call;\n+pub mod callback;\n+\n+#[tokio::main(flavor = \"multi_thread\")]\n+async fn main() {\n+    Module::run().await\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Module {\n+    pub l0_client_id: u32,\n+    pub l1_client_id: u32,\n+    pub l1_chain_id: ChainId,\n+    pub l2_chain_id: ChainId,\n+\n+    pub l2_eth_provider: RootProvider<BoxTransport>,\n+    pub l1_tm_client: cometbft_rpc::Client,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct Config {\n+    pub l0_client_id: u32,\n+    pub l1_client_id: u32,\n+    pub l1_chain_id: ChainId,\n+    pub l2_chain_id: ChainId,\n+\n+    pub l1_ws_url: String,\n+    pub l2_rpc_url: String,\n+}\n+\n+impl Plugin for Module {\n+    type Call = ModuleCall;\n+    type Callback = ModuleCallback;\n+\n+    type Config = Config;\n+    type Cmd = DefaultCmd;\n+\n+    async fn new(config: Self::Config) -> Result<Self, BoxDynError> {\n+        let l1_tm_client = cometbft_rpc::Client::new(config.l1_ws_url).await?;\n+\n+        let l1_chain_id = l1_tm_client.status().await?.node_info.network.to_string();\n+\n+        if l1_chain_id != config.l1_chain_id.as_str() {\n+            return Err(format!(\n+                \"incorrect chain id: expected `{}`, but found `{}`\",\n+                config.l1_chain_id, l1_chain_id\n+            )\n+            .into());\n+        }\n+\n+        let l2_eth_provider = ProviderBuilder::new()\n+            .on_builtin(&config.l2_rpc_url)\n+            .await?;\n+\n+        let l2_chain_id = ChainId::new(l2_eth_provider.get_chain_id().await?.to_string());\n+\n+        Ok(Self {\n+            l0_client_id: config.l0_client_id,\n+            l1_client_id: config.l1_client_id,\n+            l1_chain_id: ChainId::new(l1_chain_id),\n+            l2_chain_id,\n+            l1_tm_client,\n+            l2_eth_provider,\n+        })\n+    }\n+\n+    fn info(config: Self::Config) -> PluginInfo {\n+        PluginInfo {\n+            name: plugin_name(&config.l2_chain_id),\n+            interest_filter: UpdateHook::filter(\n+                &config.l2_chain_id,\n+                &ClientType::new(ClientType::STATE_LENS_EVM),\n+            ),\n+        }\n+    }\n+\n+    async fn cmd(_config: Self::Config, cmd: Self::Cmd) {\n+        match cmd {}\n+    }\n+}\n+\n+fn plugin_name(chain_id: &ChainId) -> String {\n+    pub const PLUGIN_NAME: &str = env!(\"CARGO_PKG_NAME\");\n+\n+    format!(\"{PLUGIN_NAME}/{}\", chain_id)\n+}\n+\n+impl Module {\n+    fn plugin_name(&self) -> String {\n+        plugin_name(&self.l2_chain_id)\n+    }\n+}\n+\n+#[async_trait]\n+impl PluginServer<ModuleCall, ModuleCallback> for Module {\n+    #[instrument(skip_all, fields(chain_id = %self.l2_chain_id))]\n+    async fn run_pass(\n+        &self,\n+        _: &Extensions,\n+        msgs: Vec<Op<VoyagerMessage>>,\n+    ) -> RpcResult<PassResult<VoyagerMessage>> {\n+        Ok(PassResult {\n+            optimize_further: vec![],\n+            ready: msgs\n+                .into_iter()\n+                .map(|mut op| {\n+                    UpdateHook::new(\n+                        &self.l2_chain_id,\n+                        &ClientType::new(ClientType::STATE_LENS_EVM),\n+                        |fetch| {\n+                            Call::Plugin(PluginMessage::new(\n+                                self.plugin_name(),\n+                                ModuleCall::from(FetchUpdate {\n+                                    counterparty_chain_id: fetch.counterparty_chain_id.clone(),\n+                                    update_from: fetch.update_from,\n+                                    update_to: fetch.update_to,\n+                                }),\n+                            ))\n+                        },\n+                    )\n+                    .visit_op(&mut op);\n+\n+                    op\n+                })\n+                .enumerate()\n+                .map(|(i, op)| (vec![i], op))\n+                .collect(),\n+        })\n+    }\n+\n+    #[instrument(skip_all, fields(chain_id = %self.l2_chain_id))]\n+    async fn call(&self, ext: &Extensions, msg: ModuleCall) -> RpcResult<Op<VoyagerMessage>> {\n+        match msg {\n+            ModuleCall::FetchUpdate(FetchUpdate {\n+                counterparty_chain_id,\n+                update_from,\n+                update_to,\n+            }) => {\n+                let voy_client = ext.try_get::<VoyagerClient>()?;\n+                let l1_latest_height = voy_client\n+                    .query_latest_height(self.l1_chain_id.clone(), true)\n+                    .await?;\n+                let l2_consensus_proof = voy_client\n+                    .query_ibc_proof(\n+                        self.l1_chain_id.clone(),\n+                        QueryHeight::Specific(l1_latest_height),\n+                        ConsensusStatePath {\n+                            client_id: self.l1_client_id,\n+                            height: update_to.height(),\n+                        },\n+                    )\n+                    .await;\n+                let continuation = call(PluginMessage::new(\n+                    self.plugin_name(),\n+                    ModuleCall::from(FetchUpdateAfterL1Update {\n+                        counterparty_chain_id,\n+                        update_from,\n+                        update_to,\n+                    }),\n+                ));\n+                // If the L2 consensus proof exists on the L1, we don't have to update the L2 on the L1.\n+                match l2_consensus_proof {\n+                    Ok(_) => Ok(continuation),\n+                    Err(_) => Ok(conc([\n+                        // Update the L2 (eth) client on L1 (union) and then dispatch the continuation\n+                        promise(\n+                            [call(FetchUpdateHeaders {\n+                                client_type: ClientType::new(ClientType::ETHEREUM),\n+                                chain_id: self.l2_chain_id.clone(),\n+                                counterparty_chain_id: self.l1_chain_id.clone(),\n+                                update_from,\n+                                update_to,\n+                            })],\n+                            [],\n+                            AggregateMsgUpdateClientsFromOrderedHeaders {\n+                                ibc_spec_id: IbcUnion::ID,\n+                                chain_id: self.l1_chain_id.clone(),\n+                                client_id: RawClientId::new(self.l1_client_id.clone()),\n+                            },\n+                        ),\n+                        seq([\n+                            call(WaitForTrustedHeight {\n+                                chain_id: self.l1_chain_id.clone(),\n+                                ibc_spec_id: IbcUnion::ID,\n+                                client_id: RawClientId::new(self.l1_client_id),\n+                                height: update_to,\n+                            }),\n+                            continuation,\n+                        ]),\n+                    ])),\n+                }\n+            }\n+            ModuleCall::FetchUpdateAfterL1Update(FetchUpdateAfterL1Update {\n+                counterparty_chain_id,\n+                update_to,\n+                ..\n+            }) => {\n+                let voy_client = ext.try_get::<VoyagerClient>()?;\n+                let l1_latest_height = voy_client\n+                    .query_latest_height(self.l1_chain_id.clone(), true)\n+                    .await?;\n+                let l0_client_meta = voy_client\n+                    .client_meta::<IbcUnion>(\n+                        counterparty_chain_id.clone(),\n+                        QueryHeight::Latest,\n+                        self.l0_client_id,\n+                    )\n+                    .await?;\n+                let l2_consensus_state_proof = serde_json::from_value::<MerkleProof>(\n+                    voy_client\n+                        .query_ibc_proof(\n+                            self.l1_chain_id.clone(),\n+                            QueryHeight::Specific(l1_latest_height),\n+                            ConsensusStatePath {\n+                                client_id: self.l1_client_id,\n+                                height: update_to.height(),\n+                            },\n+                        )\n+                        .await\n+                        .expect(\"big trouble\")\n+                        .proof,\n+                )\n+                .expect(\"impossible\");\n+                // Dispatch an update for the L1 on the destination, then dispatch the L2 update on the destination\n+                Ok(conc([\n+                    promise(\n+                        [call(FetchUpdateHeaders {\n+                            client_type: ClientType::new(ClientType::COMETBLS),",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1898649191",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3368,
        "pr_file": "voyager/plugins/client-update/state-lens/evm/src/main.rs",
        "discussion_id": "1898649191",
        "commented_code": "@@ -0,0 +1,306 @@\n+use std::{collections::VecDeque, fmt::Debug};\n+\n+use alloy::{\n+    providers::{Provider, ProviderBuilder, RootProvider},\n+    transports::BoxTransport,\n+};\n+use call::FetchUpdateAfterL1Update;\n+use evm_state_lens_light_client_types::Header;\n+use ibc_union_spec::{ConsensusStatePath, IbcUnion};\n+use jsonrpsee::{\n+    core::{async_trait, RpcResult},\n+    Extensions,\n+};\n+use serde::{Deserialize, Serialize};\n+use tracing::instrument;\n+use unionlabs::ibc::core::commitment::merkle_proof::MerkleProof;\n+use voyager_message::{\n+    call::{Call, FetchUpdateHeaders, WaitForTrustedHeight},\n+    callback::AggregateMsgUpdateClientsFromOrderedHeaders,\n+    core::{ChainId, ClientType, IbcSpec, IbcSpecId, QueryHeight},\n+    data::{Data, DecodedHeaderMeta, OrderedHeaders},\n+    hook::UpdateHook,\n+    into_value,\n+    module::{PluginInfo, PluginServer},\n+    DefaultCmd, ExtensionsExt, Plugin, PluginMessage, RawClientId, VoyagerClient, VoyagerMessage,\n+};\n+use voyager_vm::{call, conc, data, pass::PassResult, promise, seq, BoxDynError, Op, Visit};\n+\n+use crate::{\n+    call::{FetchUpdate, ModuleCall},\n+    callback::ModuleCallback,\n+};\n+\n+pub mod call;\n+pub mod callback;\n+\n+#[tokio::main(flavor = \"multi_thread\")]\n+async fn main() {\n+    Module::run().await\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Module {\n+    pub l0_client_id: u32,\n+    pub l1_client_id: u32,\n+    pub l1_chain_id: ChainId,\n+    pub l2_chain_id: ChainId,\n+\n+    pub l2_eth_provider: RootProvider<BoxTransport>,\n+    pub l1_tm_client: cometbft_rpc::Client,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct Config {\n+    pub l0_client_id: u32,\n+    pub l1_client_id: u32,\n+    pub l1_chain_id: ChainId,\n+    pub l2_chain_id: ChainId,\n+\n+    pub l1_ws_url: String,\n+    pub l2_rpc_url: String,\n+}\n+\n+impl Plugin for Module {\n+    type Call = ModuleCall;\n+    type Callback = ModuleCallback;\n+\n+    type Config = Config;\n+    type Cmd = DefaultCmd;\n+\n+    async fn new(config: Self::Config) -> Result<Self, BoxDynError> {\n+        let l1_tm_client = cometbft_rpc::Client::new(config.l1_ws_url).await?;\n+\n+        let l1_chain_id = l1_tm_client.status().await?.node_info.network.to_string();\n+\n+        if l1_chain_id != config.l1_chain_id.as_str() {\n+            return Err(format!(\n+                \"incorrect chain id: expected `{}`, but found `{}`\",\n+                config.l1_chain_id, l1_chain_id\n+            )\n+            .into());\n+        }\n+\n+        let l2_eth_provider = ProviderBuilder::new()\n+            .on_builtin(&config.l2_rpc_url)\n+            .await?;\n+\n+        let l2_chain_id = ChainId::new(l2_eth_provider.get_chain_id().await?.to_string());\n+\n+        Ok(Self {\n+            l0_client_id: config.l0_client_id,\n+            l1_client_id: config.l1_client_id,\n+            l1_chain_id: ChainId::new(l1_chain_id),\n+            l2_chain_id,\n+            l1_tm_client,\n+            l2_eth_provider,\n+        })\n+    }\n+\n+    fn info(config: Self::Config) -> PluginInfo {\n+        PluginInfo {\n+            name: plugin_name(&config.l2_chain_id),\n+            interest_filter: UpdateHook::filter(\n+                &config.l2_chain_id,\n+                &ClientType::new(ClientType::STATE_LENS_EVM),\n+            ),\n+        }\n+    }\n+\n+    async fn cmd(_config: Self::Config, cmd: Self::Cmd) {\n+        match cmd {}\n+    }\n+}\n+\n+fn plugin_name(chain_id: &ChainId) -> String {\n+    pub const PLUGIN_NAME: &str = env!(\"CARGO_PKG_NAME\");\n+\n+    format!(\"{PLUGIN_NAME}/{}\", chain_id)\n+}\n+\n+impl Module {\n+    fn plugin_name(&self) -> String {\n+        plugin_name(&self.l2_chain_id)\n+    }\n+}\n+\n+#[async_trait]\n+impl PluginServer<ModuleCall, ModuleCallback> for Module {\n+    #[instrument(skip_all, fields(chain_id = %self.l2_chain_id))]\n+    async fn run_pass(\n+        &self,\n+        _: &Extensions,\n+        msgs: Vec<Op<VoyagerMessage>>,\n+    ) -> RpcResult<PassResult<VoyagerMessage>> {\n+        Ok(PassResult {\n+            optimize_further: vec![],\n+            ready: msgs\n+                .into_iter()\n+                .map(|mut op| {\n+                    UpdateHook::new(\n+                        &self.l2_chain_id,\n+                        &ClientType::new(ClientType::STATE_LENS_EVM),\n+                        |fetch| {\n+                            Call::Plugin(PluginMessage::new(\n+                                self.plugin_name(),\n+                                ModuleCall::from(FetchUpdate {\n+                                    counterparty_chain_id: fetch.counterparty_chain_id.clone(),\n+                                    update_from: fetch.update_from,\n+                                    update_to: fetch.update_to,\n+                                }),\n+                            ))\n+                        },\n+                    )\n+                    .visit_op(&mut op);\n+\n+                    op\n+                })\n+                .enumerate()\n+                .map(|(i, op)| (vec![i], op))\n+                .collect(),\n+        })\n+    }\n+\n+    #[instrument(skip_all, fields(chain_id = %self.l2_chain_id))]\n+    async fn call(&self, ext: &Extensions, msg: ModuleCall) -> RpcResult<Op<VoyagerMessage>> {\n+        match msg {\n+            ModuleCall::FetchUpdate(FetchUpdate {\n+                counterparty_chain_id,\n+                update_from,\n+                update_to,\n+            }) => {\n+                let voy_client = ext.try_get::<VoyagerClient>()?;\n+                let l1_latest_height = voy_client\n+                    .query_latest_height(self.l1_chain_id.clone(), true)\n+                    .await?;\n+                let l2_consensus_proof = voy_client\n+                    .query_ibc_proof(\n+                        self.l1_chain_id.clone(),\n+                        QueryHeight::Specific(l1_latest_height),\n+                        ConsensusStatePath {\n+                            client_id: self.l1_client_id,\n+                            height: update_to.height(),\n+                        },\n+                    )\n+                    .await;\n+                let continuation = call(PluginMessage::new(\n+                    self.plugin_name(),\n+                    ModuleCall::from(FetchUpdateAfterL1Update {\n+                        counterparty_chain_id,\n+                        update_from,\n+                        update_to,\n+                    }),\n+                ));\n+                // If the L2 consensus proof exists on the L1, we don't have to update the L2 on the L1.\n+                match l2_consensus_proof {\n+                    Ok(_) => Ok(continuation),\n+                    Err(_) => Ok(conc([\n+                        // Update the L2 (eth) client on L1 (union) and then dispatch the continuation\n+                        promise(\n+                            [call(FetchUpdateHeaders {\n+                                client_type: ClientType::new(ClientType::ETHEREUM),\n+                                chain_id: self.l2_chain_id.clone(),\n+                                counterparty_chain_id: self.l1_chain_id.clone(),\n+                                update_from,\n+                                update_to,\n+                            })],\n+                            [],\n+                            AggregateMsgUpdateClientsFromOrderedHeaders {\n+                                ibc_spec_id: IbcUnion::ID,\n+                                chain_id: self.l1_chain_id.clone(),\n+                                client_id: RawClientId::new(self.l1_client_id.clone()),\n+                            },\n+                        ),\n+                        seq([\n+                            call(WaitForTrustedHeight {\n+                                chain_id: self.l1_chain_id.clone(),\n+                                ibc_spec_id: IbcUnion::ID,\n+                                client_id: RawClientId::new(self.l1_client_id),\n+                                height: update_to,\n+                            }),\n+                            continuation,\n+                        ]),\n+                    ])),\n+                }\n+            }\n+            ModuleCall::FetchUpdateAfterL1Update(FetchUpdateAfterL1Update {\n+                counterparty_chain_id,\n+                update_to,\n+                ..\n+            }) => {\n+                let voy_client = ext.try_get::<VoyagerClient>()?;\n+                let l1_latest_height = voy_client\n+                    .query_latest_height(self.l1_chain_id.clone(), true)\n+                    .await?;\n+                let l0_client_meta = voy_client\n+                    .client_meta::<IbcUnion>(\n+                        counterparty_chain_id.clone(),\n+                        QueryHeight::Latest,\n+                        self.l0_client_id,\n+                    )\n+                    .await?;\n+                let l2_consensus_state_proof = serde_json::from_value::<MerkleProof>(\n+                    voy_client\n+                        .query_ibc_proof(\n+                            self.l1_chain_id.clone(),\n+                            QueryHeight::Specific(l1_latest_height),\n+                            ConsensusStatePath {\n+                                client_id: self.l1_client_id,\n+                                height: update_to.height(),\n+                            },\n+                        )\n+                        .await\n+                        .expect(\"big trouble\")\n+                        .proof,\n+                )\n+                .expect(\"impossible\");\n+                // Dispatch an update for the L1 on the destination, then dispatch the L2 update on the destination\n+                Ok(conc([\n+                    promise(\n+                        [call(FetchUpdateHeaders {\n+                            client_type: ClientType::new(ClientType::COMETBLS),",
        "comment_created_at": "2024-12-27T17:59:20+00:00",
        "comment_author": "benluelo",
        "comment_body": "i know we have union hardcoded right now, but just leaving a note that this can be fetched from the voyager client (`voyager_client.client_info()`)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1674129205",
    "pr_number": 2434,
    "pr_file": "drip/src/main.rs",
    "created_at": "2024-07-11T14:37:30+00:00",
    "commented_code": "#[tokio::main(flavor = \"multi_thread\")]\n async fn main() {\n+    let batch_size = 6000;",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1674129205",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2434,
        "pr_file": "drip/src/main.rs",
        "discussion_id": "1674129205",
        "commented_code": "@@ -22,6 +22,7 @@ use unionlabs::{hash::H256, signer::CosmosSigner, ErrorReporter};\n \n #[tokio::main(flavor = \"multi_thread\")]\n async fn main() {\n+    let batch_size = 6000;",
        "comment_created_at": "2024-07-11T14:37:30+00:00",
        "comment_author": "KaiserKarel",
        "comment_body": "This batch_size doesn't seem configurable. Why not add it to the AppArgs so one can set it like:\r\n\r\nfaucet --batch-size 6000\r\n\r\nAnd if omitted, default to 6000?",
        "pr_file_module": null
      },
      {
        "comment_id": "1674411381",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2434,
        "pr_file": "drip/src/main.rs",
        "discussion_id": "1674129205",
        "commented_code": "@@ -22,6 +22,7 @@ use unionlabs::{hash::H256, signer::CosmosSigner, ErrorReporter};\n \n #[tokio::main(flavor = \"multi_thread\")]\n async fn main() {\n+    let batch_size = 6000;",
        "comment_created_at": "2024-07-11T17:38:45+00:00",
        "comment_author": "PablitoAmaral",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  }
]