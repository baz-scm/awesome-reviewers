[
  {
    "discussion_id": "2308652867",
    "pr_number": 5052,
    "pr_file": "cosmwasm/cw20-wrapped-tokenfactory/src/allowances.rs",
    "created_at": "2025-08-28T22:07:35+00:00",
    "commented_code": "Ok(res)\n }\n \n+pub fn execute_burn(\n+    _: DepsMut,\n+    env: Env,\n+    info: MessageInfo,\n+    amount: Uint128,\n+) -> Result<Response<TokenFactoryMsg>, ContractError> {\n+    Ok(Response::new()\n+        .add_message(CosmosMsg::Custom(TokenFactoryMsg::BurnTokens(\n+            BurnTokensMsg {\n+                denom: self_tf_denom(&env),\n+                amount,\n+                burn_from_address: info.sender.clone(),\n+            },\n+        )))\n+        .add_attributes(vec![\n+            attr(\"action\", \"burn\"),\n+            attr(\"from\", info.sender),\n+            attr(\"amount\", amount),\n+        ]))\n+}",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2308652867",
        "repo_full_name": "unionlabs/union",
        "pr_number": 5052,
        "pr_file": "cosmwasm/cw20-wrapped-tokenfactory/src/allowances.rs",
        "discussion_id": "2308652867",
        "commented_code": "@@ -162,6 +162,27 @@ pub fn execute_transfer_from(\n     Ok(res)\n }\n \n+pub fn execute_burn(\n+    _: DepsMut,\n+    env: Env,\n+    info: MessageInfo,\n+    amount: Uint128,\n+) -> Result<Response<TokenFactoryMsg>, ContractError> {\n+    Ok(Response::new()\n+        .add_message(CosmosMsg::Custom(TokenFactoryMsg::BurnTokens(\n+            BurnTokensMsg {\n+                denom: self_tf_denom(&env),\n+                amount,\n+                burn_from_address: info.sender.clone(),\n+            },\n+        )))\n+        .add_attributes(vec![\n+            attr(\"action\", \"burn\"),\n+            attr(\"from\", info.sender),\n+            attr(\"amount\", amount),\n+        ]))\n+}",
        "comment_created_at": "2025-08-28T22:07:35+00:00",
        "comment_author": "benluelo",
        "comment_body": "this needs to be tested to ensure it works correctly",
        "pr_file_module": null
      },
      {
        "comment_id": "2310633903",
        "repo_full_name": "unionlabs/union",
        "pr_number": 5052,
        "pr_file": "cosmwasm/cw20-wrapped-tokenfactory/src/allowances.rs",
        "discussion_id": "2308652867",
        "commented_code": "@@ -162,6 +162,27 @@ pub fn execute_transfer_from(\n     Ok(res)\n }\n \n+pub fn execute_burn(\n+    _: DepsMut,\n+    env: Env,\n+    info: MessageInfo,\n+    amount: Uint128,\n+) -> Result<Response<TokenFactoryMsg>, ContractError> {\n+    Ok(Response::new()\n+        .add_message(CosmosMsg::Custom(TokenFactoryMsg::BurnTokens(\n+            BurnTokensMsg {\n+                denom: self_tf_denom(&env),\n+                amount,\n+                burn_from_address: info.sender.clone(),\n+            },\n+        )))\n+        .add_attributes(vec![\n+            attr(\"action\", \"burn\"),\n+            attr(\"from\", info.sender),\n+            attr(\"amount\", amount),\n+        ]))\n+}",
        "comment_created_at": "2025-08-29T16:40:31+00:00",
        "comment_author": "hussein-aitlahcen",
        "comment_body": "we have basically zero test so the entire flow must be checked on testnet",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993365336",
    "pr_number": 4026,
    "pr_file": "lib/ethereum-sync-protocol/src/lib.rs",
    "created_at": "2025-03-13T11:56:10+00:00",
    "commented_code": "NEXT_SYNC_COMMITTEE_GINDEX\n }\n \n-// #[cfg(test)]\n-// mod tests {\n-//     use std::{cmp::Ordering, fs};\n-\n-//     use beacon_api_types::{Mainnet, SyncCommittee};\n-//     use serde::Deserialize;\n-\n-//     use super::*;\n-\n-//     #[derive(Debug, Clone)]\n-//     struct Context {\n-//         finalized_slot: u64,\n-//         current_sync_committee: Option<SyncCommittee<Mainnet>>,\n-//         next_sync_committee: Option<SyncCommittee<Mainnet>>,\n-//     }\n-\n-//     #[derive(Deserialize)]\n-//     struct InitialData {\n-//         genesis_validators_root: H256,\n-//         current_sync_committee: SyncCommittee<Mainnet>,\n-//         next_sync_committee: SyncCommittee<Mainnet>,\n-//     }\n-\n-//     #[derive(Deserialize)]\n-//     struct TestProof {\n-//         pub storage_root: H256,\n-//         pub storage_proof: StorageProof,\n-//     }\n-\n-//     lazy_static::lazy_static! {\n-//         static ref VALID_PROOF: TestProof = serde_json::from_str(&fs::read_to_string(\"src/test/state-proofs/valid_proof_1.json\").unwrap()).unwrap();\n-//         static ref VALID_PROOF2: TestProof = serde_json::from_str(&fs::read_to_string(\"src/test/state-proofs/valid_proof_2.json\").unwrap()).unwrap();\n-\n-//         static ref ABSENT_PROOF: TestProof = serde_json::from_str(&fs::read_to_string(\"src/test/state-proofs/absent_proof_1.json\").unwrap()).unwrap();\n-\n-//         static ref INITIAL_DATA: InitialData = serde_json::from_str(&fs::read_to_string(\"src/test/initial_test_data.json\").unwrap()).unwrap();\n-\n-//         static ref UPDATES: Vec<(Context, LightClientUpdate<Mainnet>)> = {\n-//             // Read all the updates, only process files\n-//             let mut updates: Vec<LightClientUpdate<Mainnet>> = fs::read_dir(\"src/test/updates/\").unwrap().filter(|f|\n-//                 f.as_ref().unwrap().path().is_file()\n-//             ).map(|f| {\n-//                 serde_json::from_str(&fs::read_to_string(f.unwrap().path()).unwrap()).unwrap()\n-//             }).collect();\n-\n-//             // Sort the updates from oldest to most recent for us to do updates by iterating over\n-//             updates.sort_by(|lhs, rhs| {\n-//                 if lhs.attested_header.beacon.slot > rhs.attested_header.beacon.slot {\n-//                     Ordering::Greater\n-//                 } else {\n-//                     Ordering::Less\n-//                 }\n-//             });\n-\n-//             // Since this verification library is stateless and it does not update any context after verifying an update,\n-//             // we are manually doing it here.\n-//             let mut current_sync_committee = Some(INITIAL_DATA.current_sync_committee.clone());\n-//             let mut next_sync_committee= Some(INITIAL_DATA.next_sync_committee.clone());\n-//             let mut update_data = vec![];\n-//             updates.iter().enumerate().skip(1).for_each(|(i, update)|\n-//                 {\n-//                     let current_update = &updates[i - 1];\n-//                     let context = Context {\n-//                         finalized_slot: current_update.attested_header.beacon.slot,\n-//                         current_sync_committee: current_sync_committee.clone(),\n-//                         next_sync_committee: next_sync_committee.clone(),\n-//                     };\n-//                     update_data.push((context, update.clone()));\n-\n-//                     // If the update contains a next sync committee, it means that we are moving to the next sync committee period\n-//                     // and updating the next sync committee.\n-//                     if let Some(ref nsc) = update.next_sync_committee {\n-//                         current_sync_committee = next_sync_committee.take();\n-//                         next_sync_committee = Some(nsc.clone());\n-//                     }\n-//                 });\n-\n-//             update_data\n-//         };\n-//     }\n-\n-//     impl LightClientContext for Context {\n-//         type ChainSpec = Mainnet;\n-\n-//         fn finalized_slot(&self) -> u64 {\n-//             self.finalized_slot\n-//         }\n-\n-//         fn current_sync_committee(&self) -> Option<&SyncCommittee<Self::ChainSpec>> {\n-//             self.current_sync_committee.as_ref()\n-//         }\n-\n-//         fn next_sync_committee(&self) -> Option<&SyncCommittee<Self::ChainSpec>> {\n-//             self.next_sync_committee.as_ref()\n-//         }\n-\n-//         fn fork_parameters(&self) -> &ForkParameters {\n-//             &SEPOLIA.fork_parameters\n-//         }\n-//     }\n-\n-//     struct BlsVerifier;\n-\n-//     impl BlsVerify for BlsVerifier {\n-//         fn fast_aggregate_verify<'pk>(\n-//             &self,\n-//             public_keys: impl IntoIterator<Item = &'pk BlsPublicKey>,\n-//             msg: Vec<u8>,\n-//             signature: H768,\n-//         ) -> Result<(), Error> {\n-//             let res = crate::crypto::fast_aggregate_verify_unchecked(\n-//                 public_keys.into_iter().collect::<Vec<_>>().as_slice(),\n-//                 msg.as_slice(),\n-//                 &signature,\n-//             )\n-//             .unwrap();\n-\n-//             if res {\n-//                 Ok(())\n-//             } else {\n-//                 Err(Error::Crypto)\n-//             }\n-//         }\n-//     }\n-\n-//     fn do_validate_light_client_update(\n-//         ctx: &Context,\n-//         update: LightClientUpdate<Mainnet>,\n-//     ) -> Result<(), Error> {\n-//         let attested_slot = update.attested_header.beacon.slot;\n-//         validate_light_client_update(\n-//             ctx,\n-//             update,\n-//             attested_slot + 32,\n-//             INITIAL_DATA.genesis_validators_root,\n-//             BlsVerifier,\n-//         )\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_works() {\n-//         UPDATES.iter().for_each(|(ctx, update)| {\n-//             assert_eq!(do_validate_light_client_update(ctx, update.clone()), Ok(()))\n-//         });\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_insufficient_sync_committee_participants() {\n-//         let (ctx, mut update) = UPDATES[0].clone();\n-\n-//         // Setting the sync committee bits to zero will result in no participants.\n-//         update.sync_aggregate.sync_committee_bits = Default::default();\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InsufficientSyncCommitteeParticipants { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_header() {\n-//         let (ctx, correct_update) = UPDATES[0].clone();\n-\n-//         let mut update = correct_update.clone();\n-//         update.attested_header.execution.timestamp += 1;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-\n-//         let mut update = correct_update;\n-//         update.finalized_header.execution.timestamp += 1;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_incorrect_slot_order() {\n-//         let (ctx, correct_update) = UPDATES[0].clone();\n-\n-//         // signature slot can't be bigger than the current slot\n-//         let mut update = correct_update.clone();\n-//         update.signature_slot = u64::MAX;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::UpdateMoreRecentThanCurrentSlot {\n-//                 current_slot: 3577248,\n-//                 update_signature_slot: u64::MAX,\n-//             })\n-//         ));\n-\n-//         // attested slot can't be bigger than the signature slot\n-//         let mut update = correct_update.clone();\n-\n-//         let before_deneb =\n-//             SEPOLIA.fork_parameters.deneb.epoch * (SEPOLIA.preset.SLOTS_PER_EPOCH as u64) - 1;\n-//         update.finalized_header.beacon.slot = before_deneb - 100;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidSlots { .. })\n-//         ));\n-\n-//         // finalized slot can't be bigger than the attested slot\n-//         let mut update = correct_update;\n-//         update.finalized_header.beacon.slot = before_deneb;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidSlots { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_signature_period() {\n-//         let (mut ctx, update) = UPDATES[0].clone();\n-\n-//         ctx.finalized_slot = u64::MAX;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update.clone()),\n-//             Err(Error::InvalidSignaturePeriodWhenNextSyncCommitteeExists { .. })\n-//         ));\n-\n-//         // This should fail for both when the next sync committee exist and don't exist\n-//         ctx.next_sync_committee = None;\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidSignaturePeriodWhenNextSyncCommitteeDoesNotExist { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_irrelevant_update() {\n-//         let (mut ctx, correct_update) = UPDATES\n-//             .iter()\n-//             .find(|(_, update)| update.next_sync_committee.is_some())\n-//             .cloned()\n-//             .unwrap()\n-//             .clone();\n-\n-//         // Expected next sync committee since attested slot is not bigger than the stored slot.\n-//         let mut update = correct_update.clone();\n-//         update.next_sync_committee = None;\n-//         ctx.finalized_slot = update.attested_header.beacon.slot;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::IrrelevantUpdate { .. })\n-//         ));\n-\n-//         // Expected stored next sync committee to be None\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, correct_update),\n-//             Err(Error::IrrelevantUpdate { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_finality_branch() {\n-//         let (ctx, mut update) = UPDATES[0].clone();\n-\n-//         update.finality_branch[0] = Default::default();\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_next_sync_committee_branch() {\n-//         let (ctx, mut update) = UPDATES\n-//             .iter()\n-//             .find(|(_, update)| update.next_sync_committee.is_some())\n-//             .cloned()\n-//             .unwrap()\n-//             .clone();\n-\n-//         update.next_sync_committee_branch = Some(Default::default());\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_works() {\n-//         assert_eq!(\n-//             get_node(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key.to_be_bytes(),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             )\n-//             .unwrap()\n-//             .as_ref(),\n-//             Some(&rlp::encode(&VALID_PROOF.storage_proof.value).to_vec())\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_fails_when_invalid_root() {\n-//         let storage_root = {\n-//             let mut root = VALID_PROOF.storage_root.into_bytes();\n-//             root[0] = u8::MAX - root[0];\n-//             root.try_into().unwrap()\n-//         };\n-\n-//         assert!(matches!(\n-//             get_node(\n-//                 storage_root,\n-//                 VALID_PROOF.storage_proof.key.to_be_bytes(),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Err(Error::Trie(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_returns_fails_when_invalid_key() {\n-//         let mut proof_key = VALID_PROOF.storage_proof.key.to_be_bytes();\n-//         proof_key[0] = u8::MAX - proof_key[0];\n-\n-//         assert!(matches!(\n-//             get_node(\n-//                 VALID_PROOF.storage_root,\n-//                 proof_key,\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Err(Error::Trie(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_fails_when_invalid_proof() {\n-//         let mut proof = VALID_PROOF.storage_proof.proof.clone();\n-//         proof[0][0] = u8::MAX - proof[0][0];\n-\n-//         assert!(matches!(\n-//             get_node(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key.to_be_bytes(),\n-//                 &proof\n-//             ),\n-//             Err(Error::Trie(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_absent_storage_works() {\n-//         assert_eq!(\n-//             verify_storage_absence(\n-//                 ABSENT_PROOF.storage_root,\n-//                 ABSENT_PROOF.storage_proof.key,\n-//                 ABSENT_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Ok(true)\n-//         )\n-//     }\n-\n-//     #[test]\n-//     fn verify_absent_storage_returns_false_when_storage_exists() {\n-//         assert_eq!(\n-//             verify_storage_absence(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key,\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Ok(false)\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn verify_storage_proof_works() {\n-//         assert_eq!(\n-//             verify_storage_proof(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key,\n-//                 &rlp::encode(&VALID_PROOF.storage_proof.value),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Ok(())\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn verify_storage_proof_fails_when_incorrect_value() {\n-//         let mut proof_value = VALID_PROOF.storage_proof.value.to_be_bytes();\n-//         proof_value[0] = u8::MAX - proof_value[0];\n-\n-//         assert!(matches!(\n-//             verify_storage_proof(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key,\n-//                 proof_value.as_ref(),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Err(Error::ValueMismatch { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_storage_proof_leading_zero_value_works() {\n-//         assert_eq!(\n-//             verify_storage_proof(\n-//                 VALID_PROOF2.storage_root,\n-//                 VALID_PROOF2.storage_proof.key,\n-//                 &rlp::encode(&VALID_PROOF2.storage_proof.value),\n-//                 VALID_PROOF2.storage_proof.proof.iter()\n-//             ),\n-//             Ok(())\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn is_valid_light_client_header_works() {\n-//         UPDATES.iter().for_each(|(_, update)| {\n-//             // Both finalized and attested headers should be verifiable\n-//             assert_eq!(\n-//                 is_valid_light_client_header(&SEPOLIA.fork_parameters, &update.attested_header),\n-//                 Ok(()),\n-//                 \"invalid attested header\"\n-//             );\n-\n-//             assert_eq!(\n-//                 is_valid_light_client_header(&SEPOLIA.fork_parameters, &update.finalized_header),\n-//                 Ok(()),\n-//                 \"invalid finalized header\"\n-//             );\n-//         });\n-//     }\n-// }\n+#[cfg(test)]\n+mod tests {\n+    use beacon_api_types::chain_spec::Mainnet;\n+    use hex_literal::hex;\n+    use lazy_static::lazy_static;\n+\n+    use super::*;\n+\n+    pub struct BlsVerifier;\n+\n+    impl BlsVerify for BlsVerifier {\n+        const INVERSE: bool = false;\n+\n+        fn aggregate_verify_signature<'pk>(\n+            &self,\n+            _aggregate_public_key: &'pk H384,\n+            _public_keys: impl IntoIterator<Item = &'pk H384>,\n+            _msg: Vec<u8>,\n+            _signature: H768,\n+        ) -> Result<(), Error> {\n+            Ok(())\n+        }\n+    }\n+\n+    const SEPOLIA_CHAIN_ID: u64 = 11155111;\n+\n+    lazy_static! {\n+        pub static ref UPDATE_6553725: ethereum_sync_protocol_types::LightClientUpdate =\n+            serde_json::from_str(&include_str!(\"./test/light_client_update_6553725.json\")).unwrap();\n+        pub static ref SYNC_COMMITTEE_6553725: SyncCommittee =\n+            serde_json::from_str(include_str!(\"./test/sync_committee_6553725.json\")).unwrap();\n+    }\n+\n+    pub const GENESIS_VALIDATORS_ROOT_6553725: H256 = H256::new(hex!(\n+        \"d8ea171f3c94aea21ebc42a1ed61052acf3f9209c00e4efbaaddac09ed9b8078\"\n+    ));\n+\n+    fn update_6553725(\n+        update: &ethereum_sync_protocol_types::LightClientUpdate,\n+    ) -> Result<(), Error> {\n+        validate_light_client_update::<Mainnet, BlsVerifier>(\n+            SEPOLIA_CHAIN_ID,\n+            update,\n+            Some(&SYNC_COMMITTEE_6553725),\n+            None,\n+            Slot::new(6553726),\n+            Slot::new(6553718),\n+            GENESIS_VALIDATORS_ROOT_6553725,\n+            BlsVerifier,\n+        )\n+    }\n+\n+    #[test]\n+    fn validate_update_works() {\n+        assert_eq!(update_6553725(&UPDATE_6553725), Ok(()));\n+    }\n+\n+    #[test]\n+    fn validate_update_fails_when_sync_committee_is_wrong() {\n+        let mut update = UPDATE_6553725.clone();\n+        update.sync_aggregate.sync_committee_bits = Vec::new();",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1993365336",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4026,
        "pr_file": "lib/ethereum-sync-protocol/src/lib.rs",
        "discussion_id": "1993365336",
        "commented_code": "@@ -386,441 +386,310 @@ pub fn next_sync_committee_gindex_at_slot<C: ChainSpec>(chain_id: u64, slot: Slo\n     NEXT_SYNC_COMMITTEE_GINDEX\n }\n \n-// #[cfg(test)]\n-// mod tests {\n-//     use std::{cmp::Ordering, fs};\n-\n-//     use beacon_api_types::{Mainnet, SyncCommittee};\n-//     use serde::Deserialize;\n-\n-//     use super::*;\n-\n-//     #[derive(Debug, Clone)]\n-//     struct Context {\n-//         finalized_slot: u64,\n-//         current_sync_committee: Option<SyncCommittee<Mainnet>>,\n-//         next_sync_committee: Option<SyncCommittee<Mainnet>>,\n-//     }\n-\n-//     #[derive(Deserialize)]\n-//     struct InitialData {\n-//         genesis_validators_root: H256,\n-//         current_sync_committee: SyncCommittee<Mainnet>,\n-//         next_sync_committee: SyncCommittee<Mainnet>,\n-//     }\n-\n-//     #[derive(Deserialize)]\n-//     struct TestProof {\n-//         pub storage_root: H256,\n-//         pub storage_proof: StorageProof,\n-//     }\n-\n-//     lazy_static::lazy_static! {\n-//         static ref VALID_PROOF: TestProof = serde_json::from_str(&fs::read_to_string(\"src/test/state-proofs/valid_proof_1.json\").unwrap()).unwrap();\n-//         static ref VALID_PROOF2: TestProof = serde_json::from_str(&fs::read_to_string(\"src/test/state-proofs/valid_proof_2.json\").unwrap()).unwrap();\n-\n-//         static ref ABSENT_PROOF: TestProof = serde_json::from_str(&fs::read_to_string(\"src/test/state-proofs/absent_proof_1.json\").unwrap()).unwrap();\n-\n-//         static ref INITIAL_DATA: InitialData = serde_json::from_str(&fs::read_to_string(\"src/test/initial_test_data.json\").unwrap()).unwrap();\n-\n-//         static ref UPDATES: Vec<(Context, LightClientUpdate<Mainnet>)> = {\n-//             // Read all the updates, only process files\n-//             let mut updates: Vec<LightClientUpdate<Mainnet>> = fs::read_dir(\"src/test/updates/\").unwrap().filter(|f|\n-//                 f.as_ref().unwrap().path().is_file()\n-//             ).map(|f| {\n-//                 serde_json::from_str(&fs::read_to_string(f.unwrap().path()).unwrap()).unwrap()\n-//             }).collect();\n-\n-//             // Sort the updates from oldest to most recent for us to do updates by iterating over\n-//             updates.sort_by(|lhs, rhs| {\n-//                 if lhs.attested_header.beacon.slot > rhs.attested_header.beacon.slot {\n-//                     Ordering::Greater\n-//                 } else {\n-//                     Ordering::Less\n-//                 }\n-//             });\n-\n-//             // Since this verification library is stateless and it does not update any context after verifying an update,\n-//             // we are manually doing it here.\n-//             let mut current_sync_committee = Some(INITIAL_DATA.current_sync_committee.clone());\n-//             let mut next_sync_committee= Some(INITIAL_DATA.next_sync_committee.clone());\n-//             let mut update_data = vec![];\n-//             updates.iter().enumerate().skip(1).for_each(|(i, update)|\n-//                 {\n-//                     let current_update = &updates[i - 1];\n-//                     let context = Context {\n-//                         finalized_slot: current_update.attested_header.beacon.slot,\n-//                         current_sync_committee: current_sync_committee.clone(),\n-//                         next_sync_committee: next_sync_committee.clone(),\n-//                     };\n-//                     update_data.push((context, update.clone()));\n-\n-//                     // If the update contains a next sync committee, it means that we are moving to the next sync committee period\n-//                     // and updating the next sync committee.\n-//                     if let Some(ref nsc) = update.next_sync_committee {\n-//                         current_sync_committee = next_sync_committee.take();\n-//                         next_sync_committee = Some(nsc.clone());\n-//                     }\n-//                 });\n-\n-//             update_data\n-//         };\n-//     }\n-\n-//     impl LightClientContext for Context {\n-//         type ChainSpec = Mainnet;\n-\n-//         fn finalized_slot(&self) -> u64 {\n-//             self.finalized_slot\n-//         }\n-\n-//         fn current_sync_committee(&self) -> Option<&SyncCommittee<Self::ChainSpec>> {\n-//             self.current_sync_committee.as_ref()\n-//         }\n-\n-//         fn next_sync_committee(&self) -> Option<&SyncCommittee<Self::ChainSpec>> {\n-//             self.next_sync_committee.as_ref()\n-//         }\n-\n-//         fn fork_parameters(&self) -> &ForkParameters {\n-//             &SEPOLIA.fork_parameters\n-//         }\n-//     }\n-\n-//     struct BlsVerifier;\n-\n-//     impl BlsVerify for BlsVerifier {\n-//         fn fast_aggregate_verify<'pk>(\n-//             &self,\n-//             public_keys: impl IntoIterator<Item = &'pk BlsPublicKey>,\n-//             msg: Vec<u8>,\n-//             signature: H768,\n-//         ) -> Result<(), Error> {\n-//             let res = crate::crypto::fast_aggregate_verify_unchecked(\n-//                 public_keys.into_iter().collect::<Vec<_>>().as_slice(),\n-//                 msg.as_slice(),\n-//                 &signature,\n-//             )\n-//             .unwrap();\n-\n-//             if res {\n-//                 Ok(())\n-//             } else {\n-//                 Err(Error::Crypto)\n-//             }\n-//         }\n-//     }\n-\n-//     fn do_validate_light_client_update(\n-//         ctx: &Context,\n-//         update: LightClientUpdate<Mainnet>,\n-//     ) -> Result<(), Error> {\n-//         let attested_slot = update.attested_header.beacon.slot;\n-//         validate_light_client_update(\n-//             ctx,\n-//             update,\n-//             attested_slot + 32,\n-//             INITIAL_DATA.genesis_validators_root,\n-//             BlsVerifier,\n-//         )\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_works() {\n-//         UPDATES.iter().for_each(|(ctx, update)| {\n-//             assert_eq!(do_validate_light_client_update(ctx, update.clone()), Ok(()))\n-//         });\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_insufficient_sync_committee_participants() {\n-//         let (ctx, mut update) = UPDATES[0].clone();\n-\n-//         // Setting the sync committee bits to zero will result in no participants.\n-//         update.sync_aggregate.sync_committee_bits = Default::default();\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InsufficientSyncCommitteeParticipants { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_header() {\n-//         let (ctx, correct_update) = UPDATES[0].clone();\n-\n-//         let mut update = correct_update.clone();\n-//         update.attested_header.execution.timestamp += 1;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-\n-//         let mut update = correct_update;\n-//         update.finalized_header.execution.timestamp += 1;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_incorrect_slot_order() {\n-//         let (ctx, correct_update) = UPDATES[0].clone();\n-\n-//         // signature slot can't be bigger than the current slot\n-//         let mut update = correct_update.clone();\n-//         update.signature_slot = u64::MAX;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::UpdateMoreRecentThanCurrentSlot {\n-//                 current_slot: 3577248,\n-//                 update_signature_slot: u64::MAX,\n-//             })\n-//         ));\n-\n-//         // attested slot can't be bigger than the signature slot\n-//         let mut update = correct_update.clone();\n-\n-//         let before_deneb =\n-//             SEPOLIA.fork_parameters.deneb.epoch * (SEPOLIA.preset.SLOTS_PER_EPOCH as u64) - 1;\n-//         update.finalized_header.beacon.slot = before_deneb - 100;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidSlots { .. })\n-//         ));\n-\n-//         // finalized slot can't be bigger than the attested slot\n-//         let mut update = correct_update;\n-//         update.finalized_header.beacon.slot = before_deneb;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidSlots { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_signature_period() {\n-//         let (mut ctx, update) = UPDATES[0].clone();\n-\n-//         ctx.finalized_slot = u64::MAX;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update.clone()),\n-//             Err(Error::InvalidSignaturePeriodWhenNextSyncCommitteeExists { .. })\n-//         ));\n-\n-//         // This should fail for both when the next sync committee exist and don't exist\n-//         ctx.next_sync_committee = None;\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidSignaturePeriodWhenNextSyncCommitteeDoesNotExist { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_irrelevant_update() {\n-//         let (mut ctx, correct_update) = UPDATES\n-//             .iter()\n-//             .find(|(_, update)| update.next_sync_committee.is_some())\n-//             .cloned()\n-//             .unwrap()\n-//             .clone();\n-\n-//         // Expected next sync committee since attested slot is not bigger than the stored slot.\n-//         let mut update = correct_update.clone();\n-//         update.next_sync_committee = None;\n-//         ctx.finalized_slot = update.attested_header.beacon.slot;\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::IrrelevantUpdate { .. })\n-//         ));\n-\n-//         // Expected stored next sync committee to be None\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, correct_update),\n-//             Err(Error::IrrelevantUpdate { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_finality_branch() {\n-//         let (ctx, mut update) = UPDATES[0].clone();\n-\n-//         update.finality_branch[0] = Default::default();\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn validate_light_client_update_fails_when_invalid_next_sync_committee_branch() {\n-//         let (ctx, mut update) = UPDATES\n-//             .iter()\n-//             .find(|(_, update)| update.next_sync_committee.is_some())\n-//             .cloned()\n-//             .unwrap()\n-//             .clone();\n-\n-//         update.next_sync_committee_branch = Some(Default::default());\n-\n-//         assert!(matches!(\n-//             do_validate_light_client_update(&ctx, update),\n-//             Err(Error::InvalidMerkleBranch(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_works() {\n-//         assert_eq!(\n-//             get_node(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key.to_be_bytes(),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             )\n-//             .unwrap()\n-//             .as_ref(),\n-//             Some(&rlp::encode(&VALID_PROOF.storage_proof.value).to_vec())\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_fails_when_invalid_root() {\n-//         let storage_root = {\n-//             let mut root = VALID_PROOF.storage_root.into_bytes();\n-//             root[0] = u8::MAX - root[0];\n-//             root.try_into().unwrap()\n-//         };\n-\n-//         assert!(matches!(\n-//             get_node(\n-//                 storage_root,\n-//                 VALID_PROOF.storage_proof.key.to_be_bytes(),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Err(Error::Trie(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_returns_fails_when_invalid_key() {\n-//         let mut proof_key = VALID_PROOF.storage_proof.key.to_be_bytes();\n-//         proof_key[0] = u8::MAX - proof_key[0];\n-\n-//         assert!(matches!(\n-//             get_node(\n-//                 VALID_PROOF.storage_root,\n-//                 proof_key,\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Err(Error::Trie(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_state_fails_when_invalid_proof() {\n-//         let mut proof = VALID_PROOF.storage_proof.proof.clone();\n-//         proof[0][0] = u8::MAX - proof[0][0];\n-\n-//         assert!(matches!(\n-//             get_node(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key.to_be_bytes(),\n-//                 &proof\n-//             ),\n-//             Err(Error::Trie(_))\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_absent_storage_works() {\n-//         assert_eq!(\n-//             verify_storage_absence(\n-//                 ABSENT_PROOF.storage_root,\n-//                 ABSENT_PROOF.storage_proof.key,\n-//                 ABSENT_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Ok(true)\n-//         )\n-//     }\n-\n-//     #[test]\n-//     fn verify_absent_storage_returns_false_when_storage_exists() {\n-//         assert_eq!(\n-//             verify_storage_absence(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key,\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Ok(false)\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn verify_storage_proof_works() {\n-//         assert_eq!(\n-//             verify_storage_proof(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key,\n-//                 &rlp::encode(&VALID_PROOF.storage_proof.value),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Ok(())\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn verify_storage_proof_fails_when_incorrect_value() {\n-//         let mut proof_value = VALID_PROOF.storage_proof.value.to_be_bytes();\n-//         proof_value[0] = u8::MAX - proof_value[0];\n-\n-//         assert!(matches!(\n-//             verify_storage_proof(\n-//                 VALID_PROOF.storage_root,\n-//                 VALID_PROOF.storage_proof.key,\n-//                 proof_value.as_ref(),\n-//                 VALID_PROOF.storage_proof.proof.iter()\n-//             ),\n-//             Err(Error::ValueMismatch { .. })\n-//         ));\n-//     }\n-\n-//     #[test]\n-//     fn verify_storage_proof_leading_zero_value_works() {\n-//         assert_eq!(\n-//             verify_storage_proof(\n-//                 VALID_PROOF2.storage_root,\n-//                 VALID_PROOF2.storage_proof.key,\n-//                 &rlp::encode(&VALID_PROOF2.storage_proof.value),\n-//                 VALID_PROOF2.storage_proof.proof.iter()\n-//             ),\n-//             Ok(())\n-//         );\n-//     }\n-\n-//     #[test]\n-//     fn is_valid_light_client_header_works() {\n-//         UPDATES.iter().for_each(|(_, update)| {\n-//             // Both finalized and attested headers should be verifiable\n-//             assert_eq!(\n-//                 is_valid_light_client_header(&SEPOLIA.fork_parameters, &update.attested_header),\n-//                 Ok(()),\n-//                 \"invalid attested header\"\n-//             );\n-\n-//             assert_eq!(\n-//                 is_valid_light_client_header(&SEPOLIA.fork_parameters, &update.finalized_header),\n-//                 Ok(()),\n-//                 \"invalid finalized header\"\n-//             );\n-//         });\n-//     }\n-// }\n+#[cfg(test)]\n+mod tests {\n+    use beacon_api_types::chain_spec::Mainnet;\n+    use hex_literal::hex;\n+    use lazy_static::lazy_static;\n+\n+    use super::*;\n+\n+    pub struct BlsVerifier;\n+\n+    impl BlsVerify for BlsVerifier {\n+        const INVERSE: bool = false;\n+\n+        fn aggregate_verify_signature<'pk>(\n+            &self,\n+            _aggregate_public_key: &'pk H384,\n+            _public_keys: impl IntoIterator<Item = &'pk H384>,\n+            _msg: Vec<u8>,\n+            _signature: H768,\n+        ) -> Result<(), Error> {\n+            Ok(())\n+        }\n+    }\n+\n+    const SEPOLIA_CHAIN_ID: u64 = 11155111;\n+\n+    lazy_static! {\n+        pub static ref UPDATE_6553725: ethereum_sync_protocol_types::LightClientUpdate =\n+            serde_json::from_str(&include_str!(\"./test/light_client_update_6553725.json\")).unwrap();\n+        pub static ref SYNC_COMMITTEE_6553725: SyncCommittee =\n+            serde_json::from_str(include_str!(\"./test/sync_committee_6553725.json\")).unwrap();\n+    }\n+\n+    pub const GENESIS_VALIDATORS_ROOT_6553725: H256 = H256::new(hex!(\n+        \"d8ea171f3c94aea21ebc42a1ed61052acf3f9209c00e4efbaaddac09ed9b8078\"\n+    ));\n+\n+    fn update_6553725(\n+        update: &ethereum_sync_protocol_types::LightClientUpdate,\n+    ) -> Result<(), Error> {\n+        validate_light_client_update::<Mainnet, BlsVerifier>(\n+            SEPOLIA_CHAIN_ID,\n+            update,\n+            Some(&SYNC_COMMITTEE_6553725),\n+            None,\n+            Slot::new(6553726),\n+            Slot::new(6553718),\n+            GENESIS_VALIDATORS_ROOT_6553725,\n+            BlsVerifier,\n+        )\n+    }\n+\n+    #[test]\n+    fn validate_update_works() {\n+        assert_eq!(update_6553725(&UPDATE_6553725), Ok(()));\n+    }\n+\n+    #[test]\n+    fn validate_update_fails_when_sync_committee_is_wrong() {\n+        let mut update = UPDATE_6553725.clone();\n+        update.sync_aggregate.sync_committee_bits = Vec::new();",
        "comment_created_at": "2025-03-13T11:56:10+00:00",
        "comment_author": "benluelo",
        "comment_body": "this should technically fail, since the vector length is incorrect, so:\r\n\r\n- add a test that ensures the sync committee bits vector length is checked correctly\r\n- use https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.clear here instead",
        "pr_file_module": null
      }
    ]
  }
]