[
  {
    "discussion_id": "2243728261",
    "pr_number": 4911,
    "pr_file": "evm/contracts/apps/ucs/03-zkgm/Send.sol",
    "created_at": "2025-07-30T19:59:11+00:00",
    "commented_code": "}\n     }\n \n-    function _verifyFungibleAssetOrderV2(\n+    function _verifyTokenOrderV2(\n         uint32 channelId,\n         uint256 path,\n-        FungibleAssetOrderV2 calldata order\n+        TokenOrderV2 calldata order\n     ) internal {\n         address baseToken = address(bytes20(order.baseToken));",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2243728261",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4911,
        "pr_file": "evm/contracts/apps/ucs/03-zkgm/Send.sol",
        "discussion_id": "2243728261",
        "commented_code": "@@ -217,78 +212,57 @@ contract UCS03ZkgmSendImpl is Versioned, UCS03ZkgmStore {\n         }\n     }\n \n-    function _verifyFungibleAssetOrderV2(\n+    function _verifyTokenOrderV2(\n         uint32 channelId,\n         uint256 path,\n-        FungibleAssetOrderV2 calldata order\n+        TokenOrderV2 calldata order\n     ) internal {\n         address baseToken = address(bytes20(order.baseToken));",
        "comment_created_at": "2025-07-30T19:59:11+00:00",
        "comment_author": "cor",
        "comment_body": "I suggest changing the implementation of this function to switch/match on TokenOrderV2.kind on the toplevel for three reasons:\r\n\r\n1. easier to read and follow what happens for each kind\r\n2. more gas-efficient (no need to calculate wrappings)\r\n3. slightly less error prone",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1848585316",
    "pr_number": 3193,
    "pr_file": "move/ping-pong/sources/ping_pong.move",
    "created_at": "2024-11-19T15:32:44+00:00",
    "commented_code": ");\n     }\n \n-    public entry fun recv_packet(\n-        packet_sequence: u64,\n-        packet_source_channel: u32,\n-        packet_destination_channel: u32,\n-        packet_data: vector<u8>,\n-        packet_timeout_height: u64,\n-        packet_timeout_timestamp: u64,\n-        proof: vector<u8>,\n-        proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        let pp_packet = decode_packet(&packet_data);\n-        event::emit(RingEvent { ping: pp_packet.ping });\n+    #[view]\n+    public fun get_vault_addr(): address {\n+        object::create_object_address(&@ping_pong, IBC_APP_SEED)\n+    }\n+\n+    public fun get_signer(): signer acquires SignerRef {\n+        let vault = borrow_global<SignerRef>(get_vault_addr());\n+        object::generate_signer_for_extending(&vault.self_ref)\n+    }\n+\n+    public fun get_self_address(): address acquires SignerRef {\n+        let vault = borrow_global<SignerRef>(get_vault_addr());\n+        vault.self_address\n+    }\n+\n+    public fun on_recv_intent_packet(packet: Packet): vector<u8> {\n+        std::debug::print(&string::utf8(b\"NOT IMPLEMENTED\"));\n+        abort 0\n+    }\n+\n+    // Functions with the \"on_\" prefix for each specific operation\n+    public fun on_recv_packet(packet: Packet) acquires PingPong, SignerRef {\n+        std::debug::print(&string::utf8(b\"on_recv_packet called.\"));\n \n-        // let local_timeout = pp_packet.counterparty_timeout;\n+        let packet_data = packet::data(&packet);\n+        std::debug::print(&string::utf8(b\"packet_data is:\"));\n+        std::debug::print(packet_data);\n+        let pp_packet = decode_packet(packet_data);\n+        event::emit(RingEvent { ping: pp_packet.ping });\n \n         pp_packet.ping = !pp_packet.ping;\n-        // pp_packet.counterparty_timeout = timestamp::now_seconds() * 1_000_000_000 + borrow_global<PingPong>(get_vault_addr()).timeout;\n \n         initiate(pp_packet.ping);\n \n-        let packet =\n-            packet::new(\n-                packet_sequence,\n-                packet_source_channel,\n-                packet_destination_channel,\n-                packet_data,\n-                packet_timeout_height,\n-                packet_timeout_timestamp\n-            );\n+        dispatcher::set_return_value<PingPongProof>(new_ping_pong_proof(), ACK_SUCCESS);\n \n-        ibc::recv_packet(\n-            &get_signer(),\n-            get_self_address(),\n-            vector[packet],\n-            proof,\n-            proof_height,\n-            vector[1]\n-        );\n     }\n \n-    public entry fun acknowledge_packet(\n-        packet_sequences: vector<u64>,\n-        packet_source_channels: vector<u32>,\n-        packet_destination_channels: vector<u32>,\n-        packet_datas: vector<vector<u8>>,\n-        packet_timeout_heights: vector<u64>,\n-        packet_timeout_timestamps: vector<u64>,\n-        acknowledgements: vector<vector<u8>>,\n-        proof: vector<u8>,\n-        proof_height: u64\n-    ) acquires SignerRef {\n-        let packets: vector<Packet> = vector::empty();\n-        let i = 0;\n-        while (i < vector::length(&packet_sequences)) {\n-            vector::push_back(\n-                &mut packets,\n-                packet::new(\n-                    *vector::borrow(&packet_sequences, i),\n-                    *vector::borrow(&packet_source_channels, i),\n-                    *vector::borrow(&packet_destination_channels, i),\n-                    *vector::borrow(&packet_datas, i),\n-                    *vector::borrow(&packet_timeout_heights, i),\n-                    *vector::borrow(&packet_timeout_timestamps, i)\n-                )\n-            );\n-            i = i + 1;\n+    public fun on_acknowledge_packet(\n+        packet: Packet, acknowledgement: vector<u8>\n+    ) {\n+        if (acknowledgement != ACK_SUCCESS) {\n+            abort ERR_INVALID_ACK\n         };\n-        ibc::acknowledge_packet(\n-            &get_signer(),\n-            get_self_address(),\n-            packets,\n-            acknowledgements,\n-            proof,\n-            proof_height\n-        );\n         event::emit(AcknowledgedEvent {});\n     }\n \n-    public fun timeout_packet(_packet: Packet) {\n+    public fun on_timeout_packet(_packet: Packet) {\n         event::emit(TimedOutEvent {});\n     }\n \n-    public entry fun channel_open_init(\n-        connection_id: u32, ordering: u8, version: vector<u8>\n-    ) acquires PingPong, SignerRef {\n-        // TODO(aeryz): save the channel here\n-        ibc::channel_open_init(\n-            &get_signer(),\n-            get_self_address(),\n-            connection_id,\n-            ordering,\n-            version\n-        );\n+    public fun on_channel_open_init(\n+        _ordering: u8,\n+        _connection_id: u32,\n+        _channel_id: u32,\n+        _version: vector<u8>\n+    ) acquires PingPong {\n         if (borrow_global<PingPong>(get_vault_addr()).channel_id != 0) {\n             abort ERR_ONLY_ONE_CHANNEL\n         };\n     }\n \n-    public entry fun channel_open_try(\n-        channel_state: u8,\n-        channel_order: u8,\n-        connection_id: u32,\n-        counterparty_channel_id: u32,\n-        version: vector<u8>,\n-        counterparty_version: vector<u8>,\n-        proof_init: vector<u8>,\n-        proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        // TODO(aeryz): save the channel here\n-        ibc::channel_open_try(\n-            &get_signer(),\n-            get_self_address(),\n-            channel_state,\n-            channel_order,\n-            connection_id,\n-            counterparty_channel_id,\n-            version,\n-            counterparty_version,\n-            proof_init,\n-            proof_height\n-        );\n-\n+    public fun on_channel_open_try(\n+        _ordering: u8,\n+        _connection_id: u32,\n+        _channel_id: u32,\n+        _counterparty_channel_id: u32,\n+        _version: vector<u8>,\n+        _counterparty_version: vector<u8>\n+    ) acquires PingPong {\n         if (borrow_global<PingPong>(get_vault_addr()).channel_id != 0) {\n             abort ERR_ONLY_ONE_CHANNEL\n         };\n     }\n \n-    public entry fun channel_open_ack(\n-        channel_id: u32,\n-        counterparty_version: vector<u8>,\n-        counterparty_channel_id: u32,\n-        proof_try: vector<u8>,\n-        proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        // Store the channel_id\n-        ibc::channel_open_ack(\n-            &get_signer(),\n-            get_self_address(),\n-            channel_id,\n-            counterparty_version,\n-            counterparty_channel_id,\n-            proof_try,\n-            proof_height\n-        );\n+    public fun on_channel_open_ack(\n+        channel_id: u32, _counterparty_channel_id: u32, _counterparty_version: vector<u8>\n+    ) acquires PingPong {\n         borrow_global_mut<PingPong>(get_vault_addr()).channel_id = channel_id;\n     }\n \n-    public entry fun channel_open_confirm(\n-        channel_id: u32, proof_ack: vector<u8>, proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        ibc::channel_open_confirm(\n-            &get_signer(),\n-            get_self_address(),\n-            channel_id,\n-            proof_ack,\n-            proof_height\n-        );\n-\n+    public fun on_channel_open_confirm(channel_id: u32) acquires PingPong {\n         borrow_global_mut<PingPong>(get_vault_addr()).channel_id = channel_id;\n     }\n \n-    public entry fun channel_close_init(\n-        _port_id: String, _channel_id: String\n-    ) {\n+    public fun on_channel_close_init(channel_id: u32) {\n         abort ERR_INFINITE_GAME\n     }\n \n-    public entry fun channel_close_confirm(\n-        _port_id: String, _channel_id: String\n-    ) {\n+    public fun on_channel_close_confirm(channel_id: u32) {\n         abort ERR_INFINITE_GAME\n     }\n \n-    #[view]\n-    public fun get_vault_addr(): address {\n-        object::create_object_address(&@ping_pong, IBC_APP_SEED)\n+    fun on_recv_packet_deconstruct(",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1848585316",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3193,
        "pr_file": "move/ping-pong/sources/ping_pong.move",
        "discussion_id": "1848585316",
        "commented_code": "@@ -128,203 +161,304 @@ module ping_pong::ibc {\n         );\n     }\n \n-    public entry fun recv_packet(\n-        packet_sequence: u64,\n-        packet_source_channel: u32,\n-        packet_destination_channel: u32,\n-        packet_data: vector<u8>,\n-        packet_timeout_height: u64,\n-        packet_timeout_timestamp: u64,\n-        proof: vector<u8>,\n-        proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        let pp_packet = decode_packet(&packet_data);\n-        event::emit(RingEvent { ping: pp_packet.ping });\n+    #[view]\n+    public fun get_vault_addr(): address {\n+        object::create_object_address(&@ping_pong, IBC_APP_SEED)\n+    }\n+\n+    public fun get_signer(): signer acquires SignerRef {\n+        let vault = borrow_global<SignerRef>(get_vault_addr());\n+        object::generate_signer_for_extending(&vault.self_ref)\n+    }\n+\n+    public fun get_self_address(): address acquires SignerRef {\n+        let vault = borrow_global<SignerRef>(get_vault_addr());\n+        vault.self_address\n+    }\n+\n+    public fun on_recv_intent_packet(packet: Packet): vector<u8> {\n+        std::debug::print(&string::utf8(b\"NOT IMPLEMENTED\"));\n+        abort 0\n+    }\n+\n+    // Functions with the \"on_\" prefix for each specific operation\n+    public fun on_recv_packet(packet: Packet) acquires PingPong, SignerRef {\n+        std::debug::print(&string::utf8(b\"on_recv_packet called.\"));\n \n-        // let local_timeout = pp_packet.counterparty_timeout;\n+        let packet_data = packet::data(&packet);\n+        std::debug::print(&string::utf8(b\"packet_data is:\"));\n+        std::debug::print(packet_data);\n+        let pp_packet = decode_packet(packet_data);\n+        event::emit(RingEvent { ping: pp_packet.ping });\n \n         pp_packet.ping = !pp_packet.ping;\n-        // pp_packet.counterparty_timeout = timestamp::now_seconds() * 1_000_000_000 + borrow_global<PingPong>(get_vault_addr()).timeout;\n \n         initiate(pp_packet.ping);\n \n-        let packet =\n-            packet::new(\n-                packet_sequence,\n-                packet_source_channel,\n-                packet_destination_channel,\n-                packet_data,\n-                packet_timeout_height,\n-                packet_timeout_timestamp\n-            );\n+        dispatcher::set_return_value<PingPongProof>(new_ping_pong_proof(), ACK_SUCCESS);\n \n-        ibc::recv_packet(\n-            &get_signer(),\n-            get_self_address(),\n-            vector[packet],\n-            proof,\n-            proof_height,\n-            vector[1]\n-        );\n     }\n \n-    public entry fun acknowledge_packet(\n-        packet_sequences: vector<u64>,\n-        packet_source_channels: vector<u32>,\n-        packet_destination_channels: vector<u32>,\n-        packet_datas: vector<vector<u8>>,\n-        packet_timeout_heights: vector<u64>,\n-        packet_timeout_timestamps: vector<u64>,\n-        acknowledgements: vector<vector<u8>>,\n-        proof: vector<u8>,\n-        proof_height: u64\n-    ) acquires SignerRef {\n-        let packets: vector<Packet> = vector::empty();\n-        let i = 0;\n-        while (i < vector::length(&packet_sequences)) {\n-            vector::push_back(\n-                &mut packets,\n-                packet::new(\n-                    *vector::borrow(&packet_sequences, i),\n-                    *vector::borrow(&packet_source_channels, i),\n-                    *vector::borrow(&packet_destination_channels, i),\n-                    *vector::borrow(&packet_datas, i),\n-                    *vector::borrow(&packet_timeout_heights, i),\n-                    *vector::borrow(&packet_timeout_timestamps, i)\n-                )\n-            );\n-            i = i + 1;\n+    public fun on_acknowledge_packet(\n+        packet: Packet, acknowledgement: vector<u8>\n+    ) {\n+        if (acknowledgement != ACK_SUCCESS) {\n+            abort ERR_INVALID_ACK\n         };\n-        ibc::acknowledge_packet(\n-            &get_signer(),\n-            get_self_address(),\n-            packets,\n-            acknowledgements,\n-            proof,\n-            proof_height\n-        );\n         event::emit(AcknowledgedEvent {});\n     }\n \n-    public fun timeout_packet(_packet: Packet) {\n+    public fun on_timeout_packet(_packet: Packet) {\n         event::emit(TimedOutEvent {});\n     }\n \n-    public entry fun channel_open_init(\n-        connection_id: u32, ordering: u8, version: vector<u8>\n-    ) acquires PingPong, SignerRef {\n-        // TODO(aeryz): save the channel here\n-        ibc::channel_open_init(\n-            &get_signer(),\n-            get_self_address(),\n-            connection_id,\n-            ordering,\n-            version\n-        );\n+    public fun on_channel_open_init(\n+        _ordering: u8,\n+        _connection_id: u32,\n+        _channel_id: u32,\n+        _version: vector<u8>\n+    ) acquires PingPong {\n         if (borrow_global<PingPong>(get_vault_addr()).channel_id != 0) {\n             abort ERR_ONLY_ONE_CHANNEL\n         };\n     }\n \n-    public entry fun channel_open_try(\n-        channel_state: u8,\n-        channel_order: u8,\n-        connection_id: u32,\n-        counterparty_channel_id: u32,\n-        version: vector<u8>,\n-        counterparty_version: vector<u8>,\n-        proof_init: vector<u8>,\n-        proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        // TODO(aeryz): save the channel here\n-        ibc::channel_open_try(\n-            &get_signer(),\n-            get_self_address(),\n-            channel_state,\n-            channel_order,\n-            connection_id,\n-            counterparty_channel_id,\n-            version,\n-            counterparty_version,\n-            proof_init,\n-            proof_height\n-        );\n-\n+    public fun on_channel_open_try(\n+        _ordering: u8,\n+        _connection_id: u32,\n+        _channel_id: u32,\n+        _counterparty_channel_id: u32,\n+        _version: vector<u8>,\n+        _counterparty_version: vector<u8>\n+    ) acquires PingPong {\n         if (borrow_global<PingPong>(get_vault_addr()).channel_id != 0) {\n             abort ERR_ONLY_ONE_CHANNEL\n         };\n     }\n \n-    public entry fun channel_open_ack(\n-        channel_id: u32,\n-        counterparty_version: vector<u8>,\n-        counterparty_channel_id: u32,\n-        proof_try: vector<u8>,\n-        proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        // Store the channel_id\n-        ibc::channel_open_ack(\n-            &get_signer(),\n-            get_self_address(),\n-            channel_id,\n-            counterparty_version,\n-            counterparty_channel_id,\n-            proof_try,\n-            proof_height\n-        );\n+    public fun on_channel_open_ack(\n+        channel_id: u32, _counterparty_channel_id: u32, _counterparty_version: vector<u8>\n+    ) acquires PingPong {\n         borrow_global_mut<PingPong>(get_vault_addr()).channel_id = channel_id;\n     }\n \n-    public entry fun channel_open_confirm(\n-        channel_id: u32, proof_ack: vector<u8>, proof_height: u64\n-    ) acquires PingPong, SignerRef {\n-        ibc::channel_open_confirm(\n-            &get_signer(),\n-            get_self_address(),\n-            channel_id,\n-            proof_ack,\n-            proof_height\n-        );\n-\n+    public fun on_channel_open_confirm(channel_id: u32) acquires PingPong {\n         borrow_global_mut<PingPong>(get_vault_addr()).channel_id = channel_id;\n     }\n \n-    public entry fun channel_close_init(\n-        _port_id: String, _channel_id: String\n-    ) {\n+    public fun on_channel_close_init(channel_id: u32) {\n         abort ERR_INFINITE_GAME\n     }\n \n-    public entry fun channel_close_confirm(\n-        _port_id: String, _channel_id: String\n-    ) {\n+    public fun on_channel_close_confirm(channel_id: u32) {\n         abort ERR_INFINITE_GAME\n     }\n \n-    #[view]\n-    public fun get_vault_addr(): address {\n-        object::create_object_address(&@ping_pong, IBC_APP_SEED)\n+    fun on_recv_packet_deconstruct(",
        "comment_created_at": "2024-11-19T15:32:44+00:00",
        "comment_author": "aeryz",
        "comment_body": "it would be so nice if we are able to extract these into a separate module or some kind of a helper library. That way users will be able to plug and go.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1691006894",
    "pr_number": 2546,
    "pr_file": "app/src/routes/faucet/+page.svelte",
    "created_at": "2024-07-25T07:54:47+00:00",
    "commented_code": null,
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1691006894",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2546,
        "pr_file": "app/src/routes/faucet/+page.svelte",
        "discussion_id": "1691006894",
        "commented_code": null,
        "comment_created_at": "2024-07-25T07:54:47+00:00",
        "comment_author": "cor",
        "comment_body": "we should put both the union faucet and the dydx faucet in their own components to keep things isolated",
        "pr_file_module": null
      },
      {
        "comment_id": "1691117030",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2546,
        "pr_file": "app/src/routes/faucet/+page.svelte",
        "discussion_id": "1691006894",
        "commented_code": null,
        "comment_created_at": "2024-07-25T09:13:37+00:00",
        "comment_author": "o-az",
        "comment_body": "no problem will do",
        "pr_file_module": null
      }
    ]
  }
]