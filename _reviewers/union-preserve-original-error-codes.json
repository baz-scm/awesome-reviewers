[
  {
    "discussion_id": "1816257388",
    "pr_number": 3119,
    "pr_file": "move/move-ibc/sources/ibc.move",
    "created_at": "2024-10-25T08:36:32+00:00",
    "commented_code": "public fun recv_packet(\n         ibc_app: &signer,\n         port_id: address,\n-        packet: Packet,\n+        packets: vector<Packet>,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         acknowledgement: vector<u8>\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel =\n-            ensure_channel_state(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet)\n-            );\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n-\n-        assert!(\n-            packet::source_port(&packet)\n-                == channel::chan_counterparty_port_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n+        process_receive(\n+            packets,\n+            proof_height,\n+            proof,\n+            false,\n+            acknowledgement\n+        );\n+\n+        // let channel =\n+        //     ensure_channel_state(\n+        //         *packet::destination_port(&packet),\n+        //         *packet::destination_channel(&packet)\n+        //     );\n+\n+        // let port_id = address_to_string(port_id);\n+        // assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n+\n+        // assert!(\n+        //     packet::source_port(&packet)\n+        //         == channel::chan_counterparty_port_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n+        // );\n+\n+        // assert!(\n+        //     packet::source_channel(&packet)\n+        //         == channel::chan_counterparty_channel_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+        // );\n+\n+        // let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n+        // let store = borrow_global<IBCStore>(get_vault_addr());\n+\n+        // let connection = smart_table::borrow(&store.connections, connection_hop);\n+\n+        // assert!(\n+        //     connection_end::state(connection) == CONN_STATE_OPEN,\n+        //     E_INVALID_CONNECTION_STATE\n+        // );\n+\n+        // if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n+        //     assert!(\n+        //         block::get_current_block_height()\n+        //             < height::get_revision_height(&packet::timeout_height(&packet)),\n+        //         E_HEIGHT_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n+        // if (packet::timeout_timestamp(&packet) != 0) {\n+        //     assert!(\n+        //         current_timestamp < packet::timeout_timestamp(&packet),\n+        //         E_TIMESTAMP_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let err =\n+        //     verify_commitment(\n+        //         connection,\n+        //         proof_height,\n+        //         proof,\n+        //         commitment::packet_key(\n+        //             *packet::source_port(&packet),\n+        //             *packet::source_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         ),\n+        //         packet::commitment(&packet)\n+        //     );\n+\n+        // assert!(err == 0, err);\n+\n+        // let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        // if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n+        //     let receipt_commitment_key =\n+        //         commitment::packet_receipt_key(\n+        //             *packet::destination_port(&packet),\n+        //             *packet::destination_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         );\n+        //     let receipt =\n+        //         table::borrow_with_default(\n+        //             &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n+        //         );\n+        //     assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n+        //     table::upsert(\n+        //         &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n+        //     );\n+        // } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n+        //     let expected_recv_sequence =\n+        //         from_bcs::to_u64(\n+        //             *table::borrow_with_default(\n+        //                 &store.commitments,\n+        //                 commitment::next_sequence_recv_commitment_key(\n+        //                     *packet::destination_port(&packet),\n+        //                     *packet::destination_channel(&packet)\n+        //                 ),\n+        //                 &bcs::to_bytes(&0u64)\n+        //             )\n+        //         );\n+        //     assert!(\n+        //         expected_recv_sequence == packet::sequence(&packet),\n+        //         E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n+        //     );\n+        //     table::upsert(\n+        //         &mut store.commitments,\n+        //         commitment::next_sequence_recv_commitment_key(\n+        //             *packet::destination_port(&packet),\n+        //             packet::destination_channel(&packet)\n+        //         ),\n+        //         bcs::to_bytes(&(expected_recv_sequence + 1))\n+        //     );\n+        // } else {\n+        //     abort E_UNKNOWN_CHANNEL_ORDERING\n+        // };\n+\n+        // if (vector::length(&acknowledgement) > 0) {\n+        //     write_acknowledgement(packet, acknowledgement);\n+        // };\n+\n+        // event::emit(RecvPacket { packet: packet });\n+    }\n+\n+    fun inner_write_acknowledgement(\n+        commitment_key: vector<u8>, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+        if (!table::contains(&store.commitments, commitment_key)) {\n+            abort E_PACKET_NOT_RECEIVED\n+        };\n+        let commitment = table::borrow(&store.commitments, commitment_key);\n         assert!(\n-            packet::source_channel(&packet)\n-                == channel::chan_counterparty_channel_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+            *commitment\n+                == x\"0100000000000000000000000000000000000000000000000000000000000000\",\n+            E_ACK_ALREADY_EXIST\n         );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let store = borrow_global<IBCStore>(get_vault_addr());\n-\n-        let connection = smart_table::borrow(&store.connections, connection_hop);\n-\n-        assert!(\n-            connection_end::state(connection) == CONN_STATE_OPEN,\n-            E_INVALID_CONNECTION_STATE\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment_key,\n+            commitment::commit_ack(acknowledgement)\n         );\n+    }\n \n-        if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n-            assert!(\n-                block::get_current_block_height()\n-                    < height::get_revision_height(&packet::timeout_height(&packet)),\n-                E_HEIGHT_TIMEOUT\n-            );\n-        };\n+    public fun write_acknowledgement(\n+        packet: packet::Packet, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n \n-        let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n-        if (packet::timeout_timestamp(&packet) != 0) {\n-            assert!(\n-                current_timestamp < packet::timeout_timestamp(&packet),\n-                E_TIMESTAMP_TIMEOUT\n-            );\n-        };\n+        ensure_channel_state(packet::destination_channel(&packet));\n \n-        let err =\n-            verify_commitment(\n-                connection,\n-                proof_height,\n-                proof,\n-                commitment::packet_key(\n-                    *packet::source_port(&packet),\n-                    *packet::source_channel(&packet),\n-                    packet::sequence(&packet)\n-                ),\n-                packet::commitment(&packet)\n+        let commitment_key =\n+            commitment::batch_receipts_commitment_key(\n+                packet::destination_channel(&packet),\n+                commitment::commit_packet(&packet)\n             );\n+        inner_write_acknowledgement(commitment_key, acknowledgement);\n \n-        assert!(err == 0, err);\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-\n-        if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n-            let receipt_commitment_key =\n-                commitment::packet_receipt_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet),\n-                    packet::sequence(&packet)\n-                );\n-            let receipt =\n-                table::borrow_with_default(\n-                    &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n-                );\n-            assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n-            table::upsert(\n-                &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n-            );\n-        } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n-            let expected_recv_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &store.commitments,\n-                        commitment::next_sequence_recv_key(\n-                            *packet::destination_port(&packet),\n-                            *packet::destination_channel(&packet)\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n-                );\n-            assert!(\n-                expected_recv_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-            table::upsert(\n-                &mut store.commitments,\n-                commitment::next_sequence_recv_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet)\n-                ),\n-                bcs::to_bytes(&(expected_recv_sequence + 1))\n-            );\n-        } else {\n-            abort E_UNKNOWN_CHANNEL_ORDERING\n-        };\n-\n-        if (vector::length(&acknowledgement) > 0) {\n-            write_acknowledgement(packet, acknowledgement);\n-        };\n-\n-        event::emit(RecvPacket { packet: packet });\n-    }\n-\n-    public fun write_acknowledgement(\n-        packet: packet::Packet, acknowledgement: vector<u8>\n-    ) acquires IBCStore {\n-        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n-\n-        ensure_channel_state(\n-            *packet::destination_port(&packet), *packet::destination_channel(&packet)\n-        );\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-        let ack_commitment_key =\n-            commitment::packet_acknowledgement_key(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let ack_commitment =\n-            table::borrow_with_default(\n-                &store.commitments,\n-                ack_commitment_key,\n-                &bcs::to_bytes(&0u8)\n-            );\n-        assert!(*ack_commitment == bcs::to_bytes(&0u8), E_ACKNOWLEDGEMENT_ALREADY_EXISTS);\n-        table::upsert(\n-            &mut store.commitments, ack_commitment_key, hash::sha2_256(acknowledgement)\n-        );\n-\n-        event::emit(WriteAcknowledgement { packet, acknowledgement });\n-    }\n+        event::emit(WriteAcknowledgement { packet, acknowledgement });\n+    }\n \n     public fun acknowledge_packet(\n         ibc_app: &signer,\n-        port_id: address,\n-        packet: packet::Packet,\n-        acknowledgement: vector<u8>,\n+        port_id: address, // TODO: Verify this\n+        packets: vector<packet::Packet>,\n+        acknowledgements: vector<vector<u8>>,\n         proof: vector<u8>,\n-        proof_height: height::Height\n+        proof_height: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n+        let l = vector::length(&packets);\n+        assert!(l > 0, E_NOT_ENOUGH_PACKETS);\n \n-        let source_port_id = *packet::source_port(&packet);\n-        let source_channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::source_port(&packet), E_UNAUTHORIZED);\n-\n-        let destination_port_id = *packet::destination_port(&packet);\n-        let destination_channel_id = *packet::destination_channel(&packet);\n-\n-        let channel = ensure_channel_state(source_port_id, source_channel_id);\n+        let firstPacket = *vector::borrow(&packets, 0);\n+        let source_channel = packet::source_channel(&firstPacket);\n+        let destination_channel = packet::destination_channel(&firstPacket);\n \n-        assert!(\n-            destination_port_id == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n-        assert!(\n-            destination_channel_id == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n-        let connection =\n-            ensure_connection_state(\n-                *vector::borrow(channel::connection_hops(&channel), 0)\n-            );\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                source_port_id, source_channel_id, packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        assert!(\n-            expected_packet_commitment == packet::commitment(&packet),\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let commitment_key;\n+        if (l == 1) {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packet(&firstPacket)\n+            )\n+        } else {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packets(&packets)\n+            )\n+        };\n \n         let err =\n             verify_commitment(\n-                &connection,\n+                client_id,\n                 proof_height,\n                 proof,\n-                commitment::packet_acknowledgement_key(\n-                    destination_port_id,\n-                    destination_channel_id,\n-                    packet::sequence(&packet)\n-                ),\n-                hash::sha2_256(acknowledgement)\n+                commitment_key,\n+                commitment::commit_acks(acknowledgements)\n             );\n \n         if (err != 0) {\n-            abort err\n+            abort E_INVALID_PROOF\n         };\n \n-        if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) {\n-            let expected_ack_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &borrow_global<IBCStore>(get_vault_addr()).commitments,\n-                        commitment::next_sequence_ack_key(\n-                            source_port_id, source_channel_id\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n+        let ordering = channel::ordering(&channel);\n+        let i = 0;\n+        while (i < l) {\n+            let packet = *vector::borrow(&packets, i);\n+            let commitment_key =\n+                commitment::batch_packets_commitment_key(\n+                    source_channel, commitment::commit_packet(&packet)\n                 );\n-\n-            assert!(\n-                expected_ack_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-\n-            table::upsert(\n+            table::remove(\n                 &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-                commitment::next_sequence_ack_key(source_port_id, source_channel_id),\n-                bcs::to_bytes(&(expected_ack_sequence + 1))\n+                commitment_key\n             );\n-        };\n \n-        table::remove(\n-            &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-            packet_commitment_key\n-        );\n+            let acknowledgement = *vector::borrow(&acknowledgements, i);\n+            // onAcknowledgementPacket(...)\n+            if (ordering == CHAN_ORDERING_ORDERED) {\n+                set_next_sequence_ack(source_channel, packet::sequence(&packet));\n+            };\n+\n+            event::emit(AcknowledgePacket { packet, acknowledgement });\n \n-        event::emit(AcknowledgePacket { packet, acknowledgement });\n+            i = i + 1;\n+        }\n     }\n \n     public fun timeout_packet(\n         ibc_app: &signer,\n-        port_id: address,\n+        port_id: address, // TODO: Verify this\n         packet: Packet,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         next_sequence_recv: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        let channel = ensure_channel_state(port_id, channel_id);\n-\n-        assert!(\n-            *packet::destination_port(&packet)\n-                == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-        assert!(\n-            *packet::destination_channel(&packet)\n-                == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let connection = ensure_connection_state(connection_hop);\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                *packet::source_port(&packet),\n-                *packet::source_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        let packet_commitment = packet::commitment(&packet);\n-        assert!(\n-            expected_packet_commitment == packet_commitment,\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let source_channel = packet::source_channel(&packet);\n+        let destination_channel = packet::destination_channel(&packet);\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n         let proof_timestamp =\n-            light_client::get_timestamp_at_height(\n-                *connection_end::client_id(&connection),\n-                proof_height\n-            );\n+            light_client::get_timestamp_at_height(client_id, proof_height);\n         assert!(proof_timestamp != 0, E_LATEST_TIMESTAMP_NOT_FOUND);\n \n+        let ordering = channel::ordering(&channel);\n+\n+        if (ordering == CHAN_ORDERING_ORDERED) {\n+            let err =\n+                verify_commitment(\n+                    client_id,\n+                    proof_height,\n+                    proof,\n+                    commitment::next_sequence_recv_commitment_key(destination_channel),\n+                    bcs::to_bytes(&next_sequence_recv)\n+                );\n+            assert!(err == 0, E_INVALID_PROOF);",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1816257388",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3119,
        "pr_file": "move/move-ibc/sources/ibc.move",
        "discussion_id": "1816257388",
        "commented_code": "@@ -1071,322 +1041,295 @@ module ibc::ibc {\n     public fun recv_packet(\n         ibc_app: &signer,\n         port_id: address,\n-        packet: Packet,\n+        packets: vector<Packet>,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         acknowledgement: vector<u8>\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel =\n-            ensure_channel_state(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet)\n-            );\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n-\n-        assert!(\n-            packet::source_port(&packet)\n-                == channel::chan_counterparty_port_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n+        process_receive(\n+            packets,\n+            proof_height,\n+            proof,\n+            false,\n+            acknowledgement\n+        );\n+\n+        // let channel =\n+        //     ensure_channel_state(\n+        //         *packet::destination_port(&packet),\n+        //         *packet::destination_channel(&packet)\n+        //     );\n+\n+        // let port_id = address_to_string(port_id);\n+        // assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n+\n+        // assert!(\n+        //     packet::source_port(&packet)\n+        //         == channel::chan_counterparty_port_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n+        // );\n+\n+        // assert!(\n+        //     packet::source_channel(&packet)\n+        //         == channel::chan_counterparty_channel_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+        // );\n+\n+        // let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n+        // let store = borrow_global<IBCStore>(get_vault_addr());\n+\n+        // let connection = smart_table::borrow(&store.connections, connection_hop);\n+\n+        // assert!(\n+        //     connection_end::state(connection) == CONN_STATE_OPEN,\n+        //     E_INVALID_CONNECTION_STATE\n+        // );\n+\n+        // if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n+        //     assert!(\n+        //         block::get_current_block_height()\n+        //             < height::get_revision_height(&packet::timeout_height(&packet)),\n+        //         E_HEIGHT_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n+        // if (packet::timeout_timestamp(&packet) != 0) {\n+        //     assert!(\n+        //         current_timestamp < packet::timeout_timestamp(&packet),\n+        //         E_TIMESTAMP_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let err =\n+        //     verify_commitment(\n+        //         connection,\n+        //         proof_height,\n+        //         proof,\n+        //         commitment::packet_key(\n+        //             *packet::source_port(&packet),\n+        //             *packet::source_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         ),\n+        //         packet::commitment(&packet)\n+        //     );\n+\n+        // assert!(err == 0, err);\n+\n+        // let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        // if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n+        //     let receipt_commitment_key =\n+        //         commitment::packet_receipt_key(\n+        //             *packet::destination_port(&packet),\n+        //             *packet::destination_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         );\n+        //     let receipt =\n+        //         table::borrow_with_default(\n+        //             &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n+        //         );\n+        //     assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n+        //     table::upsert(\n+        //         &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n+        //     );\n+        // } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n+        //     let expected_recv_sequence =\n+        //         from_bcs::to_u64(\n+        //             *table::borrow_with_default(\n+        //                 &store.commitments,\n+        //                 commitment::next_sequence_recv_commitment_key(\n+        //                     *packet::destination_port(&packet),\n+        //                     *packet::destination_channel(&packet)\n+        //                 ),\n+        //                 &bcs::to_bytes(&0u64)\n+        //             )\n+        //         );\n+        //     assert!(\n+        //         expected_recv_sequence == packet::sequence(&packet),\n+        //         E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n+        //     );\n+        //     table::upsert(\n+        //         &mut store.commitments,\n+        //         commitment::next_sequence_recv_commitment_key(\n+        //             *packet::destination_port(&packet),\n+        //             packet::destination_channel(&packet)\n+        //         ),\n+        //         bcs::to_bytes(&(expected_recv_sequence + 1))\n+        //     );\n+        // } else {\n+        //     abort E_UNKNOWN_CHANNEL_ORDERING\n+        // };\n+\n+        // if (vector::length(&acknowledgement) > 0) {\n+        //     write_acknowledgement(packet, acknowledgement);\n+        // };\n+\n+        // event::emit(RecvPacket { packet: packet });\n+    }\n+\n+    fun inner_write_acknowledgement(\n+        commitment_key: vector<u8>, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+        if (!table::contains(&store.commitments, commitment_key)) {\n+            abort E_PACKET_NOT_RECEIVED\n+        };\n+        let commitment = table::borrow(&store.commitments, commitment_key);\n         assert!(\n-            packet::source_channel(&packet)\n-                == channel::chan_counterparty_channel_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+            *commitment\n+                == x\"0100000000000000000000000000000000000000000000000000000000000000\",\n+            E_ACK_ALREADY_EXIST\n         );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let store = borrow_global<IBCStore>(get_vault_addr());\n-\n-        let connection = smart_table::borrow(&store.connections, connection_hop);\n-\n-        assert!(\n-            connection_end::state(connection) == CONN_STATE_OPEN,\n-            E_INVALID_CONNECTION_STATE\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment_key,\n+            commitment::commit_ack(acknowledgement)\n         );\n+    }\n \n-        if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n-            assert!(\n-                block::get_current_block_height()\n-                    < height::get_revision_height(&packet::timeout_height(&packet)),\n-                E_HEIGHT_TIMEOUT\n-            );\n-        };\n+    public fun write_acknowledgement(\n+        packet: packet::Packet, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n \n-        let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n-        if (packet::timeout_timestamp(&packet) != 0) {\n-            assert!(\n-                current_timestamp < packet::timeout_timestamp(&packet),\n-                E_TIMESTAMP_TIMEOUT\n-            );\n-        };\n+        ensure_channel_state(packet::destination_channel(&packet));\n \n-        let err =\n-            verify_commitment(\n-                connection,\n-                proof_height,\n-                proof,\n-                commitment::packet_key(\n-                    *packet::source_port(&packet),\n-                    *packet::source_channel(&packet),\n-                    packet::sequence(&packet)\n-                ),\n-                packet::commitment(&packet)\n+        let commitment_key =\n+            commitment::batch_receipts_commitment_key(\n+                packet::destination_channel(&packet),\n+                commitment::commit_packet(&packet)\n             );\n+        inner_write_acknowledgement(commitment_key, acknowledgement);\n \n-        assert!(err == 0, err);\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-\n-        if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n-            let receipt_commitment_key =\n-                commitment::packet_receipt_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet),\n-                    packet::sequence(&packet)\n-                );\n-            let receipt =\n-                table::borrow_with_default(\n-                    &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n-                );\n-            assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n-            table::upsert(\n-                &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n-            );\n-        } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n-            let expected_recv_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &store.commitments,\n-                        commitment::next_sequence_recv_key(\n-                            *packet::destination_port(&packet),\n-                            *packet::destination_channel(&packet)\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n-                );\n-            assert!(\n-                expected_recv_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-            table::upsert(\n-                &mut store.commitments,\n-                commitment::next_sequence_recv_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet)\n-                ),\n-                bcs::to_bytes(&(expected_recv_sequence + 1))\n-            );\n-        } else {\n-            abort E_UNKNOWN_CHANNEL_ORDERING\n-        };\n-\n-        if (vector::length(&acknowledgement) > 0) {\n-            write_acknowledgement(packet, acknowledgement);\n-        };\n-\n-        event::emit(RecvPacket { packet: packet });\n-    }\n-\n-    public fun write_acknowledgement(\n-        packet: packet::Packet, acknowledgement: vector<u8>\n-    ) acquires IBCStore {\n-        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n-\n-        ensure_channel_state(\n-            *packet::destination_port(&packet), *packet::destination_channel(&packet)\n-        );\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-        let ack_commitment_key =\n-            commitment::packet_acknowledgement_key(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let ack_commitment =\n-            table::borrow_with_default(\n-                &store.commitments,\n-                ack_commitment_key,\n-                &bcs::to_bytes(&0u8)\n-            );\n-        assert!(*ack_commitment == bcs::to_bytes(&0u8), E_ACKNOWLEDGEMENT_ALREADY_EXISTS);\n-        table::upsert(\n-            &mut store.commitments, ack_commitment_key, hash::sha2_256(acknowledgement)\n-        );\n-\n-        event::emit(WriteAcknowledgement { packet, acknowledgement });\n-    }\n+        event::emit(WriteAcknowledgement { packet, acknowledgement });\n+    }\n \n     public fun acknowledge_packet(\n         ibc_app: &signer,\n-        port_id: address,\n-        packet: packet::Packet,\n-        acknowledgement: vector<u8>,\n+        port_id: address, // TODO: Verify this\n+        packets: vector<packet::Packet>,\n+        acknowledgements: vector<vector<u8>>,\n         proof: vector<u8>,\n-        proof_height: height::Height\n+        proof_height: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n+        let l = vector::length(&packets);\n+        assert!(l > 0, E_NOT_ENOUGH_PACKETS);\n \n-        let source_port_id = *packet::source_port(&packet);\n-        let source_channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::source_port(&packet), E_UNAUTHORIZED);\n-\n-        let destination_port_id = *packet::destination_port(&packet);\n-        let destination_channel_id = *packet::destination_channel(&packet);\n-\n-        let channel = ensure_channel_state(source_port_id, source_channel_id);\n+        let firstPacket = *vector::borrow(&packets, 0);\n+        let source_channel = packet::source_channel(&firstPacket);\n+        let destination_channel = packet::destination_channel(&firstPacket);\n \n-        assert!(\n-            destination_port_id == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n-        assert!(\n-            destination_channel_id == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n-        let connection =\n-            ensure_connection_state(\n-                *vector::borrow(channel::connection_hops(&channel), 0)\n-            );\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                source_port_id, source_channel_id, packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        assert!(\n-            expected_packet_commitment == packet::commitment(&packet),\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let commitment_key;\n+        if (l == 1) {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packet(&firstPacket)\n+            )\n+        } else {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packets(&packets)\n+            )\n+        };\n \n         let err =\n             verify_commitment(\n-                &connection,\n+                client_id,\n                 proof_height,\n                 proof,\n-                commitment::packet_acknowledgement_key(\n-                    destination_port_id,\n-                    destination_channel_id,\n-                    packet::sequence(&packet)\n-                ),\n-                hash::sha2_256(acknowledgement)\n+                commitment_key,\n+                commitment::commit_acks(acknowledgements)\n             );\n \n         if (err != 0) {\n-            abort err\n+            abort E_INVALID_PROOF\n         };\n \n-        if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) {\n-            let expected_ack_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &borrow_global<IBCStore>(get_vault_addr()).commitments,\n-                        commitment::next_sequence_ack_key(\n-                            source_port_id, source_channel_id\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n+        let ordering = channel::ordering(&channel);\n+        let i = 0;\n+        while (i < l) {\n+            let packet = *vector::borrow(&packets, i);\n+            let commitment_key =\n+                commitment::batch_packets_commitment_key(\n+                    source_channel, commitment::commit_packet(&packet)\n                 );\n-\n-            assert!(\n-                expected_ack_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-\n-            table::upsert(\n+            table::remove(\n                 &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-                commitment::next_sequence_ack_key(source_port_id, source_channel_id),\n-                bcs::to_bytes(&(expected_ack_sequence + 1))\n+                commitment_key\n             );\n-        };\n \n-        table::remove(\n-            &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-            packet_commitment_key\n-        );\n+            let acknowledgement = *vector::borrow(&acknowledgements, i);\n+            // onAcknowledgementPacket(...)\n+            if (ordering == CHAN_ORDERING_ORDERED) {\n+                set_next_sequence_ack(source_channel, packet::sequence(&packet));\n+            };\n+\n+            event::emit(AcknowledgePacket { packet, acknowledgement });\n \n-        event::emit(AcknowledgePacket { packet, acknowledgement });\n+            i = i + 1;\n+        }\n     }\n \n     public fun timeout_packet(\n         ibc_app: &signer,\n-        port_id: address,\n+        port_id: address, // TODO: Verify this\n         packet: Packet,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         next_sequence_recv: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        let channel = ensure_channel_state(port_id, channel_id);\n-\n-        assert!(\n-            *packet::destination_port(&packet)\n-                == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-        assert!(\n-            *packet::destination_channel(&packet)\n-                == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let connection = ensure_connection_state(connection_hop);\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                *packet::source_port(&packet),\n-                *packet::source_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        let packet_commitment = packet::commitment(&packet);\n-        assert!(\n-            expected_packet_commitment == packet_commitment,\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let source_channel = packet::source_channel(&packet);\n+        let destination_channel = packet::destination_channel(&packet);\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n         let proof_timestamp =\n-            light_client::get_timestamp_at_height(\n-                *connection_end::client_id(&connection),\n-                proof_height\n-            );\n+            light_client::get_timestamp_at_height(client_id, proof_height);\n         assert!(proof_timestamp != 0, E_LATEST_TIMESTAMP_NOT_FOUND);\n \n+        let ordering = channel::ordering(&channel);\n+\n+        if (ordering == CHAN_ORDERING_ORDERED) {\n+            let err =\n+                verify_commitment(\n+                    client_id,\n+                    proof_height,\n+                    proof,\n+                    commitment::next_sequence_recv_commitment_key(destination_channel),\n+                    bcs::to_bytes(&next_sequence_recv)\n+                );\n+            assert!(err == 0, E_INVALID_PROOF);",
        "comment_created_at": "2024-10-25T08:36:32+00:00",
        "comment_author": "aeryz",
        "comment_body": "```suggestion\r\n            assert!(err == 0, err);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1816257621",
    "pr_number": 3119,
    "pr_file": "move/move-ibc/sources/ibc.move",
    "created_at": "2024-10-25T08:36:42+00:00",
    "commented_code": "public fun recv_packet(\n         ibc_app: &signer,\n         port_id: address,\n-        packet: Packet,\n+        packets: vector<Packet>,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         acknowledgement: vector<u8>\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel =\n-            ensure_channel_state(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet)\n-            );\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n-\n-        assert!(\n-            packet::source_port(&packet)\n-                == channel::chan_counterparty_port_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n+        process_receive(\n+            packets,\n+            proof_height,\n+            proof,\n+            false,\n+            acknowledgement\n+        );\n+\n+        // let channel =\n+        //     ensure_channel_state(\n+        //         *packet::destination_port(&packet),\n+        //         *packet::destination_channel(&packet)\n+        //     );\n+\n+        // let port_id = address_to_string(port_id);\n+        // assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n+\n+        // assert!(\n+        //     packet::source_port(&packet)\n+        //         == channel::chan_counterparty_port_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n+        // );\n+\n+        // assert!(\n+        //     packet::source_channel(&packet)\n+        //         == channel::chan_counterparty_channel_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+        // );\n+\n+        // let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n+        // let store = borrow_global<IBCStore>(get_vault_addr());\n+\n+        // let connection = smart_table::borrow(&store.connections, connection_hop);\n+\n+        // assert!(\n+        //     connection_end::state(connection) == CONN_STATE_OPEN,\n+        //     E_INVALID_CONNECTION_STATE\n+        // );\n+\n+        // if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n+        //     assert!(\n+        //         block::get_current_block_height()\n+        //             < height::get_revision_height(&packet::timeout_height(&packet)),\n+        //         E_HEIGHT_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n+        // if (packet::timeout_timestamp(&packet) != 0) {\n+        //     assert!(\n+        //         current_timestamp < packet::timeout_timestamp(&packet),\n+        //         E_TIMESTAMP_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let err =\n+        //     verify_commitment(\n+        //         connection,\n+        //         proof_height,\n+        //         proof,\n+        //         commitment::packet_key(\n+        //             *packet::source_port(&packet),\n+        //             *packet::source_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         ),\n+        //         packet::commitment(&packet)\n+        //     );\n+\n+        // assert!(err == 0, err);\n+\n+        // let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        // if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n+        //     let receipt_commitment_key =\n+        //         commitment::packet_receipt_key(\n+        //             *packet::destination_port(&packet),\n+        //             *packet::destination_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         );\n+        //     let receipt =\n+        //         table::borrow_with_default(\n+        //             &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n+        //         );\n+        //     assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n+        //     table::upsert(\n+        //         &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n+        //     );\n+        // } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n+        //     let expected_recv_sequence =\n+        //         from_bcs::to_u64(\n+        //             *table::borrow_with_default(\n+        //                 &store.commitments,\n+        //                 commitment::next_sequence_recv_commitment_key(\n+        //                     *packet::destination_port(&packet),\n+        //                     *packet::destination_channel(&packet)\n+        //                 ),\n+        //                 &bcs::to_bytes(&0u64)\n+        //             )\n+        //         );\n+        //     assert!(\n+        //         expected_recv_sequence == packet::sequence(&packet),\n+        //         E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n+        //     );\n+        //     table::upsert(\n+        //         &mut store.commitments,\n+        //         commitment::next_sequence_recv_commitment_key(\n+        //             *packet::destination_port(&packet),\n+        //             packet::destination_channel(&packet)\n+        //         ),\n+        //         bcs::to_bytes(&(expected_recv_sequence + 1))\n+        //     );\n+        // } else {\n+        //     abort E_UNKNOWN_CHANNEL_ORDERING\n+        // };\n+\n+        // if (vector::length(&acknowledgement) > 0) {\n+        //     write_acknowledgement(packet, acknowledgement);\n+        // };\n+\n+        // event::emit(RecvPacket { packet: packet });\n+    }\n+\n+    fun inner_write_acknowledgement(\n+        commitment_key: vector<u8>, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+        if (!table::contains(&store.commitments, commitment_key)) {\n+            abort E_PACKET_NOT_RECEIVED\n+        };\n+        let commitment = table::borrow(&store.commitments, commitment_key);\n         assert!(\n-            packet::source_channel(&packet)\n-                == channel::chan_counterparty_channel_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+            *commitment\n+                == x\"0100000000000000000000000000000000000000000000000000000000000000\",\n+            E_ACK_ALREADY_EXIST\n         );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let store = borrow_global<IBCStore>(get_vault_addr());\n-\n-        let connection = smart_table::borrow(&store.connections, connection_hop);\n-\n-        assert!(\n-            connection_end::state(connection) == CONN_STATE_OPEN,\n-            E_INVALID_CONNECTION_STATE\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment_key,\n+            commitment::commit_ack(acknowledgement)\n         );\n+    }\n \n-        if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n-            assert!(\n-                block::get_current_block_height()\n-                    < height::get_revision_height(&packet::timeout_height(&packet)),\n-                E_HEIGHT_TIMEOUT\n-            );\n-        };\n+    public fun write_acknowledgement(\n+        packet: packet::Packet, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n \n-        let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n-        if (packet::timeout_timestamp(&packet) != 0) {\n-            assert!(\n-                current_timestamp < packet::timeout_timestamp(&packet),\n-                E_TIMESTAMP_TIMEOUT\n-            );\n-        };\n+        ensure_channel_state(packet::destination_channel(&packet));\n \n-        let err =\n-            verify_commitment(\n-                connection,\n-                proof_height,\n-                proof,\n-                commitment::packet_key(\n-                    *packet::source_port(&packet),\n-                    *packet::source_channel(&packet),\n-                    packet::sequence(&packet)\n-                ),\n-                packet::commitment(&packet)\n+        let commitment_key =\n+            commitment::batch_receipts_commitment_key(\n+                packet::destination_channel(&packet),\n+                commitment::commit_packet(&packet)\n             );\n+        inner_write_acknowledgement(commitment_key, acknowledgement);\n \n-        assert!(err == 0, err);\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-\n-        if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n-            let receipt_commitment_key =\n-                commitment::packet_receipt_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet),\n-                    packet::sequence(&packet)\n-                );\n-            let receipt =\n-                table::borrow_with_default(\n-                    &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n-                );\n-            assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n-            table::upsert(\n-                &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n-            );\n-        } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n-            let expected_recv_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &store.commitments,\n-                        commitment::next_sequence_recv_key(\n-                            *packet::destination_port(&packet),\n-                            *packet::destination_channel(&packet)\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n-                );\n-            assert!(\n-                expected_recv_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-            table::upsert(\n-                &mut store.commitments,\n-                commitment::next_sequence_recv_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet)\n-                ),\n-                bcs::to_bytes(&(expected_recv_sequence + 1))\n-            );\n-        } else {\n-            abort E_UNKNOWN_CHANNEL_ORDERING\n-        };\n-\n-        if (vector::length(&acknowledgement) > 0) {\n-            write_acknowledgement(packet, acknowledgement);\n-        };\n-\n-        event::emit(RecvPacket { packet: packet });\n-    }\n-\n-    public fun write_acknowledgement(\n-        packet: packet::Packet, acknowledgement: vector<u8>\n-    ) acquires IBCStore {\n-        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n-\n-        ensure_channel_state(\n-            *packet::destination_port(&packet), *packet::destination_channel(&packet)\n-        );\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-        let ack_commitment_key =\n-            commitment::packet_acknowledgement_key(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let ack_commitment =\n-            table::borrow_with_default(\n-                &store.commitments,\n-                ack_commitment_key,\n-                &bcs::to_bytes(&0u8)\n-            );\n-        assert!(*ack_commitment == bcs::to_bytes(&0u8), E_ACKNOWLEDGEMENT_ALREADY_EXISTS);\n-        table::upsert(\n-            &mut store.commitments, ack_commitment_key, hash::sha2_256(acknowledgement)\n-        );\n-\n-        event::emit(WriteAcknowledgement { packet, acknowledgement });\n-    }\n+        event::emit(WriteAcknowledgement { packet, acknowledgement });\n+    }\n \n     public fun acknowledge_packet(\n         ibc_app: &signer,\n-        port_id: address,\n-        packet: packet::Packet,\n-        acknowledgement: vector<u8>,\n+        port_id: address, // TODO: Verify this\n+        packets: vector<packet::Packet>,\n+        acknowledgements: vector<vector<u8>>,\n         proof: vector<u8>,\n-        proof_height: height::Height\n+        proof_height: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n+        let l = vector::length(&packets);\n+        assert!(l > 0, E_NOT_ENOUGH_PACKETS);\n \n-        let source_port_id = *packet::source_port(&packet);\n-        let source_channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::source_port(&packet), E_UNAUTHORIZED);\n-\n-        let destination_port_id = *packet::destination_port(&packet);\n-        let destination_channel_id = *packet::destination_channel(&packet);\n-\n-        let channel = ensure_channel_state(source_port_id, source_channel_id);\n+        let firstPacket = *vector::borrow(&packets, 0);\n+        let source_channel = packet::source_channel(&firstPacket);\n+        let destination_channel = packet::destination_channel(&firstPacket);\n \n-        assert!(\n-            destination_port_id == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n-        assert!(\n-            destination_channel_id == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n-        let connection =\n-            ensure_connection_state(\n-                *vector::borrow(channel::connection_hops(&channel), 0)\n-            );\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                source_port_id, source_channel_id, packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        assert!(\n-            expected_packet_commitment == packet::commitment(&packet),\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let commitment_key;\n+        if (l == 1) {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packet(&firstPacket)\n+            )\n+        } else {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packets(&packets)\n+            )\n+        };\n \n         let err =\n             verify_commitment(\n-                &connection,\n+                client_id,\n                 proof_height,\n                 proof,\n-                commitment::packet_acknowledgement_key(\n-                    destination_port_id,\n-                    destination_channel_id,\n-                    packet::sequence(&packet)\n-                ),\n-                hash::sha2_256(acknowledgement)\n+                commitment_key,\n+                commitment::commit_acks(acknowledgements)\n             );\n \n         if (err != 0) {\n-            abort err\n+            abort E_INVALID_PROOF\n         };\n \n-        if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) {\n-            let expected_ack_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &borrow_global<IBCStore>(get_vault_addr()).commitments,\n-                        commitment::next_sequence_ack_key(\n-                            source_port_id, source_channel_id\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n+        let ordering = channel::ordering(&channel);\n+        let i = 0;\n+        while (i < l) {\n+            let packet = *vector::borrow(&packets, i);\n+            let commitment_key =\n+                commitment::batch_packets_commitment_key(\n+                    source_channel, commitment::commit_packet(&packet)\n                 );\n-\n-            assert!(\n-                expected_ack_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-\n-            table::upsert(\n+            table::remove(\n                 &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-                commitment::next_sequence_ack_key(source_port_id, source_channel_id),\n-                bcs::to_bytes(&(expected_ack_sequence + 1))\n+                commitment_key\n             );\n-        };\n \n-        table::remove(\n-            &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-            packet_commitment_key\n-        );\n+            let acknowledgement = *vector::borrow(&acknowledgements, i);\n+            // onAcknowledgementPacket(...)\n+            if (ordering == CHAN_ORDERING_ORDERED) {\n+                set_next_sequence_ack(source_channel, packet::sequence(&packet));\n+            };\n+\n+            event::emit(AcknowledgePacket { packet, acknowledgement });\n \n-        event::emit(AcknowledgePacket { packet, acknowledgement });\n+            i = i + 1;\n+        }\n     }\n \n     public fun timeout_packet(\n         ibc_app: &signer,\n-        port_id: address,\n+        port_id: address, // TODO: Verify this\n         packet: Packet,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         next_sequence_recv: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        let channel = ensure_channel_state(port_id, channel_id);\n-\n-        assert!(\n-            *packet::destination_port(&packet)\n-                == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-        assert!(\n-            *packet::destination_channel(&packet)\n-                == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let connection = ensure_connection_state(connection_hop);\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                *packet::source_port(&packet),\n-                *packet::source_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        let packet_commitment = packet::commitment(&packet);\n-        assert!(\n-            expected_packet_commitment == packet_commitment,\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let source_channel = packet::source_channel(&packet);\n+        let destination_channel = packet::destination_channel(&packet);\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n         let proof_timestamp =\n-            light_client::get_timestamp_at_height(\n-                *connection_end::client_id(&connection),\n-                proof_height\n-            );\n+            light_client::get_timestamp_at_height(client_id, proof_height);\n         assert!(proof_timestamp != 0, E_LATEST_TIMESTAMP_NOT_FOUND);\n \n+        let ordering = channel::ordering(&channel);\n+\n+        if (ordering == CHAN_ORDERING_ORDERED) {\n+            let err =\n+                verify_commitment(\n+                    client_id,\n+                    proof_height,\n+                    proof,\n+                    commitment::next_sequence_recv_commitment_key(destination_channel),\n+                    bcs::to_bytes(&next_sequence_recv)\n+                );\n+            assert!(err == 0, E_INVALID_PROOF);\n+        } else if (ordering == CHAN_ORDERING_UNORDERED) {\n+            let commitment_key =\n+                commitment::batch_receipts_commitment_key(\n+                    destination_channel, commitment::commit_packet(&packet)\n+                );\n+            let err =\n+                verify_absent_commitment(client_id, proof_height, proof, commitment_key);\n+            assert!(err == 0, E_INVALID_PROOF);",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1816257621",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3119,
        "pr_file": "move/move-ibc/sources/ibc.move",
        "discussion_id": "1816257621",
        "commented_code": "@@ -1071,322 +1041,295 @@ module ibc::ibc {\n     public fun recv_packet(\n         ibc_app: &signer,\n         port_id: address,\n-        packet: Packet,\n+        packets: vector<Packet>,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         acknowledgement: vector<u8>\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel =\n-            ensure_channel_state(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet)\n-            );\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n-\n-        assert!(\n-            packet::source_port(&packet)\n-                == channel::chan_counterparty_port_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n+        process_receive(\n+            packets,\n+            proof_height,\n+            proof,\n+            false,\n+            acknowledgement\n+        );\n+\n+        // let channel =\n+        //     ensure_channel_state(\n+        //         *packet::destination_port(&packet),\n+        //         *packet::destination_channel(&packet)\n+        //     );\n+\n+        // let port_id = address_to_string(port_id);\n+        // assert!(port_id == *packet::destination_port(&packet), E_UNAUTHORIZED);\n+\n+        // assert!(\n+        //     packet::source_port(&packet)\n+        //         == channel::chan_counterparty_port_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_PORT_MISMATCH\n+        // );\n+\n+        // assert!(\n+        //     packet::source_channel(&packet)\n+        //         == channel::chan_counterparty_channel_id(&channel),\n+        //     E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+        // );\n+\n+        // let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n+        // let store = borrow_global<IBCStore>(get_vault_addr());\n+\n+        // let connection = smart_table::borrow(&store.connections, connection_hop);\n+\n+        // assert!(\n+        //     connection_end::state(connection) == CONN_STATE_OPEN,\n+        //     E_INVALID_CONNECTION_STATE\n+        // );\n+\n+        // if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n+        //     assert!(\n+        //         block::get_current_block_height()\n+        //             < height::get_revision_height(&packet::timeout_height(&packet)),\n+        //         E_HEIGHT_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n+        // if (packet::timeout_timestamp(&packet) != 0) {\n+        //     assert!(\n+        //         current_timestamp < packet::timeout_timestamp(&packet),\n+        //         E_TIMESTAMP_TIMEOUT\n+        //     );\n+        // };\n+\n+        // let err =\n+        //     verify_commitment(\n+        //         connection,\n+        //         proof_height,\n+        //         proof,\n+        //         commitment::packet_key(\n+        //             *packet::source_port(&packet),\n+        //             *packet::source_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         ),\n+        //         packet::commitment(&packet)\n+        //     );\n+\n+        // assert!(err == 0, err);\n+\n+        // let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+\n+        // if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n+        //     let receipt_commitment_key =\n+        //         commitment::packet_receipt_key(\n+        //             *packet::destination_port(&packet),\n+        //             *packet::destination_channel(&packet),\n+        //             packet::sequence(&packet)\n+        //         );\n+        //     let receipt =\n+        //         table::borrow_with_default(\n+        //             &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n+        //         );\n+        //     assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n+        //     table::upsert(\n+        //         &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n+        //     );\n+        // } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n+        //     let expected_recv_sequence =\n+        //         from_bcs::to_u64(\n+        //             *table::borrow_with_default(\n+        //                 &store.commitments,\n+        //                 commitment::next_sequence_recv_commitment_key(\n+        //                     *packet::destination_port(&packet),\n+        //                     *packet::destination_channel(&packet)\n+        //                 ),\n+        //                 &bcs::to_bytes(&0u64)\n+        //             )\n+        //         );\n+        //     assert!(\n+        //         expected_recv_sequence == packet::sequence(&packet),\n+        //         E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n+        //     );\n+        //     table::upsert(\n+        //         &mut store.commitments,\n+        //         commitment::next_sequence_recv_commitment_key(\n+        //             *packet::destination_port(&packet),\n+        //             packet::destination_channel(&packet)\n+        //         ),\n+        //         bcs::to_bytes(&(expected_recv_sequence + 1))\n+        //     );\n+        // } else {\n+        //     abort E_UNKNOWN_CHANNEL_ORDERING\n+        // };\n+\n+        // if (vector::length(&acknowledgement) > 0) {\n+        //     write_acknowledgement(packet, acknowledgement);\n+        // };\n+\n+        // event::emit(RecvPacket { packet: packet });\n+    }\n+\n+    fun inner_write_acknowledgement(\n+        commitment_key: vector<u8>, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+        if (!table::contains(&store.commitments, commitment_key)) {\n+            abort E_PACKET_NOT_RECEIVED\n+        };\n+        let commitment = table::borrow(&store.commitments, commitment_key);\n         assert!(\n-            packet::source_channel(&packet)\n-                == channel::chan_counterparty_channel_id(&channel),\n-            E_SOURCE_AND_COUNTERPARTY_CHANNEL_MISMATCH\n+            *commitment\n+                == x\"0100000000000000000000000000000000000000000000000000000000000000\",\n+            E_ACK_ALREADY_EXIST\n         );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let store = borrow_global<IBCStore>(get_vault_addr());\n-\n-        let connection = smart_table::borrow(&store.connections, connection_hop);\n-\n-        assert!(\n-            connection_end::state(connection) == CONN_STATE_OPEN,\n-            E_INVALID_CONNECTION_STATE\n+        table::upsert(\n+            &mut store.commitments,\n+            commitment_key,\n+            commitment::commit_ack(acknowledgement)\n         );\n+    }\n \n-        if (height::get_revision_height(&packet::timeout_height(&packet)) != 0) {\n-            assert!(\n-                block::get_current_block_height()\n-                    < height::get_revision_height(&packet::timeout_height(&packet)),\n-                E_HEIGHT_TIMEOUT\n-            );\n-        };\n+    public fun write_acknowledgement(\n+        packet: packet::Packet, acknowledgement: vector<u8>\n+    ) acquires IBCStore {\n+        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n \n-        let current_timestamp = timestamp::now_seconds() * 1_000_000_000; // 1e9\n-        if (packet::timeout_timestamp(&packet) != 0) {\n-            assert!(\n-                current_timestamp < packet::timeout_timestamp(&packet),\n-                E_TIMESTAMP_TIMEOUT\n-            );\n-        };\n+        ensure_channel_state(packet::destination_channel(&packet));\n \n-        let err =\n-            verify_commitment(\n-                connection,\n-                proof_height,\n-                proof,\n-                commitment::packet_key(\n-                    *packet::source_port(&packet),\n-                    *packet::source_channel(&packet),\n-                    packet::sequence(&packet)\n-                ),\n-                packet::commitment(&packet)\n+        let commitment_key =\n+            commitment::batch_receipts_commitment_key(\n+                packet::destination_channel(&packet),\n+                commitment::commit_packet(&packet)\n             );\n+        inner_write_acknowledgement(commitment_key, acknowledgement);\n \n-        assert!(err == 0, err);\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-\n-        if (channel::ordering(&channel) == CHAN_ORDERING_UNORDERED) {\n-            let receipt_commitment_key =\n-                commitment::packet_receipt_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet),\n-                    packet::sequence(&packet)\n-                );\n-            let receipt =\n-                table::borrow_with_default(\n-                    &store.commitments, receipt_commitment_key, &bcs::to_bytes(&0u8)\n-                );\n-            assert!(*receipt == bcs::to_bytes(&0u8), E_PACKET_ALREADY_RECEIVED);\n-            table::upsert(\n-                &mut store.commitments, receipt_commitment_key, bcs::to_bytes(&1u8)\n-            );\n-        } else if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) { // ORDER_ORDERED\n-            let expected_recv_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &store.commitments,\n-                        commitment::next_sequence_recv_key(\n-                            *packet::destination_port(&packet),\n-                            *packet::destination_channel(&packet)\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n-                );\n-            assert!(\n-                expected_recv_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-            table::upsert(\n-                &mut store.commitments,\n-                commitment::next_sequence_recv_key(\n-                    *packet::destination_port(&packet),\n-                    *packet::destination_channel(&packet)\n-                ),\n-                bcs::to_bytes(&(expected_recv_sequence + 1))\n-            );\n-        } else {\n-            abort E_UNKNOWN_CHANNEL_ORDERING\n-        };\n-\n-        if (vector::length(&acknowledgement) > 0) {\n-            write_acknowledgement(packet, acknowledgement);\n-        };\n-\n-        event::emit(RecvPacket { packet: packet });\n-    }\n-\n-    public fun write_acknowledgement(\n-        packet: packet::Packet, acknowledgement: vector<u8>\n-    ) acquires IBCStore {\n-        assert!(!vector::is_empty(&acknowledgement), E_ACKNOWLEDGEMENT_IS_EMPTY);\n-\n-        ensure_channel_state(\n-            *packet::destination_port(&packet), *packet::destination_channel(&packet)\n-        );\n-\n-        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-        let ack_commitment_key =\n-            commitment::packet_acknowledgement_key(\n-                *packet::destination_port(&packet),\n-                *packet::destination_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let ack_commitment =\n-            table::borrow_with_default(\n-                &store.commitments,\n-                ack_commitment_key,\n-                &bcs::to_bytes(&0u8)\n-            );\n-        assert!(*ack_commitment == bcs::to_bytes(&0u8), E_ACKNOWLEDGEMENT_ALREADY_EXISTS);\n-        table::upsert(\n-            &mut store.commitments, ack_commitment_key, hash::sha2_256(acknowledgement)\n-        );\n-\n-        event::emit(WriteAcknowledgement { packet, acknowledgement });\n-    }\n+        event::emit(WriteAcknowledgement { packet, acknowledgement });\n+    }\n \n     public fun acknowledge_packet(\n         ibc_app: &signer,\n-        port_id: address,\n-        packet: packet::Packet,\n-        acknowledgement: vector<u8>,\n+        port_id: address, // TODO: Verify this\n+        packets: vector<packet::Packet>,\n+        acknowledgements: vector<vector<u8>>,\n         proof: vector<u8>,\n-        proof_height: height::Height\n+        proof_height: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n+        let l = vector::length(&packets);\n+        assert!(l > 0, E_NOT_ENOUGH_PACKETS);\n \n-        let source_port_id = *packet::source_port(&packet);\n-        let source_channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        assert!(port_id == *packet::source_port(&packet), E_UNAUTHORIZED);\n-\n-        let destination_port_id = *packet::destination_port(&packet);\n-        let destination_channel_id = *packet::destination_channel(&packet);\n-\n-        let channel = ensure_channel_state(source_port_id, source_channel_id);\n+        let firstPacket = *vector::borrow(&packets, 0);\n+        let source_channel = packet::source_channel(&firstPacket);\n+        let destination_channel = packet::destination_channel(&firstPacket);\n \n-        assert!(\n-            destination_port_id == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-\n-        assert!(\n-            destination_channel_id == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n-        let connection =\n-            ensure_connection_state(\n-                *vector::borrow(channel::connection_hops(&channel), 0)\n-            );\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                source_port_id, source_channel_id, packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        assert!(\n-            expected_packet_commitment == packet::commitment(&packet),\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let commitment_key;\n+        if (l == 1) {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packet(&firstPacket)\n+            )\n+        } else {\n+            commitment_key = commitment::batch_receipts_commitment_key(\n+                destination_channel,\n+                commitment::commit_packets(&packets)\n+            )\n+        };\n \n         let err =\n             verify_commitment(\n-                &connection,\n+                client_id,\n                 proof_height,\n                 proof,\n-                commitment::packet_acknowledgement_key(\n-                    destination_port_id,\n-                    destination_channel_id,\n-                    packet::sequence(&packet)\n-                ),\n-                hash::sha2_256(acknowledgement)\n+                commitment_key,\n+                commitment::commit_acks(acknowledgements)\n             );\n \n         if (err != 0) {\n-            abort err\n+            abort E_INVALID_PROOF\n         };\n \n-        if (channel::ordering(&channel) == CHAN_ORDERING_ORDERED) {\n-            let expected_ack_sequence =\n-                from_bcs::to_u64(\n-                    *table::borrow_with_default(\n-                        &borrow_global<IBCStore>(get_vault_addr()).commitments,\n-                        commitment::next_sequence_ack_key(\n-                            source_port_id, source_channel_id\n-                        ),\n-                        &bcs::to_bytes(&0u64)\n-                    )\n+        let ordering = channel::ordering(&channel);\n+        let i = 0;\n+        while (i < l) {\n+            let packet = *vector::borrow(&packets, i);\n+            let commitment_key =\n+                commitment::batch_packets_commitment_key(\n+                    source_channel, commitment::commit_packet(&packet)\n                 );\n-\n-            assert!(\n-                expected_ack_sequence == packet::sequence(&packet),\n-                E_PACKET_SEQUENCE_NEXT_SEQUENCE_MISMATCH\n-            );\n-\n-            table::upsert(\n+            table::remove(\n                 &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-                commitment::next_sequence_ack_key(source_port_id, source_channel_id),\n-                bcs::to_bytes(&(expected_ack_sequence + 1))\n+                commitment_key\n             );\n-        };\n \n-        table::remove(\n-            &mut borrow_global_mut<IBCStore>(get_vault_addr()).commitments,\n-            packet_commitment_key\n-        );\n+            let acknowledgement = *vector::borrow(&acknowledgements, i);\n+            // onAcknowledgementPacket(...)\n+            if (ordering == CHAN_ORDERING_ORDERED) {\n+                set_next_sequence_ack(source_channel, packet::sequence(&packet));\n+            };\n+\n+            event::emit(AcknowledgePacket { packet, acknowledgement });\n \n-        event::emit(AcknowledgePacket { packet, acknowledgement });\n+            i = i + 1;\n+        }\n     }\n \n     public fun timeout_packet(\n         ibc_app: &signer,\n-        port_id: address,\n+        port_id: address, // TODO: Verify this\n         packet: Packet,\n         proof: vector<u8>,\n-        proof_height: height::Height,\n+        proof_height: u64,\n         next_sequence_recv: u64\n     ) acquires IBCStore {\n         authorize_app(ibc_app, port_id);\n \n-        let channel_id = *packet::source_channel(&packet);\n-\n-        let port_id = address_to_string(port_id);\n-        let channel = ensure_channel_state(port_id, channel_id);\n-\n-        assert!(\n-            *packet::destination_port(&packet)\n-                == *channel::chan_counterparty_port_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_PORT_MISMATCH\n-        );\n-        assert!(\n-            *packet::destination_channel(&packet)\n-                == *channel::chan_counterparty_channel_id(&channel),\n-            E_DESTINATION_AND_COUNTERPARTY_CHANNEL_MISMATCH\n-        );\n-\n-        let connection_hop = *vector::borrow(channel::connection_hops(&channel), 0);\n-        let connection = ensure_connection_state(connection_hop);\n-\n-        let packet_commitment_key =\n-            commitment::packet_key(\n-                *packet::source_port(&packet),\n-                *packet::source_channel(&packet),\n-                packet::sequence(&packet)\n-            );\n-        let expected_packet_commitment = get_commitment(packet_commitment_key);\n-        assert!(\n-            !vector::is_empty(&expected_packet_commitment),\n-            E_PACKET_COMMITMENT_NOT_FOUND\n-        );\n-\n-        let packet_commitment = packet::commitment(&packet);\n-        assert!(\n-            expected_packet_commitment == packet_commitment,\n-            E_INVALID_PACKET_COMMITMENT\n-        );\n+        let source_channel = packet::source_channel(&packet);\n+        let destination_channel = packet::destination_channel(&packet);\n+        let channel = ensure_channel_state(source_channel);\n+        let client_id = ensure_connection_state(channel::connection_id(&channel));\n \n         let proof_timestamp =\n-            light_client::get_timestamp_at_height(\n-                *connection_end::client_id(&connection),\n-                proof_height\n-            );\n+            light_client::get_timestamp_at_height(client_id, proof_height);\n         assert!(proof_timestamp != 0, E_LATEST_TIMESTAMP_NOT_FOUND);\n \n+        let ordering = channel::ordering(&channel);\n+\n+        if (ordering == CHAN_ORDERING_ORDERED) {\n+            let err =\n+                verify_commitment(\n+                    client_id,\n+                    proof_height,\n+                    proof,\n+                    commitment::next_sequence_recv_commitment_key(destination_channel),\n+                    bcs::to_bytes(&next_sequence_recv)\n+                );\n+            assert!(err == 0, E_INVALID_PROOF);\n+        } else if (ordering == CHAN_ORDERING_UNORDERED) {\n+            let commitment_key =\n+                commitment::batch_receipts_commitment_key(\n+                    destination_channel, commitment::commit_packet(&packet)\n+                );\n+            let err =\n+                verify_absent_commitment(client_id, proof_height, proof, commitment_key);\n+            assert!(err == 0, E_INVALID_PROOF);",
        "comment_created_at": "2024-10-25T08:36:42+00:00",
        "comment_author": "aeryz",
        "comment_body": "```suggestion\r\n            assert!(err == 0, err);\r\n```",
        "pr_file_module": null
      }
    ]
  }
]