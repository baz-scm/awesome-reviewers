[
  {
    "discussion_id": "2082328257",
    "pr_number": 4536,
    "pr_file": "hubble/src/token_fetcher/client.rs",
    "created_at": "2025-05-09T18:39:50+00:00",
    "commented_code": "}\n }\n \n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct Extensions {\n+    pub hubble: Option<HubbleExtension>,\n+}\n+\n+impl Display for Extensions {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(hubble) = &self.hubble {\n+            f.write_fmt(format_args!(\"hubble: {}\", hubble))\n+        } else {\n+            f.write_str(\"no extensions\")\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct HubbleExtension {\n+    #[serde(default, deserialize_with = \"deserialize_opt_u64_from_string\")]",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2082328257",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4536,
        "pr_file": "hubble/src/token_fetcher/client.rs",
        "discussion_id": "2082328257",
        "commented_code": "@@ -86,6 +87,49 @@ impl Display for Token {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct Extensions {\n+    pub hubble: Option<HubbleExtension>,\n+}\n+\n+impl Display for Extensions {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(hubble) = &self.hubble {\n+            f.write_fmt(format_args!(\"hubble: {}\", hubble))\n+        } else {\n+            f.write_str(\"no extensions\")\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct HubbleExtension {\n+    #[serde(default, deserialize_with = \"deserialize_opt_u64_from_string\")]",
        "comment_created_at": "2025-05-09T18:39:50+00:00",
        "comment_author": "benluelo",
        "comment_body": "we have this in serde_utils already if you want to use that crate",
        "pr_file_module": null
      },
      {
        "comment_id": "2082415484",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4536,
        "pr_file": "hubble/src/token_fetcher/client.rs",
        "discussion_id": "2082328257",
        "commented_code": "@@ -86,6 +87,49 @@ impl Display for Token {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct Extensions {\n+    pub hubble: Option<HubbleExtension>,\n+}\n+\n+impl Display for Extensions {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(hubble) = &self.hubble {\n+            f.write_fmt(format_args!(\"hubble: {}\", hubble))\n+        } else {\n+            f.write_str(\"no extensions\")\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct HubbleExtension {\n+    #[serde(default, deserialize_with = \"deserialize_opt_u64_from_string\")]",
        "comment_created_at": "2025-05-09T19:56:08+00:00",
        "comment_author": "qlp",
        "comment_body": "I only see u64_hex? or is there some generic deserializer I can use?",
        "pr_file_module": null
      },
      {
        "comment_id": "2086834765",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4536,
        "pr_file": "hubble/src/token_fetcher/client.rs",
        "discussion_id": "2082328257",
        "commented_code": "@@ -86,6 +87,49 @@ impl Display for Token {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct Extensions {\n+    pub hubble: Option<HubbleExtension>,\n+}\n+\n+impl Display for Extensions {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(hubble) = &self.hubble {\n+            f.write_fmt(format_args!(\"hubble: {}\", hubble))\n+        } else {\n+            f.write_str(\"no extensions\")\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct HubbleExtension {\n+    #[serde(default, deserialize_with = \"deserialize_opt_u64_from_string\")]",
        "comment_created_at": "2025-05-13T13:29:04+00:00",
        "comment_author": "benluelo",
        "comment_body": "https://github.com/unionlabs/union/blob/3fc7119b562776d14f1718705197758259d7a31e/lib/serde-utils/src/lib.rs#L626",
        "pr_file_module": null
      },
      {
        "comment_id": "2086864308",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4536,
        "pr_file": "hubble/src/token_fetcher/client.rs",
        "discussion_id": "2082328257",
        "commented_code": "@@ -86,6 +87,49 @@ impl Display for Token {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct Extensions {\n+    pub hubble: Option<HubbleExtension>,\n+}\n+\n+impl Display for Extensions {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(hubble) = &self.hubble {\n+            f.write_fmt(format_args!(\"hubble: {}\", hubble))\n+        } else {\n+            f.write_str(\"no extensions\")\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Deserialize)]\n+pub struct HubbleExtension {\n+    #[serde(default, deserialize_with = \"deserialize_opt_u64_from_string\")]",
        "comment_created_at": "2025-05-13T13:42:10+00:00",
        "comment_author": "qlp",
        "comment_body": "fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1833141446",
    "pr_number": 3212,
    "pr_file": "lib/ibc-solidity/src/cosmwasm/types.rs",
    "created_at": "2024-11-07T18:02:46+00:00",
    "commented_code": "+// Duplicated until we resolve whether we reuse the same types, or not.\n+\n+pub mod ibc {\n+    alloy::sol! {\n+        // #![sol(cfg_attr(feature = \"rpc\", rpc))]\n+        #![sol(rpc, all_derives)]",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1833141446",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3212,
        "pr_file": "lib/ibc-solidity/src/cosmwasm/types.rs",
        "discussion_id": "1833141446",
        "commented_code": "@@ -0,0 +1,218 @@\n+// Duplicated until we resolve whether we reuse the same types, or not.\n+\n+pub mod ibc {\n+    alloy::sol! {\n+        // #![sol(cfg_attr(feature = \"rpc\", rpc))]\n+        #![sol(rpc, all_derives)]",
        "comment_created_at": "2024-11-07T18:02:46+00:00",
        "comment_author": "benluelo",
        "comment_body": "you can't use the rpc attr in cosmwasm contracts",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1649700656",
    "pr_number": 2127,
    "pr_file": "sentinel/src/chains.rs",
    "created_at": "2024-06-22T13:38:20+00:00",
    "commented_code": "+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);\n+            // Update the filter to fetch logs from the latest block processed + 1\n+            let filter = Filter::new()\n+                .address(ethers::types::H160::from(self.rpc.ibc_handler_address))\n+                .from_block(latest_block)\n+                .to_block(latest_block); //TODO(caglankaan): How can we make here subscribe like instead of latest_block\n+\n+            let logs = provider.get_logs(&filter).await.unwrap();\n+\n+            let logs_clone = logs.clone(); // Clone logs for processing\n+            futures::stream::iter(logs_clone)\n+                .filter_map(|log| async move {\n+                    let raw_log = RawLog {\n+                        topics: log.topics.clone(),\n+                        data: log.data.clone().to_vec(),\n+                    };\n+\n+                    Some(raw_log)\n+                })\n+                .for_each_concurrent(None, |raw_log| async move {\n+                    let ibc_event =\n+                        ibchandler_events_to_ibc_event(raw_log, &self.rpc, latest_block).await;\n+\n+                    if let Some(ibc_event) = ibc_event {\n+                        self.handle_ibc_event(ibc_event, &shared_map, latest_block)\n+                            .await;\n+                    }\n+                })\n+                .await;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+impl IbcListen for Cosmos {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        tracing::info!(\"Listening to Cosmos chain events\");\n+        let mut subs = self\n+            .chain\n+            .tm_client\n+            .subscribe(tendermint_rpc::query::EventType::Tx.into())\n+            .await\n+            .unwrap();\n+        loop {\n+            tokio::select! {\n+                Some(event_result) = subs.next() => {\n+                    match event_result {\n+                        Ok(event) => {\n+                            // tracing::info!(\"Received event_result: {:?}\", event.clone());\n+                            if let Some(ref events) = event.events {\n+                                if let Some(heights) = events.get(\"tx.height\") {\n+                                    if let Some(height) = heights.first() {\n+                                        let block_number: u64 = height.parse().expect(\"Failed to parse block number\");\n+                                        tracing::info!(\"Fetched cosmos Block number: {}\", block_number);\n+                                    }\n+                                }\n+                            }\n+\n+                            match event.data {\n+                                EventData::Tx { tx_result, .. } => {\n+                                    for event in tx_result.result.events {\n+                                        // tracing::info!(\"Received event: {:?}\", event.clone());\n+                                        let Some(my_event) = IbcEvent::try_from_tendermint_event(TendermintEvent {\n+                                            ty: event.kind,\n+                                            attributes: event.attributes\n+                                                .into_iter()\n+                                                .map(|attr| EventAttribute {\n+                                                    key: attr.key,\n+                                                    value: attr.value,\n+                                                    index: attr.index,\n+                                                })\n+                                                .collect(),\n+                                        }) else {\n+                                            continue;\n+                                        };\n+                                        let ibc_event = my_event.unwrap();\n+                                        self.handle_ibc_event(ibc_event, &shared_map, 13).await;\n+                                    }\n+                                }\n+                                _ => {\n+                                    tracing::error!(\"Unhandled event type: {:?}\", event);\n+                                }\n+                            }\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\"Error while receiving event: {:?}\", e);\n+                        }\n+                    }\n+                },\n+                else => break,\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+\n+impl IbcTransfer for Ethereum {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        let mut rng = StdRng::from_entropy();\n+        let index = rng.gen_range(0..self.relays.len()); // Select a random index\n+\n+        let relay = &self.relays[index];\n+        let signer_middleware = &self.signer_middlewares[index];\n+        let msg_sender = self.msg_senders[index];\n+\n+        let denom_address = match ethers::types::H160::from_str(&denom) {\n+            Ok(address) => address,\n+            Err(_) => {\n+                let formatted_denom = format!(\n+                    \"{}/{}/{}\",\n+                    self.ucs01_contract.to_lowercase(),\n+                    destination_channel,\n+                    denom\n+                );\n+\n+                relay\n+                    .get_denom_address(\n+                        destination_channel.clone().to_string(),\n+                        formatted_denom.clone(),\n+                    )\n+                    .call()\n+                    .await\n+                    .unwrap()\n+            }\n+        };\n+\n+        if denom_address == ethers::types::H160::zero() {\n+            tracing::warn!(\"Denom address not found\");\n+            return;\n+        }\n+        let erc_contract = erc20::ERC20::new(denom_address, signer_middleware.clone());\n+        let balance = erc_contract.balance_of(msg_sender).await.unwrap();\n+        tracing::info!(\"ETH Token balance: {}. Sending amount: {}\", balance, amount);\n+        if balance < amount.into() {\n+            tracing::warn!(\"Insufficient balance\");\n+            return;\n+        }\n+\n+        let allowance = erc_contract\n+            .allowance(msg_sender, self.relay_addr)\n+            .await\n+            .unwrap();\n+        if allowance < amount.into() {\n+            let _ = erc_contract\n+                .approve(self.relay_addr, (U256::MAX / U256::from(2)).into())\n+                .send()\n+                .await;\n+            tracing::info!(\"We can not transfer after approve, returning now.\");\n+            // return;\n+        }\n+\n+        let mut debug_msg;\n+        match protocol {\n+            Protocol::Ucs01 {\n+                receivers,\n+                contract,\n+            } => {\n+                let mut rng = StdRng::from_entropy();\n+                let index = rng.gen_range(0..receivers.len()); // Select a random index\n+\n+                let receiver = &receivers[index];\n+\n+                let mut final_receiver = receiver.encode_to_vec().into();\n+\n+                if memo.is_empty() {\n+                    let (_hrp, data, _variant) =\n+                        bech32::decode(&receiver).expect(\"Invalid Bech32 address\");\n+\n+                    let bytes: Vec<u8> =\n+                        Vec::<u8>::from_base32(&data).expect(\"Invalid base32 data\");\n+\n+                    final_receiver = bytes.into();\n+                }\n+\n+                debug_msg = format!(\n+                    \"[Ethereum] -> Sent IBC transfer. memo: {}. Sending denom: {}. To: {}. Amount: {}, contract: {}\",\n+                    memo,\n+                    denom,\n+                    final_receiver,\n+                    amount,\n+                    contract\n+                );\n+                let _tx_rcp: Option<ethers::types::TransactionReceipt> = match relay\n+                    .send(\n+                        destination_channel.clone().to_string(),\n+                        final_receiver,\n+                        [LocalToken {\n+                            denom: denom_address,\n+                            amount: amount as u128,\n+                        }]\n+                        .into(),\n+                        memo,\n+                        (Height {\n+                            revision_number: 0,\n+                            revision_height: 0,\n+                        })\n+                        .into(),\n+                        u64::MAX,\n+                    )\n+                    .send()\n+                    .await\n+                {\n+                    Ok(response) => match response.await {\n+                        Ok(receipt) => Some(receipt.expect(\"Failed to get transaction receipt\")),\n+                        Err(e) => {\n+                            tracing::error!(\"Failed to get transaction receipt: {:?}\", e);\n+                            return;\n+                        }\n+                    },\n+                    Err(ethers::contract::ContractError::MiddlewareError { e }) => {\n+                        if e.to_string().contains(\"replacement transaction underprice\") {\n+                            tracing::warn!(\"Replacement transaction underprice.\");\n+                        } else {\n+                            tracing::error!(\n+                                \"Failed to send transaction eth->union: {:?}\",\n+                                e.to_string()\n+                            );\n+                        }\n+                        return;\n+                    }\n+                    Err(e) => {\n+                        tracing::error!(\"Failed to send transaction eth->union: {:?}\", e);\n+                        return;\n+                    }\n+                };\n+                let tx_hash = _tx_rcp.unwrap().transaction_hash.to_string();\n+                debug_msg.push_str(&format!(\" Tx Hash: {:?}\", tx_hash));\n+\n+                tracing::info!(debug_msg);\n+            }\n+            Protocol::Ics20 {\n+                receivers: _,\n+                module: _,\n+            } => {\n+                unimplemented!(\"Ics20 protocol not implemented\"); // TODO: Do we even have this case?\n+            }\n+        }\n+    }\n+}\n+\n+impl Ethereum {\n+    pub async fn new(config: EthereumConfig) -> Self {\n+        let ethereum_rpc = EthereumRpc {\n+            provider: Arc::new(Provider::new(\n+                Ws::connect(config.eth_rpc_api.clone()).await.unwrap(),\n+            )),\n+            ibc_handler_address: config.ibc_handler_address,\n+        };\n+\n+        let mut relays = Vec::new();\n+        let mut signers_middleware = Vec::new();\n+        let mut msg_senders = Vec::new();\n+\n+        let (relay_addr, ucs01_contract) = match config.transfer_module {\n+            TransferModule::Contract { ref address } => {\n+                let relay_addr: Address = address.parse().expect(\"Invalid contract address\");\n+                (relay_addr, address.clone())\n+            }\n+            TransferModule::Native => {\n+                panic!(\"Native transfer module is not supported in this context\")\n+            }\n+        };\n+        for signer in config.signers.clone() {\n+            let signing_key: ecdsa::SigningKey = signer.value();\n+            let address_of_privkey: ethers::types::H160 = secret_key_to_address(&signing_key);\n+            tracing::info!(\"address: {:?}\", address_of_privkey);\n+\n+            let provider: Arc<Provider<Ws>> = ethereum_rpc.provider.clone();\n+\n+            let chain_id = provider\n+                .get_chainid()\n+                .await\n+                .expect(\"Failed to get chain ID\")\n+                .as_u64();\n+            let wallet = LocalWallet::new_with_signer(signing_key, address_of_privkey, chain_id);\n+\n+            let signer_middleware = Arc::new(SignerMiddleware::new(\n+                NonceManagerMiddleware::new(provider.clone(), address_of_privkey),\n+                wallet.clone(),\n+            ));\n+\n+            let relay = UCS01Relay::new(relay_addr, signer_middleware.clone());\n+\n+            relays.push(relay);\n+            signers_middleware.push(signer_middleware);\n+            msg_senders.push(address_of_privkey);\n+        }\n+\n+        Ethereum {\n+            rpc: ethereum_rpc,\n+            relays,\n+            signer_middlewares: signers_middleware,\n+            ucs01_contract,\n+            msg_senders,\n+            relay_addr,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Cosmos {\n+    pub chain: chain_utils::cosmos::Cosmos,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Union {\n+    pub chain: chain_utils::union::Union,\n+}\n+\n+impl IbcTransfer for Cosmos {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        self.chain.keyring.with(|signer| async move {\n+            let mut debug_msg;\n+            let transfer_msg = match protocol {\n+                Protocol::Ics20 { receivers, module } => {\n+                    let mut rng = StdRng::from_entropy();\n+                    let index = rng.gen_range(0..receivers.len()); // Select a random index\n+\n+                    let receiver = &receivers[index];\n+\n+                    let msg = MsgTransfer {\n+                        source_port: \"transfer\".into(),\n+                        source_channel: destination_channel.to_string(),\n+                        token: Some(\n+                            (Coin {\n+                                denom: denom.to_string(),\n+                                amount: amount as u128,\n+                            }).into()\n+                        ),\n+                        sender: signer.to_string(),\n+                        receiver: receiver.to_string(),\n+                        timeout_height: None,\n+                        timeout_timestamp: u64::MAX / 2,\n+                        memo: memo.clone(),\n+                    };\n+\n+                    debug_msg = format!(\n+                        \"[Cosmos Ics20] -> SENT IBC transfer from: {}. memo: {}. denom: {}. To: {}. Amount: {}, module: {:?}\",\n+                        signer.to_string(),\n+                        memo,\n+                        denom,\n+                        receiver,\n+                        amount,\n+                        module\n+                    );\n+\n+                    Any {\n+                        type_url: \"/ibc.applications.transfer.v1.MsgTransfer\".to_string(),",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1649700656",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2127,
        "pr_file": "sentinel/src/chains.rs",
        "discussion_id": "1649700656",
        "commented_code": "@@ -0,0 +1,997 @@\n+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);\n+            // Update the filter to fetch logs from the latest block processed + 1\n+            let filter = Filter::new()\n+                .address(ethers::types::H160::from(self.rpc.ibc_handler_address))\n+                .from_block(latest_block)\n+                .to_block(latest_block); //TODO(caglankaan): How can we make here subscribe like instead of latest_block\n+\n+            let logs = provider.get_logs(&filter).await.unwrap();\n+\n+            let logs_clone = logs.clone(); // Clone logs for processing\n+            futures::stream::iter(logs_clone)\n+                .filter_map(|log| async move {\n+                    let raw_log = RawLog {\n+                        topics: log.topics.clone(),\n+                        data: log.data.clone().to_vec(),\n+                    };\n+\n+                    Some(raw_log)\n+                })\n+                .for_each_concurrent(None, |raw_log| async move {\n+                    let ibc_event =\n+                        ibchandler_events_to_ibc_event(raw_log, &self.rpc, latest_block).await;\n+\n+                    if let Some(ibc_event) = ibc_event {\n+                        self.handle_ibc_event(ibc_event, &shared_map, latest_block)\n+                            .await;\n+                    }\n+                })\n+                .await;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+impl IbcListen for Cosmos {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        tracing::info!(\"Listening to Cosmos chain events\");\n+        let mut subs = self\n+            .chain\n+            .tm_client\n+            .subscribe(tendermint_rpc::query::EventType::Tx.into())\n+            .await\n+            .unwrap();\n+        loop {\n+            tokio::select! {\n+                Some(event_result) = subs.next() => {\n+                    match event_result {\n+                        Ok(event) => {\n+                            // tracing::info!(\"Received event_result: {:?}\", event.clone());\n+                            if let Some(ref events) = event.events {\n+                                if let Some(heights) = events.get(\"tx.height\") {\n+                                    if let Some(height) = heights.first() {\n+                                        let block_number: u64 = height.parse().expect(\"Failed to parse block number\");\n+                                        tracing::info!(\"Fetched cosmos Block number: {}\", block_number);\n+                                    }\n+                                }\n+                            }\n+\n+                            match event.data {\n+                                EventData::Tx { tx_result, .. } => {\n+                                    for event in tx_result.result.events {\n+                                        // tracing::info!(\"Received event: {:?}\", event.clone());\n+                                        let Some(my_event) = IbcEvent::try_from_tendermint_event(TendermintEvent {\n+                                            ty: event.kind,\n+                                            attributes: event.attributes\n+                                                .into_iter()\n+                                                .map(|attr| EventAttribute {\n+                                                    key: attr.key,\n+                                                    value: attr.value,\n+                                                    index: attr.index,\n+                                                })\n+                                                .collect(),\n+                                        }) else {\n+                                            continue;\n+                                        };\n+                                        let ibc_event = my_event.unwrap();\n+                                        self.handle_ibc_event(ibc_event, &shared_map, 13).await;\n+                                    }\n+                                }\n+                                _ => {\n+                                    tracing::error!(\"Unhandled event type: {:?}\", event);\n+                                }\n+                            }\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\"Error while receiving event: {:?}\", e);\n+                        }\n+                    }\n+                },\n+                else => break,\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+\n+impl IbcTransfer for Ethereum {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        let mut rng = StdRng::from_entropy();\n+        let index = rng.gen_range(0..self.relays.len()); // Select a random index\n+\n+        let relay = &self.relays[index];\n+        let signer_middleware = &self.signer_middlewares[index];\n+        let msg_sender = self.msg_senders[index];\n+\n+        let denom_address = match ethers::types::H160::from_str(&denom) {\n+            Ok(address) => address,\n+            Err(_) => {\n+                let formatted_denom = format!(\n+                    \"{}/{}/{}\",\n+                    self.ucs01_contract.to_lowercase(),\n+                    destination_channel,\n+                    denom\n+                );\n+\n+                relay\n+                    .get_denom_address(\n+                        destination_channel.clone().to_string(),\n+                        formatted_denom.clone(),\n+                    )\n+                    .call()\n+                    .await\n+                    .unwrap()\n+            }\n+        };\n+\n+        if denom_address == ethers::types::H160::zero() {\n+            tracing::warn!(\"Denom address not found\");\n+            return;\n+        }\n+        let erc_contract = erc20::ERC20::new(denom_address, signer_middleware.clone());\n+        let balance = erc_contract.balance_of(msg_sender).await.unwrap();\n+        tracing::info!(\"ETH Token balance: {}. Sending amount: {}\", balance, amount);\n+        if balance < amount.into() {\n+            tracing::warn!(\"Insufficient balance\");\n+            return;\n+        }\n+\n+        let allowance = erc_contract\n+            .allowance(msg_sender, self.relay_addr)\n+            .await\n+            .unwrap();\n+        if allowance < amount.into() {\n+            let _ = erc_contract\n+                .approve(self.relay_addr, (U256::MAX / U256::from(2)).into())\n+                .send()\n+                .await;\n+            tracing::info!(\"We can not transfer after approve, returning now.\");\n+            // return;\n+        }\n+\n+        let mut debug_msg;\n+        match protocol {\n+            Protocol::Ucs01 {\n+                receivers,\n+                contract,\n+            } => {\n+                let mut rng = StdRng::from_entropy();\n+                let index = rng.gen_range(0..receivers.len()); // Select a random index\n+\n+                let receiver = &receivers[index];\n+\n+                let mut final_receiver = receiver.encode_to_vec().into();\n+\n+                if memo.is_empty() {\n+                    let (_hrp, data, _variant) =\n+                        bech32::decode(&receiver).expect(\"Invalid Bech32 address\");\n+\n+                    let bytes: Vec<u8> =\n+                        Vec::<u8>::from_base32(&data).expect(\"Invalid base32 data\");\n+\n+                    final_receiver = bytes.into();\n+                }\n+\n+                debug_msg = format!(\n+                    \"[Ethereum] -> Sent IBC transfer. memo: {}. Sending denom: {}. To: {}. Amount: {}, contract: {}\",\n+                    memo,\n+                    denom,\n+                    final_receiver,\n+                    amount,\n+                    contract\n+                );\n+                let _tx_rcp: Option<ethers::types::TransactionReceipt> = match relay\n+                    .send(\n+                        destination_channel.clone().to_string(),\n+                        final_receiver,\n+                        [LocalToken {\n+                            denom: denom_address,\n+                            amount: amount as u128,\n+                        }]\n+                        .into(),\n+                        memo,\n+                        (Height {\n+                            revision_number: 0,\n+                            revision_height: 0,\n+                        })\n+                        .into(),\n+                        u64::MAX,\n+                    )\n+                    .send()\n+                    .await\n+                {\n+                    Ok(response) => match response.await {\n+                        Ok(receipt) => Some(receipt.expect(\"Failed to get transaction receipt\")),\n+                        Err(e) => {\n+                            tracing::error!(\"Failed to get transaction receipt: {:?}\", e);\n+                            return;\n+                        }\n+                    },\n+                    Err(ethers::contract::ContractError::MiddlewareError { e }) => {\n+                        if e.to_string().contains(\"replacement transaction underprice\") {\n+                            tracing::warn!(\"Replacement transaction underprice.\");\n+                        } else {\n+                            tracing::error!(\n+                                \"Failed to send transaction eth->union: {:?}\",\n+                                e.to_string()\n+                            );\n+                        }\n+                        return;\n+                    }\n+                    Err(e) => {\n+                        tracing::error!(\"Failed to send transaction eth->union: {:?}\", e);\n+                        return;\n+                    }\n+                };\n+                let tx_hash = _tx_rcp.unwrap().transaction_hash.to_string();\n+                debug_msg.push_str(&format!(\" Tx Hash: {:?}\", tx_hash));\n+\n+                tracing::info!(debug_msg);\n+            }\n+            Protocol::Ics20 {\n+                receivers: _,\n+                module: _,\n+            } => {\n+                unimplemented!(\"Ics20 protocol not implemented\"); // TODO: Do we even have this case?\n+            }\n+        }\n+    }\n+}\n+\n+impl Ethereum {\n+    pub async fn new(config: EthereumConfig) -> Self {\n+        let ethereum_rpc = EthereumRpc {\n+            provider: Arc::new(Provider::new(\n+                Ws::connect(config.eth_rpc_api.clone()).await.unwrap(),\n+            )),\n+            ibc_handler_address: config.ibc_handler_address,\n+        };\n+\n+        let mut relays = Vec::new();\n+        let mut signers_middleware = Vec::new();\n+        let mut msg_senders = Vec::new();\n+\n+        let (relay_addr, ucs01_contract) = match config.transfer_module {\n+            TransferModule::Contract { ref address } => {\n+                let relay_addr: Address = address.parse().expect(\"Invalid contract address\");\n+                (relay_addr, address.clone())\n+            }\n+            TransferModule::Native => {\n+                panic!(\"Native transfer module is not supported in this context\")\n+            }\n+        };\n+        for signer in config.signers.clone() {\n+            let signing_key: ecdsa::SigningKey = signer.value();\n+            let address_of_privkey: ethers::types::H160 = secret_key_to_address(&signing_key);\n+            tracing::info!(\"address: {:?}\", address_of_privkey);\n+\n+            let provider: Arc<Provider<Ws>> = ethereum_rpc.provider.clone();\n+\n+            let chain_id = provider\n+                .get_chainid()\n+                .await\n+                .expect(\"Failed to get chain ID\")\n+                .as_u64();\n+            let wallet = LocalWallet::new_with_signer(signing_key, address_of_privkey, chain_id);\n+\n+            let signer_middleware = Arc::new(SignerMiddleware::new(\n+                NonceManagerMiddleware::new(provider.clone(), address_of_privkey),\n+                wallet.clone(),\n+            ));\n+\n+            let relay = UCS01Relay::new(relay_addr, signer_middleware.clone());\n+\n+            relays.push(relay);\n+            signers_middleware.push(signer_middleware);\n+            msg_senders.push(address_of_privkey);\n+        }\n+\n+        Ethereum {\n+            rpc: ethereum_rpc,\n+            relays,\n+            signer_middlewares: signers_middleware,\n+            ucs01_contract,\n+            msg_senders,\n+            relay_addr,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Cosmos {\n+    pub chain: chain_utils::cosmos::Cosmos,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Union {\n+    pub chain: chain_utils::union::Union,\n+}\n+\n+impl IbcTransfer for Cosmos {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        self.chain.keyring.with(|signer| async move {\n+            let mut debug_msg;\n+            let transfer_msg = match protocol {\n+                Protocol::Ics20 { receivers, module } => {\n+                    let mut rng = StdRng::from_entropy();\n+                    let index = rng.gen_range(0..receivers.len()); // Select a random index\n+\n+                    let receiver = &receivers[index];\n+\n+                    let msg = MsgTransfer {\n+                        source_port: \"transfer\".into(),\n+                        source_channel: destination_channel.to_string(),\n+                        token: Some(\n+                            (Coin {\n+                                denom: denom.to_string(),\n+                                amount: amount as u128,\n+                            }).into()\n+                        ),\n+                        sender: signer.to_string(),\n+                        receiver: receiver.to_string(),\n+                        timeout_height: None,\n+                        timeout_timestamp: u64::MAX / 2,\n+                        memo: memo.clone(),\n+                    };\n+\n+                    debug_msg = format!(\n+                        \"[Cosmos Ics20] -> SENT IBC transfer from: {}. memo: {}. denom: {}. To: {}. Amount: {}, module: {:?}\",\n+                        signer.to_string(),\n+                        memo,\n+                        denom,\n+                        receiver,\n+                        amount,\n+                        module\n+                    );\n+\n+                    Any {\n+                        type_url: \"/ibc.applications.transfer.v1.MsgTransfer\".to_string(),",
        "comment_created_at": "2024-06-22T13:38:20+00:00",
        "comment_author": "benluelo",
        "comment_body": "use `MsgTransfer::type_url()`, provided by this trait: https://docs.rs/prost/latest/prost/trait.Name.html",
        "pr_file_module": null
      },
      {
        "comment_id": "1649700846",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2127,
        "pr_file": "sentinel/src/chains.rs",
        "discussion_id": "1649700656",
        "commented_code": "@@ -0,0 +1,997 @@\n+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);\n+            // Update the filter to fetch logs from the latest block processed + 1\n+            let filter = Filter::new()\n+                .address(ethers::types::H160::from(self.rpc.ibc_handler_address))\n+                .from_block(latest_block)\n+                .to_block(latest_block); //TODO(caglankaan): How can we make here subscribe like instead of latest_block\n+\n+            let logs = provider.get_logs(&filter).await.unwrap();\n+\n+            let logs_clone = logs.clone(); // Clone logs for processing\n+            futures::stream::iter(logs_clone)\n+                .filter_map(|log| async move {\n+                    let raw_log = RawLog {\n+                        topics: log.topics.clone(),\n+                        data: log.data.clone().to_vec(),\n+                    };\n+\n+                    Some(raw_log)\n+                })\n+                .for_each_concurrent(None, |raw_log| async move {\n+                    let ibc_event =\n+                        ibchandler_events_to_ibc_event(raw_log, &self.rpc, latest_block).await;\n+\n+                    if let Some(ibc_event) = ibc_event {\n+                        self.handle_ibc_event(ibc_event, &shared_map, latest_block)\n+                            .await;\n+                    }\n+                })\n+                .await;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+impl IbcListen for Cosmos {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        tracing::info!(\"Listening to Cosmos chain events\");\n+        let mut subs = self\n+            .chain\n+            .tm_client\n+            .subscribe(tendermint_rpc::query::EventType::Tx.into())\n+            .await\n+            .unwrap();\n+        loop {\n+            tokio::select! {\n+                Some(event_result) = subs.next() => {\n+                    match event_result {\n+                        Ok(event) => {\n+                            // tracing::info!(\"Received event_result: {:?}\", event.clone());\n+                            if let Some(ref events) = event.events {\n+                                if let Some(heights) = events.get(\"tx.height\") {\n+                                    if let Some(height) = heights.first() {\n+                                        let block_number: u64 = height.parse().expect(\"Failed to parse block number\");\n+                                        tracing::info!(\"Fetched cosmos Block number: {}\", block_number);\n+                                    }\n+                                }\n+                            }\n+\n+                            match event.data {\n+                                EventData::Tx { tx_result, .. } => {\n+                                    for event in tx_result.result.events {\n+                                        // tracing::info!(\"Received event: {:?}\", event.clone());\n+                                        let Some(my_event) = IbcEvent::try_from_tendermint_event(TendermintEvent {\n+                                            ty: event.kind,\n+                                            attributes: event.attributes\n+                                                .into_iter()\n+                                                .map(|attr| EventAttribute {\n+                                                    key: attr.key,\n+                                                    value: attr.value,\n+                                                    index: attr.index,\n+                                                })\n+                                                .collect(),\n+                                        }) else {\n+                                            continue;\n+                                        };\n+                                        let ibc_event = my_event.unwrap();\n+                                        self.handle_ibc_event(ibc_event, &shared_map, 13).await;\n+                                    }\n+                                }\n+                                _ => {\n+                                    tracing::error!(\"Unhandled event type: {:?}\", event);\n+                                }\n+                            }\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\"Error while receiving event: {:?}\", e);\n+                        }\n+                    }\n+                },\n+                else => break,\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+\n+impl IbcTransfer for Ethereum {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        let mut rng = StdRng::from_entropy();\n+        let index = rng.gen_range(0..self.relays.len()); // Select a random index\n+\n+        let relay = &self.relays[index];\n+        let signer_middleware = &self.signer_middlewares[index];\n+        let msg_sender = self.msg_senders[index];\n+\n+        let denom_address = match ethers::types::H160::from_str(&denom) {\n+            Ok(address) => address,\n+            Err(_) => {\n+                let formatted_denom = format!(\n+                    \"{}/{}/{}\",\n+                    self.ucs01_contract.to_lowercase(),\n+                    destination_channel,\n+                    denom\n+                );\n+\n+                relay\n+                    .get_denom_address(\n+                        destination_channel.clone().to_string(),\n+                        formatted_denom.clone(),\n+                    )\n+                    .call()\n+                    .await\n+                    .unwrap()\n+            }\n+        };\n+\n+        if denom_address == ethers::types::H160::zero() {\n+            tracing::warn!(\"Denom address not found\");\n+            return;\n+        }\n+        let erc_contract = erc20::ERC20::new(denom_address, signer_middleware.clone());\n+        let balance = erc_contract.balance_of(msg_sender).await.unwrap();\n+        tracing::info!(\"ETH Token balance: {}. Sending amount: {}\", balance, amount);\n+        if balance < amount.into() {\n+            tracing::warn!(\"Insufficient balance\");\n+            return;\n+        }\n+\n+        let allowance = erc_contract\n+            .allowance(msg_sender, self.relay_addr)\n+            .await\n+            .unwrap();\n+        if allowance < amount.into() {\n+            let _ = erc_contract\n+                .approve(self.relay_addr, (U256::MAX / U256::from(2)).into())\n+                .send()\n+                .await;\n+            tracing::info!(\"We can not transfer after approve, returning now.\");\n+            // return;\n+        }\n+\n+        let mut debug_msg;\n+        match protocol {\n+            Protocol::Ucs01 {\n+                receivers,\n+                contract,\n+            } => {\n+                let mut rng = StdRng::from_entropy();\n+                let index = rng.gen_range(0..receivers.len()); // Select a random index\n+\n+                let receiver = &receivers[index];\n+\n+                let mut final_receiver = receiver.encode_to_vec().into();\n+\n+                if memo.is_empty() {\n+                    let (_hrp, data, _variant) =\n+                        bech32::decode(&receiver).expect(\"Invalid Bech32 address\");\n+\n+                    let bytes: Vec<u8> =\n+                        Vec::<u8>::from_base32(&data).expect(\"Invalid base32 data\");\n+\n+                    final_receiver = bytes.into();\n+                }\n+\n+                debug_msg = format!(\n+                    \"[Ethereum] -> Sent IBC transfer. memo: {}. Sending denom: {}. To: {}. Amount: {}, contract: {}\",\n+                    memo,\n+                    denom,\n+                    final_receiver,\n+                    amount,\n+                    contract\n+                );\n+                let _tx_rcp: Option<ethers::types::TransactionReceipt> = match relay\n+                    .send(\n+                        destination_channel.clone().to_string(),\n+                        final_receiver,\n+                        [LocalToken {\n+                            denom: denom_address,\n+                            amount: amount as u128,\n+                        }]\n+                        .into(),\n+                        memo,\n+                        (Height {\n+                            revision_number: 0,\n+                            revision_height: 0,\n+                        })\n+                        .into(),\n+                        u64::MAX,\n+                    )\n+                    .send()\n+                    .await\n+                {\n+                    Ok(response) => match response.await {\n+                        Ok(receipt) => Some(receipt.expect(\"Failed to get transaction receipt\")),\n+                        Err(e) => {\n+                            tracing::error!(\"Failed to get transaction receipt: {:?}\", e);\n+                            return;\n+                        }\n+                    },\n+                    Err(ethers::contract::ContractError::MiddlewareError { e }) => {\n+                        if e.to_string().contains(\"replacement transaction underprice\") {\n+                            tracing::warn!(\"Replacement transaction underprice.\");\n+                        } else {\n+                            tracing::error!(\n+                                \"Failed to send transaction eth->union: {:?}\",\n+                                e.to_string()\n+                            );\n+                        }\n+                        return;\n+                    }\n+                    Err(e) => {\n+                        tracing::error!(\"Failed to send transaction eth->union: {:?}\", e);\n+                        return;\n+                    }\n+                };\n+                let tx_hash = _tx_rcp.unwrap().transaction_hash.to_string();\n+                debug_msg.push_str(&format!(\" Tx Hash: {:?}\", tx_hash));\n+\n+                tracing::info!(debug_msg);\n+            }\n+            Protocol::Ics20 {\n+                receivers: _,\n+                module: _,\n+            } => {\n+                unimplemented!(\"Ics20 protocol not implemented\"); // TODO: Do we even have this case?\n+            }\n+        }\n+    }\n+}\n+\n+impl Ethereum {\n+    pub async fn new(config: EthereumConfig) -> Self {\n+        let ethereum_rpc = EthereumRpc {\n+            provider: Arc::new(Provider::new(\n+                Ws::connect(config.eth_rpc_api.clone()).await.unwrap(),\n+            )),\n+            ibc_handler_address: config.ibc_handler_address,\n+        };\n+\n+        let mut relays = Vec::new();\n+        let mut signers_middleware = Vec::new();\n+        let mut msg_senders = Vec::new();\n+\n+        let (relay_addr, ucs01_contract) = match config.transfer_module {\n+            TransferModule::Contract { ref address } => {\n+                let relay_addr: Address = address.parse().expect(\"Invalid contract address\");\n+                (relay_addr, address.clone())\n+            }\n+            TransferModule::Native => {\n+                panic!(\"Native transfer module is not supported in this context\")\n+            }\n+        };\n+        for signer in config.signers.clone() {\n+            let signing_key: ecdsa::SigningKey = signer.value();\n+            let address_of_privkey: ethers::types::H160 = secret_key_to_address(&signing_key);\n+            tracing::info!(\"address: {:?}\", address_of_privkey);\n+\n+            let provider: Arc<Provider<Ws>> = ethereum_rpc.provider.clone();\n+\n+            let chain_id = provider\n+                .get_chainid()\n+                .await\n+                .expect(\"Failed to get chain ID\")\n+                .as_u64();\n+            let wallet = LocalWallet::new_with_signer(signing_key, address_of_privkey, chain_id);\n+\n+            let signer_middleware = Arc::new(SignerMiddleware::new(\n+                NonceManagerMiddleware::new(provider.clone(), address_of_privkey),\n+                wallet.clone(),\n+            ));\n+\n+            let relay = UCS01Relay::new(relay_addr, signer_middleware.clone());\n+\n+            relays.push(relay);\n+            signers_middleware.push(signer_middleware);\n+            msg_senders.push(address_of_privkey);\n+        }\n+\n+        Ethereum {\n+            rpc: ethereum_rpc,\n+            relays,\n+            signer_middlewares: signers_middleware,\n+            ucs01_contract,\n+            msg_senders,\n+            relay_addr,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Cosmos {\n+    pub chain: chain_utils::cosmos::Cosmos,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Union {\n+    pub chain: chain_utils::union::Union,\n+}\n+\n+impl IbcTransfer for Cosmos {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        self.chain.keyring.with(|signer| async move {\n+            let mut debug_msg;\n+            let transfer_msg = match protocol {\n+                Protocol::Ics20 { receivers, module } => {\n+                    let mut rng = StdRng::from_entropy();\n+                    let index = rng.gen_range(0..receivers.len()); // Select a random index\n+\n+                    let receiver = &receivers[index];\n+\n+                    let msg = MsgTransfer {\n+                        source_port: \"transfer\".into(),\n+                        source_channel: destination_channel.to_string(),\n+                        token: Some(\n+                            (Coin {\n+                                denom: denom.to_string(),\n+                                amount: amount as u128,\n+                            }).into()\n+                        ),\n+                        sender: signer.to_string(),\n+                        receiver: receiver.to_string(),\n+                        timeout_height: None,\n+                        timeout_timestamp: u64::MAX / 2,\n+                        memo: memo.clone(),\n+                    };\n+\n+                    debug_msg = format!(\n+                        \"[Cosmos Ics20] -> SENT IBC transfer from: {}. memo: {}. denom: {}. To: {}. Amount: {}, module: {:?}\",\n+                        signer.to_string(),\n+                        memo,\n+                        denom,\n+                        receiver,\n+                        amount,\n+                        module\n+                    );\n+\n+                    Any {\n+                        type_url: \"/ibc.applications.transfer.v1.MsgTransfer\".to_string(),",
        "comment_created_at": "2024-06-22T13:39:39+00:00",
        "comment_author": "benluelo",
        "comment_body": "we should probably also add this type to unionlabs, but don't worry about that for this PR",
        "pr_file_module": null
      }
    ]
  }
]