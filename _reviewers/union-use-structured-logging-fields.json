[
  {
    "discussion_id": "2049594107",
    "pr_number": 4369,
    "pr_file": "hubble/src/abi_fetcher/client.rs",
    "created_at": "2025-04-17T20:21:21+00:00",
    "commented_code": "+use std::{\n+    fs::{self, File},\n+    io::Read,\n+    process::Command,\n+};\n+\n+use serde_json::{json, Value};\n+use tempfile::tempdir;\n+use thiserror::Error;\n+use tracing::{debug, info, trace};\n+\n+#[derive(Debug, Error)]\n+pub enum BuildError {\n+    #[error(\"Empty git hash provided\")]\n+    EmptyGitHash,\n+\n+    #[error(\"Failed to fetch commit data: {0}\")]\n+    FetchError(#[from] reqwest::Error),\n+\n+    #[error(\"Command execution failed: {0}\")]\n+    CommandError(#[from] std::io::Error),\n+\n+    #[error(\"Nix build failed: {0}\")]\n+    NixBuildFailed(String),\n+\n+    #[error(\"Result directory not found\")]\n+    ResultDirNotFound(String),\n+\n+    #[error(\"Failed to read directory: {0}\")]\n+    DirReadError(String),\n+\n+    #[error(\"Failed to read JSON file at {path}: {error}\")]\n+    FileReadError { path: String, error: std::io::Error },\n+\n+    #[error(\"Failed to parse JSON from {path}: {error}\")]\n+    JsonParseError {\n+        path: String,\n+        error: serde_json::Error,\n+    },\n+}\n+\n+pub type Result<T> = std::result::Result<T, BuildError>;\n+\n+#[derive(Debug)]\n+pub struct AbiResult {\n+    pub command: String,\n+    pub data: Value,\n+    pub log: String,\n+}\n+\n+impl AbiResult {\n+    pub fn meta(&self) -> Value {\n+        json!({\n+            \"command\": self.command,\n+            \"logs\": self.log,\n+        })\n+    }\n+}\n+\n+pub async fn build_abis_with_commit_hash(commit_hash: &Vec<u8>) -> Result<AbiResult> {\n+    // Validate git_hash\n+    if commit_hash.is_empty() {\n+        return Err(BuildError::EmptyGitHash);\n+    }\n+\n+    // Declare repository details\n+    let repo_owner = \"unionlabs\";\n+    let repo_name = \"union\";\n+\n+    // determine nix binary location. hubble runs in a systemd service that doesn't\n+    // have nix on the path. it is configured in NIX_BIN, but defaults the\n+    // current-system (assuming we're running in nixos) when running locally.\n+    let nix_bin =\n+        std::env::var(\"NIX_BIN\").unwrap_or_else(|_| \"/run/current-system/sw/bin/nix\".to_string());\n+    trace!(\"nix bin: {nix_bin}\");\n+\n+    let nix_build_argument = format!(\n+        \"github:{}/{}/{}#packages.x86_64-linux.hubble-abis\",\n+        repo_owner,\n+        repo_name,\n+        hex::encode(commit_hash)\n+    );\n+    trace!(\"nix build argument: {nix_build_argument}\");\n+\n+    let nix_command = format!(\"{nix_bin} build \\\"{nix_build_argument}\\\"\");\n+    trace!(\"nix command: {nix_command}\");\n+\n+    let work_dir = tempdir()?;\n+    trace!(\"work dir: {work_dir:?}\");\n+\n+    let output = Command::new(nix_bin)\n+        .arg(\"build\")\n+        .arg(nix_build_argument)\n+        .current_dir(&work_dir)\n+        .output()\n+        .map_err(BuildError::CommandError)?;\n+\n+    info!(\"abi build: {} => {}\", nix_command, output.status);\n+\n+    let mut log = String::new();\n+    log.push_str(&String::from_utf8_lossy(&output.stdout));\n+    log.push_str(&String::from_utf8_lossy(&output.stderr));\n+\n+    debug!(\"abi build log: \n-----------\n{}\n-----------\", log);",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2049594107",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4369,
        "pr_file": "hubble/src/abi_fetcher/client.rs",
        "discussion_id": "2049594107",
        "commented_code": "@@ -0,0 +1,182 @@\n+use std::{\n+    fs::{self, File},\n+    io::Read,\n+    process::Command,\n+};\n+\n+use serde_json::{json, Value};\n+use tempfile::tempdir;\n+use thiserror::Error;\n+use tracing::{debug, info, trace};\n+\n+#[derive(Debug, Error)]\n+pub enum BuildError {\n+    #[error(\"Empty git hash provided\")]\n+    EmptyGitHash,\n+\n+    #[error(\"Failed to fetch commit data: {0}\")]\n+    FetchError(#[from] reqwest::Error),\n+\n+    #[error(\"Command execution failed: {0}\")]\n+    CommandError(#[from] std::io::Error),\n+\n+    #[error(\"Nix build failed: {0}\")]\n+    NixBuildFailed(String),\n+\n+    #[error(\"Result directory not found\")]\n+    ResultDirNotFound(String),\n+\n+    #[error(\"Failed to read directory: {0}\")]\n+    DirReadError(String),\n+\n+    #[error(\"Failed to read JSON file at {path}: {error}\")]\n+    FileReadError { path: String, error: std::io::Error },\n+\n+    #[error(\"Failed to parse JSON from {path}: {error}\")]\n+    JsonParseError {\n+        path: String,\n+        error: serde_json::Error,\n+    },\n+}\n+\n+pub type Result<T> = std::result::Result<T, BuildError>;\n+\n+#[derive(Debug)]\n+pub struct AbiResult {\n+    pub command: String,\n+    pub data: Value,\n+    pub log: String,\n+}\n+\n+impl AbiResult {\n+    pub fn meta(&self) -> Value {\n+        json!({\n+            \"command\": self.command,\n+            \"logs\": self.log,\n+        })\n+    }\n+}\n+\n+pub async fn build_abis_with_commit_hash(commit_hash: &Vec<u8>) -> Result<AbiResult> {\n+    // Validate git_hash\n+    if commit_hash.is_empty() {\n+        return Err(BuildError::EmptyGitHash);\n+    }\n+\n+    // Declare repository details\n+    let repo_owner = \"unionlabs\";\n+    let repo_name = \"union\";\n+\n+    // determine nix binary location. hubble runs in a systemd service that doesn't\n+    // have nix on the path. it is configured in NIX_BIN, but defaults the\n+    // current-system (assuming we're running in nixos) when running locally.\n+    let nix_bin =\n+        std::env::var(\"NIX_BIN\").unwrap_or_else(|_| \"/run/current-system/sw/bin/nix\".to_string());\n+    trace!(\"nix bin: {nix_bin}\");\n+\n+    let nix_build_argument = format!(\n+        \"github:{}/{}/{}#packages.x86_64-linux.hubble-abis\",\n+        repo_owner,\n+        repo_name,\n+        hex::encode(commit_hash)\n+    );\n+    trace!(\"nix build argument: {nix_build_argument}\");\n+\n+    let nix_command = format!(\"{nix_bin} build \\\"{nix_build_argument}\\\"\");\n+    trace!(\"nix command: {nix_command}\");\n+\n+    let work_dir = tempdir()?;\n+    trace!(\"work dir: {work_dir:?}\");\n+\n+    let output = Command::new(nix_bin)\n+        .arg(\"build\")\n+        .arg(nix_build_argument)\n+        .current_dir(&work_dir)\n+        .output()\n+        .map_err(BuildError::CommandError)?;\n+\n+    info!(\"abi build: {} => {}\", nix_command, output.status);\n+\n+    let mut log = String::new();\n+    log.push_str(&String::from_utf8_lossy(&output.stdout));\n+    log.push_str(&String::from_utf8_lossy(&output.stderr));\n+\n+    debug!(\"abi build log: \\n-----------\\n{}\\n-----------\", log);",
        "comment_created_at": "2025-04-17T20:21:21+00:00",
        "comment_author": "benluelo",
        "comment_body": "nit: in general, tracing logs should be single-line and not contain newlines. i would recommend putting the stdout and stderr as log fields (i.e. something like `debug!(%output.stdout, %output.stderr, \"abi build log\", log);`)",
        "pr_file_module": null
      },
      {
        "comment_id": "2050428689",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4369,
        "pr_file": "hubble/src/abi_fetcher/client.rs",
        "discussion_id": "2049594107",
        "commented_code": "@@ -0,0 +1,182 @@\n+use std::{\n+    fs::{self, File},\n+    io::Read,\n+    process::Command,\n+};\n+\n+use serde_json::{json, Value};\n+use tempfile::tempdir;\n+use thiserror::Error;\n+use tracing::{debug, info, trace};\n+\n+#[derive(Debug, Error)]\n+pub enum BuildError {\n+    #[error(\"Empty git hash provided\")]\n+    EmptyGitHash,\n+\n+    #[error(\"Failed to fetch commit data: {0}\")]\n+    FetchError(#[from] reqwest::Error),\n+\n+    #[error(\"Command execution failed: {0}\")]\n+    CommandError(#[from] std::io::Error),\n+\n+    #[error(\"Nix build failed: {0}\")]\n+    NixBuildFailed(String),\n+\n+    #[error(\"Result directory not found\")]\n+    ResultDirNotFound(String),\n+\n+    #[error(\"Failed to read directory: {0}\")]\n+    DirReadError(String),\n+\n+    #[error(\"Failed to read JSON file at {path}: {error}\")]\n+    FileReadError { path: String, error: std::io::Error },\n+\n+    #[error(\"Failed to parse JSON from {path}: {error}\")]\n+    JsonParseError {\n+        path: String,\n+        error: serde_json::Error,\n+    },\n+}\n+\n+pub type Result<T> = std::result::Result<T, BuildError>;\n+\n+#[derive(Debug)]\n+pub struct AbiResult {\n+    pub command: String,\n+    pub data: Value,\n+    pub log: String,\n+}\n+\n+impl AbiResult {\n+    pub fn meta(&self) -> Value {\n+        json!({\n+            \"command\": self.command,\n+            \"logs\": self.log,\n+        })\n+    }\n+}\n+\n+pub async fn build_abis_with_commit_hash(commit_hash: &Vec<u8>) -> Result<AbiResult> {\n+    // Validate git_hash\n+    if commit_hash.is_empty() {\n+        return Err(BuildError::EmptyGitHash);\n+    }\n+\n+    // Declare repository details\n+    let repo_owner = \"unionlabs\";\n+    let repo_name = \"union\";\n+\n+    // determine nix binary location. hubble runs in a systemd service that doesn't\n+    // have nix on the path. it is configured in NIX_BIN, but defaults the\n+    // current-system (assuming we're running in nixos) when running locally.\n+    let nix_bin =\n+        std::env::var(\"NIX_BIN\").unwrap_or_else(|_| \"/run/current-system/sw/bin/nix\".to_string());\n+    trace!(\"nix bin: {nix_bin}\");\n+\n+    let nix_build_argument = format!(\n+        \"github:{}/{}/{}#packages.x86_64-linux.hubble-abis\",\n+        repo_owner,\n+        repo_name,\n+        hex::encode(commit_hash)\n+    );\n+    trace!(\"nix build argument: {nix_build_argument}\");\n+\n+    let nix_command = format!(\"{nix_bin} build \\\"{nix_build_argument}\\\"\");\n+    trace!(\"nix command: {nix_command}\");\n+\n+    let work_dir = tempdir()?;\n+    trace!(\"work dir: {work_dir:?}\");\n+\n+    let output = Command::new(nix_bin)\n+        .arg(\"build\")\n+        .arg(nix_build_argument)\n+        .current_dir(&work_dir)\n+        .output()\n+        .map_err(BuildError::CommandError)?;\n+\n+    info!(\"abi build: {} => {}\", nix_command, output.status);\n+\n+    let mut log = String::new();\n+    log.push_str(&String::from_utf8_lossy(&output.stdout));\n+    log.push_str(&String::from_utf8_lossy(&output.stderr));\n+\n+    debug!(\"abi build log: \\n-----------\\n{}\\n-----------\", log);",
        "comment_created_at": "2025-04-18T09:46:53+00:00",
        "comment_author": "qlp",
        "comment_body": "\ud83d\udc4d",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1649697977",
    "pr_number": 2127,
    "pr_file": "sentinel/src/chains.rs",
    "created_at": "2024-06-22T13:20:49+00:00",
    "commented_code": "+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1649697977",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2127,
        "pr_file": "sentinel/src/chains.rs",
        "discussion_id": "1649697977",
        "commented_code": "@@ -0,0 +1,997 @@\n+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );",
        "comment_created_at": "2024-06-22T13:20:49+00:00",
        "comment_author": "benluelo",
        "comment_body": "in general, prefer to use tracing fields as opposed to formatting strings: https://docs.rs/tracing/latest/tracing/index.html#recording-fields\r\n\r\nthis function is a good example: https://github.com/unionlabs/union/blob/main/lib/relay-message/src/event.rs#L59",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1649698412",
    "pr_number": 2127,
    "pr_file": "sentinel/src/chains.rs",
    "created_at": "2024-06-22T13:23:10+00:00",
    "commented_code": "+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1649698412",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2127,
        "pr_file": "sentinel/src/chains.rs",
        "discussion_id": "1649698412",
        "commented_code": "@@ -0,0 +1,997 @@\n+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);",
        "comment_created_at": "2024-06-22T13:23:10+00:00",
        "comment_author": "benluelo",
        "comment_body": "general comment about all logs: prefer to keep all logs lowercased for consistency",
        "pr_file_module": null
      },
      {
        "comment_id": "1649698477",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2127,
        "pr_file": "sentinel/src/chains.rs",
        "discussion_id": "1649698412",
        "commented_code": "@@ -0,0 +1,997 @@\n+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);",
        "comment_created_at": "2024-06-22T13:23:42+00:00",
        "comment_author": "benluelo",
        "comment_body": "you should also include chain id here as a field, and make latest_block a field as well",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1649699683",
    "pr_number": 2127,
    "pr_file": "sentinel/src/chains.rs",
    "created_at": "2024-06-22T13:31:19+00:00",
    "commented_code": "+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);\n+            // Update the filter to fetch logs from the latest block processed + 1\n+            let filter = Filter::new()\n+                .address(ethers::types::H160::from(self.rpc.ibc_handler_address))\n+                .from_block(latest_block)\n+                .to_block(latest_block); //TODO(caglankaan): How can we make here subscribe like instead of latest_block\n+\n+            let logs = provider.get_logs(&filter).await.unwrap();\n+\n+            let logs_clone = logs.clone(); // Clone logs for processing\n+            futures::stream::iter(logs_clone)\n+                .filter_map(|log| async move {\n+                    let raw_log = RawLog {\n+                        topics: log.topics.clone(),\n+                        data: log.data.clone().to_vec(),\n+                    };\n+\n+                    Some(raw_log)\n+                })\n+                .for_each_concurrent(None, |raw_log| async move {\n+                    let ibc_event =\n+                        ibchandler_events_to_ibc_event(raw_log, &self.rpc, latest_block).await;\n+\n+                    if let Some(ibc_event) = ibc_event {\n+                        self.handle_ibc_event(ibc_event, &shared_map, latest_block)\n+                            .await;\n+                    }\n+                })\n+                .await;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+impl IbcListen for Cosmos {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        tracing::info!(\"Listening to Cosmos chain events\");\n+        let mut subs = self\n+            .chain\n+            .tm_client\n+            .subscribe(tendermint_rpc::query::EventType::Tx.into())\n+            .await\n+            .unwrap();\n+        loop {\n+            tokio::select! {\n+                Some(event_result) = subs.next() => {\n+                    match event_result {\n+                        Ok(event) => {\n+                            // tracing::info!(\"Received event_result: {:?}\", event.clone());\n+                            if let Some(ref events) = event.events {\n+                                if let Some(heights) = events.get(\"tx.height\") {\n+                                    if let Some(height) = heights.first() {\n+                                        let block_number: u64 = height.parse().expect(\"Failed to parse block number\");\n+                                        tracing::info!(\"Fetched cosmos Block number: {}\", block_number);\n+                                    }\n+                                }\n+                            }\n+\n+                            match event.data {\n+                                EventData::Tx { tx_result, .. } => {\n+                                    for event in tx_result.result.events {\n+                                        // tracing::info!(\"Received event: {:?}\", event.clone());\n+                                        let Some(my_event) = IbcEvent::try_from_tendermint_event(TendermintEvent {\n+                                            ty: event.kind,\n+                                            attributes: event.attributes\n+                                                .into_iter()\n+                                                .map(|attr| EventAttribute {\n+                                                    key: attr.key,\n+                                                    value: attr.value,\n+                                                    index: attr.index,\n+                                                })\n+                                                .collect(),\n+                                        }) else {\n+                                            continue;\n+                                        };\n+                                        let ibc_event = my_event.unwrap();\n+                                        self.handle_ibc_event(ibc_event, &shared_map, 13).await;\n+                                    }\n+                                }\n+                                _ => {\n+                                    tracing::error!(\"Unhandled event type: {:?}\", event);\n+                                }\n+                            }\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\"Error while receiving event: {:?}\", e);\n+                        }\n+                    }\n+                },\n+                else => break,\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+\n+impl IbcTransfer for Ethereum {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        let mut rng = StdRng::from_entropy();\n+        let index = rng.gen_range(0..self.relays.len()); // Select a random index\n+\n+        let relay = &self.relays[index];\n+        let signer_middleware = &self.signer_middlewares[index];\n+        let msg_sender = self.msg_senders[index];\n+\n+        let denom_address = match ethers::types::H160::from_str(&denom) {\n+            Ok(address) => address,\n+            Err(_) => {\n+                let formatted_denom = format!(\n+                    \"{}/{}/{}\",\n+                    self.ucs01_contract.to_lowercase(),\n+                    destination_channel,\n+                    denom\n+                );\n+\n+                relay\n+                    .get_denom_address(\n+                        destination_channel.clone().to_string(),\n+                        formatted_denom.clone(),\n+                    )\n+                    .call()\n+                    .await\n+                    .unwrap()\n+            }\n+        };\n+\n+        if denom_address == ethers::types::H160::zero() {\n+            tracing::warn!(\"Denom address not found\");\n+            return;\n+        }\n+        let erc_contract = erc20::ERC20::new(denom_address, signer_middleware.clone());\n+        let balance = erc_contract.balance_of(msg_sender).await.unwrap();\n+        tracing::info!(\"ETH Token balance: {}. Sending amount: {}\", balance, amount);\n+        if balance < amount.into() {\n+            tracing::warn!(\"Insufficient balance\");",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1649699683",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2127,
        "pr_file": "sentinel/src/chains.rs",
        "discussion_id": "1649699683",
        "commented_code": "@@ -0,0 +1,997 @@\n+use std::{collections::HashMap, str::FromStr, sync::Arc, time::Duration};\n+\n+use bech32::FromBase32;\n+use chain_utils::{\n+    cosmos_sdk::{BroadcastTxCommitError, CosmosSdkChainExt},\n+    ethereum::{EthereumExecutionRpcs, EthereumExecutionRpcsExt, IBCHandlerEvents},\n+};\n+use chrono::Utc;\n+use contracts::{\n+    erc20,\n+    ibc_packet::IBCPacketEvents,\n+    ucs01_relay::{LocalToken, UCS01Relay},\n+};\n+use ethers::{\n+    abi::RawLog,\n+    contract::EthLogDecode,\n+    core::k256::ecdsa,\n+    middleware::{NonceManagerMiddleware, SignerMiddleware},\n+    providers::{Middleware, Provider, Ws},\n+    signers::LocalWallet,\n+    types::{Address, Filter},\n+    utils::secret_key_to_address,\n+};\n+use futures::StreamExt;\n+use hex::{self, encode as hex_encode};\n+use prost::Message;\n+use protos::{google::protobuf::Any, ibc::applications::transfer::v1::MsgTransfer};\n+use rand::{rngs::StdRng, Rng, SeedableRng};\n+use serde::{Deserialize, Serialize};\n+use tendermint_rpc::{event::EventData, SubscriptionClient};\n+use ucs01_relay::msg::{ExecuteMsg, TransferMsg};\n+use ucs01_relay_api::types::{Ics20Ack, JsonWasm, Ucs01Ack};\n+use unionlabs::{\n+    cosmos::base::coin::Coin,\n+    cosmwasm::wasm::msg_execute_contract::MsgExecuteContract,\n+    encoding::{self, DecodeAs},\n+    events::{AcknowledgePacket, RecvPacket, SendPacket, WriteAcknowledgement},\n+    google::protobuf::any,\n+    hash::H160,\n+    ibc::core::{channel::channel::Channel, client::height::Height},\n+    id::{ChannelId, ClientId},\n+    tendermint::abci::{event::Event as TendermintEvent, event_attribute::EventAttribute},\n+    uint::U256,\n+    validated::ValidateT,\n+};\n+\n+use crate::{\n+    config::{CosmosConfig, EthereumConfig, TransferModule},\n+    context::SharedMap,\n+};\n+pub type IbcEvent = unionlabs::events::IbcEvent<ClientId, String, ClientId>;\n+\n+pub trait IbcTransfer: Send + Sync {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    );\n+}\n+\n+pub trait IbcListen: Send + Sync {\n+    async fn listen(&self, shared_map: &SharedMap);\n+\n+    // TODO(caglankaan): How can i know the protocol type here? On listen we don't know what is the destination chain\n+    // It can be anything, if i am listening on union since there is only one listener for union there could be 2 different\n+    // chains which are sending request to me 1- ethereum with ucs01 and 2- osmosis with ics20 so i am not sure how can i know\n+    // the protocol here. For know i'll try bruteforce but it's not a good solution.\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, //protocol: Protocol\n+    ) -> bool {\n+        // match protocol {\n+        //     Protocol::Ics20 => {\n+        //         let val = Ics20Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap();\n+        //         match val {\n+        //             Ics20Ack::Result(_) => {\n+        //                 return true;\n+        //             }\n+        //             Ics20Ack::Error(_) => {\n+        //                 return false;\n+        //             }\n+        //         }\n+        //     }\n+        //     Protocol::Ucs01 => {\n+        //         return (\n+        //             Ucs01Ack::try_from(cosmwasm_std::Binary::from(ack_hex)).unwrap() ==\n+        //             Ucs01Ack::Success\n+        //         );\n+        //     }\n+        //     _ => {\n+        //         tracing::error!(\"Unknown protocol {:?} -> {:?}\", protocol, ack_hex);\n+        //         return false;\n+        //     }\n+        // }\n+\n+        // Try to decode as Ics20Ack first;\n+        if let Ok(val) =\n+            Ics20Ack::decode_as::<JsonWasm>(cosmwasm_std::Binary::from(ack_hex.clone()).as_slice())\n+        {\n+            match val {\n+                Ics20Ack::Result(_) => {\n+                    tracing::info!(\"Ics20Ack::Result successfully decoded.\");\n+                    return true;\n+                }\n+                Ics20Ack::Error(_) => {\n+                    tracing::warn!(\"Ics20Ack::Result failed decode.\");\n+                }\n+            }\n+        }\n+\n+        if let Ok(val) = Ucs01Ack::decode_as::<encoding::EthAbi>(\n+            cosmwasm_std::Binary::from(ack_hex.clone()).as_slice(),\n+        ) {\n+            tracing::info!(\n+                \"Ucs01Ack:: successfully decoded: {}\",\n+                val == Ucs01Ack::Success\n+            );\n+            return val == Ucs01Ack::Success;\n+        } else {\n+            tracing::warn!(\"Failed to decode ack_hex: {:?}\", ack_hex);\n+            return false;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    );\n+\n+    fn handle_ibc_event_boxed<'a>(\n+        &'a self,\n+        ibc_event: IbcEvent,\n+        shared_map: &'a SharedMap,\n+        _block_number: u64,\n+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'a>> {\n+        Box::pin(async move {\n+            let (packet_sequence, key) = match &ibc_event {\n+                IbcEvent::SendPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::RecvPacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::WriteAcknowledgement(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                IbcEvent::AcknowledgePacket(e) => (\n+                    e.packet_sequence,\n+                    format!(\"{}->{}\", e.packet_src_channel, e.packet_dst_channel),\n+                ),\n+                // Handle other events if necessary,\n+                _ => {\n+                    return;\n+                }\n+            };\n+            tracing::info!(\"packet_sequence: {:?}, key: {:?}\", packet_sequence, key);\n+\n+            let sequence = packet_sequence.get() as i32;\n+            {\n+                let mut map = shared_map.lock().await;\n+\n+                let entry = map.entry(key.clone()).or_insert_with(HashMap::new);\n+\n+                let sequence_entry = entry.entry(sequence).or_insert_with(|| {\n+                    let mut event_map = HashMap::new();\n+                    event_map.insert(0, (false, None));\n+                    event_map.insert(1, (false, None));\n+                    event_map.insert(2, (false, None));\n+                    event_map.insert(3, (false, None));\n+                    event_map\n+                });\n+                match ibc_event {\n+                    IbcEvent::SendPacket(_) => {\n+                        sequence_entry.insert(0, (true, Some(Utc::now())));\n+                        tracing::info!(\n+                            \"SendPacket event recorded for sequence {}. key: {}\",\n+                            sequence,\n+                            key\n+                        );\n+                    }\n+                    IbcEvent::RecvPacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(1, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"RecvPacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                        }\n+                    }\n+                    IbcEvent::WriteAcknowledgement(ref e) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0 {\n+                            tracing::warn!(\n+                                \"RecvPacket event received without SendPacket for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            if self\n+                                .write_handler_packet_ack_hex_controller(e.packet_ack_hex.clone())\n+                            {\n+                                sequence_entry.insert(2, (true, Some(Utc::now())));\n+                                tracing::info!(\n+                                    \"WriteAcknowledgement event recorded for sequence {}. key: {}\",\n+                                    sequence,\n+                                    key\n+                                );\n+                            } else {\n+                                tracing::error!(\n+                                    \"[SENTINEL ERROR] WriteAcknowledgement indicates failure. Sequence: {}, packet_hack_hex: {:?}, key: {}\",\n+                                    sequence,\n+                                    e.packet_ack_hex.clone(),\n+                                    key\n+                                );\n+                                // Here remove it from the map\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    IbcEvent::AcknowledgePacket(_) => {\n+                        if !sequence_entry.get(&0).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&1).unwrap_or(&(false, None)).0\n+                            || !sequence_entry.get(&2).unwrap_or(&(false, None)).0\n+                        {\n+                            tracing::warn!(\n+                                \"AcknowledgePacket event received out of order for sequence: {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+                            entry.remove(&sequence);\n+                        } else {\n+                            sequence_entry.insert(3, (true, Some(Utc::now())));\n+                            tracing::info!(\n+                                \"AcknowledgePacket event recorded for sequence {}. key: {}\",\n+                                sequence,\n+                                key\n+                            );\n+\n+                            if sequence_entry.values().all(|&(v, _)| v) {\n+                                tracing::info!(\n+                                    \"All events completed for sequence {}: {:?}\",\n+                                    sequence,\n+                                    sequence_entry\n+                                );\n+                                entry.remove(&sequence);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return;\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub enum Protocol {\n+    Ics20 {\n+        receivers: Vec<String>, // Changed to Vec<String>\n+        module: TransferModule,\n+    },\n+    Ucs01 {\n+        receivers: Vec<String>, //Vec<Vec<u8>>,\n+        contract: String,\n+    },\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum Chain {\n+    Ethereum(Ethereum),\n+    Cosmos(Cosmos),\n+}\n+\n+impl IbcListen for Chain {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum.listen(shared_map).await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos.listen(shared_map).await;\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .handle_ibc_event(ibc_event, shared_map, block_number)\n+                    .await;\n+            }\n+        }\n+    }\n+\n+    fn write_handler_packet_ack_hex_controller(\n+        &self,\n+        ack_hex: Vec<u8>, // protocol: Protocol // TODO: Add it after find a way\n+    ) -> bool {\n+        IbcListen::write_handler_packet_ack_hex_controller(self, ack_hex /* , protocol*/)\n+    }\n+}\n+\n+impl IbcTransfer for Chain {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        match self {\n+            Chain::Ethereum(ethereum) => {\n+                ethereum\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+            Chain::Cosmos(cosmos) => {\n+                cosmos\n+                    .send_ibc_transfer(protocol, channel, destination_channel, denom, amount, memo)\n+                    .await;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Ethereum {\n+    pub rpc: EthereumRpc,\n+    pub relays:\n+        Vec<UCS01Relay<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub signer_middlewares:\n+        Vec<Arc<SignerMiddleware<NonceManagerMiddleware<Arc<Provider<Ws>>>, LocalWallet>>>,\n+    pub ucs01_contract: String,\n+    pub msg_senders: Vec<ethers::types::H160>,\n+    pub relay_addr: ethers::types::H160,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct EthereumRpc {\n+    pub provider: Arc<Provider<Ws>>,\n+    pub ibc_handler_address: H160,\n+}\n+\n+impl EthereumExecutionRpcs for EthereumRpc {\n+    fn provider(&self) -> Arc<Provider<Ws>> {\n+        self.provider.clone()\n+    }\n+\n+    fn ibc_handler_address(&self) -> H160 {\n+        self.ibc_handler_address\n+    }\n+}\n+\n+impl IbcListen for Ethereum {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        let mut latest_checked_block = 0;\n+        loop {\n+            let provider = self.rpc.provider.clone();\n+\n+            let latest_block = provider.get_block_number().await.unwrap().as_u64();\n+            if latest_checked_block == latest_block {\n+                tokio::time::sleep(Duration::from_secs(5)).await;\n+                continue;\n+            }\n+            latest_checked_block = latest_block;\n+            tracing::info!(\"Fetched Ethereum latest_block {:?}.\", latest_block);\n+            // Update the filter to fetch logs from the latest block processed + 1\n+            let filter = Filter::new()\n+                .address(ethers::types::H160::from(self.rpc.ibc_handler_address))\n+                .from_block(latest_block)\n+                .to_block(latest_block); //TODO(caglankaan): How can we make here subscribe like instead of latest_block\n+\n+            let logs = provider.get_logs(&filter).await.unwrap();\n+\n+            let logs_clone = logs.clone(); // Clone logs for processing\n+            futures::stream::iter(logs_clone)\n+                .filter_map(|log| async move {\n+                    let raw_log = RawLog {\n+                        topics: log.topics.clone(),\n+                        data: log.data.clone().to_vec(),\n+                    };\n+\n+                    Some(raw_log)\n+                })\n+                .for_each_concurrent(None, |raw_log| async move {\n+                    let ibc_event =\n+                        ibchandler_events_to_ibc_event(raw_log, &self.rpc, latest_block).await;\n+\n+                    if let Some(ibc_event) = ibc_event {\n+                        self.handle_ibc_event(ibc_event, &shared_map, latest_block)\n+                            .await;\n+                    }\n+                })\n+                .await;\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+impl IbcListen for Cosmos {\n+    async fn listen(&self, shared_map: &SharedMap) {\n+        tracing::info!(\"Listening to Cosmos chain events\");\n+        let mut subs = self\n+            .chain\n+            .tm_client\n+            .subscribe(tendermint_rpc::query::EventType::Tx.into())\n+            .await\n+            .unwrap();\n+        loop {\n+            tokio::select! {\n+                Some(event_result) = subs.next() => {\n+                    match event_result {\n+                        Ok(event) => {\n+                            // tracing::info!(\"Received event_result: {:?}\", event.clone());\n+                            if let Some(ref events) = event.events {\n+                                if let Some(heights) = events.get(\"tx.height\") {\n+                                    if let Some(height) = heights.first() {\n+                                        let block_number: u64 = height.parse().expect(\"Failed to parse block number\");\n+                                        tracing::info!(\"Fetched cosmos Block number: {}\", block_number);\n+                                    }\n+                                }\n+                            }\n+\n+                            match event.data {\n+                                EventData::Tx { tx_result, .. } => {\n+                                    for event in tx_result.result.events {\n+                                        // tracing::info!(\"Received event: {:?}\", event.clone());\n+                                        let Some(my_event) = IbcEvent::try_from_tendermint_event(TendermintEvent {\n+                                            ty: event.kind,\n+                                            attributes: event.attributes\n+                                                .into_iter()\n+                                                .map(|attr| EventAttribute {\n+                                                    key: attr.key,\n+                                                    value: attr.value,\n+                                                    index: attr.index,\n+                                                })\n+                                                .collect(),\n+                                        }) else {\n+                                            continue;\n+                                        };\n+                                        let ibc_event = my_event.unwrap();\n+                                        self.handle_ibc_event(ibc_event, &shared_map, 13).await;\n+                                    }\n+                                }\n+                                _ => {\n+                                    tracing::error!(\"Unhandled event type: {:?}\", event);\n+                                }\n+                            }\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\"Error while receiving event: {:?}\", e);\n+                        }\n+                    }\n+                },\n+                else => break,\n+            }\n+        }\n+    }\n+\n+    async fn handle_ibc_event(\n+        &self,\n+        ibc_event: IbcEvent,\n+        shared_map: &SharedMap,\n+        block_number: u64,\n+    ) {\n+        IbcListen::handle_ibc_event_boxed(self, ibc_event, shared_map, block_number).await;\n+    }\n+}\n+\n+impl IbcTransfer for Ethereum {\n+    async fn send_ibc_transfer(\n+        &self,\n+        protocol: Protocol,\n+        _channel: ChannelId,\n+        destination_channel: ChannelId,\n+        denom: String,\n+        amount: u64,\n+        memo: String,\n+    ) {\n+        let mut rng = StdRng::from_entropy();\n+        let index = rng.gen_range(0..self.relays.len()); // Select a random index\n+\n+        let relay = &self.relays[index];\n+        let signer_middleware = &self.signer_middlewares[index];\n+        let msg_sender = self.msg_senders[index];\n+\n+        let denom_address = match ethers::types::H160::from_str(&denom) {\n+            Ok(address) => address,\n+            Err(_) => {\n+                let formatted_denom = format!(\n+                    \"{}/{}/{}\",\n+                    self.ucs01_contract.to_lowercase(),\n+                    destination_channel,\n+                    denom\n+                );\n+\n+                relay\n+                    .get_denom_address(\n+                        destination_channel.clone().to_string(),\n+                        formatted_denom.clone(),\n+                    )\n+                    .call()\n+                    .await\n+                    .unwrap()\n+            }\n+        };\n+\n+        if denom_address == ethers::types::H160::zero() {\n+            tracing::warn!(\"Denom address not found\");\n+            return;\n+        }\n+        let erc_contract = erc20::ERC20::new(denom_address, signer_middleware.clone());\n+        let balance = erc_contract.balance_of(msg_sender).await.unwrap();\n+        tracing::info!(\"ETH Token balance: {}. Sending amount: {}\", balance, amount);\n+        if balance < amount.into() {\n+            tracing::warn!(\"Insufficient balance\");",
        "comment_created_at": "2024-06-22T13:31:19+00:00",
        "comment_author": "benluelo",
        "comment_body": "include the balance and requested amount as fields in the log",
        "pr_file_module": null
      }
    ]
  }
]