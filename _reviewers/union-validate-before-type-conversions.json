[
  {
    "discussion_id": "2249974467",
    "pr_number": 4859,
    "pr_file": "cosmwasm/ibc-union/core/src/contract.rs",
    "created_at": "2025-08-03T13:22:02+00:00",
    "commented_code": ")?;\n             Ok(to_json_binary(&status)?)\n         }\n+        QueryMsg::GetCommittedStatus { client_id } => {\n+            let val = deps.storage.read::<ClientStatuses>(&client_id)?;\n+            let raw = val.to_le_bytes()[0];\n+            let status = Status::try_from(raw)\n+                .map_err(|_| ContractError::InvalidClientStatusValue { value: raw as u32 })?;",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2249974467",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4859,
        "pr_file": "cosmwasm/ibc-union/core/src/contract.rs",
        "discussion_id": "2249974467",
        "commented_code": "@@ -2186,6 +2200,13 @@ pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> Result<Binary, ContractErr\n             )?;\n             Ok(to_json_binary(&status)?)\n         }\n+        QueryMsg::GetCommittedStatus { client_id } => {\n+            let val = deps.storage.read::<ClientStatuses>(&client_id)?;\n+            let raw = val.to_le_bytes()[0];\n+            let status = Status::try_from(raw)\n+                .map_err(|_| ContractError::InvalidClientStatusValue { value: raw as u32 })?;",
        "comment_created_at": "2025-08-03T13:22:02+00:00",
        "comment_author": "benluelo",
        "comment_body": "don't arbitrarily cast to an integer width. you need to consider all possible values this may take. additionally, since we control this error type, we don't need to cast to a specific integer width - we can just change the field type (as i mentioned in another comment).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1862575153",
    "pr_number": 3309,
    "pr_file": "hubble/src/indexer/tm/block_handle.rs",
    "created_at": "2024-11-28T18:18:46+00:00",
    "commented_code": "#[derive(Clone)]\n pub struct BlockHeader {\n-    pub block_id: tendermint::block::Id,\n-    pub header: tendermint::block::Header,\n+    pub block_id: BlockId,\n+    pub header: Header,\n }\n \n-impl From<tendermint_rpc::endpoint::block::Response> for BlockHeader {\n-    fn from(response: tendermint_rpc::endpoint::block::Response) -> Self {\n+impl From<BlockResponse> for BlockHeader {\n+    fn from(block_response: BlockResponse) -> Self {\n         BlockHeader {\n-            block_id: response.block_id,\n-            header: response.block.header,\n+            block_id: block_response.block_id,\n+            header: block_response.block.header,\n         }\n     }\n }\n \n-impl From<tendermint::block::Meta> for BlockHeader {\n-    fn from(meta: tendermint::block::Meta) -> Self {\n+impl From<BlockMeta> for BlockHeader {\n+    fn from(block_meta: BlockMeta) -> Self {\n         BlockHeader {\n-            block_id: meta.block_id,\n-            header: meta.header,\n+            block_id: block_meta.block_id,\n+            header: block_meta.header,\n         }\n     }\n }\n \n-impl From<tendermint_rpc::endpoint::commit::Response> for BlockHeader {\n-    fn from(response: tendermint_rpc::endpoint::commit::Response) -> Self {\n+impl From<CommitResponse> for BlockHeader {\n+    fn from(commit_response: CommitResponse) -> Self {\n         BlockHeader {\n-            block_id: response.signed_header.commit.block_id,\n-            header: response.signed_header.header,\n+            block_id: commit_response.signed_header.commit.block_id,\n+            header: commit_response.signed_header.header,\n         }\n     }\n }\n \n impl BlockReferenceProvider for BlockHeader {\n     fn block_reference(&self) -> Result<BlockReference, Report> {\n         Ok(BlockReference {\n-            height: self.header.height.into(),\n-            hash: self.block_id.hash.to_string(),\n-            timestamp: self.header.time.into(),\n+            height: self.header.height.inner() as u64,\n+            hash: self\n+                .block_id\n+                .hash\n+                .ok_or(IndexerError::ProviderError(eyre!(\"expected hash\")))?\n+                .to_string(),\n+            timestamp: OffsetDateTime::from_unix_timestamp_nanos(\n+                self.header.time.as_unix_nanos() as i128",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1862575153",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3309,
        "pr_file": "hubble/src/indexer/tm/block_handle.rs",
        "discussion_id": "1862575153",
        "commented_code": "@@ -21,53 +25,67 @@ use crate::indexer::{\n \n #[derive(Clone)]\n pub struct BlockHeader {\n-    pub block_id: tendermint::block::Id,\n-    pub header: tendermint::block::Header,\n+    pub block_id: BlockId,\n+    pub header: Header,\n }\n \n-impl From<tendermint_rpc::endpoint::block::Response> for BlockHeader {\n-    fn from(response: tendermint_rpc::endpoint::block::Response) -> Self {\n+impl From<BlockResponse> for BlockHeader {\n+    fn from(block_response: BlockResponse) -> Self {\n         BlockHeader {\n-            block_id: response.block_id,\n-            header: response.block.header,\n+            block_id: block_response.block_id,\n+            header: block_response.block.header,\n         }\n     }\n }\n \n-impl From<tendermint::block::Meta> for BlockHeader {\n-    fn from(meta: tendermint::block::Meta) -> Self {\n+impl From<BlockMeta> for BlockHeader {\n+    fn from(block_meta: BlockMeta) -> Self {\n         BlockHeader {\n-            block_id: meta.block_id,\n-            header: meta.header,\n+            block_id: block_meta.block_id,\n+            header: block_meta.header,\n         }\n     }\n }\n \n-impl From<tendermint_rpc::endpoint::commit::Response> for BlockHeader {\n-    fn from(response: tendermint_rpc::endpoint::commit::Response) -> Self {\n+impl From<CommitResponse> for BlockHeader {\n+    fn from(commit_response: CommitResponse) -> Self {\n         BlockHeader {\n-            block_id: response.signed_header.commit.block_id,\n-            header: response.signed_header.header,\n+            block_id: commit_response.signed_header.commit.block_id,\n+            header: commit_response.signed_header.header,\n         }\n     }\n }\n \n impl BlockReferenceProvider for BlockHeader {\n     fn block_reference(&self) -> Result<BlockReference, Report> {\n         Ok(BlockReference {\n-            height: self.header.height.into(),\n-            hash: self.block_id.hash.to_string(),\n-            timestamp: self.header.time.into(),\n+            height: self.header.height.inner() as u64,\n+            hash: self\n+                .block_id\n+                .hash\n+                .ok_or(IndexerError::ProviderError(eyre!(\"expected hash\")))?\n+                .to_string(),\n+            timestamp: OffsetDateTime::from_unix_timestamp_nanos(\n+                self.header.time.as_unix_nanos() as i128",
        "comment_created_at": "2024-11-28T18:18:46+00:00",
        "comment_author": "KaiserKarel",
        "comment_body": "for conversions, prefer using `try_into().expect()`, which will error if the lhs cannot convert into the rhs.",
        "pr_file_module": null
      },
      {
        "comment_id": "1863241747",
        "repo_full_name": "unionlabs/union",
        "pr_number": 3309,
        "pr_file": "hubble/src/indexer/tm/block_handle.rs",
        "discussion_id": "1862575153",
        "commented_code": "@@ -21,53 +25,67 @@ use crate::indexer::{\n \n #[derive(Clone)]\n pub struct BlockHeader {\n-    pub block_id: tendermint::block::Id,\n-    pub header: tendermint::block::Header,\n+    pub block_id: BlockId,\n+    pub header: Header,\n }\n \n-impl From<tendermint_rpc::endpoint::block::Response> for BlockHeader {\n-    fn from(response: tendermint_rpc::endpoint::block::Response) -> Self {\n+impl From<BlockResponse> for BlockHeader {\n+    fn from(block_response: BlockResponse) -> Self {\n         BlockHeader {\n-            block_id: response.block_id,\n-            header: response.block.header,\n+            block_id: block_response.block_id,\n+            header: block_response.block.header,\n         }\n     }\n }\n \n-impl From<tendermint::block::Meta> for BlockHeader {\n-    fn from(meta: tendermint::block::Meta) -> Self {\n+impl From<BlockMeta> for BlockHeader {\n+    fn from(block_meta: BlockMeta) -> Self {\n         BlockHeader {\n-            block_id: meta.block_id,\n-            header: meta.header,\n+            block_id: block_meta.block_id,\n+            header: block_meta.header,\n         }\n     }\n }\n \n-impl From<tendermint_rpc::endpoint::commit::Response> for BlockHeader {\n-    fn from(response: tendermint_rpc::endpoint::commit::Response) -> Self {\n+impl From<CommitResponse> for BlockHeader {\n+    fn from(commit_response: CommitResponse) -> Self {\n         BlockHeader {\n-            block_id: response.signed_header.commit.block_id,\n-            header: response.signed_header.header,\n+            block_id: commit_response.signed_header.commit.block_id,\n+            header: commit_response.signed_header.header,\n         }\n     }\n }\n \n impl BlockReferenceProvider for BlockHeader {\n     fn block_reference(&self) -> Result<BlockReference, Report> {\n         Ok(BlockReference {\n-            height: self.header.height.into(),\n-            hash: self.block_id.hash.to_string(),\n-            timestamp: self.header.time.into(),\n+            height: self.header.height.inner() as u64,\n+            hash: self\n+                .block_id\n+                .hash\n+                .ok_or(IndexerError::ProviderError(eyre!(\"expected hash\")))?\n+                .to_string(),\n+            timestamp: OffsetDateTime::from_unix_timestamp_nanos(\n+                self.header.time.as_unix_nanos() as i128",
        "comment_created_at": "2024-11-29T09:42:00+00:00",
        "comment_author": "qlp",
        "comment_body": "changed all `as <type>` occurrences in hubble: 9f75c28936c3fd81d3cb3eafaab2f7d9551c4b58",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1719971853",
    "pr_number": 2693,
    "pr_file": "hubble/src/arb.rs",
    "created_at": "2024-08-16T15:05:09+00:00",
    "commented_code": "async fn execution_height_of_beacon_slot(&self, slot: u64) -> Result<u64> {\n         // read the next_node_num at l1.execution_height(beacon_slot), then from there filter for `NodeCreated`\n         let next_node_num = self.next_node_num_at_beacon_slot(slot).await?;\n-\n         let [event] = self\n             .l1_client\n             .get_logs(\n-                &ethers::types::Filter::new()\n+                &Filter::new()",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1719971853",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2693,
        "pr_file": "hubble/src/arb.rs",
        "discussion_id": "1719971853",
        "commented_code": "@@ -90,40 +104,38 @@ impl Arb {\n     async fn execution_height_of_beacon_slot(&self, slot: u64) -> Result<u64> {\n         // read the next_node_num at l1.execution_height(beacon_slot), then from there filter for `NodeCreated`\n         let next_node_num = self.next_node_num_at_beacon_slot(slot).await?;\n-\n         let [event] = self\n             .l1_client\n             .get_logs(\n-                &ethers::types::Filter::new()\n+                &Filter::new()",
        "comment_created_at": "2024-08-16T15:05:09+00:00",
        "comment_author": "rohankokkulabito",
        "comment_body": "<div>\n\n<strong>Bito Code Review Agent Run</strong> <a href=https://github.com/unionlabs/union/pull/2693#issuecomment-2293655644>#ef6b49</a><span> - 08/16/2024, 03:05 pm</span>\n<br>\n\n<div><small>\ud83d\udd34</small> High importance</div>\n\n<div id=\"suggestion\">\n<div id=\"issue\">\n<b>Issue:</b> The change from 'ethers::types::H160' to 'alloy::primitives::Address' and the use of 'FixedBytes::from_slice' may introduce issues if the address length is not validated. Alloy's 'Address' expects a fixed length, and any deviation can cause runtime errors. A similar issue was also found in hubble/src/arb.rs (line 117-118).\n</div>\n<div id=\"fix\">\n<b>Fix:</b> Ensure that the address length is validated before converting it to 'FixedBytes'. This can prevent potential runtime errors due to incorrect address lengths.\n</div>\n<details>\n<summary>\n<b>Code suggestion</b>\n</summary>\n<div id=\"code\">\n\n```\n @@ -113,6 +113,10 @@\n                      alloy::eips::BlockNumberOrTag::Earliest..alloy::eips::BlockNumberOrTag::Latest,\n                  )\n                  .address(alloy::primitives::Address(\n +                    if self.rollup_finalization_config.l1_contract_address.0.len() != 20 {\n +                        return Err(eyre!(\"Invalid address length\"));\n +                    }\n                      FixedBytes::from_slice(&self.rollup_finalization_config.l1_contract_address.0),\n                  ))\n                  .event_signature(NodeCreated::SIGNATURE_HASH)\n```\n</div>\n</details>\n</div>\n<br>\n\n\n</div>\n\nIs this a valid issue, or was it incorrectly flagged by the Agent?\n- [ ] it was incorrectly flagged",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1719971877",
    "pr_number": 2693,
    "pr_file": "hubble/src/arb.rs",
    "created_at": "2024-08-16T15:05:11+00:00",
    "commented_code": ".rollup_finalization_config\n             .l1_next_node_num_slot_offset_bytes\n             .inner() as usize;\n-\n         let raw_slot = self\n             .l1_client\n             .get_storage_at(\n-                ethers::types::H160::from(self.rollup_finalization_config.l1_contract_address),\n-                ethers::types::H256(\n+                alloy::primitives::Address::new(\n+                    (self.rollup_finalization_config.l1_contract_address).0,\n+                ),\n+                alloy::primitives::Uint::from_be_bytes(",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1719971877",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2693,
        "pr_file": "hubble/src/arb.rs",
        "discussion_id": "1719971877",
        "commented_code": "@@ -141,31 +153,28 @@ impl Arb {\n             .rollup_finalization_config\n             .l1_next_node_num_slot_offset_bytes\n             .inner() as usize;\n-\n         let raw_slot = self\n             .l1_client\n             .get_storage_at(\n-                ethers::types::H160::from(self.rollup_finalization_config.l1_contract_address),\n-                ethers::types::H256(\n+                alloy::primitives::Address::new(\n+                    (self.rollup_finalization_config.l1_contract_address).0,\n+                ),\n+                alloy::primitives::Uint::from_be_bytes(",
        "comment_created_at": "2024-08-16T15:05:11+00:00",
        "comment_author": "rohankokkulabito",
        "comment_body": "<div>\n\n<strong>Bito Code Review Agent Run</strong> <a href=https://github.com/unionlabs/union/pull/2693#issuecomment-2293655644>#ef6b49</a><span> - 08/16/2024, 03:05 pm</span>\n<br>\n\n<div><small>\ud83d\udd34</small> High importance</div>\n\n<div id=\"suggestion\">\n<div id=\"issue\">\n<b>Issue:</b> The 'Address::new' function expects a byte array of length 20. If 'self.rollup_finalization_config.l1_contract_address.0' is not of the correct length, this will cause a runtime error.\n</div>\n<div id=\"fix\">\n<b>Fix:</b> Ensure that 'self.rollup_finalization_config.l1_contract_address.0' is a byte array of length 20 before passing it to 'Address::new'.\n</div>\n<details>\n<summary>\n<b>Code suggestion</b>\n</summary>\n<div id=\"code\">\n\n```\n @@ -159,7 +159,9 @@\n             alloy::primitives::Address::new(\n                 (self.rollup_finalization_config.l1_contract_address).0,\n             ),\n             alloy::primitives::Uint::from_be_bytes(\n                 self.rollup_finalization_config\n                     .l1_latest_confirmed_slot\n                     .to_be_bytes(),\n             ),\n +           if (self.rollup_finalization_config.l1_contract_address).0.len() != 20 {\n +               return Err(eyre!(\"Invalid address length\"));\n +           }\n```\n</div>\n</details>\n</div>\n<br>\n\n\n</div>\n\nIs this a valid issue, or was it incorrectly flagged by the Agent?\n- [ ] it was incorrectly flagged",
        "pr_file_module": null
      }
    ]
  }
]