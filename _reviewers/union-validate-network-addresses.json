[
  {
    "discussion_id": "1740037869",
    "pr_number": 2867,
    "pr_file": "app/src/routes/transfer/(components)/transfer-form.svelte",
    "created_at": "2024-09-01T09:58:15+00:00",
    "commented_code": "</div>\n           {/if}\n         </section>\n-        \n-          <section>\n+        <section>\n+          <CardSectionHeading>Recipient</CardSectionHeading>\n+          <div class=\"flex items-start gap-2\">\n+            <div class=\"w-full\">\n+              <div class=\"relative w-full mb-2\">\n+                <Input\n+                        autocapitalize=\"none\"\n+                        autocomplete=\"off\"\n+                        autocorrect=\"off\"\n+                        bind:value={$address}\n+                        class=\"disabled:bg-black/30\"\n+                        disabled={!$toChain}\n+                        id=\"address\"\n+                        on:input={handleInput}\n+                        placeholder=\"Enter recipient's address\"\n+                        required={true}\n+                        spellcheck=\"false\"\n+                        type=\"text\"\n+                />\n+              </div>",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1740037869",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2867,
        "pr_file": "app/src/routes/transfer/(components)/transfer-form.svelte",
        "discussion_id": "1740037869",
        "commented_code": "@@ -925,8 +923,41 @@ const resetInput = () => {\n             </div>\n           {/if}\n         </section>\n-        \n-          <section>\n+        <section>\n+          <CardSectionHeading>Recipient</CardSectionHeading>\n+          <div class=\"flex items-start gap-2\">\n+            <div class=\"w-full\">\n+              <div class=\"relative w-full mb-2\">\n+                <Input\n+                        autocapitalize=\"none\"\n+                        autocomplete=\"off\"\n+                        autocorrect=\"off\"\n+                        bind:value={$address}\n+                        class=\"disabled:bg-black/30\"\n+                        disabled={!$toChain}\n+                        id=\"address\"\n+                        on:input={handleInput}\n+                        placeholder=\"Enter recipient's address\"\n+                        required={true}\n+                        spellcheck=\"false\"\n+                        type=\"text\"\n+                />\n+              </div>",
        "comment_created_at": "2024-09-01T09:58:15+00:00",
        "comment_author": "cor",
        "comment_body": "We should do validation here based on the destination chain. Ie when you the destination chain is an EVM chain, it needs to be a valid EVM address (check the checksum). When the destination is a Stride address, it needs to be a valid stride address. for every address type check that the checksum is (bech32) prefix is correct and that the checksum matches.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1740903444",
    "pr_number": 2889,
    "pr_file": "move/move-ibc/sources/ibc.move",
    "created_at": "2024-09-02T13:09:00+00:00",
    "commented_code": "let connection = ensure_connection_state(*vector::borrow(channel::connection_hops(&channel), 0));\n \n-        let expected_counterparty = channel::new_counterparty(port_id, channel_id);\n-        let expected_channel = channel::new(\n-            CHAN_STATE_OPEN,\n-            channel::ordering(&channel),\n-            expected_counterparty,\n-            get_counterparty_hops(*vector::borrow(channel::connection_hops(&channel), 0)),\n-            *channel::version(&channel),\n+        let expected_counterparty = channel::new_counterparty(port_id, channel_id);\n+        let expected_channel = channel::new(\n+            CHAN_STATE_OPEN,\n+            channel::ordering(&channel),\n+            expected_counterparty,\n+            get_counterparty_hops(*vector::borrow(channel::connection_hops(&channel), 0)),\n+            *channel::version(&channel),\n+        );\n+\n+        if (!verify_channel_state(\n+            &connection,\n+            proof_height,\n+            proof_ack,\n+            *channel::chan_counterparty_port_id(&channel),\n+            *channel::chan_counterparty_channel_id(&channel),\n+            bcs::to_bytes(&expected_channel)\n+        )) {\n+            abort(E_INVALID_PROOF)\n+        };\n+\n+        channel::set_state(&mut channel, CHAN_STATE_OPEN);\n+        update_channel_commitment(port_id, channel_id);\n+\n+        smart_table::upsert(&mut borrow_global_mut<IBCStore>(get_vault_addr()).channels, channel_port, channel);\n+\n+        event::emit(\n+            ChannelOpenConfirm {\n+                port_id,\n+                channel_id,\n+                counterparty_port_id: *channel::chan_counterparty_port_id(&channel),\n+                counterparty_channel_id: *channel::chan_counterparty_channel_id(&channel),\n+                connection_id: *vector::borrow(channel::connection_hops(&channel), 0)\n+            },\n+        );\n+    }\n+\n+    // ========= UTILS and VIEW functions ========= //\n+\n+    public fun get_ibc_signer(): signer acquires SignerRef {\n+        let vault = borrow_global<SignerRef>(get_vault_addr());\n+        object::generate_signer_for_extending(&vault.self_ref)\n+    }\n+\n+\n+    public fun default_ibc_version(): connection_end::Version {\n+        connection_end::new_version(\n+            string::utf8(b\"1\"),\n+            vector<String>[string::utf8(b\"ORDER_ORDERED\"), string::utf8(b\"ORDER_UNORDERED\")],\n+        )\n+    }\n+\n+    public fun set_supported_versions(\n+        supported_versions: vector<connection_end::Version>,\n+        dst: &mut vector<connection_end::Version>\n+    ) {\n+        assert!(vector::length(dst) == 0, E_VERSION_MUST_BE_UNSET);\n+        vector::append(dst, supported_versions);\n+    }\n+\n+    public fun is_supported_version(\n+        supported_versions: &vector<connection_end::Version>,\n+        version: &connection_end::Version\n+    ): bool {\n+        let (supported_version, found) = find_supported_version(supported_versions, version);\n+        if(found && verify_proposed_version(&supported_version, version)) {\n+            return true\n+        };\n+        false\n+        // found && verify_proposed_version(&supported_version, version)\n+    }\n+\n+    public fun get_feature_set_intersection(\n+        source_features: &vector<String>,\n+        counterparty_features: &vector<String>\n+    ): vector<String> {\n+        let feature_set = vector::empty<String>();\n+        let source_len = vector::length(source_features);\n+        let i = 0;\n+        while (i < source_len) {\n+            let feature = vector::borrow(source_features, i);\n+            if (vector::contains(counterparty_features, feature)) {\n+                vector::push_back(&mut feature_set, *feature);\n+            };\n+            i = i + 1;\n+        };\n+        feature_set\n+    }\n+\n+\n+    public fun pick_version(\n+        supported_versions: &vector<connection_end::Version>,\n+        counterparty_versions: &vector<connection_end::Version>\n+    ): connection_end::Version  {\n+        let supported_len = vector::length(supported_versions);\n+        let i = 0;\n+        while (i < supported_len) {\n+            let supported_version = vector::borrow(supported_versions, i);\n+            let (counterparty_version, found) = find_supported_version(counterparty_versions, supported_version);\n+            if (found) {\n+                let feature_set = get_feature_set_intersection(connection_end::version_features(supported_version), connection_end::version_features(&counterparty_version));\n+                if (vector::length(&feature_set) > 0) {\n+                    return connection_end::new_version(*connection_end::version_identifier(supported_version), feature_set)\n+                };\n+            };\n+            i = i + 1;\n+        };\n+        abort(E_UNSUPPORTED_VERSION)\n+    }\n+\n+    public fun copy_version(src: &connection_end::Version, dst: &mut connection_end::Version) {\n+        connection_end::set_version_identifier(dst, *connection_end::version_identifier(src));\n+        let src_len = vector::length(connection_end::version_features(src));\n+        let dst_len = vector::length(connection_end::version_features(dst));\n+        let i = 0;\n+        let dst_features = connection_end::version_features_mut(dst);\n+        while (i < src_len) {\n+            if (i < dst_len) {\n+                let src_feature = vector::borrow(connection_end::version_features(src), i);\n+                let dst_feature = vector::borrow_mut(dst_features, i);\n+                *dst_feature = *src_feature;\n+            } else {\n+                let src_feature = vector::borrow(connection_end::version_features(src), i);\n+                vector::push_back(dst_features, *src_feature);\n+            };\n+            i = i + 1;\n+        };\n+        while (i < dst_len) {\n+            vector::remove(dst_features, i);\n+            i = i + 1;\n+        }\n+    }\n+\n+    public fun copy_versions(src: &vector<connection_end::Version>, dst: &mut vector<connection_end::Version>) {\n+        let src_len = vector::length(src);\n+        let dst_len = vector::length(dst);\n+        if (src_len == dst_len) {\n+            let i = 0;\n+            while (i < src_len) {\n+                let src_version = vector::borrow(src, i);\n+                let dst_version = vector::borrow_mut(dst, i);\n+                copy_version(src_version, dst_version);\n+                i = i + 1;\n+            };\n+        } else if (src_len > dst_len) {\n+            let i = 0;\n+            while (i < dst_len) {\n+                let src_version = vector::borrow(src, i);\n+                let dst_version = vector::borrow_mut(dst, i);\n+                copy_version(src_version, dst_version);\n+                i = i + 1;\n+            };\n+            let j = dst_len;\n+            while (j < src_len) {\n+                let src_version = vector::borrow(src, j);\n+                vector::push_back(dst, *src_version);\n+                j = j + 1;\n+            };\n+        } else {\n+            let i = 0;\n+            while (i < src_len) {\n+                let src_version = vector::borrow(src, i);\n+                let dst_version = vector::borrow_mut(dst, i);\n+                copy_version(src_version, dst_version);\n+                i = i + 1;\n+            };\n+            let j = src_len;\n+            while (j < dst_len) {\n+                vector::remove(dst, j);\n+                j = j + 1;\n+            };\n+        }\n+    }\n+\n+\n+    public fun find_supported_version(\n+        supported_versions: &vector<connection_end::Version>,\n+        version: &connection_end::Version\n+    ): (connection_end::Version, bool) {\n+        let found_version = connection_end::default_version();\n+        let found = false;\n+        let len_supported_versions = vector::length(supported_versions);\n+        let i = 0;\n+        while(i < len_supported_versions) {\n+            let v = vector::borrow(supported_versions, i);\n+            if (connection_end::version_identifier(v) == connection_end::version_identifier(version)) {\n+                found_version = *v;\n+                found = true;\n+                break\n+            };\n+            i = i + 1;\n+        };\n+        (found_version, found)\n+    }\n+\n+    public fun verify_proposed_version(\n+        supported_version: &connection_end::Version,\n+        proposed_version: &connection_end::Version\n+    ): bool {\n+        let is_supported = false;\n+        if(connection_end::version_identifier(supported_version) == connection_end::version_identifier(proposed_version)) {\n+            let len_proposed_version = vector::length(connection_end::version_features(proposed_version));\n+            let i = 0;\n+            while(i < len_proposed_version) {\n+                let feature = vector::borrow(connection_end::version_features(proposed_version), i);\n+                is_supported = vector::contains(connection_end::version_features(supported_version), feature);\n+                if(!is_supported) {\n+                    break\n+                };\n+                i = i + 1;\n+            };\n+        };\n+        is_supported\n+    }\n+\n+    public fun verify_client_state(\n+        connection: &ConnectionEnd,\n+        height: height::Height,\n+        path: vector<u8>,\n+        proof: vector<u8>,\n+        client_state_bytes: vector<u8>\n+    ): bool {\n+        let error_code = LightClient::verify_membership(\n+            *connection_end::client_id(connection),\n+            height,\n+            proof,\n+            *connection_end::conn_counterparty_key_prefix(connection),\n+            path,\n+            client_state_bytes\n+        );\n+        assert!(error_code == 0, E_INVALID_CONNECTION_STATE);\n+        true\n+    }\n+\n+    public fun verify_connection_state(\n+        connection: &ConnectionEnd,\n+        height: height::Height,\n+        proof: vector<u8>,\n+        connection_id: String,\n+        counterparty_connection: ConnectionEnd\n+    ): bool {\n+        let error_code = LightClient::verify_membership(\n+            *connection_end::client_id(connection),\n+            height,\n+            proof,\n+            *connection_end::conn_counterparty_key_prefix(connection),\n+            bcs::to_bytes(&IBCCommitment::connection_path(connection_id)),\n+            connection_end::encode_proto(counterparty_connection)\n+        );\n+        assert!(error_code == 0, E_INVALID_CONNECTION_STATE);\n+        true\n+    }\n+\n+    public fun verify_commitment(\n+        connection: &ConnectionEnd,\n+        height: Height,\n+        proof: vector<u8>,\n+        path: String,\n+        commitment: vector<u8>,\n+    ): u64 {\n+        let err = LightClient::verify_membership(\n+            *connection_end::client_id(connection),\n+            height,\n+            proof,\n+            *connection_end::conn_counterparty_key_prefix(connection),\n+            *string::bytes(&path),\n+            commitment\n+        );\n+\n+        err\n+    }\n+\n+    public fun generate_connection_identifier(): String acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+        let next_sequence_bytes = table::borrow_with_default(\n+            &store.commitments,\n+            b\"nextConnectionSequence\",\n+            &bcs::to_bytes<u64>(&0)\n+        );\n+        let next_sequence = from_bcs::to_u64(*next_sequence_bytes);\n+        let identifier = string::utf8(b\"connection-\");\n+        string::append(&mut identifier, string_utils::to_string(&next_sequence));\n+        let new_sequence = next_sequence + 1;\n+        table::upsert(\n+            &mut store.commitments,\n+            b\"nextConnectionSequence\",\n+            bcs::to_bytes(&new_sequence)\n+        );\n+        identifier\n+    }\n+\n+    public fun update_connection_commitment(store: &mut IBCStore, connection_id: String) {\n+        let connection = smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n         );\n \n-        if (!verify_channel_state(\n-            &connection,\n-            proof_height,\n-            proof_ack,\n-            *channel::chan_counterparty_port_id(&channel),\n-            *channel::chan_counterparty_channel_id(&channel),\n-            bcs::to_bytes(&expected_channel)\n-        )) {\n-            abort(E_INVALID_PROOF)\n-        };\n+        let encoded_connection = connection_end::encode_proto(*connection);\n+        let key = IBCCommitment::connection_commitment_key(connection_id);\n+        let hash = hash::sha2_256(encoded_connection);\n+        table::upsert(&mut store.commitments, key, hash);\n+    }\n \n-        channel::set_state(&mut channel, CHAN_STATE_OPEN);\n-        update_channel_commitment(port_id, channel_id);\n+    public fun get_compatible_versions(): vector<connection_end::Version> {\n+        vector<connection_end::Version>[default_ibc_version()]\n+    }\n \n-        smart_table::upsert(&mut borrow_global_mut<IBCStore>(get_vault_addr()).channels, channel_port, channel);\n+    // Returns connection by `connection_id`. Aborts if the connection does not exist.\n+    #[view]\n+    public fun get_connection(connection_id: String): ConnectionEnd acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n \n-        event::emit(\n-            ChannelOpenConfirm {\n-                port_id,\n-                channel_id,\n-                counterparty_port_id: *channel::chan_counterparty_port_id(&channel),\n-                counterparty_channel_id: *channel::chan_counterparty_channel_id(&channel),\n-                connection_id: *vector::borrow(channel::connection_hops(&channel), 0)\n-            },\n-        );\n+        *smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n+        )\n     }\n \n-    public fun channel_open_try(\n-        ibc_app: &signer,\n-        port_id: String,\n-        connection_hops: vector<String>,\n-        ordering: u8,\n-        counterparty: channel::Counterparty,\n-        counterparty_version: String,\n-        version: String,\n-        proof_init: vector<u8>,\n-        proof_height: height::Height\n-    ): (Channel, u64) acquires IBCStore {\n-        let (connection_id, connection) = ensure_connection_feature(connection_hops, ordering);\n-        \n-        let expected_counterparty = channel::new_counterparty(port_id, string::utf8(b\"\"));\n-        let expected_channel = channel::new(\n-            CHAN_STATE_INIT,\n-            ordering,\n-            expected_counterparty,\n-            get_counterparty_hops(*vector::borrow(&connection_hops, 0)),\n-            counterparty_version\n-        );\n+    // Getter function to retrieve a connection commitment by its ID\n+    #[view]\n+    public fun get_connection_commitment(connection_id: String): vector<u8> acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n+        let key = IBCCommitment::connection_commitment_key(connection_id);\n+        *table::borrow(\n+            &store.commitments,\n+            key,\n+        )\n+    }\n \n-        if (!verify_channel_state(\n-            &connection,\n-            proof_height,\n-            proof_init,\n-            *channel::counterparty_port_id(&counterparty),\n-            *channel::counterparty_channel_id(&counterparty),\n-            bcs::to_bytes(&expected_channel)\n-        )) {\n-            abort(E_INVALID_PROOF)\n+    public fun verify_supported_feature(version: &connection_end::Version, feature: String): bool {\n+        let i = 0;\n+        while (i < vector::length(connection_end::version_features(version))) {\n+            if (*vector::borrow(connection_end::version_features(version), i) == feature) {\n+                return true\n+            };\n+            i = i + 1;\n         };\n+        false\n+    }\n \n-        let channel_id = generate_channel_identifier();\n+    public fun to_string(ordering: u8): String {\n+        let return_val = string::utf8(b\"ORDER_INVALID\");\n+        if (ordering == 1) { // Order.ORDER_UNORDERED\n+            return_val = string::utf8(b\"ORDER_UNORDERED\");\n+        } else if (ordering == 2) { // Order.ORDER_ORDERED\n+            return_val = string::utf8(b\"ORDER_ORDERED\");\n+        };\n+        return_val\n+    }\n \n-        event::emit(\n-            ChannelOpenTry {\n-                port_id,\n-                channel_id,\n-                counterparty_port_id: *channel::counterparty_port_id(&counterparty),\n-                counterparty_channel_id: *channel::counterparty_channel_id(&counterparty),\n-                connection_id,\n-                version: counterparty_version\n-            },\n+\n+    public fun get_counterparty_hops(connection_id: String): vector<String> acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n+        let connection = smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n         );\n+        let hops = vector::empty<String>();\n+        vector::push_back(&mut hops, *connection_end::conn_counterparty_connection_id(connection));\n+        hops\n+    }\n \n-        let channel_port = ChannelPort { port_id, channel_id };\n+    public fun generate_channel_identifier(): String acquires IBCStore {\n         let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-\n-        let channel = channel::new(CHAN_STATE_TRYOPEN, ordering, counterparty, connection_hops, version);\n-        smart_table::upsert(&mut store.channels, channel_port, channel);\n-\n+        let next_sequence_bytes = table::borrow_with_default(\n+            &store.commitments,\n+            b\"nextChannelSequence\",\n+            &bcs::to_bytes<u64>(&0)\n+        );\n+        let next_sequence = from_bcs::to_u64(*next_sequence_bytes);\n+        let identifier = string::utf8(b\"channel-\");\n+        string::append(&mut identifier, string_utils::to_string(&next_sequence));\n+        let new_sequence = next_sequence + 1;\n         table::upsert(\n             &mut store.commitments,\n-            IBCCommitment::next_sequence_send_commitment_key(port_id, channel_id),\n-            bcs::to_bytes(&1)\n+            b\"nextChannelSequence\",\n+            bcs::to_bytes(&new_sequence)\n         );\n+        identifier\n+    }\n \n-        table::upsert(\n-            &mut store.commitments,\n-            IBCCommitment::next_sequence_recv_commitment_key(port_id, channel_id),\n-            bcs::to_bytes(&1)\n+    public fun ensure_connection_state(connection_id: String): ConnectionEnd acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n+        let connection = smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n         );\n+        if (connection_end::state(connection) != CONN_STATE_OPEN) {\n+            abort(E_INVALID_CONNECTION_STATE)\n+        };\n+        *connection\n+    }\n \n-        table::upsert(\n-            &mut store.commitments,\n-            IBCCommitment::next_sequence_ack_commitment_key(port_id, channel_id),\n-            bcs::to_bytes(&1)\n+    // TODO(aeryz): borrow instead of copy\n+    public fun ensure_connection_feature(connection_hops: vector<String>, ordering: u8): (String, ConnectionEnd) acquires IBCStore {\n+        if (vector::length(&connection_hops) != 1) {\n+            abort(E_CONN_NOT_SINGLE_HOP)\n+        };\n+        let connection_id = *vector::borrow(&connection_hops, 0);\n+        let connection = ensure_connection_state(connection_id);\n+        if (vector::length(connection_end::versions(&connection)) != 1) {\n+            abort(E_CONN_NOT_SINGLE_VERSION)\n+        };\n+        let version = *vector::borrow(connection_end::versions(&connection), 0);\n+        if (!verify_supported_feature(&version, to_string(ordering))) {\n+            abort(E_UNSUPPORTED_FEATURE)\n+        };\n+        (connection_id, connection)\n+    }\n+\n+    // TODO: Here the implementation returns false if there is any uppercase character in the string\n+    // eg: \"portId\" will return false but \"port-0\" will return true. Is this correct way to check?\n+    public fun is_lowercase(s: &String): bool {\n+        let bytes = bcs::to_bytes(s);\n+        let i = 1; // First byte is the length of the string\n+        while (i < vector::length(&bytes)) {\n+            let byte = *vector::borrow(&bytes, i);\n+            // if (byte < 0x61 || byte > 0x7A) { // ASCII values for 'a' and 'z'\n+            //     return false;\n+            // };\n+            if (byte > 0x40 && byte < 0x5b) {\n+                return false\n+            };\n+            i = i + 1;\n+        };\n+        true\n+    }",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "1740903444",
        "repo_full_name": "unionlabs/union",
        "pr_number": 2889,
        "pr_file": "move/move-ibc/sources/ibc.move",
        "discussion_id": "1740903444",
        "commented_code": "@@ -1230,120 +928,481 @@ module IBC::Core {\n \n         let connection = ensure_connection_state(*vector::borrow(channel::connection_hops(&channel), 0));\n \n-        let expected_counterparty = channel::new_counterparty(port_id, channel_id);\n-        let expected_channel = channel::new(\n-            CHAN_STATE_OPEN,\n-            channel::ordering(&channel),\n-            expected_counterparty,\n-            get_counterparty_hops(*vector::borrow(channel::connection_hops(&channel), 0)),\n-            *channel::version(&channel),\n+        let expected_counterparty = channel::new_counterparty(port_id, channel_id);\n+        let expected_channel = channel::new(\n+            CHAN_STATE_OPEN,\n+            channel::ordering(&channel),\n+            expected_counterparty,\n+            get_counterparty_hops(*vector::borrow(channel::connection_hops(&channel), 0)),\n+            *channel::version(&channel),\n+        );\n+\n+        if (!verify_channel_state(\n+            &connection,\n+            proof_height,\n+            proof_ack,\n+            *channel::chan_counterparty_port_id(&channel),\n+            *channel::chan_counterparty_channel_id(&channel),\n+            bcs::to_bytes(&expected_channel)\n+        )) {\n+            abort(E_INVALID_PROOF)\n+        };\n+\n+        channel::set_state(&mut channel, CHAN_STATE_OPEN);\n+        update_channel_commitment(port_id, channel_id);\n+\n+        smart_table::upsert(&mut borrow_global_mut<IBCStore>(get_vault_addr()).channels, channel_port, channel);\n+\n+        event::emit(\n+            ChannelOpenConfirm {\n+                port_id,\n+                channel_id,\n+                counterparty_port_id: *channel::chan_counterparty_port_id(&channel),\n+                counterparty_channel_id: *channel::chan_counterparty_channel_id(&channel),\n+                connection_id: *vector::borrow(channel::connection_hops(&channel), 0)\n+            },\n+        );\n+    }\n+\n+    // ========= UTILS and VIEW functions ========= //\n+\n+    public fun get_ibc_signer(): signer acquires SignerRef {\n+        let vault = borrow_global<SignerRef>(get_vault_addr());\n+        object::generate_signer_for_extending(&vault.self_ref)\n+    }\n+\n+\n+    public fun default_ibc_version(): connection_end::Version {\n+        connection_end::new_version(\n+            string::utf8(b\"1\"),\n+            vector<String>[string::utf8(b\"ORDER_ORDERED\"), string::utf8(b\"ORDER_UNORDERED\")],\n+        )\n+    }\n+\n+    public fun set_supported_versions(\n+        supported_versions: vector<connection_end::Version>,\n+        dst: &mut vector<connection_end::Version>\n+    ) {\n+        assert!(vector::length(dst) == 0, E_VERSION_MUST_BE_UNSET);\n+        vector::append(dst, supported_versions);\n+    }\n+\n+    public fun is_supported_version(\n+        supported_versions: &vector<connection_end::Version>,\n+        version: &connection_end::Version\n+    ): bool {\n+        let (supported_version, found) = find_supported_version(supported_versions, version);\n+        if(found && verify_proposed_version(&supported_version, version)) {\n+            return true\n+        };\n+        false\n+        // found && verify_proposed_version(&supported_version, version)\n+    }\n+\n+    public fun get_feature_set_intersection(\n+        source_features: &vector<String>,\n+        counterparty_features: &vector<String>\n+    ): vector<String> {\n+        let feature_set = vector::empty<String>();\n+        let source_len = vector::length(source_features);\n+        let i = 0;\n+        while (i < source_len) {\n+            let feature = vector::borrow(source_features, i);\n+            if (vector::contains(counterparty_features, feature)) {\n+                vector::push_back(&mut feature_set, *feature);\n+            };\n+            i = i + 1;\n+        };\n+        feature_set\n+    }\n+\n+\n+    public fun pick_version(\n+        supported_versions: &vector<connection_end::Version>,\n+        counterparty_versions: &vector<connection_end::Version>\n+    ): connection_end::Version  {\n+        let supported_len = vector::length(supported_versions);\n+        let i = 0;\n+        while (i < supported_len) {\n+            let supported_version = vector::borrow(supported_versions, i);\n+            let (counterparty_version, found) = find_supported_version(counterparty_versions, supported_version);\n+            if (found) {\n+                let feature_set = get_feature_set_intersection(connection_end::version_features(supported_version), connection_end::version_features(&counterparty_version));\n+                if (vector::length(&feature_set) > 0) {\n+                    return connection_end::new_version(*connection_end::version_identifier(supported_version), feature_set)\n+                };\n+            };\n+            i = i + 1;\n+        };\n+        abort(E_UNSUPPORTED_VERSION)\n+    }\n+\n+    public fun copy_version(src: &connection_end::Version, dst: &mut connection_end::Version) {\n+        connection_end::set_version_identifier(dst, *connection_end::version_identifier(src));\n+        let src_len = vector::length(connection_end::version_features(src));\n+        let dst_len = vector::length(connection_end::version_features(dst));\n+        let i = 0;\n+        let dst_features = connection_end::version_features_mut(dst);\n+        while (i < src_len) {\n+            if (i < dst_len) {\n+                let src_feature = vector::borrow(connection_end::version_features(src), i);\n+                let dst_feature = vector::borrow_mut(dst_features, i);\n+                *dst_feature = *src_feature;\n+            } else {\n+                let src_feature = vector::borrow(connection_end::version_features(src), i);\n+                vector::push_back(dst_features, *src_feature);\n+            };\n+            i = i + 1;\n+        };\n+        while (i < dst_len) {\n+            vector::remove(dst_features, i);\n+            i = i + 1;\n+        }\n+    }\n+\n+    public fun copy_versions(src: &vector<connection_end::Version>, dst: &mut vector<connection_end::Version>) {\n+        let src_len = vector::length(src);\n+        let dst_len = vector::length(dst);\n+        if (src_len == dst_len) {\n+            let i = 0;\n+            while (i < src_len) {\n+                let src_version = vector::borrow(src, i);\n+                let dst_version = vector::borrow_mut(dst, i);\n+                copy_version(src_version, dst_version);\n+                i = i + 1;\n+            };\n+        } else if (src_len > dst_len) {\n+            let i = 0;\n+            while (i < dst_len) {\n+                let src_version = vector::borrow(src, i);\n+                let dst_version = vector::borrow_mut(dst, i);\n+                copy_version(src_version, dst_version);\n+                i = i + 1;\n+            };\n+            let j = dst_len;\n+            while (j < src_len) {\n+                let src_version = vector::borrow(src, j);\n+                vector::push_back(dst, *src_version);\n+                j = j + 1;\n+            };\n+        } else {\n+            let i = 0;\n+            while (i < src_len) {\n+                let src_version = vector::borrow(src, i);\n+                let dst_version = vector::borrow_mut(dst, i);\n+                copy_version(src_version, dst_version);\n+                i = i + 1;\n+            };\n+            let j = src_len;\n+            while (j < dst_len) {\n+                vector::remove(dst, j);\n+                j = j + 1;\n+            };\n+        }\n+    }\n+\n+\n+    public fun find_supported_version(\n+        supported_versions: &vector<connection_end::Version>,\n+        version: &connection_end::Version\n+    ): (connection_end::Version, bool) {\n+        let found_version = connection_end::default_version();\n+        let found = false;\n+        let len_supported_versions = vector::length(supported_versions);\n+        let i = 0;\n+        while(i < len_supported_versions) {\n+            let v = vector::borrow(supported_versions, i);\n+            if (connection_end::version_identifier(v) == connection_end::version_identifier(version)) {\n+                found_version = *v;\n+                found = true;\n+                break\n+            };\n+            i = i + 1;\n+        };\n+        (found_version, found)\n+    }\n+\n+    public fun verify_proposed_version(\n+        supported_version: &connection_end::Version,\n+        proposed_version: &connection_end::Version\n+    ): bool {\n+        let is_supported = false;\n+        if(connection_end::version_identifier(supported_version) == connection_end::version_identifier(proposed_version)) {\n+            let len_proposed_version = vector::length(connection_end::version_features(proposed_version));\n+            let i = 0;\n+            while(i < len_proposed_version) {\n+                let feature = vector::borrow(connection_end::version_features(proposed_version), i);\n+                is_supported = vector::contains(connection_end::version_features(supported_version), feature);\n+                if(!is_supported) {\n+                    break\n+                };\n+                i = i + 1;\n+            };\n+        };\n+        is_supported\n+    }\n+\n+    public fun verify_client_state(\n+        connection: &ConnectionEnd,\n+        height: height::Height,\n+        path: vector<u8>,\n+        proof: vector<u8>,\n+        client_state_bytes: vector<u8>\n+    ): bool {\n+        let error_code = LightClient::verify_membership(\n+            *connection_end::client_id(connection),\n+            height,\n+            proof,\n+            *connection_end::conn_counterparty_key_prefix(connection),\n+            path,\n+            client_state_bytes\n+        );\n+        assert!(error_code == 0, E_INVALID_CONNECTION_STATE);\n+        true\n+    }\n+\n+    public fun verify_connection_state(\n+        connection: &ConnectionEnd,\n+        height: height::Height,\n+        proof: vector<u8>,\n+        connection_id: String,\n+        counterparty_connection: ConnectionEnd\n+    ): bool {\n+        let error_code = LightClient::verify_membership(\n+            *connection_end::client_id(connection),\n+            height,\n+            proof,\n+            *connection_end::conn_counterparty_key_prefix(connection),\n+            bcs::to_bytes(&IBCCommitment::connection_path(connection_id)),\n+            connection_end::encode_proto(counterparty_connection)\n+        );\n+        assert!(error_code == 0, E_INVALID_CONNECTION_STATE);\n+        true\n+    }\n+\n+    public fun verify_commitment(\n+        connection: &ConnectionEnd,\n+        height: Height,\n+        proof: vector<u8>,\n+        path: String,\n+        commitment: vector<u8>,\n+    ): u64 {\n+        let err = LightClient::verify_membership(\n+            *connection_end::client_id(connection),\n+            height,\n+            proof,\n+            *connection_end::conn_counterparty_key_prefix(connection),\n+            *string::bytes(&path),\n+            commitment\n+        );\n+\n+        err\n+    }\n+\n+    public fun generate_connection_identifier(): String acquires IBCStore {\n+        let store = borrow_global_mut<IBCStore>(get_vault_addr());\n+        let next_sequence_bytes = table::borrow_with_default(\n+            &store.commitments,\n+            b\"nextConnectionSequence\",\n+            &bcs::to_bytes<u64>(&0)\n+        );\n+        let next_sequence = from_bcs::to_u64(*next_sequence_bytes);\n+        let identifier = string::utf8(b\"connection-\");\n+        string::append(&mut identifier, string_utils::to_string(&next_sequence));\n+        let new_sequence = next_sequence + 1;\n+        table::upsert(\n+            &mut store.commitments,\n+            b\"nextConnectionSequence\",\n+            bcs::to_bytes(&new_sequence)\n+        );\n+        identifier\n+    }\n+\n+    public fun update_connection_commitment(store: &mut IBCStore, connection_id: String) {\n+        let connection = smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n         );\n \n-        if (!verify_channel_state(\n-            &connection,\n-            proof_height,\n-            proof_ack,\n-            *channel::chan_counterparty_port_id(&channel),\n-            *channel::chan_counterparty_channel_id(&channel),\n-            bcs::to_bytes(&expected_channel)\n-        )) {\n-            abort(E_INVALID_PROOF)\n-        };\n+        let encoded_connection = connection_end::encode_proto(*connection);\n+        let key = IBCCommitment::connection_commitment_key(connection_id);\n+        let hash = hash::sha2_256(encoded_connection);\n+        table::upsert(&mut store.commitments, key, hash);\n+    }\n \n-        channel::set_state(&mut channel, CHAN_STATE_OPEN);\n-        update_channel_commitment(port_id, channel_id);\n+    public fun get_compatible_versions(): vector<connection_end::Version> {\n+        vector<connection_end::Version>[default_ibc_version()]\n+    }\n \n-        smart_table::upsert(&mut borrow_global_mut<IBCStore>(get_vault_addr()).channels, channel_port, channel);\n+    // Returns connection by `connection_id`. Aborts if the connection does not exist.\n+    #[view]\n+    public fun get_connection(connection_id: String): ConnectionEnd acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n \n-        event::emit(\n-            ChannelOpenConfirm {\n-                port_id,\n-                channel_id,\n-                counterparty_port_id: *channel::chan_counterparty_port_id(&channel),\n-                counterparty_channel_id: *channel::chan_counterparty_channel_id(&channel),\n-                connection_id: *vector::borrow(channel::connection_hops(&channel), 0)\n-            },\n-        );\n+        *smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n+        )\n     }\n \n-    public fun channel_open_try(\n-        ibc_app: &signer,\n-        port_id: String,\n-        connection_hops: vector<String>,\n-        ordering: u8,\n-        counterparty: channel::Counterparty,\n-        counterparty_version: String,\n-        version: String,\n-        proof_init: vector<u8>,\n-        proof_height: height::Height\n-    ): (Channel, u64) acquires IBCStore {\n-        let (connection_id, connection) = ensure_connection_feature(connection_hops, ordering);\n-        \n-        let expected_counterparty = channel::new_counterparty(port_id, string::utf8(b\"\"));\n-        let expected_channel = channel::new(\n-            CHAN_STATE_INIT,\n-            ordering,\n-            expected_counterparty,\n-            get_counterparty_hops(*vector::borrow(&connection_hops, 0)),\n-            counterparty_version\n-        );\n+    // Getter function to retrieve a connection commitment by its ID\n+    #[view]\n+    public fun get_connection_commitment(connection_id: String): vector<u8> acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n+        let key = IBCCommitment::connection_commitment_key(connection_id);\n+        *table::borrow(\n+            &store.commitments,\n+            key,\n+        )\n+    }\n \n-        if (!verify_channel_state(\n-            &connection,\n-            proof_height,\n-            proof_init,\n-            *channel::counterparty_port_id(&counterparty),\n-            *channel::counterparty_channel_id(&counterparty),\n-            bcs::to_bytes(&expected_channel)\n-        )) {\n-            abort(E_INVALID_PROOF)\n+    public fun verify_supported_feature(version: &connection_end::Version, feature: String): bool {\n+        let i = 0;\n+        while (i < vector::length(connection_end::version_features(version))) {\n+            if (*vector::borrow(connection_end::version_features(version), i) == feature) {\n+                return true\n+            };\n+            i = i + 1;\n         };\n+        false\n+    }\n \n-        let channel_id = generate_channel_identifier();\n+    public fun to_string(ordering: u8): String {\n+        let return_val = string::utf8(b\"ORDER_INVALID\");\n+        if (ordering == 1) { // Order.ORDER_UNORDERED\n+            return_val = string::utf8(b\"ORDER_UNORDERED\");\n+        } else if (ordering == 2) { // Order.ORDER_ORDERED\n+            return_val = string::utf8(b\"ORDER_ORDERED\");\n+        };\n+        return_val\n+    }\n \n-        event::emit(\n-            ChannelOpenTry {\n-                port_id,\n-                channel_id,\n-                counterparty_port_id: *channel::counterparty_port_id(&counterparty),\n-                counterparty_channel_id: *channel::counterparty_channel_id(&counterparty),\n-                connection_id,\n-                version: counterparty_version\n-            },\n+\n+    public fun get_counterparty_hops(connection_id: String): vector<String> acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n+        let connection = smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n         );\n+        let hops = vector::empty<String>();\n+        vector::push_back(&mut hops, *connection_end::conn_counterparty_connection_id(connection));\n+        hops\n+    }\n \n-        let channel_port = ChannelPort { port_id, channel_id };\n+    public fun generate_channel_identifier(): String acquires IBCStore {\n         let store = borrow_global_mut<IBCStore>(get_vault_addr());\n-\n-        let channel = channel::new(CHAN_STATE_TRYOPEN, ordering, counterparty, connection_hops, version);\n-        smart_table::upsert(&mut store.channels, channel_port, channel);\n-\n+        let next_sequence_bytes = table::borrow_with_default(\n+            &store.commitments,\n+            b\"nextChannelSequence\",\n+            &bcs::to_bytes<u64>(&0)\n+        );\n+        let next_sequence = from_bcs::to_u64(*next_sequence_bytes);\n+        let identifier = string::utf8(b\"channel-\");\n+        string::append(&mut identifier, string_utils::to_string(&next_sequence));\n+        let new_sequence = next_sequence + 1;\n         table::upsert(\n             &mut store.commitments,\n-            IBCCommitment::next_sequence_send_commitment_key(port_id, channel_id),\n-            bcs::to_bytes(&1)\n+            b\"nextChannelSequence\",\n+            bcs::to_bytes(&new_sequence)\n         );\n+        identifier\n+    }\n \n-        table::upsert(\n-            &mut store.commitments,\n-            IBCCommitment::next_sequence_recv_commitment_key(port_id, channel_id),\n-            bcs::to_bytes(&1)\n+    public fun ensure_connection_state(connection_id: String): ConnectionEnd acquires IBCStore {\n+        let store = borrow_global<IBCStore>(get_vault_addr());\n+        let connection = smart_table::borrow(\n+            &store.connections,\n+            connection_id,\n         );\n+        if (connection_end::state(connection) != CONN_STATE_OPEN) {\n+            abort(E_INVALID_CONNECTION_STATE)\n+        };\n+        *connection\n+    }\n \n-        table::upsert(\n-            &mut store.commitments,\n-            IBCCommitment::next_sequence_ack_commitment_key(port_id, channel_id),\n-            bcs::to_bytes(&1)\n+    // TODO(aeryz): borrow instead of copy\n+    public fun ensure_connection_feature(connection_hops: vector<String>, ordering: u8): (String, ConnectionEnd) acquires IBCStore {\n+        if (vector::length(&connection_hops) != 1) {\n+            abort(E_CONN_NOT_SINGLE_HOP)\n+        };\n+        let connection_id = *vector::borrow(&connection_hops, 0);\n+        let connection = ensure_connection_state(connection_id);\n+        if (vector::length(connection_end::versions(&connection)) != 1) {\n+            abort(E_CONN_NOT_SINGLE_VERSION)\n+        };\n+        let version = *vector::borrow(connection_end::versions(&connection), 0);\n+        if (!verify_supported_feature(&version, to_string(ordering))) {\n+            abort(E_UNSUPPORTED_FEATURE)\n+        };\n+        (connection_id, connection)\n+    }\n+\n+    // TODO: Here the implementation returns false if there is any uppercase character in the string\n+    // eg: \"portId\" will return false but \"port-0\" will return true. Is this correct way to check?\n+    public fun is_lowercase(s: &String): bool {\n+        let bytes = bcs::to_bytes(s);\n+        let i = 1; // First byte is the length of the string\n+        while (i < vector::length(&bytes)) {\n+            let byte = *vector::borrow(&bytes, i);\n+            // if (byte < 0x61 || byte > 0x7A) { // ASCII values for 'a' and 'z'\n+            //     return false;\n+            // };\n+            if (byte > 0x40 && byte < 0x5b) {\n+                return false\n+            };\n+            i = i + 1;\n+        };\n+        true\n+    }",
        "comment_created_at": "2024-09-02T13:09:00+00:00",
        "comment_author": "benluelo",
        "comment_body": "the reason we did this in the solidity contract is that we re-encode the port (contract address) as hex when indexing into the capabilities table, and if you create the channel with a checksummed address as the port id then it doesn't match and you can't actually send any packets on the channel. i'm not sure how this will work in move, but do keep it in mind",
        "pr_file_module": null
      }
    ]
  }
]