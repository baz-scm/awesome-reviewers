[
  {
    "discussion_id": "2158783794",
    "pr_number": 4679,
    "pr_file": "hubble/src/indexer/event.rs",
    "created_at": "2025-06-20T11:53:25+00:00",
    "commented_code": "+use std::{\n+    collections::HashMap,\n+    fmt::{self, Display},\n+    str::FromStr,\n+};\n+\n+use bytes::Bytes;\n+use hex::decode;\n+use itertools::Itertools;\n+use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+use serde_json::Value;\n+use sha2::Digest;\n+use sqlx::Postgres;\n+use time::OffsetDateTime;\n+use tracing::debug;\n+\n+use crate::indexer::{\n+    api::{BlockHeight, BlockRange, BlockReference, FetcherClient, IndexerError, UniversalChainId},\n+    nats::subject_for_block,\n+    postgres::nats::schedule,\n+    Indexer,\n+};\n+\n+#[derive(serde::Serialize, serde::Deserialize)]\n+pub struct HubbleEvent {\n+    pub version: u8,",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2158783794",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4679,
        "pr_file": "hubble/src/indexer/event.rs",
        "discussion_id": "2158783794",
        "commented_code": "@@ -0,0 +1,324 @@\n+use std::{\n+    collections::HashMap,\n+    fmt::{self, Display},\n+    str::FromStr,\n+};\n+\n+use bytes::Bytes;\n+use hex::decode;\n+use itertools::Itertools;\n+use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+use serde_json::Value;\n+use sha2::Digest;\n+use sqlx::Postgres;\n+use time::OffsetDateTime;\n+use tracing::debug;\n+\n+use crate::indexer::{\n+    api::{BlockHeight, BlockRange, BlockReference, FetcherClient, IndexerError, UniversalChainId},\n+    nats::subject_for_block,\n+    postgres::nats::schedule,\n+    Indexer,\n+};\n+\n+#[derive(serde::Serialize, serde::Deserialize)]\n+pub struct HubbleEvent {\n+    pub version: u8,",
        "comment_created_at": "2025-06-20T11:53:25+00:00",
        "comment_author": "cor",
        "comment_body": "how is backwards/forwards compatibility defined with this versioning system? does perhaps some sort of semver system make sense for if a producer starts providing extra data that is _optionally_ consumed and not a breaking update?",
        "pr_file_module": null
      },
      {
        "comment_id": "2158813016",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4679,
        "pr_file": "hubble/src/indexer/event.rs",
        "discussion_id": "2158783794",
        "commented_code": "@@ -0,0 +1,324 @@\n+use std::{\n+    collections::HashMap,\n+    fmt::{self, Display},\n+    str::FromStr,\n+};\n+\n+use bytes::Bytes;\n+use hex::decode;\n+use itertools::Itertools;\n+use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+use serde_json::Value;\n+use sha2::Digest;\n+use sqlx::Postgres;\n+use time::OffsetDateTime;\n+use tracing::debug;\n+\n+use crate::indexer::{\n+    api::{BlockHeight, BlockRange, BlockReference, FetcherClient, IndexerError, UniversalChainId},\n+    nats::subject_for_block,\n+    postgres::nats::schedule,\n+    Indexer,\n+};\n+\n+#[derive(serde::Serialize, serde::Deserialize)]\n+pub struct HubbleEvent {\n+    pub version: u8,",
        "comment_created_at": "2025-06-20T12:09:37+00:00",
        "comment_author": "qlp",
        "comment_body": "not specified yet, it's mostly a tag that we can use to handle change. imo we should not process messages if we're not supporting the version (so consumers should nack them, but should be backward compatible).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012949588",
    "pr_number": 4119,
    "pr_file": "lib/mpt-trusted-light-client-types/src/client_state.rs",
    "created_at": "2025-03-25T21:13:37+00:00",
    "commented_code": "+use unionlabs::primitives::{H160, U256};\n+\n+#[derive(Debug, Clone, PartialEq)]\n+#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n+#[cfg_attr(feature = \"bincode\", derive(bincode::Encode, bincode::Decode))]\n+pub struct ClientState {\n+    pub chain_id: U256,\n+    pub latest_height: u64,\n+    pub ibc_contract_address: H160,\n+    pub whitelisted_relayers: Vec<String>,\n+}",
    "repo_full_name": "unionlabs/union",
    "discussion_comments": [
      {
        "comment_id": "2012949588",
        "repo_full_name": "unionlabs/union",
        "pr_number": 4119,
        "pr_file": "lib/mpt-trusted-light-client-types/src/client_state.rs",
        "discussion_id": "2012949588",
        "commented_code": "@@ -0,0 +1,11 @@\n+use unionlabs::primitives::{H160, U256};\n+\n+#[derive(Debug, Clone, PartialEq)]\n+#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n+#[cfg_attr(feature = \"bincode\", derive(bincode::Encode, bincode::Decode))]\n+pub struct ClientState {\n+    pub chain_id: U256,\n+    pub latest_height: u64,\n+    pub ibc_contract_address: H160,\n+    pub whitelisted_relayers: Vec<String>,\n+}",
        "comment_created_at": "2025-03-25T21:13:37+00:00",
        "comment_author": "benluelo",
        "comment_body": "version this (`enum ClientState { V1(ClientStateV1) }`)",
        "pr_file_module": null
      }
    ]
  }
]