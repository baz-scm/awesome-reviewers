[
  {
    "discussion_id": "1571767823",
    "pr_number": 2905,
    "pr_file": "test_unstructured_ingest/unit/pipeline/reformat/test_chunking.py",
    "created_at": "2024-04-19T04:25:06+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+import os\n+import tempfile\n+\n+import pytest\n+from _pytest.logging import LogCaptureFixture\n+\n+from test_unstructured.unit_utils import (\n+    FixtureRequest,\n+    Mock,\n+    example_doc_path,\n+    function_mock,\n+    method_mock,\n+)\n+from unstructured.documents.elements import CompositeElement\n+from unstructured.ingest.interfaces import ChunkingConfig, PartitionConfig\n+from unstructured.ingest.pipeline.interfaces import PipelineContext\n+from unstructured.ingest.pipeline.reformat.chunking import Chunker\n+\n+ELEMENTS_JSON_FILE = example_doc_path(\n+    \"test_evaluate_files/unstructured_output/Bank Good Credit Loan.pptx.json\"\n+)\n+\n+\n+class DescribeChunker:\n+    \"\"\"Unit tests for ingest.pipeline.reformat.chunking.Chunker\"\"\"\n+\n+    # -- Chunker.run() -----------------------------------------------------------------------------\n+\n+    # -- integration test --\n+    def it_creates_json(self, _ingest_docs_map_: Mock):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_title\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig()\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        with tempfile.TemporaryDirectory() as tmpdir:\n+            # -- `Chunker.chunk()` defaults to writing to \"{work_dir}/chunked\", which is located in\n+            # -- \"/.cache\" of a user's profile.\n+            # -- Define `work_dir` add the \"/chunked\" subdirectory to it:\n+            chunker.pipeline_context.work_dir = tmpdir\n+            os.makedirs(os.path.join(tmpdir, \"chunked\"), exist_ok=True)\n+\n+            filename = chunker.run(ELEMENTS_JSON_FILE)\n+            head, tail = os.path.split(filename if filename else \"\")\n+            # -- Check that a json file was created in `/chunked` --\n+            assert head.endswith(\"chunked\")\n+            assert tail.endswith(\".json\")\n+\n+    def it_logs_error_with_invalid_remote_chunking_args(\n+        self, _ingest_docs_map_: Mock, caplog: LogCaptureFixture\n+    ):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_invalid\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig(partition_by_api=True)\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        chunker.run(ELEMENTS_JSON_FILE)\n+        assert \"Input should be 'basic', 'by_page', 'by_similarity'\" in caplog.text\n+\n+    def it_warns_with_nonlocal_chunking_strategy_and_partition_by_api_False(\n+        self, _ingest_docs_map_: Mock, caplog: LogCaptureFixture\n+    ):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_similarity\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig(partition_by_api=True)\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+\n+        chunker.run(ELEMENTS_JSON_FILE)\n+        assert \"There is no locally available chunking_strategy:\" in caplog.text\n+\n+    # -- Chunker.chunk() ---------------------------------------------------------------------------\n+\n+    def it_skips_chunking_if_strategy_is_None(self):\n+        chunking_config = ChunkingConfig(chunking_strategy=None)\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig()\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        assert chunker.chunk(ELEMENTS_JSON_FILE) is None\n+\n+    # -- integration test --\n+    @pytest.mark.parametrize(\"strategy\", [\"by_title\", \"basic\"])\n+    def it_chunks_locally(self, strategy: str, _ingest_docs_map_: Mock):\n+        chunking_config = ChunkingConfig(chunking_strategy=strategy)\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig()\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        chunked_elements = chunker.chunk(ELEMENTS_JSON_FILE)\n+        assert all(isinstance(elem, CompositeElement) for elem in chunked_elements)  # type: ignore\n+\n+    def it_chunks_remotely(self, _ingest_docs_map_: Mock, _partition_via_api_: Mock):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_similarity\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig(partition_by_api=True, api_key=\"aaaaaaaaaaaaaaaaaaaaa\")\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+\n+        chunker.chunk(ELEMENTS_JSON_FILE)",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1571767823",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2905,
        "pr_file": "test_unstructured_ingest/unit/pipeline/reformat/test_chunking.py",
        "discussion_id": "1571767823",
        "commented_code": "@@ -0,0 +1,144 @@\n+from __future__ import annotations\n+\n+import os\n+import tempfile\n+\n+import pytest\n+from _pytest.logging import LogCaptureFixture\n+\n+from test_unstructured.unit_utils import (\n+    FixtureRequest,\n+    Mock,\n+    example_doc_path,\n+    function_mock,\n+    method_mock,\n+)\n+from unstructured.documents.elements import CompositeElement\n+from unstructured.ingest.interfaces import ChunkingConfig, PartitionConfig\n+from unstructured.ingest.pipeline.interfaces import PipelineContext\n+from unstructured.ingest.pipeline.reformat.chunking import Chunker\n+\n+ELEMENTS_JSON_FILE = example_doc_path(\n+    \"test_evaluate_files/unstructured_output/Bank Good Credit Loan.pptx.json\"\n+)\n+\n+\n+class DescribeChunker:\n+    \"\"\"Unit tests for ingest.pipeline.reformat.chunking.Chunker\"\"\"\n+\n+    # -- Chunker.run() -----------------------------------------------------------------------------\n+\n+    # -- integration test --\n+    def it_creates_json(self, _ingest_docs_map_: Mock):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_title\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig()\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        with tempfile.TemporaryDirectory() as tmpdir:\n+            # -- `Chunker.chunk()` defaults to writing to \"{work_dir}/chunked\", which is located in\n+            # -- \"/.cache\" of a user's profile.\n+            # -- Define `work_dir` add the \"/chunked\" subdirectory to it:\n+            chunker.pipeline_context.work_dir = tmpdir\n+            os.makedirs(os.path.join(tmpdir, \"chunked\"), exist_ok=True)\n+\n+            filename = chunker.run(ELEMENTS_JSON_FILE)\n+            head, tail = os.path.split(filename if filename else \"\")\n+            # -- Check that a json file was created in `/chunked` --\n+            assert head.endswith(\"chunked\")\n+            assert tail.endswith(\".json\")\n+\n+    def it_logs_error_with_invalid_remote_chunking_args(\n+        self, _ingest_docs_map_: Mock, caplog: LogCaptureFixture\n+    ):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_invalid\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig(partition_by_api=True)\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        chunker.run(ELEMENTS_JSON_FILE)\n+        assert \"Input should be 'basic', 'by_page', 'by_similarity'\" in caplog.text\n+\n+    def it_warns_with_nonlocal_chunking_strategy_and_partition_by_api_False(\n+        self, _ingest_docs_map_: Mock, caplog: LogCaptureFixture\n+    ):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_similarity\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig(partition_by_api=True)\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+\n+        chunker.run(ELEMENTS_JSON_FILE)\n+        assert \"There is no locally available chunking_strategy:\" in caplog.text\n+\n+    # -- Chunker.chunk() ---------------------------------------------------------------------------\n+\n+    def it_skips_chunking_if_strategy_is_None(self):\n+        chunking_config = ChunkingConfig(chunking_strategy=None)\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig()\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        assert chunker.chunk(ELEMENTS_JSON_FILE) is None\n+\n+    # -- integration test --\n+    @pytest.mark.parametrize(\"strategy\", [\"by_title\", \"basic\"])\n+    def it_chunks_locally(self, strategy: str, _ingest_docs_map_: Mock):\n+        chunking_config = ChunkingConfig(chunking_strategy=strategy)\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig()\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+        chunked_elements = chunker.chunk(ELEMENTS_JSON_FILE)\n+        assert all(isinstance(elem, CompositeElement) for elem in chunked_elements)  # type: ignore\n+\n+    def it_chunks_remotely(self, _ingest_docs_map_: Mock, _partition_via_api_: Mock):\n+        chunking_config = ChunkingConfig(chunking_strategy=\"by_similarity\")\n+        pipeline_context = PipelineContext()\n+        partition_config = PartitionConfig(partition_by_api=True, api_key=\"aaaaaaaaaaaaaaaaaaaaa\")\n+        chunker = Chunker(\n+            chunking_config=chunking_config,\n+            pipeline_context=pipeline_context,\n+            partition_config=partition_config,\n+        )\n+\n+        chunker.chunk(ELEMENTS_JSON_FILE)",
        "comment_created_at": "2024-04-19T04:25:06+00:00",
        "comment_author": "scanny",
        "comment_body": "All tests have three parts, setting up the test-fixture, running the unit under test, and then verifying the results. There are different names for it around like Arrange-Act-Assert and others you can find around.\r\n\r\nI find it very helpful to the reader to separate the three sections with a blank line (and keep the sections together with no blank lines but sometimes comment lines.\r\n\r\nThe first question when reading a test or trying to find the test you're interested in is always: What is the unit under test? (unit being function or method generally). Making the line that exercises the unit stand out by being surrounded by a blank line above and below eases that search.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1577221869",
    "pr_number": 2905,
    "pr_file": "test_unstructured_ingest/unit/pipeline/reformat/test_chunking.py",
    "created_at": "2024-04-24T04:00:59+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+import logging\n+import os\n+\n+import pytest\n+from _pytest.logging import LogCaptureFixture\n+\n+from test_unstructured.unit_utils import (\n+    FixtureRequest,\n+    Mock,\n+    example_doc_path,\n+    function_mock,\n+    method_mock,\n+)\n+from unstructured.documents.elements import CompositeElement\n+from unstructured.ingest.interfaces import ChunkingConfig, PartitionConfig\n+from unstructured.ingest.pipeline.interfaces import PipelineContext\n+from unstructured.ingest.pipeline.reformat.chunking import Chunker\n+\n+ELEMENTS_JSON_FILE = example_doc_path(\n+    \"test_evaluate_files/unstructured_output/Bank Good Credit Loan.pptx.json\"\n+)\n+\n+\n+class DescribeChunker:\n+    \"\"\"Unit tests for ingest.pipeline.reformat.chunking.Chunker\"\"\"\n+\n+    # -- Chunker.run() -----------------------------------------------------------------------------\n+\n+    # -- integration test --\n+    def it_creates_json(self, _ingest_docs_map_: Mock, tmpdir: str):\n+        chunker = Chunker(\n+            chunking_config=ChunkingConfig(chunking_strategy=\"by_title\"),\n+            pipeline_context=PipelineContext(work_dir=tmpdir),\n+            partition_config=PartitionConfig(),\n+        )\n+        # -- `Chunker.chunk()` defaults to writing to \"{work_dir}/chunked\", which is located in\n+        # -- \"/.cache\" of a user's profile.\n+        # -- Define `work_dir` add the \"/chunked\" subdirectory to it:\n+        os.makedirs(os.path.join(tmpdir, \"chunked\"), exist_ok=True)\n+\n+        filename = chunker.run(ELEMENTS_JSON_FILE)\n+\n+        head, tail = os.path.split(filename if filename else \"\")\n+        # -- Check that a json file was created in `/chunked` --\n+        assert head.endswith(\"chunked\")\n+        assert tail.endswith(\".json\")",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1577221869",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2905,
        "pr_file": "test_unstructured_ingest/unit/pipeline/reformat/test_chunking.py",
        "discussion_id": "1577221869",
        "commented_code": "@@ -0,0 +1,147 @@\n+from __future__ import annotations\n+\n+import logging\n+import os\n+\n+import pytest\n+from _pytest.logging import LogCaptureFixture\n+\n+from test_unstructured.unit_utils import (\n+    FixtureRequest,\n+    Mock,\n+    example_doc_path,\n+    function_mock,\n+    method_mock,\n+)\n+from unstructured.documents.elements import CompositeElement\n+from unstructured.ingest.interfaces import ChunkingConfig, PartitionConfig\n+from unstructured.ingest.pipeline.interfaces import PipelineContext\n+from unstructured.ingest.pipeline.reformat.chunking import Chunker\n+\n+ELEMENTS_JSON_FILE = example_doc_path(\n+    \"test_evaluate_files/unstructured_output/Bank Good Credit Loan.pptx.json\"\n+)\n+\n+\n+class DescribeChunker:\n+    \"\"\"Unit tests for ingest.pipeline.reformat.chunking.Chunker\"\"\"\n+\n+    # -- Chunker.run() -----------------------------------------------------------------------------\n+\n+    # -- integration test --\n+    def it_creates_json(self, _ingest_docs_map_: Mock, tmpdir: str):\n+        chunker = Chunker(\n+            chunking_config=ChunkingConfig(chunking_strategy=\"by_title\"),\n+            pipeline_context=PipelineContext(work_dir=tmpdir),\n+            partition_config=PartitionConfig(),\n+        )\n+        # -- `Chunker.chunk()` defaults to writing to \"{work_dir}/chunked\", which is located in\n+        # -- \"/.cache\" of a user's profile.\n+        # -- Define `work_dir` add the \"/chunked\" subdirectory to it:\n+        os.makedirs(os.path.join(tmpdir, \"chunked\"), exist_ok=True)\n+\n+        filename = chunker.run(ELEMENTS_JSON_FILE)\n+\n+        head, tail = os.path.split(filename if filename else \"\")\n+        # -- Check that a json file was created in `/chunked` --\n+        assert head.endswith(\"chunked\")\n+        assert tail.endswith(\".json\")",
        "comment_created_at": "2024-04-24T04:00:59+00:00",
        "comment_author": "scanny",
        "comment_body": "Hmm, this seems like a weak test. I'd be inclined to open that file, parse the contents (`elements = json.load(...)`), and then make some assertions about the contents. A couple go-to facts about chunking that could make more convincing assertions:\r\n\r\n- Chunk count should be consistent, like `len(chunks) == 42`.\r\n- A chunk can only ever be a `CompositeElement`, a `Table`, or a `TableChunk`. `CompositeElement` and `TableChunk` never show up in partitioner output, so something like:\r\n    ```python\r\n    assert all(e[\"type\"] in (\"CompositeElement, ...) for e in elements)\r\n    ```\r\n- Maybe a spot check on text like `assert elements[4].text.startswith(\"Demographic: Base file ...\")\r\n- The assertions on the filename are fine, those can stay, just not really enough by themselves.\r\n\r\nThen I would name this: `it_chunks_JSON_elements()` and you will have demonstrated that convincingly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1492840825",
    "pr_number": 2554,
    "pr_file": "test_unstructured/test_utils.py",
    "created_at": "2024-02-16T18:26:25+00:00",
    "commented_code": "],\n             ),\n         ),\n+        (",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1492840825",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2554,
        "pr_file": "test_unstructured/test_utils.py",
        "discussion_id": "1492840825",
        "commented_code": "@@ -223,6 +220,76 @@ def test_only_raises_if_empty(iterator):\n                 ],\n             ),\n         ),\n+        (",
        "comment_created_at": "2024-02-16T18:26:25+00:00",
        "comment_author": "scanny",
        "comment_body": "The test case inputs are mostly repeated and it makes reading this test a scrolling chore. Can you extract the differentiators to the parameters and place the repeated parts in the test body. I'm thinking this looks something like:\r\n```python\r\n@pytest.paramatrize(\r\n    (\"coords\", \"coords2\", \"expectation\"),\r\n    (\r\n        (\r\n            ((4, 5), (4, 8), ...),\r\n            ((2, 3), (2, 6), ...),\r\n            {\r\n                \"overlapping_elements\": ...\r\n                ...\r\n            },\r\n            ...\r\n        ),\r\n\r\n)\r\ndef test...():\r\n    elements = [\r\n         Title(..., coords),\r\n         NarrativeText(... coords2),\r\n    ]\r\n\r\n    assert overlapping_flag is True\r\n    assert overlapping_cases == [expectation]\r\n```\r\nThis reduces the vertical size by over 150 lines (12 + 1 + 6) * 8 = 152\r\n\r\nThen the last case would be a separate test like `test_it_does_not_catch_non_overlapping_cases()`, that way you can parametrize only the dict part of the response and provide the rest in the test body.\r\n\r\nWhile you're a",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1496408053",
    "pr_number": 2554,
    "pr_file": "test_unstructured/test_utils.py",
    "created_at": "2024-02-20T19:55:55+00:00",
    "commented_code": "with pytest.raises(ValueError):\n         utils.validate_date_args(None)\n+\n+\n+def test_validate_date_args_accepts_standard_formats():\n+    assert utils.validate_date_args(\"1990-12-01\")\n+    assert utils.validate_date_args(\"2050-01-01T00:00:00\")\n+    assert utils.validate_date_args(\"2050-01-01+00:00:00\")\n+    assert utils.validate_date_args(\"2022-02-12T14:30:00-0500\")\n+\n+\n+def test_validate_date_args_raises_for_invalid_formats():",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1496408053",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2554,
        "pr_file": "test_unstructured/test_utils.py",
        "discussion_id": "1496408053",
        "commented_code": "@@ -337,3 +311,66 @@ def test_validate_data_args():\n \n     with pytest.raises(ValueError):\n         utils.validate_date_args(None)\n+\n+\n+def test_validate_date_args_accepts_standard_formats():\n+    assert utils.validate_date_args(\"1990-12-01\")\n+    assert utils.validate_date_args(\"2050-01-01T00:00:00\")\n+    assert utils.validate_date_args(\"2050-01-01+00:00:00\")\n+    assert utils.validate_date_args(\"2022-02-12T14:30:00-0500\")\n+\n+\n+def test_validate_date_args_raises_for_invalid_formats():",
        "comment_created_at": "2024-02-20T19:55:55+00:00",
        "comment_author": "scanny",
        "comment_body": "You're going to need to parameterize this test. Only the first case will execute because it raises, then the remaining just get skipped.\r\n\r\nAlso, you should use the `match` arg to `pytest.raises()` to give an idea what the error message looks like. That takes a regex so you can just provide the beginning, middle, or end if that's convenient for skipping details. Doing so gives the reader a more vivid view of the behavior. Also it points up crappy error messages :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1496419947",
    "pr_number": 2554,
    "pr_file": "test_unstructured/test_utils.py",
    "created_at": "2024-02-20T20:04:12+00:00",
    "commented_code": "with pytest.raises(ValueError):\n         utils.validate_date_args(None)\n+\n+\n+def test_validate_date_args_accepts_standard_formats():\n+    assert utils.validate_date_args(\"1990-12-01\")\n+    assert utils.validate_date_args(\"2050-01-01T00:00:00\")\n+    assert utils.validate_date_args(\"2050-01-01+00:00:00\")\n+    assert utils.validate_date_args(\"2022-02-12T14:30:00-0500\")\n+\n+\n+def test_validate_date_args_raises_for_invalid_formats():\n+    with pytest.raises(ValueError):\n+        assert utils.validate_date_args(None)\n+        assert utils.validate_date_args(\"not a date\")\n+        assert utils.validate_date_args(\"1990-12-33\")\n+        assert utils.validate_date_args(\"2022-02-12T14:30:00-2000\")\n+\n+\n+def test_htmlify_matrix_handles_empty_cells():\n+    matrix = [[\"cell1\", \"\", \"cell3\"], [\"\", \"cell5\", \"\"]]\n+    expected_html = (\n+        \"<table><tr><td>cell1</td><td></td><td>cell3</td></tr>\"\n+        \"<tr><td></td><td>cell5</td><td></td></tr></table>\"\n+    )",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1496419947",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2554,
        "pr_file": "test_unstructured/test_utils.py",
        "discussion_id": "1496419947",
        "commented_code": "@@ -337,3 +311,66 @@ def test_validate_data_args():\n \n     with pytest.raises(ValueError):\n         utils.validate_date_args(None)\n+\n+\n+def test_validate_date_args_accepts_standard_formats():\n+    assert utils.validate_date_args(\"1990-12-01\")\n+    assert utils.validate_date_args(\"2050-01-01T00:00:00\")\n+    assert utils.validate_date_args(\"2050-01-01+00:00:00\")\n+    assert utils.validate_date_args(\"2022-02-12T14:30:00-0500\")\n+\n+\n+def test_validate_date_args_raises_for_invalid_formats():\n+    with pytest.raises(ValueError):\n+        assert utils.validate_date_args(None)\n+        assert utils.validate_date_args(\"not a date\")\n+        assert utils.validate_date_args(\"1990-12-33\")\n+        assert utils.validate_date_args(\"2022-02-12T14:30:00-2000\")\n+\n+\n+def test_htmlify_matrix_handles_empty_cells():\n+    matrix = [[\"cell1\", \"\", \"cell3\"], [\"\", \"cell5\", \"\"]]\n+    expected_html = (\n+        \"<table><tr><td>cell1</td><td></td><td>cell3</td></tr>\"\n+        \"<tr><td></td><td>cell5</td><td></td></tr></table>\"\n+    )",
        "comment_created_at": "2024-02-20T20:04:12+00:00",
        "comment_author": "scanny",
        "comment_body": "It's generally best to avoid trivial variables that are used only once. It introduces a level of abstraction that detracts from the direct-reading of the test, like giving this produces that.\r\n\r\nIn this case:\r\n```python\r\n    assert utils.htmlify_matrix_of_cell_texts(matrix) == (\r\n        \"<table><tr><td>cell1</td><td></td><td>cell3</td></tr>\"\r\n        \"<tr><td></td><td>cell5</td><td></td></tr></table>\"\r\n    )\r\n```\r\nremoves that level of abstraction. Even this in this case:\r\n```python\r\n    assert utils.htmlify_matrix_of_cell_texts(matrix=[[\"cell1\", \"\", \"cell3\"], [\"\", \"cell5\", \"\"]]) == (\r\n        \"<table><tr><td>cell1</td><td></td><td>cell3</td></tr>\"\r\n        \"<tr><td></td><td>cell5</td><td></td></tr></table>\"\r\n    )\r\n```\r\nyou have the `matrix=` in the call, which is just as informative as an assignment, and the additional step of mentally mapping `expected_html` to that string is removed.\r\n\r\nYou can reserve using variables like this for when the value is actually variable, such as in a parameterized test.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1496427815",
    "pr_number": 2554,
    "pr_file": "test_unstructured/test_utils.py",
    "created_at": "2024-02-20T20:09:09+00:00",
    "commented_code": "with pytest.raises(ValueError):\n         utils.validate_date_args(None)\n+\n+\n+def test_validate_date_args_accepts_standard_formats():\n+    assert utils.validate_date_args(\"1990-12-01\")\n+    assert utils.validate_date_args(\"2050-01-01T00:00:00\")\n+    assert utils.validate_date_args(\"2050-01-01+00:00:00\")\n+    assert utils.validate_date_args(\"2022-02-12T14:30:00-0500\")\n+\n+\n+def test_validate_date_args_raises_for_invalid_formats():\n+    with pytest.raises(ValueError):\n+        assert utils.validate_date_args(None)\n+        assert utils.validate_date_args(\"not a date\")\n+        assert utils.validate_date_args(\"1990-12-33\")\n+        assert utils.validate_date_args(\"2022-02-12T14:30:00-2000\")\n+\n+\n+def test_htmlify_matrix_handles_empty_cells():\n+    matrix = [[\"cell1\", \"\", \"cell3\"], [\"\", \"cell5\", \"\"]]\n+    expected_html = (\n+        \"<table><tr><td>cell1</td><td></td><td>cell3</td></tr>\"\n+        \"<tr><td></td><td>cell5</td><td></td></tr></table>\"\n+    )\n+    assert utils.htmlify_matrix_of_cell_texts(matrix) == expected_html\n+\n+\n+def test_htmlify_matrix_handles_special_characters():\n+    matrix = [['<>&\"', \"newline\n\"]]\n+    expected_html = \"<table><tr><td>&lt;&gt;&amp;&quot;</td><td>newline<br/></td></tr></table>\"\n+    assert utils.htmlify_matrix_of_cell_texts(matrix) == expected_html\n+\n+\n+def test_htmlify_matrix_handles_multiple_rows_and_cells():\n+    matrix = [[\"cell1\", \"cell2\"], [\"cell3\", \"cell4\"]]\n+    expected_html = (\n+        \"<table><tr><td>cell1</td><td>cell2</td></tr><tr><td>cell3</td><td>cell4</td></tr></table>\"\n+    )\n+    assert utils.htmlify_matrix_of_cell_texts(matrix) == expected_html\n+\n+\n+def test_htmlify_matrix_handles_empty_matrix():\n+    assert utils.htmlify_matrix_of_cell_texts([]) == \"\"\n+\n+\n+def test_only_returns_singleton_iterable():\n+    singleton_iterable = [42]\n+    result = utils.only(singleton_iterable)\n+    assert result == 42\n+\n+\n+def test_only_raises_on_non_singleton_iterable():\n+    singleton_iterable = [42, 0]\n+    with pytest.raises(ValueError):\n+        utils.only(singleton_iterable)\n+\n+\n+def test_calculate_shared_ngram_percentage_returns_null_vals_for_empty_str():\n+    str1 = \"\"\n+    str2 = \"banana orange pineapple\"\n+    n = 2\n+    percent, common_ngrams = utils.calculate_shared_ngram_percentage(str1, str2, n)\n+    assert percent == 0\n+    assert not bool(common_ngrams)",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1496427815",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2554,
        "pr_file": "test_unstructured/test_utils.py",
        "discussion_id": "1496427815",
        "commented_code": "@@ -337,3 +311,66 @@ def test_validate_data_args():\n \n     with pytest.raises(ValueError):\n         utils.validate_date_args(None)\n+\n+\n+def test_validate_date_args_accepts_standard_formats():\n+    assert utils.validate_date_args(\"1990-12-01\")\n+    assert utils.validate_date_args(\"2050-01-01T00:00:00\")\n+    assert utils.validate_date_args(\"2050-01-01+00:00:00\")\n+    assert utils.validate_date_args(\"2022-02-12T14:30:00-0500\")\n+\n+\n+def test_validate_date_args_raises_for_invalid_formats():\n+    with pytest.raises(ValueError):\n+        assert utils.validate_date_args(None)\n+        assert utils.validate_date_args(\"not a date\")\n+        assert utils.validate_date_args(\"1990-12-33\")\n+        assert utils.validate_date_args(\"2022-02-12T14:30:00-2000\")\n+\n+\n+def test_htmlify_matrix_handles_empty_cells():\n+    matrix = [[\"cell1\", \"\", \"cell3\"], [\"\", \"cell5\", \"\"]]\n+    expected_html = (\n+        \"<table><tr><td>cell1</td><td></td><td>cell3</td></tr>\"\n+        \"<tr><td></td><td>cell5</td><td></td></tr></table>\"\n+    )\n+    assert utils.htmlify_matrix_of_cell_texts(matrix) == expected_html\n+\n+\n+def test_htmlify_matrix_handles_special_characters():\n+    matrix = [['<>&\"', \"newline\\n\"]]\n+    expected_html = \"<table><tr><td>&lt;&gt;&amp;&quot;</td><td>newline<br/></td></tr></table>\"\n+    assert utils.htmlify_matrix_of_cell_texts(matrix) == expected_html\n+\n+\n+def test_htmlify_matrix_handles_multiple_rows_and_cells():\n+    matrix = [[\"cell1\", \"cell2\"], [\"cell3\", \"cell4\"]]\n+    expected_html = (\n+        \"<table><tr><td>cell1</td><td>cell2</td></tr><tr><td>cell3</td><td>cell4</td></tr></table>\"\n+    )\n+    assert utils.htmlify_matrix_of_cell_texts(matrix) == expected_html\n+\n+\n+def test_htmlify_matrix_handles_empty_matrix():\n+    assert utils.htmlify_matrix_of_cell_texts([]) == \"\"\n+\n+\n+def test_only_returns_singleton_iterable():\n+    singleton_iterable = [42]\n+    result = utils.only(singleton_iterable)\n+    assert result == 42\n+\n+\n+def test_only_raises_on_non_singleton_iterable():\n+    singleton_iterable = [42, 0]\n+    with pytest.raises(ValueError):\n+        utils.only(singleton_iterable)\n+\n+\n+def test_calculate_shared_ngram_percentage_returns_null_vals_for_empty_str():\n+    str1 = \"\"\n+    str2 = \"banana orange pineapple\"\n+    n = 2\n+    percent, common_ngrams = utils.calculate_shared_ngram_percentage(str1, str2, n)\n+    assert percent == 0\n+    assert not bool(common_ngrams)",
        "comment_created_at": "2024-02-20T20:09:09+00:00",
        "comment_author": "scanny",
        "comment_body": "same principle on all the rest of these, except `test_htmlify_matrix_handles_empty_matrix()` which you intuitively followed this principle. All of these can be single-statement asserts (counting `with pytest.raises` as a single statement when it has a single-line body).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1480472152",
    "pr_number": 2510,
    "pr_file": "test_unstructured/partition/docx/test_docx.py",
    "created_at": "2024-02-06T20:02:27+00:00",
    "commented_code": "assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-inline-shapes.docx\"))",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1480472152",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2510,
        "pr_file": "test_unstructured/partition/docx/test_docx.py",
        "discussion_id": "1480472152",
        "commented_code": "@@ -764,6 +764,31 @@ def test_partition_docx_includes_hyperlink_metadata():\n     assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-inline-shapes.docx\"))",
        "comment_created_at": "2024-02-06T20:02:27+00:00",
        "comment_author": "scanny",
        "comment_body": "I would create a single document that contains several examples you can access via indexing. Separate paragraphs should be enough.\r\n\r\nI think you're going to want more cases and if it's a single document that's easy, just add more paragraphs.\r\n\r\nThe individual cases should be parameterized, something like this: https://github.com/Unstructured-IO/unstructured/blob/29b9ea7ba675f0627b51a4afa32c0350075c2746/test_unstructured/partition/csv/test_tsv.py#L18\r\n\r\nI think you still need two tests (one for finds and one for excludes) but they can use the same file.\r\n\r\nA couple questions to guide the test-case development.\r\n- What is the role of text inside an image? Is it a caption or something?\r\n- What possible relationships can the text have to the image? Is there a before or after or in-the-middle variation?\r\n- Can there be more than one text involved, like both before and after?\r\n- I expect there can be multiple runs just by bolding a word in the middle, we should make sure that works, not just the single-run case.\r\n\r\nHappy to do a quick Google Meet with you on this if we can find a time when we're both at the keyboard. Feel free to ping me on Slack to discuss.",
        "pr_file_module": null
      },
      {
        "comment_id": "1481874793",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2510,
        "pr_file": "test_unstructured/partition/docx/test_docx.py",
        "discussion_id": "1480472152",
        "commented_code": "@@ -764,6 +764,31 @@ def test_partition_docx_includes_hyperlink_metadata():\n     assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-inline-shapes.docx\"))",
        "comment_created_at": "2024-02-07T17:56:17+00:00",
        "comment_author": "scanny",
        "comment_body": "@ds-filipknefel Okay, now that I see the document I can better see what we're trying to do. So this is like a PowerPoint shape inserted in the text, not an image (PNG, JPG) per se. So that's not going to be complicated. Each shape will have (effectively) a text frame that can contain text, so there's no \"text before the image\", \"text after the image\" etc. (because there is no image).\r\n\r\nSo I think the test cases we have are fine. There just isn't more possible variation that we need to consider.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1481885855",
    "pr_number": 2510,
    "pr_file": "test_unstructured/partition/docx/test_docx.py",
    "created_at": "2024-02-07T18:03:09+00:00",
    "commented_code": "assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph1 = elements[0]\n+    paragraph2 = elements[1]\n+\n+    # <bracketed> text is written inside inline shapes\n+    assert paragraph1.text == \"Paragraph with single <inline-image> within.\"\n+    assert paragraph2.text == \"Paragraph with <inline-image1> and <inline-image2> within.\"\n+\n+\n+def test_exclude_floating_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph = elements[2]\n+\n+    assert paragraph.text == \"Paragraph with floating shape attached.\"",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1481885855",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2510,
        "pr_file": "test_unstructured/partition/docx/test_docx.py",
        "discussion_id": "1481885855",
        "commented_code": "@@ -764,6 +764,32 @@ def test_partition_docx_includes_hyperlink_metadata():\n     assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph1 = elements[0]\n+    paragraph2 = elements[1]\n+\n+    # <bracketed> text is written inside inline shapes\n+    assert paragraph1.text == \"Paragraph with single <inline-image> within.\"\n+    assert paragraph2.text == \"Paragraph with <inline-image1> and <inline-image2> within.\"\n+\n+\n+def test_exclude_floating_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph = elements[2]\n+\n+    assert paragraph.text == \"Paragraph with floating shape attached.\"",
        "comment_created_at": "2024-02-07T18:03:09+00:00",
        "comment_author": "scanny",
        "comment_body": "Okay, now I think this simplifies to:\r\n```python\r\ndef test_it_considers_text_inside_shapes():\r\n    # -- <bracketed> text is written inside inline shapes --\r\n    assert partition_docx(example_doc_path(\"docx-shapes.docx\")) == [\r\n        NarrativeText(\"Paragraph with single <inline-image> within.\")\r\n        NarrativeText(\"Paragraph with <inline-image1> and <inline-image2> within.\")\r\n        # -- text \"<floating-shape>\" in floating shape is ignored --\r\n        NarrativeText(\"Paragraph with floating shape attached.\")\r\n    ]\r\n```\r\n\r\nYou might need to adjust the Element sub-types to match, they might not be classified as NarrativeText.",
        "pr_file_module": null
      },
      {
        "comment_id": "1482668232",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2510,
        "pr_file": "test_unstructured/partition/docx/test_docx.py",
        "discussion_id": "1481885855",
        "commented_code": "@@ -764,6 +764,32 @@ def test_partition_docx_includes_hyperlink_metadata():\n     assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph1 = elements[0]\n+    paragraph2 = elements[1]\n+\n+    # <bracketed> text is written inside inline shapes\n+    assert paragraph1.text == \"Paragraph with single <inline-image> within.\"\n+    assert paragraph2.text == \"Paragraph with <inline-image1> and <inline-image2> within.\"\n+\n+\n+def test_exclude_floating_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph = elements[2]\n+\n+    assert paragraph.text == \"Paragraph with floating shape attached.\"",
        "comment_created_at": "2024-02-08T09:32:37+00:00",
        "comment_author": "ds-filipknefel",
        "comment_body": "I don't now if this is necessarily better.\r\n\r\n1. Regardless of how these paragraphs get classified (e.g. here first two are `Title`, third one is `NarrativeText`) their text should remain the same, so looking at text directly avoids test breaking on unrelated change.\r\n2. If this detection breaks and text is different `pytest -vv` will tell you only that the objects differ like this:\r\n  ```\r\n  E         -     <unstructured.documents.elements.Title object at 0x7f2b326af520>,\r\n  E         ?                                                              ^^ ^^\r\n  E         +     <unstructured.documents.elements.Title object at 0x7f2b324f3040>,\r\n  ```\r\nwhich isn't very helpful until you unpack it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1483364739",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2510,
        "pr_file": "test_unstructured/partition/docx/test_docx.py",
        "discussion_id": "1481885855",
        "commented_code": "@@ -764,6 +764,32 @@ def test_partition_docx_includes_hyperlink_metadata():\n     assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph1 = elements[0]\n+    paragraph2 = elements[1]\n+\n+    # <bracketed> text is written inside inline shapes\n+    assert paragraph1.text == \"Paragraph with single <inline-image> within.\"\n+    assert paragraph2.text == \"Paragraph with <inline-image1> and <inline-image2> within.\"\n+\n+\n+def test_exclude_floating_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph = elements[2]\n+\n+    assert paragraph.text == \"Paragraph with floating shape attached.\"",
        "comment_created_at": "2024-02-08T17:44:11+00:00",
        "comment_author": "scanny",
        "comment_body": "You can avoid coupling to the exact element type by changing it to:\r\n```python\r\nassert [element.text for element in partition_docx(...)] == [\r\n    \"string 1\",\r\n    \"string 2\",\r\n    \"string 3\",\r\n]\r\n```\r\nThat's probably not a bad idea since this particular behavior should have no direct influence on which element the paragraph is classified as.",
        "pr_file_module": null
      },
      {
        "comment_id": "1485863607",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2510,
        "pr_file": "test_unstructured/partition/docx/test_docx.py",
        "discussion_id": "1481885855",
        "commented_code": "@@ -764,6 +764,32 @@ def test_partition_docx_includes_hyperlink_metadata():\n     assert metadata.link_urls is None\n \n \n+# -- shape behaviors -----------------------------------------------------------------------------\n+\n+\n+def test_include_inline_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph1 = elements[0]\n+    paragraph2 = elements[1]\n+\n+    # <bracketed> text is written inside inline shapes\n+    assert paragraph1.text == \"Paragraph with single <inline-image> within.\"\n+    assert paragraph2.text == \"Paragraph with <inline-image1> and <inline-image2> within.\"\n+\n+\n+def test_exclude_floating_shapes_text():\n+    elements = partition_docx(example_doc_path(\"docx-shapes.docx\"))\n+\n+    assert len(elements) == 3\n+\n+    paragraph = elements[2]\n+\n+    assert paragraph.text == \"Paragraph with floating shape attached.\"",
        "comment_created_at": "2024-02-12T08:36:42+00:00",
        "comment_author": "ds-filipknefel",
        "comment_body": "Alright, I merged these tests and we're checking only text content.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1466663410",
    "pr_number": 2435,
    "pr_file": "test_unstructured/partition/pdf_image/test_pdf.py",
    "created_at": "2024-01-25T16:50:22+00:00",
    "commented_code": "def test_partition_pdf_warns_with_ocr_languages(caplog):\n     filename = example_doc_path(\"chevron-page.pdf\")\n     pdf.partition_pdf(filename=filename, strategy=PartitionStrategy.HI_RES, ocr_languages=\"eng\")\n-    assert \"The ocr_languages kwarg will be deprecated\" in caplog.text\n-\n-\n-def test_partition_pdf_or_image_warns_with_ocr_languages(caplog):\n-    filename = example_doc_path(\"DA-1p.pdf\")\n-    pdf.partition_pdf_or_image(\n-        filename=filename, strategy=PartitionStrategy.HI_RES, ocr_languages=\"eng\"\n-    )\n-    assert \"The ocr_languages kwarg will be deprecated\" in caplog.text\n+    assert \"ocr_languages\" in caplog.text",
    "repo_full_name": "Unstructured-IO/unstructured",
    "discussion_comments": [
      {
        "comment_id": "1466663410",
        "repo_full_name": "Unstructured-IO/unstructured",
        "pr_number": 2435,
        "pr_file": "test_unstructured/partition/pdf_image/test_pdf.py",
        "discussion_id": "1466663410",
        "commented_code": "@@ -742,15 +742,7 @@ def test_partition_pdf_formats_languages_for_tesseract():\n def test_partition_pdf_warns_with_ocr_languages(caplog):\n     filename = example_doc_path(\"chevron-page.pdf\")\n     pdf.partition_pdf(filename=filename, strategy=PartitionStrategy.HI_RES, ocr_languages=\"eng\")\n-    assert \"The ocr_languages kwarg will be deprecated\" in caplog.text\n-\n-\n-def test_partition_pdf_or_image_warns_with_ocr_languages(caplog):\n-    filename = example_doc_path(\"DA-1p.pdf\")\n-    pdf.partition_pdf_or_image(\n-        filename=filename, strategy=PartitionStrategy.HI_RES, ocr_languages=\"eng\"\n-    )\n-    assert \"The ocr_languages kwarg will be deprecated\" in caplog.text\n+    assert \"ocr_languages\" in caplog.text",
        "comment_created_at": "2024-01-25T16:50:22+00:00",
        "comment_author": "scanny",
        "comment_body": "I would make the str long enough for the reader to make sense of what the warning message is. Usually what I do is use a string still long enough to fit on one line but that captures the gist, like:\r\n```python\r\nassert \"ocr_languages parameter will be removed in future rel\" in caplog.text.\r\n```\r\nLeaving flexibility for the message to change is not important because the test would immediately fail if a later developer tweaked the message and they would be prompted to update it. So better to take care of the multiple readers than the one developer who may end up changing the message three years from now.",
        "pr_file_module": null
      }
    ]
  }
]