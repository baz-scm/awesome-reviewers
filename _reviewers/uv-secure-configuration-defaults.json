[
  {
    "discussion_id": "2186128736",
    "pr_number": 14413,
    "pr_file": "docs/concepts/projects/dependencies.md",
    "created_at": "2025-07-04T21:31:39+00:00",
    "commented_code": "$ uv add ~/projects/bar/\n ```\n \n-!!! important\n+### Path dependency installation\n \n-    An [editable installation](#editable-dependencies) is not used for path dependencies by\n-    default. An editable installation may be requested for project directories:\n+By default, a path dependency project is installed in the environment as a package, unless it is\n+explicitly marked as a [non-package](./config.md#build-systems). This is true even if it lacks a\n+[`[build-system]` table](./config.md#build-systems). If you'd like to override this behavior and\n+ensure the path dependency is not installed as a package, set `package = false` on the source:\n \n-    ```console\n-    $ uv add --editable ../projects/bar/\n-    ```\n+```toml title=\"pyproject.toml\"\n+[project]\n+dependencies = [\"bar\"]",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2186128736",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 14413,
        "pr_file": "docs/concepts/projects/dependencies.md",
        "discussion_id": "2186128736",
        "commented_code": "@@ -408,38 +408,50 @@ Or, a path to a project directory:\n $ uv add ~/projects/bar/\n ```\n \n-!!! important\n+### Path dependency installation\n \n-    An [editable installation](#editable-dependencies) is not used for path dependencies by\n-    default. An editable installation may be requested for project directories:\n+By default, a path dependency project is installed in the environment as a package, unless it is\n+explicitly marked as a [non-package](./config.md#build-systems). This is true even if it lacks a\n+[`[build-system]` table](./config.md#build-systems). If you'd like to override this behavior and\n+ensure the path dependency is not installed as a package, set `package = false` on the source:\n \n-    ```console\n-    $ uv add --editable ../projects/bar/\n-    ```\n+```toml title=\"pyproject.toml\"\n+[project]\n+dependencies = [\"bar\"]",
        "comment_created_at": "2025-07-04T21:31:39+00:00",
        "comment_author": "T-256",
        "comment_body": "Invalid `project` table? (missing name and version)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2047301719",
    "pr_number": 12804,
    "pr_file": "docs/configuration/build_backend.md",
    "created_at": "2025-04-16T16:26:41+00:00",
    "commented_code": "+# The uv build backend\n+\n+!!! note\n+\n+    The uv build backend is currently in preview and may change in any future release.\n+\n+    By default, uv currently uses the hatchling build backend.\n+\n+A build backend transforms a source directory into a source distribution or a wheel. While uv\n+supports all build backends (PEP 517), it ships with the `uv_build` backend that integrates tightly\n+with uv.\n+\n+The uv build backend currently only supports Python code and only builds universal wheels. An\n+alternative backend is required if you want to create a\n+[library with extension modules](../concepts/projects/init.md#projects-with-extension-modules).\n+\n+To use the uv build backend, configure it in `pyproject.toml`:",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2047301719",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 12804,
        "pr_file": "docs/configuration/build_backend.md",
        "discussion_id": "2047301719",
        "commented_code": "@@ -0,0 +1,82 @@\n+# The uv build backend\n+\n+!!! note\n+\n+    The uv build backend is currently in preview and may change in any future release.\n+\n+    By default, uv currently uses the hatchling build backend.\n+\n+A build backend transforms a source directory into a source distribution or a wheel. While uv\n+supports all build backends (PEP 517), it ships with the `uv_build` backend that integrates tightly\n+with uv.\n+\n+The uv build backend currently only supports Python code and only builds universal wheels. An\n+alternative backend is required if you want to create a\n+[library with extension modules](../concepts/projects/init.md#projects-with-extension-modules).\n+\n+To use the uv build backend, configure it in `pyproject.toml`:",
        "comment_created_at": "2025-04-16T16:26:41+00:00",
        "comment_author": "zanieb",
        "comment_body": "```suggestion\r\nTo use the uv build backend in an existing project, add it to the `[build-system]` section in your `pyproject.toml`:\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1802231631",
    "pr_number": 7976,
    "pr_file": "docs/concepts/projects.md",
    "created_at": "2024-10-16T02:06:33+00:00",
    "commented_code": "To distribute your project to others (e.g., to upload it to an index like PyPI), you'll need to\n build it into a distributable format.\n \n+In Python building packages is split between the build frontend and the build backend. The build\n+backend is the `[build-system]` definition in the `pyproject.toml`, e.g. `build-backend = \"uv\"` or\n+`build-backend = \"setuptools.build_meta\"`. The build frontend is the command you execute for\n+building source distributions and wheels, such as `uv build` or `python -m build`. You can mix\n+tools: `uv build` can build a package with a setuptools backend, just like `python -m build` can use\n+a uv backend.\n+\n Python projects are typically distributed as both source distributions (sdists) and binary\n-distributions (wheels). The former is typically a `.tar.gz` or `.zip` file containing the project's\n-source code along with some additional metadata, while the latter is a `.whl` file containing\n-pre-built artifacts that can be installed directly.\n+distributions (wheels). The former is typically a `.tar.gz` file containing the project's source\n+code along with some additional metadata, while the latter is a `.whl` file containing pre-built\n+artifacts that can be installed directly. Wheel come in two flavors: Universal and platform\n+specific. A universal wheel is called `{name}-{version}-py3-none-any.whl` and only needs a\n+sufficiently recent Python version. Package with native code produce platform-specific wheels, e.g.,\n+`numpy-2.1.2-cp312-cp312-win_amd64.whl` only works on CPython 3.12 on 64-bit x86 Windows. With\n+universal wheels, the source distribution only exists for redistributors such as linux\n+distributions, while with platform specific wheels, it is a fallback for platforms with no matching\n+built wheel. The uv build backend currently only supports universal, pure Python projects, while the\n+`uv build` frontend can build native code through specialized build backends.\n+\n+### Build backend\n+\n+The uv build backend supports pure python projects. Their code needs to be in `src/{project_name}`\n+where all dots (`.`) and dashes (`-`) in the project name are replaced with underscores, e.g., the\n+project `foo-bar` needs at least `src/foo_bar/__init__.py`.\n+\n+To use uv as build backend, add the following to `pyproject.toml`:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "1802231631",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 7976,
        "pr_file": "docs/concepts/projects.md",
        "discussion_id": "1802231631",
        "commented_code": "@@ -603,14 +611,47 @@ documentation.\n To distribute your project to others (e.g., to upload it to an index like PyPI), you'll need to\n build it into a distributable format.\n \n+In Python building packages is split between the build frontend and the build backend. The build\n+backend is the `[build-system]` definition in the `pyproject.toml`, e.g. `build-backend = \"uv\"` or\n+`build-backend = \"setuptools.build_meta\"`. The build frontend is the command you execute for\n+building source distributions and wheels, such as `uv build` or `python -m build`. You can mix\n+tools: `uv build` can build a package with a setuptools backend, just like `python -m build` can use\n+a uv backend.\n+\n Python projects are typically distributed as both source distributions (sdists) and binary\n-distributions (wheels). The former is typically a `.tar.gz` or `.zip` file containing the project's\n-source code along with some additional metadata, while the latter is a `.whl` file containing\n-pre-built artifacts that can be installed directly.\n+distributions (wheels). The former is typically a `.tar.gz` file containing the project's source\n+code along with some additional metadata, while the latter is a `.whl` file containing pre-built\n+artifacts that can be installed directly. Wheel come in two flavors: Universal and platform\n+specific. A universal wheel is called `{name}-{version}-py3-none-any.whl` and only needs a\n+sufficiently recent Python version. Package with native code produce platform-specific wheels, e.g.,\n+`numpy-2.1.2-cp312-cp312-win_amd64.whl` only works on CPython 3.12 on 64-bit x86 Windows. With\n+universal wheels, the source distribution only exists for redistributors such as linux\n+distributions, while with platform specific wheels, it is a fallback for platforms with no matching\n+built wheel. The uv build backend currently only supports universal, pure Python projects, while the\n+`uv build` frontend can build native code through specialized build backends.\n+\n+### Build backend\n+\n+The uv build backend supports pure python projects. Their code needs to be in `src/{project_name}`\n+where all dots (`.`) and dashes (`-`) in the project name are replaced with underscores, e.g., the\n+project `foo-bar` needs at least `src/foo_bar/__init__.py`.\n+\n+To use uv as build backend, add the following to `pyproject.toml`:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
        "comment_created_at": "2024-10-16T02:06:33+00:00",
        "comment_author": "pantheraleo-7",
        "comment_body": "```suggestion\r\nrequires = [\"uv>=0.4.18,<0.5\"]\r\n```\r\n\r\nalso, is a minor version bumb be breaking change? maybe it can `requires = [\"uv>=0.4.18,<1\"]`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1809855429",
    "pr_number": 7976,
    "pr_file": "docs/concepts/projects.md",
    "created_at": "2024-10-22T04:25:18+00:00",
    "commented_code": "[editable mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html) so changes to\n the source code are reflected immediately, without re-installation.\n \n+To define uv as build backend:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "1809855429",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 7976,
        "pr_file": "docs/concepts/projects.md",
        "discussion_id": "1809855429",
        "commented_code": "@@ -71,6 +71,14 @@ build and install the project into the project environment. By default, projects\n [editable mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html) so changes to\n the source code are reflected immediately, without re-installation.\n \n+To define uv as build backend:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
        "comment_created_at": "2024-10-22T04:25:18+00:00",
        "comment_author": "henryiii",
        "comment_body": "This is a really large range. :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1809870594",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 7976,
        "pr_file": "docs/concepts/projects.md",
        "discussion_id": "1809855429",
        "commented_code": "@@ -71,6 +71,14 @@ build and install the project into the project environment. By default, projects\n [editable mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html) so changes to\n the source code are reflected immediately, without re-installation.\n \n+To define uv as build backend:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
        "comment_created_at": "2024-10-22T04:28:12+00:00",
        "comment_author": "henryiii",
        "comment_body": "Also, you only need an upper bound if there's custom configuration that might change. `[project]` is fine, it's just if there are `tool.uv.*` options that might change in the future. I don't see any custom configuration explained at all below?",
        "pr_file_module": null
      },
      {
        "comment_id": "1809891404",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 7976,
        "pr_file": "docs/concepts/projects.md",
        "discussion_id": "1809855429",
        "commented_code": "@@ -71,6 +71,14 @@ build and install the project into the project environment. By default, projects\n [editable mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html) so changes to\n the source code are reflected immediately, without re-installation.\n \n+To define uv as build backend:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
        "comment_created_at": "2024-10-22T04:33:05+00:00",
        "comment_author": "henryiii",
        "comment_body": "FWIW, scikit-build-core handles this by having the minimum version be something a user can specify, and then the any changed behaviors will keep the same behavior as the minimum version specified. (CMake works the same way)\r\n\r\nSo if we change a default, or a name, we respect the old way of doing things if the minimum version is set and below the value where it changed.",
        "pr_file_module": null
      },
      {
        "comment_id": "1810354554",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 7976,
        "pr_file": "docs/concepts/projects.md",
        "discussion_id": "1809855429",
        "commented_code": "@@ -71,6 +71,14 @@ build and install the project into the project environment. By default, projects\n [editable mode](https://setuptools.pypa.io/en/latest/userguide/development_mode.html) so changes to\n the source code are reflected immediately, without re-installation.\n \n+To define uv as build backend:\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.18,<5\"]",
        "comment_created_at": "2024-10-22T09:30:06+00:00",
        "comment_author": "konstin",
        "comment_body": "We will add custom options, we need them for inclusions and exclusions, and from my experience in maturin and ruff we need to be able to evolve them.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1825190088",
    "pr_number": 7976,
    "pr_file": "docs/reference/pyproject_toml.md",
    "created_at": "2024-10-31T21:38:01+00:00",
    "commented_code": "+# Pyproject.toml\n+\n+`pyproject.toml` is a\n+[standardized](https://packaging.python.org/en/latest/specifications/pyproject-toml/) file for\n+specifying the metadata and build system of a Python project. See [Projects](../guides/projects.md)\n+for an introduction.\n+\n+Most parts of uv only consider the name, version, (optional) dependencies and build system of a\n+project, and read only those fields from `pyproject.toml`. The `project.name` is always required,\n+while `project.version`. If `project.dependencies` is not specified, it means that the project has\n+no dependencies. If you need to use dynamic dependencies (discouraged), you must add `dependencies`\n+to `project.dynamic`. The same applies to `optional-dependencies`.\n+\n+For the build backend (`build-system = \"uv\"`), all fields are relevant and get translated to\n+[Core Metadata](https://packaging.python.org/en/latest/specifications/core-metadata) in the final\n+field. uv supports the\n+[living standard](https://packaging.python.org/en/latest/specifications/core-metadata) in addition\n+to the provisional [PEP 639](https://peps.python.org/pep-0639/) for better upload metadata. When\n+using the uv build backend, the `project.name`, `project.version`, `build-system.requires` and\n+`build-system.build-backend` keys are required, `project.dynamic` is not supported, and all other\n+fields are optional.\n+\n+## The `[build-system]` table\n+\n+The may be breaking changes to the uv build backend configuration in future uv versions, so you\n+constrain the uv version with lower and upper bounds.\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.15,<5\"]\n+build-backend = \"uv\"\n+```\n+\n+## The `[project]` table\n+\n+The following fields are recognized in the `[project]` table.\n+\n+### `name`\n+\n+The name of the project. The name of the package should match the name of the Python module it\n+contains. The name can contain runs of `-`, `_`, and `.`, which uv internally replaces by a single\n+`-` (or `_` in filenames).\n+\n+### `version`\n+\n+The version of the project, following the\n+[Version Specifiers](https://packaging.python.org/en/latest/specifications/version-specifiers/)\n+rules. Examples: `1.2.3`, `1.2.3-alpha.4`, `1.2.3-beta.1`, `1.2.3-rc.3` and `2.0.0+cpu`.\n+\n+### `description`\n+\n+A short, single-line description of the project.\n+\n+### `readme`\n+\n+The path to the Readme, relative to project root.\n+\n+Three forms are supported:\n+\n+1. A single string value, containing the relative path to the Readme.\n+\n+   ```toml\n+   readme = \"path/to/Readme.md\"\n+   ```\n+\n+2. A table with the relative path to the Readme and a content type, one of `text/plain`,\n+   `text/x-rst`, `text/markdown`.\n+\n+   ```toml\n+   readme = { file = \"path/to/Readme.md\", content-type = \"text/markdown\"  }\n+   ```\n+\n+3. A table with the Readme text inline and a content type, one of `text/plain`, `text/x-rst`,\n+   `text/markdown`.\n+\n+   ```toml\n+   readme = { text = \"# Description\n\nThe project description\", content-type = \"text/markdown\" }\n+   ```\n+\n+### `requires-python`\n+\n+The minimum supported Python version as version specifiers, for example `>=3.10`. Adding an upper\n+bound or anything other than a lower bound is not recommended. While uv does preserve the specifiers\n+as written, the resolver does only use the lower bound on published packages.\n+\n+### `license` and `license-files`\n+\n+The packaging ecosystem is currently transitioning from packaging core metadata version 2.3 to\n+version 2.4, which brings an overhaul of the license metadata.\n+\n+In version 2.3, the two variants of the `license` key are supported, while `license-files` is not\n+supported:\n+\n+```toml\n+license = { file = \"LICENSE\" }\n+```\n+\n+```toml\n+license = { text = \"Lorem ipsum dolor sit amet\nconsetetur sadipscing elitr.\" }\n+```\n+\n+In version 2.4, the `license` key is an [SPDX Expression](https://spdx.org/licenses/) and\n+`license-files` is a list of glob expression of license files to include:\n+\n+```toml\n+license = \"MIT OR Apache-2.0\"\n+license-files = [\"LICENSE.apache\", \"LICENSE.mit\", \"_vendor/licenses/*\"]\n+```\n+\n+When using both `license-files` and `license`, `license` must be a valid SPDX expression. Using\n+`license` with a string or specifying `license-files` increases the default metadata version from\n+2.3 to 2.4. At time of writing, PyPI does not support publishing packages using version 2.4.\n+\n+### `authors` and `maintainers`\n+\n+Name and/or email address for the authors or maintainers of the project. Either a `name` key or an\n+`email` key must be present.\n+\n+```toml\n+authors = [\n+  { name = \"Ferris the crab\", email = \"ferris@example.net\" },\n+  { name = \"The project authors\" },\n+  { email = \"say-hi@example.org\" }\n+]\n+```\n+\n+### `keywords`\n+\n+List of terms that make the project easier to discover.\n+\n+```toml\n+keywords = [\"uv\", \"requirements\", \"packaging\"]\n+```\n+\n+### `classifiers`\n+\n+List of [Trove classifiers](https://pypi.org/classifiers/) describing the project.\n+\n+```toml\n+classifiers = [\n+  \"Development Status :: 4 - Beta\",\n+  \"Programming Language :: Python :: 3.11\",\n+  \"Programming Language :: Python :: 3.12\",\n+]\n+```\n+\n+To prevent a private project from accidentally being uploaded to PyPI, add the\n+`\"Private :: Do Not Upload\"` classifier.\n+\n+### `urls`\n+\n+Links to important pages of the project. The following labels are known to be supported:\n+\n+- `changelog` (Changelog): The project's comprehensive changelog\n+- `documentation` (Documentation): The project's online documentation\n+- `download` (Download): A download URL for the current distribution\n+- `funding` (Funding): Funding Information\n+- `homepage` (Homepage): The project's home page\n+- `issues` (Issue Tracker): The project's bug tracker\n+- `releasenotes` (Release Notes): The project's curated release notes\n+- `source` (Source Code): The project's hosted source code or repository\n+\n+```toml\n+[project.urls]\n+changelog = \"https://github.com/astral-sh/uv/blob/main/CHANGELOG.md\"\n+documentation = \"https://docs.astral.sh/uv\"\n+releases = \"https://github.com/astral-sh/uv/releases\"\n+repository = \"https://github.com/astral-sh/uv\"\n+```\n+\n+### `scripts`, `gui-scripts` and `entry-points`\n+\n+`scripts` define a mapping from a name to a Python function. When installing the package, the\n+installer adds a launcher in `.venv/bin` (Unix) or `.venv\\Scripts` (Windows) with that name that\n+launches the Python function. The Python function is given as the import-path to a module, separated\n+by dots, followed by a colon (`:`) and an argument-less function inside that module that will be\n+called. On Windows, starting a script by default creates a terminal. You can suppress this by using\n+`gui-scripts` instead. On other platforms, there is no difference between `scripts` and\n+`gui-scripts`.\n+\n+`entry-points` can define additional name/Python function mappings that can be read across packages\n+with [`importlib.metadata`](https://docs.python.org/3/library/importlib.metadata.html#entry-points),\n+which is useful for plugin interfaces.\n+\n+```toml\n+[project.scripts]\n+foo = \"foo.cli:launch\"\n+\n+[project.entry-points.bar_group]\n+foo-bar = \"foo:bar\"\n+```\n+\n+### `dependencies` and `optional-dependencies`\n+\n+See [Dependencies](../concepts/dependencies.md).\n+\n+### `dynamic`\n+\n+Dynamic metadata is not supported. Please specify all metadata statically.\n+\n+## Full example\n+\n+```toml\n+[project]\n+name = \"foo\"\n+version = \"0.1.0\"\n+description = \"A Python package\"\n+readme = \"Readme.md\"\n+requires_python = \">=3.12\"\n+license = { file = \"License.txt\" }\n+authors = [{ name = \"Ferris the crab\", email = \"ferris@rustacean.net\" }]\n+maintainers = [{ name = \"Konsti\", email = \"konstin@mailbox.org\" }]\n+keywords = [\"demo\", \"example\", \"package\"]\n+classifiers = [\n+  \"Development Status :: 6 - Mature\",\n+  \"License :: OSI Approved :: MIT License\",\n+  \"Programming Language :: Python\",",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "1825190088",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 7976,
        "pr_file": "docs/reference/pyproject_toml.md",
        "discussion_id": "1825190088",
        "commented_code": "@@ -0,0 +1,241 @@\n+# Pyproject.toml\n+\n+`pyproject.toml` is a\n+[standardized](https://packaging.python.org/en/latest/specifications/pyproject-toml/) file for\n+specifying the metadata and build system of a Python project. See [Projects](../guides/projects.md)\n+for an introduction.\n+\n+Most parts of uv only consider the name, version, (optional) dependencies and build system of a\n+project, and read only those fields from `pyproject.toml`. The `project.name` is always required,\n+while `project.version`. If `project.dependencies` is not specified, it means that the project has\n+no dependencies. If you need to use dynamic dependencies (discouraged), you must add `dependencies`\n+to `project.dynamic`. The same applies to `optional-dependencies`.\n+\n+For the build backend (`build-system = \"uv\"`), all fields are relevant and get translated to\n+[Core Metadata](https://packaging.python.org/en/latest/specifications/core-metadata) in the final\n+field. uv supports the\n+[living standard](https://packaging.python.org/en/latest/specifications/core-metadata) in addition\n+to the provisional [PEP 639](https://peps.python.org/pep-0639/) for better upload metadata. When\n+using the uv build backend, the `project.name`, `project.version`, `build-system.requires` and\n+`build-system.build-backend` keys are required, `project.dynamic` is not supported, and all other\n+fields are optional.\n+\n+## The `[build-system]` table\n+\n+The may be breaking changes to the uv build backend configuration in future uv versions, so you\n+constrain the uv version with lower and upper bounds.\n+\n+```toml\n+[build-system]\n+requires = [\"uv>=0.4.15,<5\"]\n+build-backend = \"uv\"\n+```\n+\n+## The `[project]` table\n+\n+The following fields are recognized in the `[project]` table.\n+\n+### `name`\n+\n+The name of the project. The name of the package should match the name of the Python module it\n+contains. The name can contain runs of `-`, `_`, and `.`, which uv internally replaces by a single\n+`-` (or `_` in filenames).\n+\n+### `version`\n+\n+The version of the project, following the\n+[Version Specifiers](https://packaging.python.org/en/latest/specifications/version-specifiers/)\n+rules. Examples: `1.2.3`, `1.2.3-alpha.4`, `1.2.3-beta.1`, `1.2.3-rc.3` and `2.0.0+cpu`.\n+\n+### `description`\n+\n+A short, single-line description of the project.\n+\n+### `readme`\n+\n+The path to the Readme, relative to project root.\n+\n+Three forms are supported:\n+\n+1. A single string value, containing the relative path to the Readme.\n+\n+   ```toml\n+   readme = \"path/to/Readme.md\"\n+   ```\n+\n+2. A table with the relative path to the Readme and a content type, one of `text/plain`,\n+   `text/x-rst`, `text/markdown`.\n+\n+   ```toml\n+   readme = { file = \"path/to/Readme.md\", content-type = \"text/markdown\"  }\n+   ```\n+\n+3. A table with the Readme text inline and a content type, one of `text/plain`, `text/x-rst`,\n+   `text/markdown`.\n+\n+   ```toml\n+   readme = { text = \"# Description\\n\\nThe project description\", content-type = \"text/markdown\" }\n+   ```\n+\n+### `requires-python`\n+\n+The minimum supported Python version as version specifiers, for example `>=3.10`. Adding an upper\n+bound or anything other than a lower bound is not recommended. While uv does preserve the specifiers\n+as written, the resolver does only use the lower bound on published packages.\n+\n+### `license` and `license-files`\n+\n+The packaging ecosystem is currently transitioning from packaging core metadata version 2.3 to\n+version 2.4, which brings an overhaul of the license metadata.\n+\n+In version 2.3, the two variants of the `license` key are supported, while `license-files` is not\n+supported:\n+\n+```toml\n+license = { file = \"LICENSE\" }\n+```\n+\n+```toml\n+license = { text = \"Lorem ipsum dolor sit amet\\nconsetetur sadipscing elitr.\" }\n+```\n+\n+In version 2.4, the `license` key is an [SPDX Expression](https://spdx.org/licenses/) and\n+`license-files` is a list of glob expression of license files to include:\n+\n+```toml\n+license = \"MIT OR Apache-2.0\"\n+license-files = [\"LICENSE.apache\", \"LICENSE.mit\", \"_vendor/licenses/*\"]\n+```\n+\n+When using both `license-files` and `license`, `license` must be a valid SPDX expression. Using\n+`license` with a string or specifying `license-files` increases the default metadata version from\n+2.3 to 2.4. At time of writing, PyPI does not support publishing packages using version 2.4.\n+\n+### `authors` and `maintainers`\n+\n+Name and/or email address for the authors or maintainers of the project. Either a `name` key or an\n+`email` key must be present.\n+\n+```toml\n+authors = [\n+  { name = \"Ferris the crab\", email = \"ferris@example.net\" },\n+  { name = \"The project authors\" },\n+  { email = \"say-hi@example.org\" }\n+]\n+```\n+\n+### `keywords`\n+\n+List of terms that make the project easier to discover.\n+\n+```toml\n+keywords = [\"uv\", \"requirements\", \"packaging\"]\n+```\n+\n+### `classifiers`\n+\n+List of [Trove classifiers](https://pypi.org/classifiers/) describing the project.\n+\n+```toml\n+classifiers = [\n+  \"Development Status :: 4 - Beta\",\n+  \"Programming Language :: Python :: 3.11\",\n+  \"Programming Language :: Python :: 3.12\",\n+]\n+```\n+\n+To prevent a private project from accidentally being uploaded to PyPI, add the\n+`\"Private :: Do Not Upload\"` classifier.\n+\n+### `urls`\n+\n+Links to important pages of the project. The following labels are known to be supported:\n+\n+- `changelog` (Changelog): The project's comprehensive changelog\n+- `documentation` (Documentation): The project's online documentation\n+- `download` (Download): A download URL for the current distribution\n+- `funding` (Funding): Funding Information\n+- `homepage` (Homepage): The project's home page\n+- `issues` (Issue Tracker): The project's bug tracker\n+- `releasenotes` (Release Notes): The project's curated release notes\n+- `source` (Source Code): The project's hosted source code or repository\n+\n+```toml\n+[project.urls]\n+changelog = \"https://github.com/astral-sh/uv/blob/main/CHANGELOG.md\"\n+documentation = \"https://docs.astral.sh/uv\"\n+releases = \"https://github.com/astral-sh/uv/releases\"\n+repository = \"https://github.com/astral-sh/uv\"\n+```\n+\n+### `scripts`, `gui-scripts` and `entry-points`\n+\n+`scripts` define a mapping from a name to a Python function. When installing the package, the\n+installer adds a launcher in `.venv/bin` (Unix) or `.venv\\Scripts` (Windows) with that name that\n+launches the Python function. The Python function is given as the import-path to a module, separated\n+by dots, followed by a colon (`:`) and an argument-less function inside that module that will be\n+called. On Windows, starting a script by default creates a terminal. You can suppress this by using\n+`gui-scripts` instead. On other platforms, there is no difference between `scripts` and\n+`gui-scripts`.\n+\n+`entry-points` can define additional name/Python function mappings that can be read across packages\n+with [`importlib.metadata`](https://docs.python.org/3/library/importlib.metadata.html#entry-points),\n+which is useful for plugin interfaces.\n+\n+```toml\n+[project.scripts]\n+foo = \"foo.cli:launch\"\n+\n+[project.entry-points.bar_group]\n+foo-bar = \"foo:bar\"\n+```\n+\n+### `dependencies` and `optional-dependencies`\n+\n+See [Dependencies](../concepts/dependencies.md).\n+\n+### `dynamic`\n+\n+Dynamic metadata is not supported. Please specify all metadata statically.\n+\n+## Full example\n+\n+```toml\n+[project]\n+name = \"foo\"\n+version = \"0.1.0\"\n+description = \"A Python package\"\n+readme = \"Readme.md\"\n+requires_python = \">=3.12\"\n+license = { file = \"License.txt\" }\n+authors = [{ name = \"Ferris the crab\", email = \"ferris@rustacean.net\" }]\n+maintainers = [{ name = \"Konsti\", email = \"konstin@mailbox.org\" }]\n+keywords = [\"demo\", \"example\", \"package\"]\n+classifiers = [\n+  \"Development Status :: 6 - Mature\",\n+  \"License :: OSI Approved :: MIT License\",\n+  \"Programming Language :: Python\",",
        "comment_created_at": "2024-10-31T21:38:01+00:00",
        "comment_author": "chrisrodrigue",
        "comment_body": "`\"Private :: Do Not Upload\"` is a handy classifier which causes PyPI to reject a package. It's handy for packages that you don't want to accidentally publish, so maybe it could be used in the full example?",
        "pr_file_module": null
      }
    ]
  }
]