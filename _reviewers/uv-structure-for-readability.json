[
  {
    "discussion_id": "2181031296",
    "pr_number": 14428,
    "pr_file": "crates/uv-lock/src/lib.rs",
    "created_at": "2025-07-02T21:45:56+00:00",
    "commented_code": "+use std::fmt::Display;\n+use std::io::Write;\n+use std::path::{Path, PathBuf};\n+use std::sync::LazyLock;\n+\n+use fs_err as fs;\n+use fs2::FileExt;\n+use tracing::{debug, error, info, trace};\n+\n+use uv_cache_key::{CacheKey, cache_digest};\n+use uv_fs::Simplified;\n+use uv_state::{StateBucket, StateStore};\n+use uv_static::EnvVars;\n+\n+/// Acquire a cross-process lock for files at the provided path.\n+#[cfg(feature = \"tokio\")]\n+pub async fn acquire_path(path: impl AsRef<Path>) -> Result<LockedFile, std::io::Error> {\n+    let Ok(locks) = &*LOCKS else {\n+        return Err(std::io::Error::other(\n+            \"Filesystem locks are not initialized\",\n+        ));\n+    };\n+    let path = path.as_ref();\n+    LockedFile::acquire(locks.join(cache_digest(&path)), path.display()).await\n+}\n+\n+/// Acquire a cross-process lock for an arbitrary hashable resource (like a URL).\n+#[cfg(feature = \"tokio\")]\n+pub async fn acquire_resource<T: CacheKey + Display>(\n+    resource: T,\n+) -> Result<LockedFile, std::io::Error> {\n+    let Ok(locks) = &*LOCKS else {\n+        return Err(std::io::Error::other(\n+            \"Filesystem locks are not initialized\",\n+        ));\n+    };\n+    LockedFile::acquire(locks.join(cache_digest(&resource)), resource).await\n+}\n+\n+static LOCKS: LazyLock<Result<FilesystemLocks, std::io::Error>> =\n+    LazyLock::new(|| FilesystemLocks::from_settings()?.init());\n+\n+/// Filesystem locks used to synchronize access to shared resources across processes.\n+#[derive(Debug, Clone)]\n+struct FilesystemLocks {\n+    /// The path to the top-level directory of the filesystem locks.\n+    root: PathBuf,\n+}\n+\n+impl FilesystemLocks {\n+    /// A directory for filesystem locks at `root`.\n+    fn from_path(root: impl Into<PathBuf>) -> Self {\n+        Self { root: root.into() }\n+    }\n+\n+    /// Create a new [`FilesystemLocks`] from settings.\n+    ///\n+    /// Prefer, in order:\n+    ///\n+    /// 1. The specific tool directory specified by the user, i.e., `UV_LOCK_DIR`\n+    /// 2. A directory in the system-appropriate user-level data directory, e.g., `~/.local/uv/tools`\n+    /// 3. A directory in the local data directory, e.g., `./.uv/tools`\n+    fn from_settings() -> Result<Self, std::io::Error> {\n+        if let Some(lock_dir) = std::env::var_os(EnvVars::UV_LOCK_DIR).filter(|s| !s.is_empty()) {\n+            Ok(Self::from_path(std::path::absolute(lock_dir)?))\n+        } else {\n+            Ok(Self::from_path(\n+                StateStore::from_settings(None)?.bucket(StateBucket::Locks),\n+            ))\n+        }\n+    }\n+\n+    /// Initialize the directory.\n+    fn init(self) -> Result<Self, std::io::Error> {",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2181031296",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 14428,
        "pr_file": "crates/uv-lock/src/lib.rs",
        "discussion_id": "2181031296",
        "commented_code": "@@ -0,0 +1,232 @@\n+use std::fmt::Display;\n+use std::io::Write;\n+use std::path::{Path, PathBuf};\n+use std::sync::LazyLock;\n+\n+use fs_err as fs;\n+use fs2::FileExt;\n+use tracing::{debug, error, info, trace};\n+\n+use uv_cache_key::{CacheKey, cache_digest};\n+use uv_fs::Simplified;\n+use uv_state::{StateBucket, StateStore};\n+use uv_static::EnvVars;\n+\n+/// Acquire a cross-process lock for files at the provided path.\n+#[cfg(feature = \"tokio\")]\n+pub async fn acquire_path(path: impl AsRef<Path>) -> Result<LockedFile, std::io::Error> {\n+    let Ok(locks) = &*LOCKS else {\n+        return Err(std::io::Error::other(\n+            \"Filesystem locks are not initialized\",\n+        ));\n+    };\n+    let path = path.as_ref();\n+    LockedFile::acquire(locks.join(cache_digest(&path)), path.display()).await\n+}\n+\n+/// Acquire a cross-process lock for an arbitrary hashable resource (like a URL).\n+#[cfg(feature = \"tokio\")]\n+pub async fn acquire_resource<T: CacheKey + Display>(\n+    resource: T,\n+) -> Result<LockedFile, std::io::Error> {\n+    let Ok(locks) = &*LOCKS else {\n+        return Err(std::io::Error::other(\n+            \"Filesystem locks are not initialized\",\n+        ));\n+    };\n+    LockedFile::acquire(locks.join(cache_digest(&resource)), resource).await\n+}\n+\n+static LOCKS: LazyLock<Result<FilesystemLocks, std::io::Error>> =\n+    LazyLock::new(|| FilesystemLocks::from_settings()?.init());\n+\n+/// Filesystem locks used to synchronize access to shared resources across processes.\n+#[derive(Debug, Clone)]\n+struct FilesystemLocks {\n+    /// The path to the top-level directory of the filesystem locks.\n+    root: PathBuf,\n+}\n+\n+impl FilesystemLocks {\n+    /// A directory for filesystem locks at `root`.\n+    fn from_path(root: impl Into<PathBuf>) -> Self {\n+        Self { root: root.into() }\n+    }\n+\n+    /// Create a new [`FilesystemLocks`] from settings.\n+    ///\n+    /// Prefer, in order:\n+    ///\n+    /// 1. The specific tool directory specified by the user, i.e., `UV_LOCK_DIR`\n+    /// 2. A directory in the system-appropriate user-level data directory, e.g., `~/.local/uv/tools`\n+    /// 3. A directory in the local data directory, e.g., `./.uv/tools`\n+    fn from_settings() -> Result<Self, std::io::Error> {\n+        if let Some(lock_dir) = std::env::var_os(EnvVars::UV_LOCK_DIR).filter(|s| !s.is_empty()) {\n+            Ok(Self::from_path(std::path::absolute(lock_dir)?))\n+        } else {\n+            Ok(Self::from_path(\n+                StateStore::from_settings(None)?.bucket(StateBucket::Locks),\n+            ))\n+        }\n+    }\n+\n+    /// Initialize the directory.\n+    fn init(self) -> Result<Self, std::io::Error> {",
        "comment_created_at": "2025-07-02T21:45:56+00:00",
        "comment_author": "oconnor663",
        "comment_body": "Taking `self` here means that in some sense we need to reason about a `FilesystemLocks` instance that has not had `.init()` called on it. I usually prefer to move initialization logic into the constructor, so that if you have an instance, you never need to ask whether it's been initialized.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149905358",
    "pr_number": 13954,
    "pr_file": "crates/uv-python/src/discovery.rs",
    "created_at": "2025-06-16T12:34:17+00:00",
    "commented_code": "true\n                     })\n                     .inspect(|installation| debug!(\"Found managed installation `{installation}`\"))\n-                    .map(|installation| (PythonSource::Managed, installation.executable(false))))\n+                    .map(move |installation| {\n+                        (\n+                            PythonSource::Managed,\n+                            // If it's not a patch version request, then attempt to read the stable\n+                            // minor version link.\n+                            version",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2149905358",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13954,
        "pr_file": "crates/uv-python/src/discovery.rs",
        "discussion_id": "2149905358",
        "commented_code": "@@ -339,7 +341,30 @@ fn python_executables_from_installed<'a>(\n                         true\n                     })\n                     .inspect(|installation| debug!(\"Found managed installation `{installation}`\"))\n-                    .map(|installation| (PythonSource::Managed, installation.executable(false))))\n+                    .map(move |installation| {\n+                        (\n+                            PythonSource::Managed,\n+                            // If it's not a patch version request, then attempt to read the stable\n+                            // minor version link.\n+                            version",
        "comment_created_at": "2025-06-16T12:34:17+00:00",
        "comment_author": "konstin",
        "comment_body": "nit: assign this to a variable outside the tuple to make it easier to follow that this is a tuple; ideally, we'd also de-nest it a bit.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149448252",
    "pr_number": 13897,
    "pr_file": "crates/uv-client/src/cached_client.rs",
    "created_at": "2025-06-16T09:16:13+00:00",
    "commented_code": "}\n }\n \n-/// Either a cached client error or a (user specified) error from the callback\n+/// Dispatch type: Either a cached client error or a (user specified) error from the callback\n pub enum CachedClientError<CallbackError: std::error::Error + 'static> {\n-    Client(Error),\n-    Callback(CallbackError),\n-}\n-\n-impl<CallbackError: std::error::Error + 'static> Display for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            CachedClientError::Client(err) => write!(f, \"{err}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err}\"),\n-        }\n-    }\n+    Client {\n+        retries: Option<u32>,\n+        err: Error,\n+    },\n+    Callback {\n+        retries: Option<u32>,\n+        err: CallbackError,\n+    },\n }\n \n-impl<CallbackError: std::error::Error + 'static> Debug for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {\n+    fn retries(&self) -> Option<u32> {\n         match self {\n-            CachedClientError::Client(err) => write!(f, \"{err:?}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err:?}\"),\n+            CachedClientError::Client { retries, .. } => *retries,\n+            CachedClientError::Callback { retries, .. } => *retries,\n         }\n     }\n }\n \n-impl<CallbackError: std::error::Error + 'static> std::error::Error\n-    for CachedClientError<CallbackError>\n-{\n-    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2149448252",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13897,
        "pr_file": "crates/uv-client/src/cached_client.rs",
        "discussion_id": "2149448252",
        "commented_code": "@@ -100,60 +99,78 @@ where\n     }\n }\n \n-/// Either a cached client error or a (user specified) error from the callback\n+/// Dispatch type: Either a cached client error or a (user specified) error from the callback\n pub enum CachedClientError<CallbackError: std::error::Error + 'static> {\n-    Client(Error),\n-    Callback(CallbackError),\n-}\n-\n-impl<CallbackError: std::error::Error + 'static> Display for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            CachedClientError::Client(err) => write!(f, \"{err}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err}\"),\n-        }\n-    }\n+    Client {\n+        retries: Option<u32>,\n+        err: Error,\n+    },\n+    Callback {\n+        retries: Option<u32>,\n+        err: CallbackError,\n+    },\n }\n \n-impl<CallbackError: std::error::Error + 'static> Debug for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {\n+    fn retries(&self) -> Option<u32> {\n         match self {\n-            CachedClientError::Client(err) => write!(f, \"{err:?}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err:?}\"),\n+            CachedClientError::Client { retries, .. } => *retries,\n+            CachedClientError::Callback { retries, .. } => *retries,\n         }\n     }\n }\n \n-impl<CallbackError: std::error::Error + 'static> std::error::Error\n-    for CachedClientError<CallbackError>\n-{\n-    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {",
        "comment_created_at": "2025-06-16T09:16:13+00:00",
        "comment_author": "jtfmumm",
        "comment_body": "Can this `impl` line be removed now?",
        "pr_file_module": null
      },
      {
        "comment_id": "2149516399",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13897,
        "pr_file": "crates/uv-client/src/cached_client.rs",
        "discussion_id": "2149448252",
        "commented_code": "@@ -100,60 +99,78 @@ where\n     }\n }\n \n-/// Either a cached client error or a (user specified) error from the callback\n+/// Dispatch type: Either a cached client error or a (user specified) error from the callback\n pub enum CachedClientError<CallbackError: std::error::Error + 'static> {\n-    Client(Error),\n-    Callback(CallbackError),\n-}\n-\n-impl<CallbackError: std::error::Error + 'static> Display for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            CachedClientError::Client(err) => write!(f, \"{err}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err}\"),\n-        }\n-    }\n+    Client {\n+        retries: Option<u32>,\n+        err: Error,\n+    },\n+    Callback {\n+        retries: Option<u32>,\n+        err: CallbackError,\n+    },\n }\n \n-impl<CallbackError: std::error::Error + 'static> Debug for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {\n+    fn retries(&self) -> Option<u32> {\n         match self {\n-            CachedClientError::Client(err) => write!(f, \"{err:?}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err:?}\"),\n+            CachedClientError::Client { retries, .. } => *retries,\n+            CachedClientError::Callback { retries, .. } => *retries,\n         }\n     }\n }\n \n-impl<CallbackError: std::error::Error + 'static> std::error::Error\n-    for CachedClientError<CallbackError>\n-{\n-    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {",
        "comment_created_at": "2025-06-16T09:44:11+00:00",
        "comment_author": "konstin",
        "comment_body": "It's used as the non-consuming conversion `is_extended_transient_error`, while the `From`s consume `Self`. Could be a deref or a `From` with `&Self` too, not sure what the most intuitive here is.",
        "pr_file_module": null
      },
      {
        "comment_id": "2149531043",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13897,
        "pr_file": "crates/uv-client/src/cached_client.rs",
        "discussion_id": "2149448252",
        "commented_code": "@@ -100,60 +99,78 @@ where\n     }\n }\n \n-/// Either a cached client error or a (user specified) error from the callback\n+/// Dispatch type: Either a cached client error or a (user specified) error from the callback\n pub enum CachedClientError<CallbackError: std::error::Error + 'static> {\n-    Client(Error),\n-    Callback(CallbackError),\n-}\n-\n-impl<CallbackError: std::error::Error + 'static> Display for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            CachedClientError::Client(err) => write!(f, \"{err}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err}\"),\n-        }\n-    }\n+    Client {\n+        retries: Option<u32>,\n+        err: Error,\n+    },\n+    Callback {\n+        retries: Option<u32>,\n+        err: CallbackError,\n+    },\n }\n \n-impl<CallbackError: std::error::Error + 'static> Debug for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {\n+    fn retries(&self) -> Option<u32> {\n         match self {\n-            CachedClientError::Client(err) => write!(f, \"{err:?}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err:?}\"),\n+            CachedClientError::Client { retries, .. } => *retries,\n+            CachedClientError::Callback { retries, .. } => *retries,\n         }\n     }\n }\n \n-impl<CallbackError: std::error::Error + 'static> std::error::Error\n-    for CachedClientError<CallbackError>\n-{\n-    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {",
        "comment_created_at": "2025-06-16T09:51:36+00:00",
        "comment_author": "jtfmumm",
        "comment_body": "What I meant was that it looks like `retries()` and `error()` can be under one instance of that line:\r\n\r\n```rust\r\nimpl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {\r\n    fn retries(&self) -> Option<u32> {\r\n        match self {\r\n            CachedClientError::Client { retries, .. } => *retries,\r\n            CachedClientError::Callback { retries, .. } => *retries,\r\n        }\r\n    }\r\n\r\n    fn error(&self) -> &dyn std::error::Error {\r\n        match self {\r\n            CachedClientError::Client { err, .. } => err,\r\n            CachedClientError::Callback { err, .. } => err,\r\n        }\r\n    }\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2149535273",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13897,
        "pr_file": "crates/uv-client/src/cached_client.rs",
        "discussion_id": "2149448252",
        "commented_code": "@@ -100,60 +99,78 @@ where\n     }\n }\n \n-/// Either a cached client error or a (user specified) error from the callback\n+/// Dispatch type: Either a cached client error or a (user specified) error from the callback\n pub enum CachedClientError<CallbackError: std::error::Error + 'static> {\n-    Client(Error),\n-    Callback(CallbackError),\n-}\n-\n-impl<CallbackError: std::error::Error + 'static> Display for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            CachedClientError::Client(err) => write!(f, \"{err}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err}\"),\n-        }\n-    }\n+    Client {\n+        retries: Option<u32>,\n+        err: Error,\n+    },\n+    Callback {\n+        retries: Option<u32>,\n+        err: CallbackError,\n+    },\n }\n \n-impl<CallbackError: std::error::Error + 'static> Debug for CachedClientError<CallbackError> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {\n+    fn retries(&self) -> Option<u32> {\n         match self {\n-            CachedClientError::Client(err) => write!(f, \"{err:?}\"),\n-            CachedClientError::Callback(err) => write!(f, \"{err:?}\"),\n+            CachedClientError::Client { retries, .. } => *retries,\n+            CachedClientError::Callback { retries, .. } => *retries,\n         }\n     }\n }\n \n-impl<CallbackError: std::error::Error + 'static> std::error::Error\n-    for CachedClientError<CallbackError>\n-{\n-    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+impl<CallbackError: std::error::Error + 'static> CachedClientError<CallbackError> {",
        "comment_created_at": "2025-06-16T09:53:36+00:00",
        "comment_author": "konstin",
        "comment_body": "oh, yes sure that's better!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077804757",
    "pr_number": 13312,
    "pr_file": "crates/uv-python/src/managed.rs",
    "created_at": "2025-05-07T14:43:43+00:00",
    "commented_code": "}\n }\n \n+#[derive(Clone, Debug)]\n+pub struct DirectorySymlink {\n+    pub symlink: PathBuf,\n+    pub target_directory: PathBuf,\n+}\n+\n+impl DirectorySymlink {\n+    pub fn is_self_link(&self) -> bool {\n+        self.symlink == self.target_directory\n+    }\n+}\n+\n+pub fn symlink_directory_from_executable(\n+    major: u8,\n+    minor: u8,\n+    executable: &Path,\n+) -> Option<DirectorySymlink> {\n+    let symlink_directory_name = symlink_directory_name(major, minor);\n+    if let Some(parent) = executable.parent() {\n+        #[cfg(unix)]\n+        if parent\n+            .components()\n+            .next_back()\n+            .is_some_and(|c| c.as_os_str() == \"bin\")\n+        {\n+            if let Some(target_directory) = parent.parent() {\n+                let target_directory = target_directory.to_path_buf();\n+                let symlink = target_directory.with_file_name(symlink_directory_name);\n+                return Some(DirectorySymlink {\n+                    symlink,\n+                    target_directory,\n+                });\n+            }\n+        }\n+        if let Some(target_directory) = parent.parent() {\n+            let target_directory = target_directory.to_path_buf();\n+            let symlink = target_directory.with_file_name(symlink_directory_name);\n+            return Some(DirectorySymlink {\n+                symlink,\n+                target_directory,\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+pub fn create_symlink_directory(major: u8, minor: u8, executable: &Path) -> Result<(), Error> {\n+    let Some(directory_symlink) = symlink_directory_from_executable(major, minor, executable)\n+    else {\n+        return Ok(());\n+    };\n+    if directory_symlink.is_self_link() {\n+        return Ok(());\n+    }\n+\n+    match replace_symlink(\n+        directory_symlink.target_directory.as_path(),\n+        directory_symlink.symlink.as_path(),\n+    ) {\n+        Ok(()) => {\n+            debug!(\n+                \"Created link {} -> {}\",\n+                &directory_symlink.symlink.user_display(),\n+                &directory_symlink.target_directory.user_display(),\n+            );\n+        }\n+        Err(err) if err.kind() == io::ErrorKind::NotFound => {\n+            return Err(Error::MissingLinkTargetDirectory(\n+                directory_symlink.target_directory.clone(),\n+            ))\n+        }\n+        Err(err) if err.kind() == io::ErrorKind::AlreadyExists => {}\n+        Err(err) => {\n+            return Err(Error::ExecutableLinkDirectory {\n+                from: directory_symlink.symlink,\n+                to: directory_symlink.target_directory,\n+                err,\n+            })\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// Create a link to the managed Python executable.\n+///\n+/// If the file already exists at the target path, an error will be returned.\n+pub fn create_bin_link(target: &Path, executable: PathBuf) -> Result<(), Error> {",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2077804757",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13312,
        "pr_file": "crates/uv-python/src/managed.rs",
        "discussion_id": "2077804757",
        "commented_code": "@@ -670,6 +657,139 @@ impl ManagedPythonInstallation {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct DirectorySymlink {\n+    pub symlink: PathBuf,\n+    pub target_directory: PathBuf,\n+}\n+\n+impl DirectorySymlink {\n+    pub fn is_self_link(&self) -> bool {\n+        self.symlink == self.target_directory\n+    }\n+}\n+\n+pub fn symlink_directory_from_executable(\n+    major: u8,\n+    minor: u8,\n+    executable: &Path,\n+) -> Option<DirectorySymlink> {\n+    let symlink_directory_name = symlink_directory_name(major, minor);\n+    if let Some(parent) = executable.parent() {\n+        #[cfg(unix)]\n+        if parent\n+            .components()\n+            .next_back()\n+            .is_some_and(|c| c.as_os_str() == \"bin\")\n+        {\n+            if let Some(target_directory) = parent.parent() {\n+                let target_directory = target_directory.to_path_buf();\n+                let symlink = target_directory.with_file_name(symlink_directory_name);\n+                return Some(DirectorySymlink {\n+                    symlink,\n+                    target_directory,\n+                });\n+            }\n+        }\n+        if let Some(target_directory) = parent.parent() {\n+            let target_directory = target_directory.to_path_buf();\n+            let symlink = target_directory.with_file_name(symlink_directory_name);\n+            return Some(DirectorySymlink {\n+                symlink,\n+                target_directory,\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+pub fn create_symlink_directory(major: u8, minor: u8, executable: &Path) -> Result<(), Error> {\n+    let Some(directory_symlink) = symlink_directory_from_executable(major, minor, executable)\n+    else {\n+        return Ok(());\n+    };\n+    if directory_symlink.is_self_link() {\n+        return Ok(());\n+    }\n+\n+    match replace_symlink(\n+        directory_symlink.target_directory.as_path(),\n+        directory_symlink.symlink.as_path(),\n+    ) {\n+        Ok(()) => {\n+            debug!(\n+                \"Created link {} -> {}\",\n+                &directory_symlink.symlink.user_display(),\n+                &directory_symlink.target_directory.user_display(),\n+            );\n+        }\n+        Err(err) if err.kind() == io::ErrorKind::NotFound => {\n+            return Err(Error::MissingLinkTargetDirectory(\n+                directory_symlink.target_directory.clone(),\n+            ))\n+        }\n+        Err(err) if err.kind() == io::ErrorKind::AlreadyExists => {}\n+        Err(err) => {\n+            return Err(Error::ExecutableLinkDirectory {\n+                from: directory_symlink.symlink,\n+                to: directory_symlink.target_directory,\n+                err,\n+            })\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// Create a link to the managed Python executable.\n+///\n+/// If the file already exists at the target path, an error will be returned.\n+pub fn create_bin_link(target: &Path, executable: PathBuf) -> Result<(), Error> {",
        "comment_created_at": "2025-05-07T14:43:43+00:00",
        "comment_author": "zanieb",
        "comment_body": "A dedicated `StandaloneIntepreter` type might be helpful to keep the logic about the `executable` to use in the `uv-python` crate.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2091723128",
    "pr_number": 13469,
    "pr_file": "crates/uv-cache-info/src/glob.rs",
    "created_at": "2025-05-15T18:06:30+00:00",
    "commented_code": "+use std::{\n+    collections::BTreeMap,\n+    path::{Component, Components, Path, PathBuf},\n+};\n+\n+fn is_glob_like(part: Component) -> bool {\n+    matches!(part, Component::Normal(_))\n+        && part\n+            .as_os_str()\n+            .to_str()\n+            .is_some_and(|part| [\"*\", \"{\", \"}\", \"?\"].into_iter().any(|c| part.contains(c)))\n+}\n+\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+struct GlobParts {\n+    base: PathBuf,\n+    pattern: PathBuf,\n+}\n+\n+/// Split a glob into longest possible base + shortest possible glob pattern.\n+fn split_glob(pattern: impl AsRef<str>) -> GlobParts {\n+    let pattern: &Path = pattern.as_ref().as_ref();\n+\n+    let mut glob = GlobParts::default();\n+    let mut current = PathBuf::new();",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2091723128",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13469,
        "pr_file": "crates/uv-cache-info/src/glob.rs",
        "discussion_id": "2091723128",
        "commented_code": "@@ -0,0 +1,293 @@\n+use std::{\n+    collections::BTreeMap,\n+    path::{Component, Components, Path, PathBuf},\n+};\n+\n+fn is_glob_like(part: Component) -> bool {\n+    matches!(part, Component::Normal(_))\n+        && part\n+            .as_os_str()\n+            .to_str()\n+            .is_some_and(|part| [\"*\", \"{\", \"}\", \"?\"].into_iter().any(|c| part.contains(c)))\n+}\n+\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+struct GlobParts {\n+    base: PathBuf,\n+    pattern: PathBuf,\n+}\n+\n+/// Split a glob into longest possible base + shortest possible glob pattern.\n+fn split_glob(pattern: impl AsRef<str>) -> GlobParts {\n+    let pattern: &Path = pattern.as_ref().as_ref();\n+\n+    let mut glob = GlobParts::default();\n+    let mut current = PathBuf::new();",
        "comment_created_at": "2025-05-15T18:06:30+00:00",
        "comment_author": "BurntSushi",
        "comment_body": "This might be vestigial? It's pushed to below, but then appears unused.",
        "pr_file_module": null
      },
      {
        "comment_id": "2091725265",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13469,
        "pr_file": "crates/uv-cache-info/src/glob.rs",
        "discussion_id": "2091723128",
        "commented_code": "@@ -0,0 +1,293 @@\n+use std::{\n+    collections::BTreeMap,\n+    path::{Component, Components, Path, PathBuf},\n+};\n+\n+fn is_glob_like(part: Component) -> bool {\n+    matches!(part, Component::Normal(_))\n+        && part\n+            .as_os_str()\n+            .to_str()\n+            .is_some_and(|part| [\"*\", \"{\", \"}\", \"?\"].into_iter().any(|c| part.contains(c)))\n+}\n+\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+struct GlobParts {\n+    base: PathBuf,\n+    pattern: PathBuf,\n+}\n+\n+/// Split a glob into longest possible base + shortest possible glob pattern.\n+fn split_glob(pattern: impl AsRef<str>) -> GlobParts {\n+    let pattern: &Path = pattern.as_ref().as_ref();\n+\n+    let mut glob = GlobParts::default();\n+    let mut current = PathBuf::new();",
        "comment_created_at": "2025-05-15T18:08:03+00:00",
        "comment_author": "BurntSushi",
        "comment_body": "I do wonder if this code can be simplified by doing `let mut current = &mut glob.base;`. And then in the loop below:\r\n\r\n```rust\r\nif !globbing && is_glob_like(part) {\r\n    current = &mut glob.pattern;\r\n}\r\n```\r\n\r\nThen you can just do `current.push(last);` in both places and avoid the extra case analysis on `globbing`.\r\n\r\n(I'm wondering if this is what you had and it didn't work for some reason.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2091805416",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13469,
        "pr_file": "crates/uv-cache-info/src/glob.rs",
        "discussion_id": "2091723128",
        "commented_code": "@@ -0,0 +1,293 @@\n+use std::{\n+    collections::BTreeMap,\n+    path::{Component, Components, Path, PathBuf},\n+};\n+\n+fn is_glob_like(part: Component) -> bool {\n+    matches!(part, Component::Normal(_))\n+        && part\n+            .as_os_str()\n+            .to_str()\n+            .is_some_and(|part| [\"*\", \"{\", \"}\", \"?\"].into_iter().any(|c| part.contains(c)))\n+}\n+\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+struct GlobParts {\n+    base: PathBuf,\n+    pattern: PathBuf,\n+}\n+\n+/// Split a glob into longest possible base + shortest possible glob pattern.\n+fn split_glob(pattern: impl AsRef<str>) -> GlobParts {\n+    let pattern: &Path = pattern.as_ref().as_ref();\n+\n+    let mut glob = GlobParts::default();\n+    let mut current = PathBuf::new();",
        "comment_created_at": "2025-05-15T19:05:33+00:00",
        "comment_author": "aldanor",
        "comment_body": "Good catch, this is a leftover from a previous version that wasn't cleaned up after a refactor.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2111631271",
    "pr_number": 13689,
    "pr_file": "crates/uv/src/commands/project/sync.rs",
    "created_at": "2025-05-28T11:38:36+00:00",
    "commented_code": "if dry_run.enabled() {\n                 match result {\n                     LockResult::Unchanged(..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Found up-to-date lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::AlreadyExist,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });\n                     }\n                     LockResult::Changed(None, ..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Would create lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::Create,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });\n                     }\n                     LockResult::Changed(Some(..), ..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Would update lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::Update,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2111631271",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13689,
        "pr_file": "crates/uv/src/commands/project/sync.rs",
        "discussion_id": "2111631271",
        "commented_code": "@@ -376,37 +396,25 @@ pub(crate) async fn sync(\n             if dry_run.enabled() {\n                 match result {\n                     LockResult::Unchanged(..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Found up-to-date lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::AlreadyExist,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });\n                     }\n                     LockResult::Changed(None, ..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Would create lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::Create,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });\n                     }\n                     LockResult::Changed(Some(..), ..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Would update lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::Update,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });",
        "comment_created_at": "2025-05-28T11:38:36+00:00",
        "comment_author": "konstin",
        "comment_body": "Can we DRY this up by only determining the action in the branches?",
        "pr_file_module": null
      },
      {
        "comment_id": "2112529388",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13689,
        "pr_file": "crates/uv/src/commands/project/sync.rs",
        "discussion_id": "2111631271",
        "commented_code": "@@ -376,37 +396,25 @@ pub(crate) async fn sync(\n             if dry_run.enabled() {\n                 match result {\n                     LockResult::Unchanged(..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Found up-to-date lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::AlreadyExist,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });\n                     }\n                     LockResult::Changed(None, ..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Would create lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::Create,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });\n                     }\n                     LockResult::Changed(Some(..), ..) => {\n-                        writeln!(\n-                            printer.stderr(),\n-                            \"{}\",\n-                            format!(\n-                                \"Would update lockfile at: {}\",\n-                                lock_target.lock_path().user_display().bold()\n-                            )\n-                            .dimmed()\n-                        )?;\n+                        report.lock = Some(LockReport {\n+                            action: LockAction::Update,\n+                            dry: dry_run.enabled(),\n+                            lock_path: lock_target.lock_path(),\n+                        });",
        "comment_created_at": "2025-05-28T18:39:22+00:00",
        "comment_author": "Gankra",
        "comment_body": "Wow good call, I got so tunnel-visioned during the refactor I didn't realize how simple I had made this code!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112864324",
    "pr_number": 13689,
    "pr_file": "crates/uv/src/commands/project/sync.rs",
    "created_at": "2025-05-28T22:21:26+00:00",
    "commented_code": "};\n \n     // Notify the user of any environment changes.\n-    match &environment {\n-        SyncEnvironment::Project(ProjectEnvironment::Existing(environment))\n-            if dry_run.enabled() =>\n-        {\n-            writeln!(\n-                printer.stderr(),\n-                \"{}\",\n-                format!(\n-                    \"Discovered existing environment at: {}\",\n-                    environment.root().user_display().bold()\n-                )\n-                .dimmed()\n-            )?;\n-        }\n-        SyncEnvironment::Project(ProjectEnvironment::WouldReplace(root, ..))\n-            if dry_run.enabled() =>\n-        {\n-            writeln!(\n-                printer.stderr(),\n-                \"{}\",\n-                format!(\n-                    \"Would replace existing virtual environment at: {}\",\n-                    root.user_display().bold()\n-                )\n-                .dimmed()\n-            )?;\n-        }\n-        SyncEnvironment::Project(ProjectEnvironment::WouldCreate(root, ..))\n-            if dry_run.enabled() =>\n-        {\n-            writeln!(\n-                printer.stderr(),\n-                \"{}\",\n-                format!(\n-                    \"Would create virtual environment at: {}\",\n-                    root.user_display().bold()\n-                )\n-                .dimmed()\n-            )?;\n-        }\n-        SyncEnvironment::Script(ScriptEnvironment::Existing(environment)) => {\n-            if dry_run.enabled() {\n-                writeln!(\n-                    printer.stderr(),\n-                    \"{}\",\n-                    format!(\n-                        \"Discovered existing environment at: {}\",\n-                        environment.root().user_display().bold()\n-                    )\n-                    .dimmed()\n-                )?;\n-            } else {\n-                writeln!(\n-                    printer.stderr(),\n-                    \"Using script environment at: {}\",\n-                    environment.root().user_display().cyan()\n-                )?;\n+    let mut report = ProjectReport {\n+        project_dir: project_dir.into(),\n+        workspace_dir: match &target {\n+            SyncTarget::Project(project) => Some(project.root().into()),\n+            SyncTarget::Script(_) => None,\n+        },\n+        sync: None,\n+        lock: None,\n+    };\n+    report.sync = Some(SyncReport {\n+        dry_run: dry_run.enabled(),\n+        python_executable: environment.python_executable().into(),\n+        python_version: environment.interpreter().python_full_version().to_string(),\n+        env_kind: match &environment {\n+            SyncEnvironment::Project(..) => EnvKind::Project,\n+            SyncEnvironment::Script(..) => EnvKind::Script,\n+        },\n+        env_path: match &environment {\n+            SyncEnvironment::Project(ProjectEnvironment::Existing(env))\n+            | SyncEnvironment::Project(ProjectEnvironment::Created(env))\n+            | SyncEnvironment::Project(ProjectEnvironment::Replaced(env))\n+            | SyncEnvironment::Script(ScriptEnvironment::Existing(env))\n+            | SyncEnvironment::Script(ScriptEnvironment::Created(env))\n+            | SyncEnvironment::Script(ScriptEnvironment::Replaced(env)) => env.root().into(),\n+            SyncEnvironment::Project(ProjectEnvironment::WouldCreate(root, ..))\n+            | SyncEnvironment::Project(ProjectEnvironment::WouldReplace(root, ..))\n+            | SyncEnvironment::Script(ScriptEnvironment::WouldCreate(root, ..))\n+            | SyncEnvironment::Script(ScriptEnvironment::WouldReplace(root, ..)) => {\n+                root.as_path().into()",
    "repo_full_name": "astral-sh/uv",
    "discussion_comments": [
      {
        "comment_id": "2112864324",
        "repo_full_name": "astral-sh/uv",
        "pr_number": 13689,
        "pr_file": "crates/uv/src/commands/project/sync.rs",
        "discussion_id": "2112864324",
        "commented_code": "@@ -167,102 +170,53 @@ pub(crate) async fn sync(\n     };\n \n     // Notify the user of any environment changes.\n-    match &environment {\n-        SyncEnvironment::Project(ProjectEnvironment::Existing(environment))\n-            if dry_run.enabled() =>\n-        {\n-            writeln!(\n-                printer.stderr(),\n-                \"{}\",\n-                format!(\n-                    \"Discovered existing environment at: {}\",\n-                    environment.root().user_display().bold()\n-                )\n-                .dimmed()\n-            )?;\n-        }\n-        SyncEnvironment::Project(ProjectEnvironment::WouldReplace(root, ..))\n-            if dry_run.enabled() =>\n-        {\n-            writeln!(\n-                printer.stderr(),\n-                \"{}\",\n-                format!(\n-                    \"Would replace existing virtual environment at: {}\",\n-                    root.user_display().bold()\n-                )\n-                .dimmed()\n-            )?;\n-        }\n-        SyncEnvironment::Project(ProjectEnvironment::WouldCreate(root, ..))\n-            if dry_run.enabled() =>\n-        {\n-            writeln!(\n-                printer.stderr(),\n-                \"{}\",\n-                format!(\n-                    \"Would create virtual environment at: {}\",\n-                    root.user_display().bold()\n-                )\n-                .dimmed()\n-            )?;\n-        }\n-        SyncEnvironment::Script(ScriptEnvironment::Existing(environment)) => {\n-            if dry_run.enabled() {\n-                writeln!(\n-                    printer.stderr(),\n-                    \"{}\",\n-                    format!(\n-                        \"Discovered existing environment at: {}\",\n-                        environment.root().user_display().bold()\n-                    )\n-                    .dimmed()\n-                )?;\n-            } else {\n-                writeln!(\n-                    printer.stderr(),\n-                    \"Using script environment at: {}\",\n-                    environment.root().user_display().cyan()\n-                )?;\n+    let mut report = ProjectReport {\n+        project_dir: project_dir.into(),\n+        workspace_dir: match &target {\n+            SyncTarget::Project(project) => Some(project.root().into()),\n+            SyncTarget::Script(_) => None,\n+        },\n+        sync: None,\n+        lock: None,\n+    };\n+    report.sync = Some(SyncReport {\n+        dry_run: dry_run.enabled(),\n+        python_executable: environment.python_executable().into(),\n+        python_version: environment.interpreter().python_full_version().to_string(),\n+        env_kind: match &environment {\n+            SyncEnvironment::Project(..) => EnvKind::Project,\n+            SyncEnvironment::Script(..) => EnvKind::Script,\n+        },\n+        env_path: match &environment {\n+            SyncEnvironment::Project(ProjectEnvironment::Existing(env))\n+            | SyncEnvironment::Project(ProjectEnvironment::Created(env))\n+            | SyncEnvironment::Project(ProjectEnvironment::Replaced(env))\n+            | SyncEnvironment::Script(ScriptEnvironment::Existing(env))\n+            | SyncEnvironment::Script(ScriptEnvironment::Created(env))\n+            | SyncEnvironment::Script(ScriptEnvironment::Replaced(env)) => env.root().into(),\n+            SyncEnvironment::Project(ProjectEnvironment::WouldCreate(root, ..))\n+            | SyncEnvironment::Project(ProjectEnvironment::WouldReplace(root, ..))\n+            | SyncEnvironment::Script(ScriptEnvironment::WouldCreate(root, ..))\n+            | SyncEnvironment::Script(ScriptEnvironment::WouldReplace(root, ..)) => {\n+                root.as_path().into()",
        "comment_created_at": "2025-05-28T22:21:26+00:00",
        "comment_author": "oconnor663",
        "comment_body": "Clearly not new in this diff, but it looks like `ProjectEnvironment` and `ScriptEnvironment` are mostly (actually, 100%?) duplicated. Is that bad? It seems like it's leading to more duplication in both of these matches.",
        "pr_file_module": null
      }
    ]
  }
]