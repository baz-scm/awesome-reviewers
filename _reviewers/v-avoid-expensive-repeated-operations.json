[
  {
    "discussion_id": "2203214032",
    "pr_number": 24885,
    "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
    "created_at": "2025-07-13T07:11:18+00:00",
    "commented_code": "+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2203214032",
        "repo_full_name": "vlang/v",
        "pr_number": 24885,
        "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
        "discussion_id": "2203214032",
        "commented_code": "@@ -0,0 +1,10 @@\n+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
        "comment_created_at": "2025-07-13T07:11:18+00:00",
        "comment_author": "spytheman",
        "comment_body": "hm, that is weird ... json.encode() is used here, but in the generated code, the error is inside `json__decode__option_int` which is not used by json.encode, but by json.decode, which is not used by the main program.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203214564",
        "repo_full_name": "vlang/v",
        "pr_number": 24885,
        "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
        "discussion_id": "2203214032",
        "commented_code": "@@ -0,0 +1,10 @@\n+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
        "comment_created_at": "2025-07-13T07:13:37+00:00",
        "comment_author": "spytheman",
        "comment_body": "To me, it seems like the fix is in the wrong place - it will ensure that the `builtin` `_option_none` is always available to cgen, no matter if it is used or not.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203464419",
        "repo_full_name": "vlang/v",
        "pr_number": 24885,
        "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
        "discussion_id": "2203214032",
        "commented_code": "@@ -0,0 +1,10 @@\n+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
        "comment_created_at": "2025-07-13T16:53:45+00:00",
        "comment_author": "felipensp",
        "comment_body": "But we already do the same for `_option_ok` and `_option_clone`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203480683",
        "repo_full_name": "vlang/v",
        "pr_number": 24885,
        "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
        "discussion_id": "2203214032",
        "commented_code": "@@ -0,0 +1,10 @@\n+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
        "comment_created_at": "2025-07-13T18:00:11+00:00",
        "comment_author": "spytheman",
        "comment_body": "Yes, we do the same for `_option_ok` and `_option_clone` too, and they are not used by most short programs either.\r\n\r\nI think, that we should work on improving markused, so that the use of options is tracked, and add those only in cases, when they are used as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203481083",
        "repo_full_name": "vlang/v",
        "pr_number": 24885,
        "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
        "discussion_id": "2203214032",
        "commented_code": "@@ -0,0 +1,10 @@\n+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
        "comment_created_at": "2025-07-13T18:01:46+00:00",
        "comment_author": "spytheman",
        "comment_body": "i.e. I can merge this as it is, at the cost of a small increase in cgen output for small programs, but if we tracked the use of options, we could avoid it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2204683689",
        "repo_full_name": "vlang/v",
        "pr_number": 24885,
        "pr_file": "vlib/v/tests/skip_unused/struct_field_none.vv",
        "discussion_id": "2203214032",
        "commented_code": "@@ -0,0 +1,10 @@\n+import json\n+\n+pub struct Struct {\n+\tversion ?int // = none\n+}\n+\n+fn main() {\n+\ts := Struct{}\n+\tprintln('${json.encode(s)}')",
        "comment_created_at": "2025-07-14T11:38:03+00:00",
        "comment_author": "felipensp",
        "comment_body": "Right. \ud83d\udcaf ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132127230",
    "pr_number": 24652,
    "pr_file": "vlib/v/fmt/fmt.v",
    "created_at": "2025-06-06T12:42:47+00:00",
    "commented_code": "}\n \n pub fn (mut f Fmt) selector_expr(node ast.SelectorExpr) {\n+\t// TODO(StunxFS): Even though we ignored the JS backend, the `v/gen/js/tests/js.v`\n+\t// file was still formatted/transformed, so it is specifically ignored here. Fix this.\n+\tif node.expr is ast.StringLiteral && node.field_name == 'str' && !f.pref.backend.is_js()\n+\t\t&& f.file.language != .js",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2132127230",
        "repo_full_name": "vlang/v",
        "pr_number": 24652,
        "pr_file": "vlib/v/fmt/fmt.v",
        "discussion_id": "2132127230",
        "commented_code": "@@ -3039,6 +3040,15 @@ pub fn (mut f Fmt) select_expr(node ast.SelectExpr) {\n }\n \n pub fn (mut f Fmt) selector_expr(node ast.SelectorExpr) {\n+\t// TODO(StunxFS): Even though we ignored the JS backend, the `v/gen/js/tests/js.v`\n+\t// file was still formatted/transformed, so it is specifically ignored here. Fix this.\n+\tif node.expr is ast.StringLiteral && node.field_name == 'str' && !f.pref.backend.is_js()\n+\t\t&& f.file.language != .js",
        "comment_created_at": "2025-06-06T12:42:47+00:00",
        "comment_author": "spytheman",
        "comment_body": "put that condition first, since it is cheaper to check, compared to the string comparisons and the function calls",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2113362176",
    "pr_number": 24578,
    "pr_file": "vlib/v/gen/native/amd64.v",
    "created_at": "2025-05-29T07:12:40+00:00",
    "commented_code": "pub fn (mut c Amd64) call_fn(node ast.CallExpr) {\n \tname := node.name\n \tmut n := name\n-\tif !n.contains('.') {\n+\tif !n.contains('.') && n !in c.g.fn_addr.keys() { // if the name is in keys, it is a function from builtin",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2113362176",
        "repo_full_name": "vlang/v",
        "pr_number": 24578,
        "pr_file": "vlib/v/gen/native/amd64.v",
        "discussion_id": "2113362176",
        "commented_code": "@@ -1757,7 +1757,7 @@ fn (mut c Amd64) sar8(r Amd64Register, val u8) {\n pub fn (mut c Amd64) call_fn(node ast.CallExpr) {\n \tname := node.name\n \tmut n := name\n-\tif !n.contains('.') {\n+\tif !n.contains('.') && n !in c.g.fn_addr.keys() { // if the name is in keys, it is a function from builtin",
        "comment_created_at": "2025-05-29T07:12:40+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho, cache `c.g.fn_addr.keys()` in `c`, since calling .keys() for each call can become expensive for longer programs.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2026999623",
    "pr_number": 24119,
    "pr_file": "vlib/crypto/ripemd160/ripemd160block.v",
    "created_at": "2025-04-03T13:28:30+00:00",
    "commented_code": "+// Based on: https://github.com/golang/crypto/blob/master/ripemd160/ripemd160block.go\n+\n+// RIPEMD-160 block step.\n+module ripemd160\n+\n+import math.bits\n+\n+@[direct_array_access]\n+fn block(mut md Digest, p0 []u8) int {\n+\t// vfmt off\n+\tn__ := [\n+\t\tu32(0), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n+\t\t7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n+\t\t3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n+\t\t1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n+\t\t4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,\n+\t]\n+\n+\tr__ := [\n+\t\tu32(11), 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n+\t\t7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n+\t\t11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n+\t\t11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n+\t\t9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,\n+\t]\n+\n+\tn_ := [\n+\t\tu32(5), 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n+\t\t6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n+\t\t15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n+\t\t8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n+\t\t12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,\n+\t]\n+\n+\tr_ := [\n+\t\tu32(8), 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n+\t\t9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n+\t\t9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n+\t\t15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n+\t\t8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,\n+\t]",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2026999623",
        "repo_full_name": "vlang/v",
        "pr_number": 24119,
        "pr_file": "vlib/crypto/ripemd160/ripemd160block.v",
        "discussion_id": "2026999623",
        "commented_code": "@@ -0,0 +1,155 @@\n+// Based on: https://github.com/golang/crypto/blob/master/ripemd160/ripemd160block.go\n+\n+// RIPEMD-160 block step.\n+module ripemd160\n+\n+import math.bits\n+\n+@[direct_array_access]\n+fn block(mut md Digest, p0 []u8) int {\n+\t// vfmt off\n+\tn__ := [\n+\t\tu32(0), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n+\t\t7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n+\t\t3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n+\t\t1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n+\t\t4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,\n+\t]\n+\n+\tr__ := [\n+\t\tu32(11), 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n+\t\t7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n+\t\t11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n+\t\t11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n+\t\t9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,\n+\t]\n+\n+\tn_ := [\n+\t\tu32(5), 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n+\t\t6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n+\t\t15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n+\t\t8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n+\t\t12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,\n+\t]\n+\n+\tr_ := [\n+\t\tu32(8), 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n+\t\t9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n+\t\t9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n+\t\t15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n+\t\t8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,\n+\t]",
        "comment_created_at": "2025-04-03T13:28:30+00:00",
        "comment_author": "spytheman",
        "comment_body": "If these are not modified, they can be extracted as constants too.\r\nIt will avoid allocating them for each `block()` call.",
        "pr_file_module": null
      },
      {
        "comment_id": "2027329815",
        "repo_full_name": "vlang/v",
        "pr_number": 24119,
        "pr_file": "vlib/crypto/ripemd160/ripemd160block.v",
        "discussion_id": "2026999623",
        "commented_code": "@@ -0,0 +1,155 @@\n+// Based on: https://github.com/golang/crypto/blob/master/ripemd160/ripemd160block.go\n+\n+// RIPEMD-160 block step.\n+module ripemd160\n+\n+import math.bits\n+\n+@[direct_array_access]\n+fn block(mut md Digest, p0 []u8) int {\n+\t// vfmt off\n+\tn__ := [\n+\t\tu32(0), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n+\t\t7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n+\t\t3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n+\t\t1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n+\t\t4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,\n+\t]\n+\n+\tr__ := [\n+\t\tu32(11), 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n+\t\t7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n+\t\t11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n+\t\t11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n+\t\t9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,\n+\t]\n+\n+\tn_ := [\n+\t\tu32(5), 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n+\t\t6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n+\t\t15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n+\t\t8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n+\t\t12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,\n+\t]\n+\n+\tr_ := [\n+\t\tu32(8), 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n+\t\t9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n+\t\t9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n+\t\t15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n+\t\t8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,\n+\t]",
        "comment_created_at": "2025-04-03T16:04:57+00:00",
        "comment_author": "sibkod",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1986243102",
    "pr_number": 23887,
    "pr_file": "vlib/crypto/ecdsa/util.v",
    "created_at": "2025-03-09T07:50:53+00:00",
    "commented_code": "C.EVP_PKEY_free(evpkey)\n \t\treturn error('Get an nid of non ecPublicKey')\n \t}\n-\n-\teckey := C.EVP_PKEY_get1_EC_KEY(evpkey)\n-\tif eckey == 0 {\n+\tpctx := C.EVP_PKEY_CTX_new(evpkey, 0)\n+\tif pctx == 0 {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('Failed to get ec key')\n+\t\treturn error('EVP_PKEY_CTX_new failed')\n \t}\n-\t// check the group for the supported curve(s)\n-\tif !is_valid_supported_group(eckey) {\n+\t// performs evpkey check\n+\tnck := C.EVP_PKEY_check(pctx)\n+\tif nck != 1 {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('Unsupported group')\n+\t\treturn error('EVP_PKEY_check failed')\n \t}\n-\n-\tchk := C.EC_KEY_check_key(eckey)\n-\tif chk == 0 {\n+\t// Matching the supported group\n+\tgn := key_group_name(evpkey)!\n+\t// TODO: using shortname constant\n+\tif gn != 'secp256k1' && gn != 'secp384r1' && gn != 'secp521r1' && gn != 'prime256v1' {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('EC_KEY_check_key failed')\n+\t\treturn error('Unsupported group')\n \t}\n-\tksize := ec_key_size(eckey)!\n-\n+\t// Cleans up\n \tC.BIO_free_all(bo)\n+\tC.EVP_PKEY_CTX_free(pctx)\n \n \t// Its OK to return\n \treturn PrivateKey{\n \t\tevpkey:  evpkey\n-\t\tkey:     eckey\n \t\tks_flag: .fixed\n-\t\tks_size: ksize\n \t}\n }\n \n-// Helpers\n-//\n-// is_valid_supported_group checks whether this eckey has valid group of supported curve.\n-@[inline]\n-fn is_valid_supported_group(eckey &C.EC_KEY) bool {\n-\tgroup := voidptr(C.EC_KEY_get0_group(eckey))\n-\tif group == 0 {\n-\t\treturn false\n-\t}\n-\tnidgroup := C.EC_GROUP_get_curve_name(group)\n-\tif nidgroup == nid_prime256v1 || nidgroup == nid_secp384r1 || nidgroup == nid_secp521r1\n-\t\t|| nidgroup == nid_secp256k1 {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// key_size get the key size of this ec key\n-fn ec_key_size(ec_key &C.EC_KEY) !int {\n-\tgroup := voidptr(C.EC_KEY_get0_group(ec_key))\n-\tif group == 0 {\n-\t\treturn error('Unable to load group')\n-\t}\n-\tnum_bits := C.EC_GROUP_get_degree(group)\n+// evp_key_size get the key size of this ec key\n+fn evp_key_size(key &C.EVP_PKEY) !int {\n+\tnum_bits := C.EVP_PKEY_get_bits(key)\n \tkey_size := (num_bits + 7) / 8\n+\n \treturn key_size\n }\n+\n+const default_groupname_size = 25 // short name commonly only take 10-15 length\n+\n+// key_group_name returns underlying group name of the key as a string.\n+fn key_group_name(key &C.EVP_PKEY) !string {\n+\tgname := []u8{len: default_groupname_size}\n+\tgname_len := usize(0)\n+\tmut s := C.EVP_PKEY_get_group_name(key, gname.data, u32(gname.len), &gname_len)\n+\tif s == 0 {\n+\t\tunsafe { gname.free() }\n+\t\treturn error('fail to get group name')\n+\t}\n+\tgroup := gname[..gname_len].clone().bytestr()",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1986243102",
        "repo_full_name": "vlang/v",
        "pr_number": 23887,
        "pr_file": "vlib/crypto/ecdsa/util.v",
        "discussion_id": "1986243102",
        "commented_code": "@@ -168,66 +187,61 @@ pub fn privkey_from_string(s string) !PrivateKey {\n \t\tC.EVP_PKEY_free(evpkey)\n \t\treturn error('Get an nid of non ecPublicKey')\n \t}\n-\n-\teckey := C.EVP_PKEY_get1_EC_KEY(evpkey)\n-\tif eckey == 0 {\n+\tpctx := C.EVP_PKEY_CTX_new(evpkey, 0)\n+\tif pctx == 0 {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('Failed to get ec key')\n+\t\treturn error('EVP_PKEY_CTX_new failed')\n \t}\n-\t// check the group for the supported curve(s)\n-\tif !is_valid_supported_group(eckey) {\n+\t// performs evpkey check\n+\tnck := C.EVP_PKEY_check(pctx)\n+\tif nck != 1 {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('Unsupported group')\n+\t\treturn error('EVP_PKEY_check failed')\n \t}\n-\n-\tchk := C.EC_KEY_check_key(eckey)\n-\tif chk == 0 {\n+\t// Matching the supported group\n+\tgn := key_group_name(evpkey)!\n+\t// TODO: using shortname constant\n+\tif gn != 'secp256k1' && gn != 'secp384r1' && gn != 'secp521r1' && gn != 'prime256v1' {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('EC_KEY_check_key failed')\n+\t\treturn error('Unsupported group')\n \t}\n-\tksize := ec_key_size(eckey)!\n-\n+\t// Cleans up\n \tC.BIO_free_all(bo)\n+\tC.EVP_PKEY_CTX_free(pctx)\n \n \t// Its OK to return\n \treturn PrivateKey{\n \t\tevpkey:  evpkey\n-\t\tkey:     eckey\n \t\tks_flag: .fixed\n-\t\tks_size: ksize\n \t}\n }\n \n-// Helpers\n-//\n-// is_valid_supported_group checks whether this eckey has valid group of supported curve.\n-@[inline]\n-fn is_valid_supported_group(eckey &C.EC_KEY) bool {\n-\tgroup := voidptr(C.EC_KEY_get0_group(eckey))\n-\tif group == 0 {\n-\t\treturn false\n-\t}\n-\tnidgroup := C.EC_GROUP_get_curve_name(group)\n-\tif nidgroup == nid_prime256v1 || nidgroup == nid_secp384r1 || nidgroup == nid_secp521r1\n-\t\t|| nidgroup == nid_secp256k1 {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// key_size get the key size of this ec key\n-fn ec_key_size(ec_key &C.EC_KEY) !int {\n-\tgroup := voidptr(C.EC_KEY_get0_group(ec_key))\n-\tif group == 0 {\n-\t\treturn error('Unable to load group')\n-\t}\n-\tnum_bits := C.EC_GROUP_get_degree(group)\n+// evp_key_size get the key size of this ec key\n+fn evp_key_size(key &C.EVP_PKEY) !int {\n+\tnum_bits := C.EVP_PKEY_get_bits(key)\n \tkey_size := (num_bits + 7) / 8\n+\n \treturn key_size\n }\n+\n+const default_groupname_size = 25 // short name commonly only take 10-15 length\n+\n+// key_group_name returns underlying group name of the key as a string.\n+fn key_group_name(key &C.EVP_PKEY) !string {\n+\tgname := []u8{len: default_groupname_size}\n+\tgname_len := usize(0)\n+\tmut s := C.EVP_PKEY_get_group_name(key, gname.data, u32(gname.len), &gname_len)\n+\tif s == 0 {\n+\t\tunsafe { gname.free() }\n+\t\treturn error('fail to get group name')\n+\t}\n+\tgroup := gname[..gname_len].clone().bytestr()",
        "comment_created_at": "2025-03-09T07:50:53+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n\tgroup := gname[..gname_len].bytestr()\r\n```\r\n`.bytestr()` creates a copy too, i.e. the clone() is superfluous",
        "pr_file_module": null
      },
      {
        "comment_id": "1986250219",
        "repo_full_name": "vlang/v",
        "pr_number": 23887,
        "pr_file": "vlib/crypto/ecdsa/util.v",
        "discussion_id": "1986243102",
        "commented_code": "@@ -168,66 +187,61 @@ pub fn privkey_from_string(s string) !PrivateKey {\n \t\tC.EVP_PKEY_free(evpkey)\n \t\treturn error('Get an nid of non ecPublicKey')\n \t}\n-\n-\teckey := C.EVP_PKEY_get1_EC_KEY(evpkey)\n-\tif eckey == 0 {\n+\tpctx := C.EVP_PKEY_CTX_new(evpkey, 0)\n+\tif pctx == 0 {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('Failed to get ec key')\n+\t\treturn error('EVP_PKEY_CTX_new failed')\n \t}\n-\t// check the group for the supported curve(s)\n-\tif !is_valid_supported_group(eckey) {\n+\t// performs evpkey check\n+\tnck := C.EVP_PKEY_check(pctx)\n+\tif nck != 1 {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('Unsupported group')\n+\t\treturn error('EVP_PKEY_check failed')\n \t}\n-\n-\tchk := C.EC_KEY_check_key(eckey)\n-\tif chk == 0 {\n+\t// Matching the supported group\n+\tgn := key_group_name(evpkey)!\n+\t// TODO: using shortname constant\n+\tif gn != 'secp256k1' && gn != 'secp384r1' && gn != 'secp521r1' && gn != 'prime256v1' {\n \t\tC.BIO_free_all(bo)\n-\t\tC.EC_KEY_free(eckey)\n+\t\tC.EVP_PKEY_CTX_free(pctx)\n \t\tC.EVP_PKEY_free(evpkey)\n-\t\treturn error('EC_KEY_check_key failed')\n+\t\treturn error('Unsupported group')\n \t}\n-\tksize := ec_key_size(eckey)!\n-\n+\t// Cleans up\n \tC.BIO_free_all(bo)\n+\tC.EVP_PKEY_CTX_free(pctx)\n \n \t// Its OK to return\n \treturn PrivateKey{\n \t\tevpkey:  evpkey\n-\t\tkey:     eckey\n \t\tks_flag: .fixed\n-\t\tks_size: ksize\n \t}\n }\n \n-// Helpers\n-//\n-// is_valid_supported_group checks whether this eckey has valid group of supported curve.\n-@[inline]\n-fn is_valid_supported_group(eckey &C.EC_KEY) bool {\n-\tgroup := voidptr(C.EC_KEY_get0_group(eckey))\n-\tif group == 0 {\n-\t\treturn false\n-\t}\n-\tnidgroup := C.EC_GROUP_get_curve_name(group)\n-\tif nidgroup == nid_prime256v1 || nidgroup == nid_secp384r1 || nidgroup == nid_secp521r1\n-\t\t|| nidgroup == nid_secp256k1 {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// key_size get the key size of this ec key\n-fn ec_key_size(ec_key &C.EC_KEY) !int {\n-\tgroup := voidptr(C.EC_KEY_get0_group(ec_key))\n-\tif group == 0 {\n-\t\treturn error('Unable to load group')\n-\t}\n-\tnum_bits := C.EC_GROUP_get_degree(group)\n+// evp_key_size get the key size of this ec key\n+fn evp_key_size(key &C.EVP_PKEY) !int {\n+\tnum_bits := C.EVP_PKEY_get_bits(key)\n \tkey_size := (num_bits + 7) / 8\n+\n \treturn key_size\n }\n+\n+const default_groupname_size = 25 // short name commonly only take 10-15 length\n+\n+// key_group_name returns underlying group name of the key as a string.\n+fn key_group_name(key &C.EVP_PKEY) !string {\n+\tgname := []u8{len: default_groupname_size}\n+\tgname_len := usize(0)\n+\tmut s := C.EVP_PKEY_get_group_name(key, gname.data, u32(gname.len), &gname_len)\n+\tif s == 0 {\n+\t\tunsafe { gname.free() }\n+\t\treturn error('fail to get group name')\n+\t}\n+\tgroup := gname[..gname_len].clone().bytestr()",
        "comment_created_at": "2025-03-09T08:25:20+00:00",
        "comment_author": "blackshirt",
        "comment_body": "Thanks for fixing it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921570065",
    "pr_number": 23521,
    "pr_file": "vlib/v/checker/checker.v",
    "created_at": "2025-01-19T14:42:01+00:00",
    "commented_code": "orig_type = field.typ\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif field := scope.find_struct_field(expr.expr.str(), expr.expr_type, expr.field_name) {\n+\t\t\tmut nested_unwrap := false\n+\t\t\tif mut field := scope.find_struct_field(expr.expr.str(), expr.expr_type, expr.field_name) {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1921570065",
        "repo_full_name": "vlang/v",
        "pr_number": 23521,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1921570065",
        "commented_code": "@@ -4286,20 +4286,33 @@ fn (mut c Checker) smartcast(mut expr ast.Expr, cur_type ast.Type, to_type_ ast.\n \t\t\t\t\torig_type = field.typ\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif field := scope.find_struct_field(expr.expr.str(), expr.expr_type, expr.field_name) {\n+\t\t\tmut nested_unwrap := false\n+\t\t\tif mut field := scope.find_struct_field(expr.expr.str(), expr.expr_type, expr.field_name) {",
        "comment_created_at": "2025-01-19T14:42:01+00:00",
        "comment_author": "spytheman",
        "comment_body": "`expr.expr.str()` is called several times in the code, it may be beneficial to store it in a local variable",
        "pr_file_module": null
      },
      {
        "comment_id": "1921579167",
        "repo_full_name": "vlang/v",
        "pr_number": 23521,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1921570065",
        "commented_code": "@@ -4286,20 +4286,33 @@ fn (mut c Checker) smartcast(mut expr ast.Expr, cur_type ast.Type, to_type_ ast.\n \t\t\t\t\torig_type = field.typ\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif field := scope.find_struct_field(expr.expr.str(), expr.expr_type, expr.field_name) {\n+\t\t\tmut nested_unwrap := false\n+\t\t\tif mut field := scope.find_struct_field(expr.expr.str(), expr.expr_type, expr.field_name) {",
        "comment_created_at": "2025-01-19T15:28:50+00:00",
        "comment_author": "felipensp",
        "comment_body": "True.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1894600557",
    "pr_number": 23230,
    "pr_file": "vlib/v/gen/c/cgen.v",
    "created_at": "2024-12-21T10:41:58+00:00",
    "commented_code": "sb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1894600557",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T10:41:58+00:00",
        "comment_author": "spytheman",
        "comment_body": "That seems very weird - you have already written the `{`, and then you are cutting it back.\r\n\r\nWhy not just generate different code depending on the flag, instead of doing that maneuver? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1894602729",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T10:59:29+00:00",
        "comment_author": "felipensp",
        "comment_body": "It is cutting back only to g.extern_out, for `sb` it still. I'm just reusing already written buffer.",
        "pr_file_module": null
      },
      {
        "comment_id": "1894604145",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T11:12:24+00:00",
        "comment_author": "spytheman",
        "comment_body": "You are doing `sb.str()`, which empties `sb`, followed by `sb.writeln(fn_header)` which fills it back up.\r\nIt is needless copying.",
        "pr_file_module": null
      },
      {
        "comment_id": "1894604262",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T11:13:30+00:00",
        "comment_author": "spytheman",
        "comment_body": "At the very least, you can call `sb.bytestr()` to get a string, without emptying it :-( .",
        "pr_file_module": null
      },
      {
        "comment_id": "1894604350",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T11:14:29+00:00",
        "comment_author": "spytheman",
        "comment_body": "And you can do that before line 4415, so that you would not have to do the .all_before() etc.",
        "pr_file_module": null
      },
      {
        "comment_id": "1894605153",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T11:19:17+00:00",
        "comment_author": "felipensp",
        "comment_body": "> At the very least, you can call `sb.bytestr()` to get a string, without emptying it :-( .\r\n\r\nOh, I didn't have seen .bytestr() when looking for stuff like this on strings.builder impl. Thanks. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1894605946",
        "repo_full_name": "vlang/v",
        "pr_number": 23230,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1894600557",
        "commented_code": "@@ -4413,6 +4413,11 @@ fn (mut g Gen) gen_closure_fn(expr_styp string, m ast.Fn, name string) {\n \t\tsb.write_string('${g.styp(param.typ)} a${i}')\n \t}\n \tsb.writeln(') {')\n+\tif g.pref.parallel_cc {\n+\t\tfn_header := sb.str()\n+\t\tg.extern_out.writeln('${fn_header.all_before(' {')};')\n+\t\tsb.writeln(fn_header)\n+\t}",
        "comment_created_at": "2024-12-21T11:25:03+00:00",
        "comment_author": "spytheman",
        "comment_body": "`strings.Builder` is an alias to `[]u8`, and has all the methods that are defined on `[]u8` too.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1885087375",
    "pr_number": 23158,
    "pr_file": "vlib/v/gen/c/cgen.v",
    "created_at": "2024-12-14T14:51:47+00:00",
    "commented_code": "mut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\n#define V_HEADER_FILE' + header\n \theader += '\n#endif\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1885087375",
        "repo_full_name": "vlang/v",
        "pr_number": 23158,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1885087375",
        "commented_code": "@@ -658,14 +668,14 @@ pub fn gen(files []&ast.File, mut table ast.Table, pref_ &pref.Preferences) (str\n \tmut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\\n#define V_HEADER_FILE' + header\n \theader += '\\n#endif\\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
        "comment_created_at": "2024-12-14T14:51:47+00:00",
        "comment_author": "spytheman",
        "comment_body": "why 50_000 ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1885087546",
        "repo_full_name": "vlang/v",
        "pr_number": 23158,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1885087375",
        "commented_code": "@@ -658,14 +668,14 @@ pub fn gen(files []&ast.File, mut table ast.Table, pref_ &pref.Preferences) (str\n \tmut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\\n#define V_HEADER_FILE' + header\n \theader += '\\n#endif\\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
        "comment_created_at": "2024-12-14T14:52:34+00:00",
        "comment_author": "felipensp",
        "comment_body": "Just a shoot, what do you suggest?",
        "pr_file_module": null
      },
      {
        "comment_id": "1885106135",
        "repo_full_name": "vlang/v",
        "pr_number": 23158,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1885087375",
        "commented_code": "@@ -658,14 +668,14 @@ pub fn gen(files []&ast.File, mut table ast.Table, pref_ &pref.Preferences) (str\n \tmut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\\n#define V_HEADER_FILE' + header\n \theader += '\\n#endif\\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
        "comment_created_at": "2024-12-14T16:00:51+00:00",
        "comment_author": "JalonSolov",
        "comment_body": "I usually use powers of 2, since the computer is more \"comfortable\" with those.  It doesn't really matter, though.  It should be based on max line length, to avoid re-alloc of the buffer.",
        "pr_file_module": null
      },
      {
        "comment_id": "1885108756",
        "repo_full_name": "vlang/v",
        "pr_number": 23158,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1885087375",
        "commented_code": "@@ -658,14 +668,14 @@ pub fn gen(files []&ast.File, mut table ast.Table, pref_ &pref.Preferences) (str\n \tmut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\\n#define V_HEADER_FILE' + header\n \theader += '\\n#endif\\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
        "comment_created_at": "2024-12-14T16:10:23+00:00",
        "comment_author": "felipensp",
        "comment_body": "Well, for cmd/v it is 175225.",
        "pr_file_module": null
      },
      {
        "comment_id": "1885109324",
        "repo_full_name": "vlang/v",
        "pr_number": 23158,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1885087375",
        "commented_code": "@@ -658,14 +668,14 @@ pub fn gen(files []&ast.File, mut table ast.Table, pref_ &pref.Preferences) (str\n \tmut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\\n#define V_HEADER_FILE' + header\n \theader += '\\n#endif\\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
        "comment_created_at": "2024-12-14T16:12:07+00:00",
        "comment_author": "felipensp",
        "comment_body": "hmm. `b` is 539610 for cmd/v, we could adjust it too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1885109964",
        "repo_full_name": "vlang/v",
        "pr_number": 23158,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1885087375",
        "commented_code": "@@ -658,14 +668,14 @@ pub fn gen(files []&ast.File, mut table ast.Table, pref_ &pref.Preferences) (str\n \tmut header := b.last_n(b.len)\n \theader = '#ifndef V_HEADER_FILE\\n#define V_HEADER_FILE' + header\n \theader += '\\n#endif\\n'\n-\tg.out0_start = b.len\n-\tb.writeln('// ZULUL1')\n+\n+\tmut helpers := strings.new_builder(50_000)",
        "comment_created_at": "2024-12-14T16:14:47+00:00",
        "comment_author": "spytheman",
        "comment_body": "I was just curious, because of the round number. You are right that it can be adjusted later if needed to avoid reallocations for the common cases.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1827064593",
    "pr_number": 22743,
    "pr_file": "vlib/v/checker/fn.v",
    "created_at": "2024-11-03T20:54:41+00:00",
    "commented_code": "// This is done so that all generic function calls can\n \t\t// have a chance to populate c.table.fn_generic_types with\n \t\t// the correct concrete types.\n-\t\tc.file.generic_fns << node\n-\t\tc.need_recheck_generic_fns = true\n+\t\tif !c.generic_fns[node.fkey()] {\n+\t\t\tc.need_recheck_generic_fns = true\n+\t\t\tc.generic_fns[node.fkey()] = true\n+\t\t\tc.file.generic_fns << node\n+\t\t}",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1827064593",
        "repo_full_name": "vlang/v",
        "pr_number": 22743,
        "pr_file": "vlib/v/checker/fn.v",
        "discussion_id": "1827064593",
        "commented_code": "@@ -38,8 +38,11 @@ fn (mut c Checker) fn_decl(mut node ast.FnDecl) {\n \t\t// This is done so that all generic function calls can\n \t\t// have a chance to populate c.table.fn_generic_types with\n \t\t// the correct concrete types.\n-\t\tc.file.generic_fns << node\n-\t\tc.need_recheck_generic_fns = true\n+\t\tif !c.generic_fns[node.fkey()] {\n+\t\t\tc.need_recheck_generic_fns = true\n+\t\t\tc.generic_fns[node.fkey()] = true\n+\t\t\tc.file.generic_fns << node\n+\t\t}",
        "comment_created_at": "2024-11-03T20:54:41+00:00",
        "comment_author": "StunxFS",
        "comment_body": "```suggestion\n\t\tfkey := node.fkey()\n\t\tif !c.generic_fns[fkey] {\n\t\t\tc.need_recheck_generic_fns = true\n\t\t\tc.generic_fns[fkey] = true\n\t\t\tc.file.generic_fns << node\n\t\t}\n```\n\nI think it's better to use a variable to store the value of `node.fkey()`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1807195497",
    "pr_number": 22578,
    "pr_file": "vlib/v/gen/c/if.v",
    "created_at": "2024-10-19T05:52:23+00:00",
    "commented_code": "return true\n \t\t\t\t}\n \t\t\t}\n+\t\t\tsym := g.table.sym(expr.typ)\n+\t\t\tif sym.info is ast.Struct {\n+\t\t\t\treturn sym.info.fields.any(it.typ.has_flag(.option))",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1807195497",
        "repo_full_name": "vlang/v",
        "pr_number": 22578,
        "pr_file": "vlib/v/gen/c/if.v",
        "discussion_id": "1807195497",
        "commented_code": "@@ -156,6 +156,10 @@ fn (mut g Gen) need_tmp_var_in_expr(expr ast.Expr) bool {\n \t\t\t\t\treturn true\n \t\t\t\t}\n \t\t\t}\n+\t\t\tsym := g.table.sym(expr.typ)\n+\t\t\tif sym.info is ast.Struct {\n+\t\t\t\treturn sym.info.fields.any(it.typ.has_flag(.option))",
        "comment_created_at": "2024-10-19T05:52:23+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho cache the information in another field in `ast.Struct`, about whether there are any option fields in a struct, during parsing, so that it is done just once, and then just use it here, instead of doing the loop for `any` potentially many times for each expression.",
        "pr_file_module": null
      },
      {
        "comment_id": "1807283967",
        "repo_full_name": "vlang/v",
        "pr_number": 22578,
        "pr_file": "vlib/v/gen/c/if.v",
        "discussion_id": "1807195497",
        "commented_code": "@@ -156,6 +156,10 @@ fn (mut g Gen) need_tmp_var_in_expr(expr ast.Expr) bool {\n \t\t\t\t\treturn true\n \t\t\t\t}\n \t\t\t}\n+\t\t\tsym := g.table.sym(expr.typ)\n+\t\t\tif sym.info is ast.Struct {\n+\t\t\t\treturn sym.info.fields.any(it.typ.has_flag(.option))",
        "comment_created_at": "2024-10-19T10:35:19+00:00",
        "comment_author": "felipensp",
        "comment_body": "Yeah, makes sense.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1790546378",
    "pr_number": 22441,
    "pr_file": "vlib/builtin/string.v",
    "created_at": "2024-10-07T16:32:46+00:00",
    "commented_code": "}\n \treturn unsafe { tos(b, i) }\n }\n+\n+@[params]\n+pub struct WrapConfig {\n+pub:\n+\twidth int    = 80\n+\tend   string = '\n'\n+}\n+\n+// wrap wraps the string `s` when each line exceeds the width specified in `width`\n+// (default value is 80), and will use `end` (default value is '\n') as a line break.\n+// Example: `assert 'Hello, my name is Carl and I am a delivery'.wrap(width: 20) == 'Hello, my name is\nCarl and I am a\ndelivery'`\n+pub fn (s string) wrap(config WrapConfig) string {\n+\tif config.width <= 0 {\n+\t\treturn ''\n+\t}\n+\twords := s.fields()\n+\tif words.len == 0 {\n+\t\treturn ''\n+\t}\n+\tmut sb := strings.new_builder(50)",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1790546378",
        "repo_full_name": "vlang/v",
        "pr_number": 22441,
        "pr_file": "vlib/builtin/string.v",
        "discussion_id": "1790546378",
        "commented_code": "@@ -2820,3 +2821,39 @@ pub fn (s string) snake_to_camel() string {\n \t}\n \treturn unsafe { tos(b, i) }\n }\n+\n+@[params]\n+pub struct WrapConfig {\n+pub:\n+\twidth int    = 80\n+\tend   string = '\\n'\n+}\n+\n+// wrap wraps the string `s` when each line exceeds the width specified in `width`\n+// (default value is 80), and will use `end` (default value is '\\n') as a line break.\n+// Example: `assert 'Hello, my name is Carl and I am a delivery'.wrap(width: 20) == 'Hello, my name is\\nCarl and I am a\\ndelivery'`\n+pub fn (s string) wrap(config WrapConfig) string {\n+\tif config.width <= 0 {\n+\t\treturn ''\n+\t}\n+\twords := s.fields()\n+\tif words.len == 0 {\n+\t\treturn ''\n+\t}\n+\tmut sb := strings.new_builder(50)",
        "comment_created_at": "2024-10-07T16:32:46+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n\tmut sb := strings.new_builder(s.len)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1790547759",
        "repo_full_name": "vlang/v",
        "pr_number": 22441,
        "pr_file": "vlib/builtin/string.v",
        "discussion_id": "1790546378",
        "commented_code": "@@ -2820,3 +2821,39 @@ pub fn (s string) snake_to_camel() string {\n \t}\n \treturn unsafe { tos(b, i) }\n }\n+\n+@[params]\n+pub struct WrapConfig {\n+pub:\n+\twidth int    = 80\n+\tend   string = '\\n'\n+}\n+\n+// wrap wraps the string `s` when each line exceeds the width specified in `width`\n+// (default value is 80), and will use `end` (default value is '\\n') as a line break.\n+// Example: `assert 'Hello, my name is Carl and I am a delivery'.wrap(width: 20) == 'Hello, my name is\\nCarl and I am a\\ndelivery'`\n+pub fn (s string) wrap(config WrapConfig) string {\n+\tif config.width <= 0 {\n+\t\treturn ''\n+\t}\n+\twords := s.fields()\n+\tif words.len == 0 {\n+\t\treturn ''\n+\t}\n+\tmut sb := strings.new_builder(50)",
        "comment_created_at": "2024-10-07T16:33:50+00:00",
        "comment_author": "spytheman",
        "comment_body": "Each \\n is replacing a space (or several) -> s.len will be probably very close to the final result length.",
        "pr_file_module": null
      },
      {
        "comment_id": "1790561840",
        "repo_full_name": "vlang/v",
        "pr_number": 22441,
        "pr_file": "vlib/builtin/string.v",
        "discussion_id": "1790546378",
        "commented_code": "@@ -2820,3 +2821,39 @@ pub fn (s string) snake_to_camel() string {\n \t}\n \treturn unsafe { tos(b, i) }\n }\n+\n+@[params]\n+pub struct WrapConfig {\n+pub:\n+\twidth int    = 80\n+\tend   string = '\\n'\n+}\n+\n+// wrap wraps the string `s` when each line exceeds the width specified in `width`\n+// (default value is 80), and will use `end` (default value is '\\n') as a line break.\n+// Example: `assert 'Hello, my name is Carl and I am a delivery'.wrap(width: 20) == 'Hello, my name is\\nCarl and I am a\\ndelivery'`\n+pub fn (s string) wrap(config WrapConfig) string {\n+\tif config.width <= 0 {\n+\t\treturn ''\n+\t}\n+\twords := s.fields()\n+\tif words.len == 0 {\n+\t\treturn ''\n+\t}\n+\tmut sb := strings.new_builder(50)",
        "comment_created_at": "2024-10-07T16:44:48+00:00",
        "comment_author": "StunxFS",
        "comment_body": "You are right! Thank you \ud83d\udc4c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1784599666",
    "pr_number": 22354,
    "pr_file": "vlib/v/checker/checker.v",
    "created_at": "2024-10-02T14:08:03+00:00",
    "commented_code": "return to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1784599666",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T14:08:03+00:00",
        "comment_author": "spytheman",
        "comment_body": "Can this check be done only inside __global declarations ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1784602188",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T14:09:24+00:00",
        "comment_author": "Delta456",
        "comment_body": "The issue is not only with `__global` but in all scopes.",
        "pr_file_module": null
      },
      {
        "comment_id": "1784626711",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T14:23:07+00:00",
        "comment_author": "spytheman",
        "comment_body": "In this case, please add test cases for some of the other usages.",
        "pr_file_module": null
      },
      {
        "comment_id": "1784631701",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T14:25:47+00:00",
        "comment_author": "spytheman",
        "comment_body": "What I do not like about this, is that it does relatively heavy operations for each cast, while the error and the results of those operations will be used only in a very limited amount of cases.\r\n\r\nAt the very least, the `c.expected_type.has_flag(.generic)` check should be done first, since it is fast.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1784637540",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T14:28:56+00:00",
        "comment_author": "spytheman",
        "comment_body": "You could probably also use `to_sym.name` directly, not calling `c.table.type_to_str` just to check the first non `&` character in the result.",
        "pr_file_module": null
      },
      {
        "comment_id": "1784982559",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T17:57:53+00:00",
        "comment_author": "Delta456",
        "comment_body": "> You could probably also use `to_sym.name` directly, not calling `c.table.type_to_str` just to check the first non `&` character in the result.\r\n\r\nNo, it won't give the actual type. Like stated here\r\n\r\n![image](https://github.com/user-attachments/assets/8a0eddc0-5993-4edc-b32e-f12ac731d974)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1785007226",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T18:07:43+00:00",
        "comment_author": "Delta456",
        "comment_body": "Rest are done",
        "pr_file_module": null
      },
      {
        "comment_id": "1785085016",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T18:53:14+00:00",
        "comment_author": "spytheman",
        "comment_body": "After the .type_to_str() call, you are calling `.replace('&', '')`, giving you the same as `to_sym.name` afaik.",
        "pr_file_module": null
      },
      {
        "comment_id": "1785149899",
        "repo_full_name": "vlang/v",
        "pr_number": 22354,
        "pr_file": "vlib/v/checker/checker.v",
        "discussion_id": "1784599666",
        "commented_code": "@@ -3191,6 +3191,13 @@ fn (mut c Checker) cast_expr(mut node ast.CastExpr) ast.Type {\n \t\treturn to_type\n \t}\n \n+\ttype_str := c.table.type_to_str(to_type)\n+\ttype_rm_ptr := type_str.replace('&', '')\n+\tif type_rm_ptr.len == 1 && type_rm_ptr.starts_with_capital()\n+\t\t&& !c.expected_type.has_flag(.generic) {\n+\t\tc.error('unknown type `${to_sym.name}`', node.pos)\n+\t}\n+",
        "comment_created_at": "2024-10-02T19:55:16+00:00",
        "comment_author": "Delta456",
        "comment_body": "Oh you were right...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1782182889",
    "pr_number": 22332,
    "pr_file": "vlib/encoding/iconv/iconv_windows.c.v",
    "created_at": "2024-10-01T06:28:21+00:00",
    "commented_code": "+module iconv\n+\n+// Module iconv provides functions convert between vstring(UTF8) to/from different encodings.\n+// iconv implementation using Win32 API to convert\n+// Idear from https://github.com/win-iconv/win-iconv\n+\n+fn C.GetACP() int\n+fn C.GetOEMCP() int\n+fn C.WideCharToMultiByte(codepage u32, dwflags u32, src &u8, src_len int, dst &u8, dst_len int, default_char &u8, used_default_char &bool) int\n+fn C.MultiByteToWideChar(codepage u32, dwflags u32, src &u8, src_len int, dst &u8, dst_len int) int\n+\n+struct Codepage_Alias {\n+\tcodepage int\n+\tname     string\n+}\n+\n+const codepage_alias = [\n+\t// NOTE! name field string MUST in uppercase!\n+\t// vfmt off\n+\tCodepage_Alias{65001, 'CP65001'},\n+    Codepage_Alias{65001, 'UTF8'},\n+    Codepage_Alias{65001, 'UTF-8'},\n+\n+    Codepage_Alias{1200, 'CP1200'},\n+    Codepage_Alias{1200, 'UTF16LE'},\n+    Codepage_Alias{1200, 'UTF-16LE'},\n+    Codepage_Alias{1200, 'UCS2LE'},\n+    Codepage_Alias{1200, 'UCS-2LE'},\n+    Codepage_Alias{1200, 'UCS-2-INTERNAL'},\n+    Codepage_Alias{1200, 'UNICODE'},\t// for iconv \n+\n+    Codepage_Alias{1201, 'CP1201'},\n+    Codepage_Alias{1201, 'UTF16BE'},\n+    Codepage_Alias{1201, 'UTF-16BE'},\n+    Codepage_Alias{1201, 'UCS2BE'},\n+    Codepage_Alias{1201, 'UCS-2BE'},\n+    Codepage_Alias{1201, 'UNICODEFFFE'},\n+\n+    Codepage_Alias{12000, 'CP12000'},\n+    Codepage_Alias{12000, 'UTF32LE'},\n+    Codepage_Alias{12000, 'UTF-32LE'},\n+    Codepage_Alias{12000, 'UCS4LE'},\n+    Codepage_Alias{12000, 'UCS-4LE'},\n+\n+    Codepage_Alias{12001, 'CP12001'},\n+    Codepage_Alias{12001, 'UTF32BE'},\n+    Codepage_Alias{12001, 'UTF-32BE'},\n+    Codepage_Alias{12001, 'UCS4BE'},\n+    Codepage_Alias{12001, 'UCS-4BE'},\n+\n+//#ifndef GLIB_COMPILATION\n+//    //\n+//     * Default is big endian.\n+//     * See rfc2781 4.3 Interpreting text labelled as UTF-16.\n+//     \n+//    Codepage_Alias{1201, 'UTF16'},\n+//    Codepage_Alias{1201, 'UTF-16'},\n+//    Codepage_Alias{1201, 'UCS2'},\n+//    Codepage_Alias{1201, 'UCS-2'},\n+//    Codepage_Alias{12001, 'UTF32'},\n+//    Codepage_Alias{12001, 'UTF-32'},\n+//    Codepage_Alias{12001, 'UCS-4'},\n+//    Codepage_Alias{12001, 'UCS4'},\n+//#else\n+    // Default is little endian, because the platform is\n+    Codepage_Alias{1200, 'UTF16'},\n+    Codepage_Alias{1200, 'UTF-16'},\n+    Codepage_Alias{1200, 'UCS2'},\n+    Codepage_Alias{1200, 'UCS-2'},\n+    Codepage_Alias{12000, 'UTF32'},\n+    Codepage_Alias{12000, 'UTF-32'},\n+    Codepage_Alias{12000, 'UCS4'},\n+    Codepage_Alias{12000, 'UCS-4'},\n+//#endif\n+\n+    // copy from libiconv `iconv -l`\n+    // !IsValidCodePage(367)\n+    Codepage_Alias{20127, 'ANSI_X3.4-1968'},\n+    Codepage_Alias{20127, 'ANSI_X3.4-1986'},\n+    Codepage_Alias{20127, 'ASCII'},\n+    Codepage_Alias{20127, 'CP367'},\n+    Codepage_Alias{20127, 'IBM367'},\n+    Codepage_Alias{20127, 'ISO-IR-6'},\n+    Codepage_Alias{20127, 'ISO646-US'},\n+    Codepage_Alias{20127, 'ISO_646.IRV:1991'},\n+    Codepage_Alias{20127, 'US'},\n+    Codepage_Alias{20127, 'US-ASCII'},\n+    Codepage_Alias{20127, 'CSASCII'},\n+\n+    // !IsValidCodePage(819)\n+    Codepage_Alias{1252, 'CP819'},\n+    Codepage_Alias{1252, 'IBM819'},\n+    Codepage_Alias{28591, 'ISO-8859-1'},\n+    Codepage_Alias{28591, 'ISO-IR-100'},\n+    Codepage_Alias{28591, 'ISO8859-1'},\n+    Codepage_Alias{28591, 'ISO_8859-1'},\n+    Codepage_Alias{28591, 'ISO_8859-1:1987'},\n+    Codepage_Alias{28591, 'L1'},\n+    Codepage_Alias{28591, 'LATIN1'},\n+    Codepage_Alias{28591, 'CSISOLATIN1'},\n+\n+    Codepage_Alias{1250, 'CP1250'},\n+    Codepage_Alias{1250, 'MS-EE'},\n+    Codepage_Alias{1250, 'WINDOWS-1250'},\n+\n+    Codepage_Alias{1251, 'CP1251'},\n+    Codepage_Alias{1251, 'MS-CYRL'},\n+    Codepage_Alias{1251, 'WINDOWS-1251'},\n+\n+    Codepage_Alias{1252, 'CP1252'},\n+    Codepage_Alias{1252, 'MS-ANSI'},\n+    Codepage_Alias{1252, 'WINDOWS-1252'},\n+\n+    Codepage_Alias{1253, 'CP1253'},\n+    Codepage_Alias{1253, 'MS-GREEK'},\n+    Codepage_Alias{1253, 'WINDOWS-1253'},\n+\n+    Codepage_Alias{1254, 'CP1254'},\n+    Codepage_Alias{1254, 'MS-TURK'},\n+    Codepage_Alias{1254, 'WINDOWS-1254'},\n+\n+    Codepage_Alias{1255, 'CP1255'},\n+    Codepage_Alias{1255, 'MS-HEBR'},\n+    Codepage_Alias{1255, 'WINDOWS-1255'},\n+\n+    Codepage_Alias{1256, 'CP1256'},\n+    Codepage_Alias{1256, 'MS-ARAB'},\n+    Codepage_Alias{1256, 'WINDOWS-1256'},\n+\n+    Codepage_Alias{1257, 'CP1257'},\n+    Codepage_Alias{1257, 'WINBALTRIM'},\n+    Codepage_Alias{1257, 'WINDOWS-1257'},\n+\n+    Codepage_Alias{1258, 'CP1258'},\n+    Codepage_Alias{1258, 'WINDOWS-1258'},\n+\n+    Codepage_Alias{850, '850'},\n+    Codepage_Alias{850, 'CP850'},\n+    Codepage_Alias{850, 'IBM850'},\n+    Codepage_Alias{850, 'CSPC850MULTILINGUAL'},\n+\n+    // !IsValidCodePage(862)\n+    Codepage_Alias{862, '862'},\n+    Codepage_Alias{862, 'CP862'},\n+    Codepage_Alias{862, 'IBM862'},\n+    Codepage_Alias{862, 'CSPC862LATINHEBREW'},\n+\n+    Codepage_Alias{866, '866'},\n+    Codepage_Alias{866, 'CP866'},\n+    Codepage_Alias{866, 'IBM866'},\n+    Codepage_Alias{866, 'CSIBM866'},\n+\n+    // !IsValidCodePage(154) \n+    Codepage_Alias{154, 'CP154'},\n+    Codepage_Alias{154, 'CYRILLIC-ASIAN'},\n+    Codepage_Alias{154, 'PT154'},\n+    Codepage_Alias{154, 'PTCP154'},\n+    Codepage_Alias{154, 'CSPTCP154'},\n+\n+    // !IsValidCodePage(1133) \n+    Codepage_Alias{1133, 'CP1133'},\n+    Codepage_Alias{1133, 'IBM-CP1133'},\n+\n+    Codepage_Alias{874, 'CP874'},\n+    Codepage_Alias{874, 'WINDOWS-874'},\n+\n+    // !IsValidCodePage(51932) \n+    Codepage_Alias{51932, 'CP51932'},\n+    Codepage_Alias{51932, 'MS51932'},\n+    Codepage_Alias{51932, 'WINDOWS-51932'},\n+    Codepage_Alias{51932, 'EUC-JP'},\n+\n+    Codepage_Alias{932, 'CP932'},\n+    Codepage_Alias{932, 'MS932'},\n+    Codepage_Alias{932, 'SHIFFT_JIS'},\n+    Codepage_Alias{932, 'SHIFFT_JIS-MS'},\n+    Codepage_Alias{932, 'SJIS'},\n+    Codepage_Alias{932, 'SJIS-MS'},\n+    Codepage_Alias{932, 'SJIS-OPEN'},\n+    Codepage_Alias{932, 'SJIS-WIN'},\n+    Codepage_Alias{932, 'WINDOWS-31J'},\n+    Codepage_Alias{932, 'WINDOWS-932'},\n+    Codepage_Alias{932, 'CSWINDOWS31J'},\n+\n+    Codepage_Alias{50221, 'CP50221'},\n+    Codepage_Alias{50221, 'ISO-2022-JP'},\n+    Codepage_Alias{50221, 'ISO-2022-JP-MS'},\n+    Codepage_Alias{50221, 'ISO2022-JP'},\n+    Codepage_Alias{50221, 'ISO2022-JP-MS'},\n+    Codepage_Alias{50221, 'MS50221'},\n+    Codepage_Alias{50221, 'WINDOWS-50221'},\n+\n+    Codepage_Alias{936, 'CP936'},\n+    Codepage_Alias{936, 'GBK'},\n+    Codepage_Alias{936, 'MS936'},\n+    Codepage_Alias{936, 'WINDOWS-936'},\n+\n+    Codepage_Alias{950, 'CP950'},\n+    Codepage_Alias{950, 'BIG5'},\n+    Codepage_Alias{950, 'BIG5HKSCS'},\n+    Codepage_Alias{950, 'BIG5-HKSCS'},\n+\n+    Codepage_Alias{949, 'CP949'},\n+    Codepage_Alias{949, 'UHC'},\n+    Codepage_Alias{949, 'EUC-KR'},\n+\n+    Codepage_Alias{1361, 'CP1361'},\n+    Codepage_Alias{1361, 'JOHAB'},\n+\n+    Codepage_Alias{437, '437'},\n+    Codepage_Alias{437, 'CP437'},\n+    Codepage_Alias{437, 'IBM437'},\n+    Codepage_Alias{437, 'CSPC8CODEPAGE437'},\n+\n+    Codepage_Alias{737, 'CP737'},\n+\n+    Codepage_Alias{775, 'CP775'},\n+    Codepage_Alias{775, 'IBM775'},\n+    Codepage_Alias{775, 'CSPC775BALTIC'},\n+\n+    Codepage_Alias{852, '852'},\n+    Codepage_Alias{852, 'CP852'},\n+    Codepage_Alias{852, 'IBM852'},\n+    Codepage_Alias{852, 'CSPCP852'},\n+\n+    // !IsValidCodePage(853) \n+    Codepage_Alias{853, 'CP853'},\n+\n+    Codepage_Alias{855, '855'},\n+    Codepage_Alias{855, 'CP855'},\n+    Codepage_Alias{855, 'IBM855'},\n+    Codepage_Alias{855, 'CSIBM855'},\n+\n+    Codepage_Alias{857, '857'},\n+    Codepage_Alias{857, 'CP857'},\n+    Codepage_Alias{857, 'IBM857'},\n+    Codepage_Alias{857, 'CSIBM857'},\n+\n+    // !IsValidCodePage(858) \n+    Codepage_Alias{858, 'CP858'},\n+\n+    Codepage_Alias{860, '860'},\n+    Codepage_Alias{860, 'CP860'},\n+    Codepage_Alias{860, 'IBM860'},\n+    Codepage_Alias{860, 'CSIBM860'},\n+\n+    Codepage_Alias{861, '861'},\n+    Codepage_Alias{861, 'CP-IS'},\n+    Codepage_Alias{861, 'CP861'},\n+    Codepage_Alias{861, 'IBM861'},\n+    Codepage_Alias{861, 'CSIBM861'},\n+\n+    Codepage_Alias{863, '863'},\n+    Codepage_Alias{863, 'CP863'},\n+    Codepage_Alias{863, 'IBM863'},\n+    Codepage_Alias{863, 'CSIBM863'},\n+\n+    Codepage_Alias{864, 'CP864'},\n+    Codepage_Alias{864, 'IBM864'},\n+    Codepage_Alias{864, 'CSIBM864'},\n+\n+    Codepage_Alias{865, '865'},\n+    Codepage_Alias{865, 'CP865'},\n+    Codepage_Alias{865, 'IBM865'},\n+    Codepage_Alias{865, 'CSIBM865'},\n+\n+    Codepage_Alias{869, '869'},\n+    Codepage_Alias{869, 'CP-GR'},\n+    Codepage_Alias{869, 'CP869'},\n+    Codepage_Alias{869, 'IBM869'},\n+    Codepage_Alias{869, 'CSIBM869'},\n+\n+    // !IsValidCodePage(1152) \n+    Codepage_Alias{1125, 'CP1125'},\n+\n+    //\n+    // * Code Page Identifiers\n+    // * https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers\n+     \n+    Codepage_Alias{37, 'IBM037'}, // IBM EBCDIC US-Canada \n+    Codepage_Alias{437, 'IBM437'}, // OEM United States \n+    Codepage_Alias{500, 'IBM500'}, // IBM EBCDIC International \n+    Codepage_Alias{708, 'ASMO-708'}, // Arabic (ASMO 708) \n+    // 709 \t\tArabic (ASMO-449+, BCON V4) \n+    // 710 \t\tArabic - Transparent Arabic \n+    Codepage_Alias{720, 'DOS-720'}, // Arabic (Transparent ASMO); Arabic (DOS) \n+    Codepage_Alias{737, 'IBM737'}, // OEM Greek (formerly 437G); Greek (DOS) \n+    Codepage_Alias{775, 'IBM775'}, // OEM Baltic; Baltic (DOS) \n+    Codepage_Alias{850, 'IBM850'}, // OEM Multilingual Latin 1; Western European (DOS) \n+    Codepage_Alias{852, 'IBM852'}, // OEM Latin 2; Central European (DOS) \n+    Codepage_Alias{855, 'IBM855'}, // OEM Cyrillic (primarily Russian) \n+    Codepage_Alias{857, 'IBM857'}, // OEM Turkish; Turkish (DOS) \n+    Codepage_Alias{858, 'IBM00858'}, // OEM Multilingual Latin 1 + Euro symbol \n+    Codepage_Alias{860, 'IBM860'}, // OEM Portuguese; Portuguese (DOS) \n+    Codepage_Alias{861, 'IBM861'}, // OEM Icelandic; Icelandic (DOS) \n+    Codepage_Alias{862, 'DOS-862'}, // OEM Hebrew; Hebrew (DOS) \n+    Codepage_Alias{863, 'IBM863'}, // OEM French Canadian; French Canadian (DOS) \n+    Codepage_Alias{864, 'IBM864'}, // OEM Arabic; Arabic (864) \n+    Codepage_Alias{865, 'IBM865'}, // OEM Nordic; Nordic (DOS) \n+    Codepage_Alias{866, 'CP866'}, // OEM Russian; Cyrillic (DOS) \n+    Codepage_Alias{869, 'IBM869'}, // OEM Modern Greek; Greek, Modern (DOS) \n+    Codepage_Alias{870, 'IBM870'}, // IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2 \n+    Codepage_Alias{874, 'WINDOWS-874'}, // ANSI/OEM Thai (same as 28605, ISO 8859-15); Thai (Windows) \n+    Codepage_Alias{875, 'CP875'}, // IBM EBCDIC Greek Modern \n+    Codepage_Alias{932, 'SHIFT_JIS'}, // ANSI/OEM Japanese; Japanese (Shift-JIS) \n+    Codepage_Alias{932, 'SHIFT-JIS'}, // alternative name for it \n+    Codepage_Alias{936, 'GB2312'}, // ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312) \n+    Codepage_Alias{949, 'KS_C_5601-1987'}, // ANSI/OEM Korean (Unified Hangul Code) \n+    Codepage_Alias{950, 'BIG5'}, // ANSI/OEM Traditional Chinese (Taiwan; Hong Kong SAR, PRC); Chinese Traditional (Big5) \n+    Codepage_Alias{950, 'BIG5HKSCS'}, // ANSI/OEM Traditional Chinese (Hong Kong SAR); Chinese Traditional (Big5-HKSCS) \n+    Codepage_Alias{950, 'BIG5-HKSCS'}, // alternative name for it \n+    Codepage_Alias{1026, 'IBM1026'}, // IBM EBCDIC Turkish (Latin 5) \n+    Codepage_Alias{1047, 'IBM01047'}, // IBM EBCDIC Latin 1/Open System \n+    Codepage_Alias{1140, 'IBM01140'}, // IBM EBCDIC US-Canada (037 + Euro symbol); IBM EBCDIC (US-Canada-Euro) \n+    Codepage_Alias{1141, 'IBM01141'}, // IBM EBCDIC Germany (20273 + Euro symbol); IBM EBCDIC (Germany-Euro) \n+    Codepage_Alias{1142, 'IBM01142'}, // IBM EBCDIC Denmark-Norway (20277 + Euro symbol); IBM EBCDIC (Denmark-Norway-Euro) \n+    Codepage_Alias{1143, 'IBM01143'}, // IBM EBCDIC Finland-Sweden (20278 + Euro symbol); IBM EBCDIC (Finland-Sweden-Euro) \n+    Codepage_Alias{1144, 'IBM01144'}, // IBM EBCDIC Italy (20280 + Euro symbol); IBM EBCDIC (Italy-Euro) \n+    Codepage_Alias{1145, 'IBM01145'}, // IBM EBCDIC Latin America-Spain (20284 + Euro symbol); IBM EBCDIC (Spain-Euro) \n+    Codepage_Alias{1146, 'IBM01146'}, // IBM EBCDIC United Kingdom (20285 + Euro symbol); IBM EBCDIC (UK-Euro) \n+    Codepage_Alias{1147, 'IBM01147'}, // IBM EBCDIC France (20297 + Euro symbol); IBM EBCDIC (France-Euro) \n+    Codepage_Alias{1148, 'IBM01148'}, // IBM EBCDIC International (500 + Euro symbol); IBM EBCDIC (International-Euro) \n+    Codepage_Alias{1149, 'IBM01149'}, // IBM EBCDIC Icelandic (20871 + Euro symbol); IBM EBCDIC (Icelandic-Euro) \n+    Codepage_Alias{1200, 'UTF-16'}, // Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications \n+    Codepage_Alias{1201, 'UNICODEFFFE'}, // Unicode UTF-16, big endian byte order; available only to managed applications \n+    Codepage_Alias{1250, 'WINDOWS-1250'}, // ANSI Central European; Central European (Windows) \n+    Codepage_Alias{1251, 'WINDOWS-1251'}, // ANSI Cyrillic; Cyrillic (Windows) \n+    Codepage_Alias{1252, 'WINDOWS-1252'}, // ANSI Latin 1; Western European (Windows) \n+    Codepage_Alias{1253, 'WINDOWS-1253'}, // ANSI Greek; Greek (Windows) \n+    Codepage_Alias{1254, 'WINDOWS-1254'}, // ANSI Turkish; Turkish (Windows) \n+    Codepage_Alias{1255, 'WINDOWS-1255'}, // ANSI Hebrew; Hebrew (Windows) \n+    Codepage_Alias{1256, 'WINDOWS-1256'}, // ANSI Arabic; Arabic (Windows) \n+    Codepage_Alias{1257, 'WINDOWS-1257'}, // ANSI Baltic; Baltic (Windows) \n+    Codepage_Alias{1258, 'WINDOWS-1258'}, // ANSI/OEM Vietnamese; Vietnamese (Windows) \n+    Codepage_Alias{1361, 'JOHAB'}, // Korean (Johab) \n+    Codepage_Alias{10000, 'MACINTOSH'}, // MAC Roman; Western European (Mac) \n+    Codepage_Alias{10001, 'X-MAC-JAPANESE'}, // Japanese (Mac) \n+    Codepage_Alias{10002, 'X-MAC-CHINESETRAD'}, // MAC Traditional Chinese (Big5); Chinese Traditional (Mac) \n+    Codepage_Alias{10003, 'X-MAC-KOREAN'}, // Korean (Mac) \n+    Codepage_Alias{10004, 'X-MAC-ARABIC'}, // Arabic (Mac) \n+    Codepage_Alias{10005, 'X-MAC-HEBREW'}, // Hebrew (Mac) \n+    Codepage_Alias{10006, 'X-MAC-GREEK'}, // Greek (Mac) \n+    Codepage_Alias{10007, 'X-MAC-CYRILLIC'}, // Cyrillic (Mac) \n+    Codepage_Alias{10008, 'X-MAC-CHINESESIMP'}, // MAC Simplified Chinese (GB 2312); Chinese Simplified (Mac) \n+    Codepage_Alias{10010, 'X-MAC-ROMANIAN'}, // Romanian (Mac) \n+    Codepage_Alias{10017, 'X-MAC-UKRAINIAN'}, // Ukrainian (Mac) \n+    Codepage_Alias{10021, 'X-MAC-THAI'}, // Thai (Mac) \n+    Codepage_Alias{10029, 'X-MAC-CE'}, // MAC Latin 2; Central European (Mac) \n+    Codepage_Alias{10079, 'X-MAC-ICELANDIC'}, // Icelandic (Mac) \n+    Codepage_Alias{10081, 'X-MAC-TURKISH'}, // Turkish (Mac) \n+    Codepage_Alias{10082, 'X-MAC-CROATIAN'}, // Croatian (Mac) \n+    Codepage_Alias{12000, 'UTF-32'}, // Unicode UTF-32, little endian byte order; available only to managed applications \n+    Codepage_Alias{12001, 'UTF-32BE'}, // Unicode UTF-32, big endian byte order; available only to managed applications \n+\tCodepage_Alias{20000, 'X-CHINESE_CNS'}, // CNS Taiwan; Chinese Traditional (CNS) \n+    Codepage_Alias{20001, 'X-CP20001'}, // TCA Taiwan \n+    Codepage_Alias{20002, 'X_CHINESE-ETEN'}, // Eten Taiwan; Chinese Traditional (Eten) \n+    Codepage_Alias{20003, 'X-CP20003'}, // IBM5550 Taiwan \n+    Codepage_Alias{20004, 'X-CP20004'}, // TeleText Taiwan \n+    Codepage_Alias{20005, 'X-CP20005'}, // Wang Taiwan \n+    Codepage_Alias{20105, 'X-IA5'}, // IA5 (IRV International Alphabet No. 5, 7-bit); Western European (IA5) \n+    Codepage_Alias{20106, 'X-IA5-GERMAN'}, // IA5 German (7-bit) \n+    Codepage_Alias{20107, 'X-IA5-SWEDISH'}, // IA5 Swedish (7-bit) \n+    Codepage_Alias{20108, 'X-IA5-NORWEGIAN'}, // IA5 Norwegian (7-bit) \n+    Codepage_Alias{20127, 'US-ASCII'}, // US-ASCII (7-bit) \n+    Codepage_Alias{20261, 'X-CP20261'}, // T.61 \n+    Codepage_Alias{20269, 'X-CP20269'}, // ISO 6937 Non-Spacing Accent \n+    Codepage_Alias{20273, 'IBM273'}, // IBM EBCDIC Germany \n+    Codepage_Alias{20277, 'IBM277'}, // IBM EBCDIC Denmark-Norway \n+    Codepage_Alias{20278, 'IBM278'}, // IBM EBCDIC Finland-Sweden \n+    Codepage_Alias{20280, 'IBM280'}, // IBM EBCDIC Italy \n+    Codepage_Alias{20284, 'IBM284'}, // IBM EBCDIC Latin America-Spain \n+    Codepage_Alias{20285, 'IBM285'}, // IBM EBCDIC United Kingdom \n+    Codepage_Alias{20290, 'IBM290'}, // IBM EBCDIC Japanese Katakana Extended \n+    Codepage_Alias{20297, 'IBM297'}, // IBM EBCDIC France \n+    Codepage_Alias{20420, 'IBM420'}, // IBM EBCDIC Arabic \n+    Codepage_Alias{20423, 'IBM423'}, // IBM EBCDIC Greek \n+    Codepage_Alias{20424, 'IBM424'}, // IBM EBCDIC Hebrew \n+    Codepage_Alias{20833, 'X-EBCDIC-KOREANEXTENDED'}, // IBM EBCDIC Korean Extended \n+    Codepage_Alias{20838, 'IBM-THAI'}, // IBM EBCDIC Thai \n+    Codepage_Alias{20866, 'KOI8-R'}, // Russian (KOI8-R); Cyrillic (KOI8-R) \n+    Codepage_Alias{20871, 'IBM871'}, // IBM EBCDIC Icelandic \n+    Codepage_Alias{20880, 'IBM880'}, // IBM EBCDIC Cyrillic Russian \n+    Codepage_Alias{20905, 'IBM905'}, // IBM EBCDIC Turkish \n+    Codepage_Alias{20924, 'IBM00924'}, // IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) \n+    Codepage_Alias{20932, 'EUC-JP'}, // Japanese (JIS 0208-1990 and 0121-1990) \n+    Codepage_Alias{20936, 'X-CP20936'}, // Simplified Chinese (GB2312); Chinese Simplified (GB2312-80) \n+    Codepage_Alias{20949, 'X-CP20949'}, // Korean Wansung \n+    Codepage_Alias{21025, 'CP1025'}, // IBM EBCDIC Cyrillic Serbian-Bulgarian \n+    // 21027 \t\t(deprecated) \n+    Codepage_Alias{21866, 'KOI8-U'}, // Ukrainian (KOI8-U); Cyrillic (KOI8-U) \n+    Codepage_Alias{28591, 'ISO-8859-1'}, // ISO 8859-1 Latin 1; Western European (ISO) \n+    Codepage_Alias{28591, 'ISO8859-1'}, // ISO 8859-1 Latin 1; Western European (ISO) \n+    Codepage_Alias{28591, 'ISO_8859-1'},\n+    Codepage_Alias{28591, 'ISO_8859_1'},\n+    Codepage_Alias{28592, 'ISO-8859-2'}, // ISO 8859-2 Central European; Central European (ISO) \n+    Codepage_Alias{28592, 'ISO8859-2'}, // ISO 8859-2 Central European; Central European (ISO) \n+    Codepage_Alias{28592, 'ISO_8859-2'},\n+    Codepage_Alias{28592, 'ISO_8859_2'},\n+    Codepage_Alias{28593, 'ISO-8859-3'}, // ISO 8859-3 Latin 3 \n+    Codepage_Alias{28593, 'ISO8859-3'}, // ISO 8859-3 Latin 3 \n+    Codepage_Alias{28593, 'ISO_8859-3'},\n+    Codepage_Alias{28593, 'ISO_8859_3'},\n+    Codepage_Alias{28594, 'ISO-8859-4'}, // ISO 8859-4 Baltic \n+    Codepage_Alias{28594, 'ISO8859-4'}, // ISO 8859-4 Baltic \n+    Codepage_Alias{28594, 'ISO_8859-4'},\n+    Codepage_Alias{28594, 'ISO_8859_4'},\n+    Codepage_Alias{28595, 'ISO-8859-5'}, // ISO 8859-5 Cyrillic \n+    Codepage_Alias{28595, 'ISO8859-5'}, // ISO 8859-5 Cyrillic \n+    Codepage_Alias{28595, 'ISO_8859-5'},\n+    Codepage_Alias{28595, 'ISO_8859_5'},\n+    Codepage_Alias{28596, 'ISO-8859-6'}, // ISO 8859-6 Arabic \n+    Codepage_Alias{28596, 'ISO8859-6'}, // ISO 8859-6 Arabic \n+    Codepage_Alias{28596, 'ISO_8859-6'},\n+    Codepage_Alias{28596, 'ISO_8859_6'},\n+    Codepage_Alias{28597, 'ISO-8859-7'}, // ISO 8859-7 Greek \n+    Codepage_Alias{28597, 'ISO8859-7'}, // ISO 8859-7 Greek \n+    Codepage_Alias{28597, 'ISO_8859-7'},\n+    Codepage_Alias{28597, 'ISO_8859_7'},\n+    Codepage_Alias{28598, 'ISO-8859-8'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Visual) \n+    Codepage_Alias{28598, 'ISO8859-8'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Visual) \n+    Codepage_Alias{28598, 'ISO_8859-8'},\n+    Codepage_Alias{28598, 'ISO_8859_8'},\n+    Codepage_Alias{28599, 'ISO-8859-9'}, // ISO 8859-9 Turkish \n+    Codepage_Alias{28599, 'ISO8859-9'}, // ISO 8859-9 Turkish \n+    Codepage_Alias{28599, 'ISO_8859-9'},\n+    Codepage_Alias{28599, 'ISO_8859_9'},\n+    Codepage_Alias{28603, 'ISO-8859-13'}, // ISO 8859-13 Estonian \n+    Codepage_Alias{28603, 'ISO8859-13'}, // ISO 8859-13 Estonian \n+    Codepage_Alias{28603, 'ISO_8859-13'},\n+    Codepage_Alias{28603, 'ISO_8859_13'},\n+    Codepage_Alias{28605, 'ISO-8859-15'}, // ISO 8859-15 Latin 9 \n+    Codepage_Alias{28605, 'ISO8859-15'}, // ISO 8859-15 Latin 9 \n+    Codepage_Alias{28605, 'ISO_8859-15'},\n+    Codepage_Alias{28605, 'ISO_8859_15'},\n+    Codepage_Alias{29001, 'X-EUROPA'}, // Europa 3 \n+    Codepage_Alias{38598, 'ISO-8859-8-I'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Logical) \n+    Codepage_Alias{38598, 'ISO8859-8-I'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Logical) \n+    Codepage_Alias{38598, 'ISO_8859-8-I'},\n+    Codepage_Alias{38598, 'ISO_8859_8-I'},\n+    Codepage_Alias{50220, 'ISO-2022-JP'}, // ISO 2022 Japanese with no halfwidth Katakana; Japanese (JIS) \n+    Codepage_Alias{50221, 'CSISO2022JP'}, // ISO 2022 Japanese with halfwidth Katakana; Japanese (JIS-Allow 1 byte Kana) \n+    Codepage_Alias{50222, 'ISO-2022-JP'}, // ISO 2022 Japanese JIS X 0201-1989; Japanese (JIS-Allow 1 byte Kana - SO/SI) \n+    Codepage_Alias{50225, 'ISO-2022-KR'}, // ISO 2022 Korean \n+    Codepage_Alias{50225, 'ISO2022-KR'}, // ISO 2022 Korean \n+    Codepage_Alias{50227, 'X-CP50227'}, // ISO 2022 Simplified Chinese; Chinese Simplified (ISO 2022) \n+    // 50229 \t\tISO 2022 Traditional Chinese \n+    // 50930 \t\tEBCDIC Japanese (Katakana) Extended \n+    // 50931 \t\tEBCDIC US-Canada and Japanese \n+    // 50933 \t\tEBCDIC Korean Extended and Korean \n+    // 50935 \t\tEBCDIC Simplified Chinese Extended and Simplified Chinese \n+    // 50936 \t\tEBCDIC Simplified Chinese \n+    // 50937 \t\tEBCDIC US-Canada and Traditional Chinese \n+    // 50939 \t\tEBCDIC Japanese (Latin) Extended and Japanese \n+    Codepage_Alias{51932, 'EUC-JP'}, // EUC Japanese \n+    Codepage_Alias{51936, 'EUC-CN'}, // EUC Simplified Chinese; Chinese Simplified (EUC) \n+    Codepage_Alias{51949, 'EUC-KR'}, // EUC Korean \n+    // 51950 \t\tEUC Traditional Chinese \n+    Codepage_Alias{52936, 'HZ-GB-2312'}, // HZ-GB2312 Simplified Chinese; Chinese Simplified (HZ) \n+    Codepage_Alias{54936, 'GB18030'}, // Windows XP and later: GB18030 Simplified Chinese (4 byte); Chinese Simplified (GB18030) \n+    Codepage_Alias{57002, 'X-ISCII-DE'}, // ISCII Devanagari \n+    Codepage_Alias{57003, 'X-ISCII-BE'}, // ISCII Bengali \n+    Codepage_Alias{57004, 'X-ISCII-TA'}, // ISCII Tamil \n+    Codepage_Alias{57005, 'X-ISCII-TE'}, // ISCII Telugu \n+    Codepage_Alias{57006, 'X-ISCII-AS'}, // ISCII Assamese \n+    Codepage_Alias{57007, 'X-ISCII-OR'}, // ISCII Oriya \n+    Codepage_Alias{57008, 'X-ISCII-KA'}, // ISCII Kannada \n+    Codepage_Alias{57009, 'X-ISCII-MA'}, // ISCII Malayalam \n+    Codepage_Alias{57010, 'X-ISCII-GU'}, // ISCII Gujarati \n+    Codepage_Alias{57011, 'X-ISCII-PA'}, // ISCII Punjabi \n+    Codepage_Alias{65000, 'UTF-7'}, // Unicode (UTF-7) \n+    Codepage_Alias{65001, 'UTF-8'}, // Unicode (UTF-8) \n+\t// vfmt on\n+]\n+\n+fn name_to_codepage(name string) int {\n+\tname_upper := name.to_upper()",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1782182889",
        "repo_full_name": "vlang/v",
        "pr_number": 22332,
        "pr_file": "vlib/encoding/iconv/iconv_windows.c.v",
        "discussion_id": "1782182889",
        "commented_code": "@@ -0,0 +1,563 @@\n+module iconv\n+\n+// Module iconv provides functions convert between vstring(UTF8) to/from different encodings.\n+// iconv implementation using Win32 API to convert\n+// Idear from https://github.com/win-iconv/win-iconv\n+\n+fn C.GetACP() int\n+fn C.GetOEMCP() int\n+fn C.WideCharToMultiByte(codepage u32, dwflags u32, src &u8, src_len int, dst &u8, dst_len int, default_char &u8, used_default_char &bool) int\n+fn C.MultiByteToWideChar(codepage u32, dwflags u32, src &u8, src_len int, dst &u8, dst_len int) int\n+\n+struct Codepage_Alias {\n+\tcodepage int\n+\tname     string\n+}\n+\n+const codepage_alias = [\n+\t// NOTE! name field string MUST in uppercase!\n+\t// vfmt off\n+\tCodepage_Alias{65001, 'CP65001'},\n+    Codepage_Alias{65001, 'UTF8'},\n+    Codepage_Alias{65001, 'UTF-8'},\n+\n+    Codepage_Alias{1200, 'CP1200'},\n+    Codepage_Alias{1200, 'UTF16LE'},\n+    Codepage_Alias{1200, 'UTF-16LE'},\n+    Codepage_Alias{1200, 'UCS2LE'},\n+    Codepage_Alias{1200, 'UCS-2LE'},\n+    Codepage_Alias{1200, 'UCS-2-INTERNAL'},\n+    Codepage_Alias{1200, 'UNICODE'},\t// for iconv \n+\n+    Codepage_Alias{1201, 'CP1201'},\n+    Codepage_Alias{1201, 'UTF16BE'},\n+    Codepage_Alias{1201, 'UTF-16BE'},\n+    Codepage_Alias{1201, 'UCS2BE'},\n+    Codepage_Alias{1201, 'UCS-2BE'},\n+    Codepage_Alias{1201, 'UNICODEFFFE'},\n+\n+    Codepage_Alias{12000, 'CP12000'},\n+    Codepage_Alias{12000, 'UTF32LE'},\n+    Codepage_Alias{12000, 'UTF-32LE'},\n+    Codepage_Alias{12000, 'UCS4LE'},\n+    Codepage_Alias{12000, 'UCS-4LE'},\n+\n+    Codepage_Alias{12001, 'CP12001'},\n+    Codepage_Alias{12001, 'UTF32BE'},\n+    Codepage_Alias{12001, 'UTF-32BE'},\n+    Codepage_Alias{12001, 'UCS4BE'},\n+    Codepage_Alias{12001, 'UCS-4BE'},\n+\n+//#ifndef GLIB_COMPILATION\n+//    //\n+//     * Default is big endian.\n+//     * See rfc2781 4.3 Interpreting text labelled as UTF-16.\n+//     \n+//    Codepage_Alias{1201, 'UTF16'},\n+//    Codepage_Alias{1201, 'UTF-16'},\n+//    Codepage_Alias{1201, 'UCS2'},\n+//    Codepage_Alias{1201, 'UCS-2'},\n+//    Codepage_Alias{12001, 'UTF32'},\n+//    Codepage_Alias{12001, 'UTF-32'},\n+//    Codepage_Alias{12001, 'UCS-4'},\n+//    Codepage_Alias{12001, 'UCS4'},\n+//#else\n+    // Default is little endian, because the platform is\n+    Codepage_Alias{1200, 'UTF16'},\n+    Codepage_Alias{1200, 'UTF-16'},\n+    Codepage_Alias{1200, 'UCS2'},\n+    Codepage_Alias{1200, 'UCS-2'},\n+    Codepage_Alias{12000, 'UTF32'},\n+    Codepage_Alias{12000, 'UTF-32'},\n+    Codepage_Alias{12000, 'UCS4'},\n+    Codepage_Alias{12000, 'UCS-4'},\n+//#endif\n+\n+    // copy from libiconv `iconv -l`\n+    // !IsValidCodePage(367)\n+    Codepage_Alias{20127, 'ANSI_X3.4-1968'},\n+    Codepage_Alias{20127, 'ANSI_X3.4-1986'},\n+    Codepage_Alias{20127, 'ASCII'},\n+    Codepage_Alias{20127, 'CP367'},\n+    Codepage_Alias{20127, 'IBM367'},\n+    Codepage_Alias{20127, 'ISO-IR-6'},\n+    Codepage_Alias{20127, 'ISO646-US'},\n+    Codepage_Alias{20127, 'ISO_646.IRV:1991'},\n+    Codepage_Alias{20127, 'US'},\n+    Codepage_Alias{20127, 'US-ASCII'},\n+    Codepage_Alias{20127, 'CSASCII'},\n+\n+    // !IsValidCodePage(819)\n+    Codepage_Alias{1252, 'CP819'},\n+    Codepage_Alias{1252, 'IBM819'},\n+    Codepage_Alias{28591, 'ISO-8859-1'},\n+    Codepage_Alias{28591, 'ISO-IR-100'},\n+    Codepage_Alias{28591, 'ISO8859-1'},\n+    Codepage_Alias{28591, 'ISO_8859-1'},\n+    Codepage_Alias{28591, 'ISO_8859-1:1987'},\n+    Codepage_Alias{28591, 'L1'},\n+    Codepage_Alias{28591, 'LATIN1'},\n+    Codepage_Alias{28591, 'CSISOLATIN1'},\n+\n+    Codepage_Alias{1250, 'CP1250'},\n+    Codepage_Alias{1250, 'MS-EE'},\n+    Codepage_Alias{1250, 'WINDOWS-1250'},\n+\n+    Codepage_Alias{1251, 'CP1251'},\n+    Codepage_Alias{1251, 'MS-CYRL'},\n+    Codepage_Alias{1251, 'WINDOWS-1251'},\n+\n+    Codepage_Alias{1252, 'CP1252'},\n+    Codepage_Alias{1252, 'MS-ANSI'},\n+    Codepage_Alias{1252, 'WINDOWS-1252'},\n+\n+    Codepage_Alias{1253, 'CP1253'},\n+    Codepage_Alias{1253, 'MS-GREEK'},\n+    Codepage_Alias{1253, 'WINDOWS-1253'},\n+\n+    Codepage_Alias{1254, 'CP1254'},\n+    Codepage_Alias{1254, 'MS-TURK'},\n+    Codepage_Alias{1254, 'WINDOWS-1254'},\n+\n+    Codepage_Alias{1255, 'CP1255'},\n+    Codepage_Alias{1255, 'MS-HEBR'},\n+    Codepage_Alias{1255, 'WINDOWS-1255'},\n+\n+    Codepage_Alias{1256, 'CP1256'},\n+    Codepage_Alias{1256, 'MS-ARAB'},\n+    Codepage_Alias{1256, 'WINDOWS-1256'},\n+\n+    Codepage_Alias{1257, 'CP1257'},\n+    Codepage_Alias{1257, 'WINBALTRIM'},\n+    Codepage_Alias{1257, 'WINDOWS-1257'},\n+\n+    Codepage_Alias{1258, 'CP1258'},\n+    Codepage_Alias{1258, 'WINDOWS-1258'},\n+\n+    Codepage_Alias{850, '850'},\n+    Codepage_Alias{850, 'CP850'},\n+    Codepage_Alias{850, 'IBM850'},\n+    Codepage_Alias{850, 'CSPC850MULTILINGUAL'},\n+\n+    // !IsValidCodePage(862)\n+    Codepage_Alias{862, '862'},\n+    Codepage_Alias{862, 'CP862'},\n+    Codepage_Alias{862, 'IBM862'},\n+    Codepage_Alias{862, 'CSPC862LATINHEBREW'},\n+\n+    Codepage_Alias{866, '866'},\n+    Codepage_Alias{866, 'CP866'},\n+    Codepage_Alias{866, 'IBM866'},\n+    Codepage_Alias{866, 'CSIBM866'},\n+\n+    // !IsValidCodePage(154) \n+    Codepage_Alias{154, 'CP154'},\n+    Codepage_Alias{154, 'CYRILLIC-ASIAN'},\n+    Codepage_Alias{154, 'PT154'},\n+    Codepage_Alias{154, 'PTCP154'},\n+    Codepage_Alias{154, 'CSPTCP154'},\n+\n+    // !IsValidCodePage(1133) \n+    Codepage_Alias{1133, 'CP1133'},\n+    Codepage_Alias{1133, 'IBM-CP1133'},\n+\n+    Codepage_Alias{874, 'CP874'},\n+    Codepage_Alias{874, 'WINDOWS-874'},\n+\n+    // !IsValidCodePage(51932) \n+    Codepage_Alias{51932, 'CP51932'},\n+    Codepage_Alias{51932, 'MS51932'},\n+    Codepage_Alias{51932, 'WINDOWS-51932'},\n+    Codepage_Alias{51932, 'EUC-JP'},\n+\n+    Codepage_Alias{932, 'CP932'},\n+    Codepage_Alias{932, 'MS932'},\n+    Codepage_Alias{932, 'SHIFFT_JIS'},\n+    Codepage_Alias{932, 'SHIFFT_JIS-MS'},\n+    Codepage_Alias{932, 'SJIS'},\n+    Codepage_Alias{932, 'SJIS-MS'},\n+    Codepage_Alias{932, 'SJIS-OPEN'},\n+    Codepage_Alias{932, 'SJIS-WIN'},\n+    Codepage_Alias{932, 'WINDOWS-31J'},\n+    Codepage_Alias{932, 'WINDOWS-932'},\n+    Codepage_Alias{932, 'CSWINDOWS31J'},\n+\n+    Codepage_Alias{50221, 'CP50221'},\n+    Codepage_Alias{50221, 'ISO-2022-JP'},\n+    Codepage_Alias{50221, 'ISO-2022-JP-MS'},\n+    Codepage_Alias{50221, 'ISO2022-JP'},\n+    Codepage_Alias{50221, 'ISO2022-JP-MS'},\n+    Codepage_Alias{50221, 'MS50221'},\n+    Codepage_Alias{50221, 'WINDOWS-50221'},\n+\n+    Codepage_Alias{936, 'CP936'},\n+    Codepage_Alias{936, 'GBK'},\n+    Codepage_Alias{936, 'MS936'},\n+    Codepage_Alias{936, 'WINDOWS-936'},\n+\n+    Codepage_Alias{950, 'CP950'},\n+    Codepage_Alias{950, 'BIG5'},\n+    Codepage_Alias{950, 'BIG5HKSCS'},\n+    Codepage_Alias{950, 'BIG5-HKSCS'},\n+\n+    Codepage_Alias{949, 'CP949'},\n+    Codepage_Alias{949, 'UHC'},\n+    Codepage_Alias{949, 'EUC-KR'},\n+\n+    Codepage_Alias{1361, 'CP1361'},\n+    Codepage_Alias{1361, 'JOHAB'},\n+\n+    Codepage_Alias{437, '437'},\n+    Codepage_Alias{437, 'CP437'},\n+    Codepage_Alias{437, 'IBM437'},\n+    Codepage_Alias{437, 'CSPC8CODEPAGE437'},\n+\n+    Codepage_Alias{737, 'CP737'},\n+\n+    Codepage_Alias{775, 'CP775'},\n+    Codepage_Alias{775, 'IBM775'},\n+    Codepage_Alias{775, 'CSPC775BALTIC'},\n+\n+    Codepage_Alias{852, '852'},\n+    Codepage_Alias{852, 'CP852'},\n+    Codepage_Alias{852, 'IBM852'},\n+    Codepage_Alias{852, 'CSPCP852'},\n+\n+    // !IsValidCodePage(853) \n+    Codepage_Alias{853, 'CP853'},\n+\n+    Codepage_Alias{855, '855'},\n+    Codepage_Alias{855, 'CP855'},\n+    Codepage_Alias{855, 'IBM855'},\n+    Codepage_Alias{855, 'CSIBM855'},\n+\n+    Codepage_Alias{857, '857'},\n+    Codepage_Alias{857, 'CP857'},\n+    Codepage_Alias{857, 'IBM857'},\n+    Codepage_Alias{857, 'CSIBM857'},\n+\n+    // !IsValidCodePage(858) \n+    Codepage_Alias{858, 'CP858'},\n+\n+    Codepage_Alias{860, '860'},\n+    Codepage_Alias{860, 'CP860'},\n+    Codepage_Alias{860, 'IBM860'},\n+    Codepage_Alias{860, 'CSIBM860'},\n+\n+    Codepage_Alias{861, '861'},\n+    Codepage_Alias{861, 'CP-IS'},\n+    Codepage_Alias{861, 'CP861'},\n+    Codepage_Alias{861, 'IBM861'},\n+    Codepage_Alias{861, 'CSIBM861'},\n+\n+    Codepage_Alias{863, '863'},\n+    Codepage_Alias{863, 'CP863'},\n+    Codepage_Alias{863, 'IBM863'},\n+    Codepage_Alias{863, 'CSIBM863'},\n+\n+    Codepage_Alias{864, 'CP864'},\n+    Codepage_Alias{864, 'IBM864'},\n+    Codepage_Alias{864, 'CSIBM864'},\n+\n+    Codepage_Alias{865, '865'},\n+    Codepage_Alias{865, 'CP865'},\n+    Codepage_Alias{865, 'IBM865'},\n+    Codepage_Alias{865, 'CSIBM865'},\n+\n+    Codepage_Alias{869, '869'},\n+    Codepage_Alias{869, 'CP-GR'},\n+    Codepage_Alias{869, 'CP869'},\n+    Codepage_Alias{869, 'IBM869'},\n+    Codepage_Alias{869, 'CSIBM869'},\n+\n+    // !IsValidCodePage(1152) \n+    Codepage_Alias{1125, 'CP1125'},\n+\n+    //\n+    // * Code Page Identifiers\n+    // * https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers\n+     \n+    Codepage_Alias{37, 'IBM037'}, // IBM EBCDIC US-Canada \n+    Codepage_Alias{437, 'IBM437'}, // OEM United States \n+    Codepage_Alias{500, 'IBM500'}, // IBM EBCDIC International \n+    Codepage_Alias{708, 'ASMO-708'}, // Arabic (ASMO 708) \n+    // 709 \t\tArabic (ASMO-449+, BCON V4) \n+    // 710 \t\tArabic - Transparent Arabic \n+    Codepage_Alias{720, 'DOS-720'}, // Arabic (Transparent ASMO); Arabic (DOS) \n+    Codepage_Alias{737, 'IBM737'}, // OEM Greek (formerly 437G); Greek (DOS) \n+    Codepage_Alias{775, 'IBM775'}, // OEM Baltic; Baltic (DOS) \n+    Codepage_Alias{850, 'IBM850'}, // OEM Multilingual Latin 1; Western European (DOS) \n+    Codepage_Alias{852, 'IBM852'}, // OEM Latin 2; Central European (DOS) \n+    Codepage_Alias{855, 'IBM855'}, // OEM Cyrillic (primarily Russian) \n+    Codepage_Alias{857, 'IBM857'}, // OEM Turkish; Turkish (DOS) \n+    Codepage_Alias{858, 'IBM00858'}, // OEM Multilingual Latin 1 + Euro symbol \n+    Codepage_Alias{860, 'IBM860'}, // OEM Portuguese; Portuguese (DOS) \n+    Codepage_Alias{861, 'IBM861'}, // OEM Icelandic; Icelandic (DOS) \n+    Codepage_Alias{862, 'DOS-862'}, // OEM Hebrew; Hebrew (DOS) \n+    Codepage_Alias{863, 'IBM863'}, // OEM French Canadian; French Canadian (DOS) \n+    Codepage_Alias{864, 'IBM864'}, // OEM Arabic; Arabic (864) \n+    Codepage_Alias{865, 'IBM865'}, // OEM Nordic; Nordic (DOS) \n+    Codepage_Alias{866, 'CP866'}, // OEM Russian; Cyrillic (DOS) \n+    Codepage_Alias{869, 'IBM869'}, // OEM Modern Greek; Greek, Modern (DOS) \n+    Codepage_Alias{870, 'IBM870'}, // IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2 \n+    Codepage_Alias{874, 'WINDOWS-874'}, // ANSI/OEM Thai (same as 28605, ISO 8859-15); Thai (Windows) \n+    Codepage_Alias{875, 'CP875'}, // IBM EBCDIC Greek Modern \n+    Codepage_Alias{932, 'SHIFT_JIS'}, // ANSI/OEM Japanese; Japanese (Shift-JIS) \n+    Codepage_Alias{932, 'SHIFT-JIS'}, // alternative name for it \n+    Codepage_Alias{936, 'GB2312'}, // ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312) \n+    Codepage_Alias{949, 'KS_C_5601-1987'}, // ANSI/OEM Korean (Unified Hangul Code) \n+    Codepage_Alias{950, 'BIG5'}, // ANSI/OEM Traditional Chinese (Taiwan; Hong Kong SAR, PRC); Chinese Traditional (Big5) \n+    Codepage_Alias{950, 'BIG5HKSCS'}, // ANSI/OEM Traditional Chinese (Hong Kong SAR); Chinese Traditional (Big5-HKSCS) \n+    Codepage_Alias{950, 'BIG5-HKSCS'}, // alternative name for it \n+    Codepage_Alias{1026, 'IBM1026'}, // IBM EBCDIC Turkish (Latin 5) \n+    Codepage_Alias{1047, 'IBM01047'}, // IBM EBCDIC Latin 1/Open System \n+    Codepage_Alias{1140, 'IBM01140'}, // IBM EBCDIC US-Canada (037 + Euro symbol); IBM EBCDIC (US-Canada-Euro) \n+    Codepage_Alias{1141, 'IBM01141'}, // IBM EBCDIC Germany (20273 + Euro symbol); IBM EBCDIC (Germany-Euro) \n+    Codepage_Alias{1142, 'IBM01142'}, // IBM EBCDIC Denmark-Norway (20277 + Euro symbol); IBM EBCDIC (Denmark-Norway-Euro) \n+    Codepage_Alias{1143, 'IBM01143'}, // IBM EBCDIC Finland-Sweden (20278 + Euro symbol); IBM EBCDIC (Finland-Sweden-Euro) \n+    Codepage_Alias{1144, 'IBM01144'}, // IBM EBCDIC Italy (20280 + Euro symbol); IBM EBCDIC (Italy-Euro) \n+    Codepage_Alias{1145, 'IBM01145'}, // IBM EBCDIC Latin America-Spain (20284 + Euro symbol); IBM EBCDIC (Spain-Euro) \n+    Codepage_Alias{1146, 'IBM01146'}, // IBM EBCDIC United Kingdom (20285 + Euro symbol); IBM EBCDIC (UK-Euro) \n+    Codepage_Alias{1147, 'IBM01147'}, // IBM EBCDIC France (20297 + Euro symbol); IBM EBCDIC (France-Euro) \n+    Codepage_Alias{1148, 'IBM01148'}, // IBM EBCDIC International (500 + Euro symbol); IBM EBCDIC (International-Euro) \n+    Codepage_Alias{1149, 'IBM01149'}, // IBM EBCDIC Icelandic (20871 + Euro symbol); IBM EBCDIC (Icelandic-Euro) \n+    Codepage_Alias{1200, 'UTF-16'}, // Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications \n+    Codepage_Alias{1201, 'UNICODEFFFE'}, // Unicode UTF-16, big endian byte order; available only to managed applications \n+    Codepage_Alias{1250, 'WINDOWS-1250'}, // ANSI Central European; Central European (Windows) \n+    Codepage_Alias{1251, 'WINDOWS-1251'}, // ANSI Cyrillic; Cyrillic (Windows) \n+    Codepage_Alias{1252, 'WINDOWS-1252'}, // ANSI Latin 1; Western European (Windows) \n+    Codepage_Alias{1253, 'WINDOWS-1253'}, // ANSI Greek; Greek (Windows) \n+    Codepage_Alias{1254, 'WINDOWS-1254'}, // ANSI Turkish; Turkish (Windows) \n+    Codepage_Alias{1255, 'WINDOWS-1255'}, // ANSI Hebrew; Hebrew (Windows) \n+    Codepage_Alias{1256, 'WINDOWS-1256'}, // ANSI Arabic; Arabic (Windows) \n+    Codepage_Alias{1257, 'WINDOWS-1257'}, // ANSI Baltic; Baltic (Windows) \n+    Codepage_Alias{1258, 'WINDOWS-1258'}, // ANSI/OEM Vietnamese; Vietnamese (Windows) \n+    Codepage_Alias{1361, 'JOHAB'}, // Korean (Johab) \n+    Codepage_Alias{10000, 'MACINTOSH'}, // MAC Roman; Western European (Mac) \n+    Codepage_Alias{10001, 'X-MAC-JAPANESE'}, // Japanese (Mac) \n+    Codepage_Alias{10002, 'X-MAC-CHINESETRAD'}, // MAC Traditional Chinese (Big5); Chinese Traditional (Mac) \n+    Codepage_Alias{10003, 'X-MAC-KOREAN'}, // Korean (Mac) \n+    Codepage_Alias{10004, 'X-MAC-ARABIC'}, // Arabic (Mac) \n+    Codepage_Alias{10005, 'X-MAC-HEBREW'}, // Hebrew (Mac) \n+    Codepage_Alias{10006, 'X-MAC-GREEK'}, // Greek (Mac) \n+    Codepage_Alias{10007, 'X-MAC-CYRILLIC'}, // Cyrillic (Mac) \n+    Codepage_Alias{10008, 'X-MAC-CHINESESIMP'}, // MAC Simplified Chinese (GB 2312); Chinese Simplified (Mac) \n+    Codepage_Alias{10010, 'X-MAC-ROMANIAN'}, // Romanian (Mac) \n+    Codepage_Alias{10017, 'X-MAC-UKRAINIAN'}, // Ukrainian (Mac) \n+    Codepage_Alias{10021, 'X-MAC-THAI'}, // Thai (Mac) \n+    Codepage_Alias{10029, 'X-MAC-CE'}, // MAC Latin 2; Central European (Mac) \n+    Codepage_Alias{10079, 'X-MAC-ICELANDIC'}, // Icelandic (Mac) \n+    Codepage_Alias{10081, 'X-MAC-TURKISH'}, // Turkish (Mac) \n+    Codepage_Alias{10082, 'X-MAC-CROATIAN'}, // Croatian (Mac) \n+    Codepage_Alias{12000, 'UTF-32'}, // Unicode UTF-32, little endian byte order; available only to managed applications \n+    Codepage_Alias{12001, 'UTF-32BE'}, // Unicode UTF-32, big endian byte order; available only to managed applications \n+\tCodepage_Alias{20000, 'X-CHINESE_CNS'}, // CNS Taiwan; Chinese Traditional (CNS) \n+    Codepage_Alias{20001, 'X-CP20001'}, // TCA Taiwan \n+    Codepage_Alias{20002, 'X_CHINESE-ETEN'}, // Eten Taiwan; Chinese Traditional (Eten) \n+    Codepage_Alias{20003, 'X-CP20003'}, // IBM5550 Taiwan \n+    Codepage_Alias{20004, 'X-CP20004'}, // TeleText Taiwan \n+    Codepage_Alias{20005, 'X-CP20005'}, // Wang Taiwan \n+    Codepage_Alias{20105, 'X-IA5'}, // IA5 (IRV International Alphabet No. 5, 7-bit); Western European (IA5) \n+    Codepage_Alias{20106, 'X-IA5-GERMAN'}, // IA5 German (7-bit) \n+    Codepage_Alias{20107, 'X-IA5-SWEDISH'}, // IA5 Swedish (7-bit) \n+    Codepage_Alias{20108, 'X-IA5-NORWEGIAN'}, // IA5 Norwegian (7-bit) \n+    Codepage_Alias{20127, 'US-ASCII'}, // US-ASCII (7-bit) \n+    Codepage_Alias{20261, 'X-CP20261'}, // T.61 \n+    Codepage_Alias{20269, 'X-CP20269'}, // ISO 6937 Non-Spacing Accent \n+    Codepage_Alias{20273, 'IBM273'}, // IBM EBCDIC Germany \n+    Codepage_Alias{20277, 'IBM277'}, // IBM EBCDIC Denmark-Norway \n+    Codepage_Alias{20278, 'IBM278'}, // IBM EBCDIC Finland-Sweden \n+    Codepage_Alias{20280, 'IBM280'}, // IBM EBCDIC Italy \n+    Codepage_Alias{20284, 'IBM284'}, // IBM EBCDIC Latin America-Spain \n+    Codepage_Alias{20285, 'IBM285'}, // IBM EBCDIC United Kingdom \n+    Codepage_Alias{20290, 'IBM290'}, // IBM EBCDIC Japanese Katakana Extended \n+    Codepage_Alias{20297, 'IBM297'}, // IBM EBCDIC France \n+    Codepage_Alias{20420, 'IBM420'}, // IBM EBCDIC Arabic \n+    Codepage_Alias{20423, 'IBM423'}, // IBM EBCDIC Greek \n+    Codepage_Alias{20424, 'IBM424'}, // IBM EBCDIC Hebrew \n+    Codepage_Alias{20833, 'X-EBCDIC-KOREANEXTENDED'}, // IBM EBCDIC Korean Extended \n+    Codepage_Alias{20838, 'IBM-THAI'}, // IBM EBCDIC Thai \n+    Codepage_Alias{20866, 'KOI8-R'}, // Russian (KOI8-R); Cyrillic (KOI8-R) \n+    Codepage_Alias{20871, 'IBM871'}, // IBM EBCDIC Icelandic \n+    Codepage_Alias{20880, 'IBM880'}, // IBM EBCDIC Cyrillic Russian \n+    Codepage_Alias{20905, 'IBM905'}, // IBM EBCDIC Turkish \n+    Codepage_Alias{20924, 'IBM00924'}, // IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) \n+    Codepage_Alias{20932, 'EUC-JP'}, // Japanese (JIS 0208-1990 and 0121-1990) \n+    Codepage_Alias{20936, 'X-CP20936'}, // Simplified Chinese (GB2312); Chinese Simplified (GB2312-80) \n+    Codepage_Alias{20949, 'X-CP20949'}, // Korean Wansung \n+    Codepage_Alias{21025, 'CP1025'}, // IBM EBCDIC Cyrillic Serbian-Bulgarian \n+    // 21027 \t\t(deprecated) \n+    Codepage_Alias{21866, 'KOI8-U'}, // Ukrainian (KOI8-U); Cyrillic (KOI8-U) \n+    Codepage_Alias{28591, 'ISO-8859-1'}, // ISO 8859-1 Latin 1; Western European (ISO) \n+    Codepage_Alias{28591, 'ISO8859-1'}, // ISO 8859-1 Latin 1; Western European (ISO) \n+    Codepage_Alias{28591, 'ISO_8859-1'},\n+    Codepage_Alias{28591, 'ISO_8859_1'},\n+    Codepage_Alias{28592, 'ISO-8859-2'}, // ISO 8859-2 Central European; Central European (ISO) \n+    Codepage_Alias{28592, 'ISO8859-2'}, // ISO 8859-2 Central European; Central European (ISO) \n+    Codepage_Alias{28592, 'ISO_8859-2'},\n+    Codepage_Alias{28592, 'ISO_8859_2'},\n+    Codepage_Alias{28593, 'ISO-8859-3'}, // ISO 8859-3 Latin 3 \n+    Codepage_Alias{28593, 'ISO8859-3'}, // ISO 8859-3 Latin 3 \n+    Codepage_Alias{28593, 'ISO_8859-3'},\n+    Codepage_Alias{28593, 'ISO_8859_3'},\n+    Codepage_Alias{28594, 'ISO-8859-4'}, // ISO 8859-4 Baltic \n+    Codepage_Alias{28594, 'ISO8859-4'}, // ISO 8859-4 Baltic \n+    Codepage_Alias{28594, 'ISO_8859-4'},\n+    Codepage_Alias{28594, 'ISO_8859_4'},\n+    Codepage_Alias{28595, 'ISO-8859-5'}, // ISO 8859-5 Cyrillic \n+    Codepage_Alias{28595, 'ISO8859-5'}, // ISO 8859-5 Cyrillic \n+    Codepage_Alias{28595, 'ISO_8859-5'},\n+    Codepage_Alias{28595, 'ISO_8859_5'},\n+    Codepage_Alias{28596, 'ISO-8859-6'}, // ISO 8859-6 Arabic \n+    Codepage_Alias{28596, 'ISO8859-6'}, // ISO 8859-6 Arabic \n+    Codepage_Alias{28596, 'ISO_8859-6'},\n+    Codepage_Alias{28596, 'ISO_8859_6'},\n+    Codepage_Alias{28597, 'ISO-8859-7'}, // ISO 8859-7 Greek \n+    Codepage_Alias{28597, 'ISO8859-7'}, // ISO 8859-7 Greek \n+    Codepage_Alias{28597, 'ISO_8859-7'},\n+    Codepage_Alias{28597, 'ISO_8859_7'},\n+    Codepage_Alias{28598, 'ISO-8859-8'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Visual) \n+    Codepage_Alias{28598, 'ISO8859-8'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Visual) \n+    Codepage_Alias{28598, 'ISO_8859-8'},\n+    Codepage_Alias{28598, 'ISO_8859_8'},\n+    Codepage_Alias{28599, 'ISO-8859-9'}, // ISO 8859-9 Turkish \n+    Codepage_Alias{28599, 'ISO8859-9'}, // ISO 8859-9 Turkish \n+    Codepage_Alias{28599, 'ISO_8859-9'},\n+    Codepage_Alias{28599, 'ISO_8859_9'},\n+    Codepage_Alias{28603, 'ISO-8859-13'}, // ISO 8859-13 Estonian \n+    Codepage_Alias{28603, 'ISO8859-13'}, // ISO 8859-13 Estonian \n+    Codepage_Alias{28603, 'ISO_8859-13'},\n+    Codepage_Alias{28603, 'ISO_8859_13'},\n+    Codepage_Alias{28605, 'ISO-8859-15'}, // ISO 8859-15 Latin 9 \n+    Codepage_Alias{28605, 'ISO8859-15'}, // ISO 8859-15 Latin 9 \n+    Codepage_Alias{28605, 'ISO_8859-15'},\n+    Codepage_Alias{28605, 'ISO_8859_15'},\n+    Codepage_Alias{29001, 'X-EUROPA'}, // Europa 3 \n+    Codepage_Alias{38598, 'ISO-8859-8-I'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Logical) \n+    Codepage_Alias{38598, 'ISO8859-8-I'}, // ISO 8859-8 Hebrew; Hebrew (ISO-Logical) \n+    Codepage_Alias{38598, 'ISO_8859-8-I'},\n+    Codepage_Alias{38598, 'ISO_8859_8-I'},\n+    Codepage_Alias{50220, 'ISO-2022-JP'}, // ISO 2022 Japanese with no halfwidth Katakana; Japanese (JIS) \n+    Codepage_Alias{50221, 'CSISO2022JP'}, // ISO 2022 Japanese with halfwidth Katakana; Japanese (JIS-Allow 1 byte Kana) \n+    Codepage_Alias{50222, 'ISO-2022-JP'}, // ISO 2022 Japanese JIS X 0201-1989; Japanese (JIS-Allow 1 byte Kana - SO/SI) \n+    Codepage_Alias{50225, 'ISO-2022-KR'}, // ISO 2022 Korean \n+    Codepage_Alias{50225, 'ISO2022-KR'}, // ISO 2022 Korean \n+    Codepage_Alias{50227, 'X-CP50227'}, // ISO 2022 Simplified Chinese; Chinese Simplified (ISO 2022) \n+    // 50229 \t\tISO 2022 Traditional Chinese \n+    // 50930 \t\tEBCDIC Japanese (Katakana) Extended \n+    // 50931 \t\tEBCDIC US-Canada and Japanese \n+    // 50933 \t\tEBCDIC Korean Extended and Korean \n+    // 50935 \t\tEBCDIC Simplified Chinese Extended and Simplified Chinese \n+    // 50936 \t\tEBCDIC Simplified Chinese \n+    // 50937 \t\tEBCDIC US-Canada and Traditional Chinese \n+    // 50939 \t\tEBCDIC Japanese (Latin) Extended and Japanese \n+    Codepage_Alias{51932, 'EUC-JP'}, // EUC Japanese \n+    Codepage_Alias{51936, 'EUC-CN'}, // EUC Simplified Chinese; Chinese Simplified (EUC) \n+    Codepage_Alias{51949, 'EUC-KR'}, // EUC Korean \n+    // 51950 \t\tEUC Traditional Chinese \n+    Codepage_Alias{52936, 'HZ-GB-2312'}, // HZ-GB2312 Simplified Chinese; Chinese Simplified (HZ) \n+    Codepage_Alias{54936, 'GB18030'}, // Windows XP and later: GB18030 Simplified Chinese (4 byte); Chinese Simplified (GB18030) \n+    Codepage_Alias{57002, 'X-ISCII-DE'}, // ISCII Devanagari \n+    Codepage_Alias{57003, 'X-ISCII-BE'}, // ISCII Bengali \n+    Codepage_Alias{57004, 'X-ISCII-TA'}, // ISCII Tamil \n+    Codepage_Alias{57005, 'X-ISCII-TE'}, // ISCII Telugu \n+    Codepage_Alias{57006, 'X-ISCII-AS'}, // ISCII Assamese \n+    Codepage_Alias{57007, 'X-ISCII-OR'}, // ISCII Oriya \n+    Codepage_Alias{57008, 'X-ISCII-KA'}, // ISCII Kannada \n+    Codepage_Alias{57009, 'X-ISCII-MA'}, // ISCII Malayalam \n+    Codepage_Alias{57010, 'X-ISCII-GU'}, // ISCII Gujarati \n+    Codepage_Alias{57011, 'X-ISCII-PA'}, // ISCII Punjabi \n+    Codepage_Alias{65000, 'UTF-7'}, // Unicode (UTF-7) \n+    Codepage_Alias{65001, 'UTF-8'}, // Unicode (UTF-8) \n+\t// vfmt on\n+]\n+\n+fn name_to_codepage(name string) int {\n+\tname_upper := name.to_upper()",
        "comment_created_at": "2024-10-01T06:28:21+00:00",
        "comment_author": "spytheman",
        "comment_body": "A special case like this here:\r\n`if name == 'UTF-8' { return 65001 }` \r\nput before anything else, would be beneficial since half of the checks will be for it.",
        "pr_file_module": null
      }
    ]
  }
]