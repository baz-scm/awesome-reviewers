[
  {
    "discussion_id": "2134512491",
    "pr_number": 24666,
    "pr_file": "vlib/math/big/integer.v",
    "created_at": "2025-06-08T07:49:14+00:00",
    "commented_code": "module big\n \n+import datatypes",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2134512491",
        "repo_full_name": "vlang/v",
        "pr_number": 24666,
        "pr_file": "vlib/math/big/integer.v",
        "discussion_id": "2134512491",
        "commented_code": "@@ -1,10 +1,19 @@\n module big\n \n+import datatypes",
        "comment_created_at": "2025-06-08T07:49:14+00:00",
        "comment_author": "spytheman",
        "comment_body": "there is no need for this, if you are only going to use the push/pop operations for the Stack - the builtin arrays are enough",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2120264355",
    "pr_number": 24636,
    "pr_file": "cmd/tools/vvet/vvet.v",
    "created_at": "2025-06-02T07:15:32+00:00",
    "commented_code": "fn (mut vt Vet) vet_empty_str(expr ast.InfixExpr) {\n \tif expr.left is ast.SelectorExpr && expr.right is ast.IntegerLiteral {\n \t\toperand := (expr.left as ast.SelectorExpr) // TODO: remove as-casts when multiple conds can be smart-casted.\n-\t\tif operand.expr is ast.Ident && operand.expr.info.typ == ast.string_type_idx\n-\t\t\t&& operand.field_name == 'len' {\n+\t\tif operand.expr is ast.Ident && operand.field_name == 'len'\n+\t\t\t&& operand.expr.info.typ == ast.string_type_idx {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2120264355",
        "repo_full_name": "vlang/v",
        "pr_number": 24636,
        "pr_file": "cmd/tools/vvet/vvet.v",
        "discussion_id": "2120264355",
        "commented_code": "@@ -404,8 +404,8 @@ fn (mut vt Vet) const_decl(stmt ast.ConstDecl) {\n fn (mut vt Vet) vet_empty_str(expr ast.InfixExpr) {\n \tif expr.left is ast.SelectorExpr && expr.right is ast.IntegerLiteral {\n \t\toperand := (expr.left as ast.SelectorExpr) // TODO: remove as-casts when multiple conds can be smart-casted.\n-\t\tif operand.expr is ast.Ident && operand.expr.info.typ == ast.string_type_idx\n-\t\t\t&& operand.field_name == 'len' {\n+\t\tif operand.expr is ast.Ident && operand.field_name == 'len'\n+\t\t\t&& operand.expr.info.typ == ast.string_type_idx {",
        "comment_created_at": "2025-06-02T07:15:32+00:00",
        "comment_author": "spytheman",
        "comment_body": "is not it a bit better if the integer comparison is before the more complex string one, due to the short-circuiting behavior of boolean expressions? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1178253083",
    "pr_number": 18046,
    "pr_file": "vlib/datatypes/crdt/gset.v",
    "created_at": "2023-04-26T18:32:45+00:00",
    "commented_code": "+module crdt\n+\n+// Gset is a grow-only set.\n+struct GSet[T] {\n+mut:\n+\tmain_set map[T]T",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1178253083",
        "repo_full_name": "vlang/v",
        "pr_number": 18046,
        "pr_file": "vlib/datatypes/crdt/gset.v",
        "discussion_id": "1178253083",
        "commented_code": "@@ -0,0 +1,53 @@\n+module crdt\n+\n+// Gset is a grow-only set.\n+struct GSet[T] {\n+mut:\n+\tmain_set map[T]T",
        "comment_created_at": "2023-04-26T18:32:45+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n\tmain_set map[T]bool\r\n```\r\n\r\nFor most types, like strings or pointers etc, sizeof(bool) < sizeof(T), and the map here is only used for its keys afaik.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1178254794",
    "pr_number": 18046,
    "pr_file": "vlib/datatypes/crdt/gset.v",
    "created_at": "2023-04-26T18:34:42+00:00",
    "commented_code": "+module crdt\n+\n+// Gset is a grow-only set.\n+struct GSet[T] {\n+mut:\n+\tmain_set map[T]T\n+}\n+\n+// new_gset returns an instance of GSet.\n+pub fn new_gset[T]() GSet[T] {\n+\treturn GSet[T]{\n+\t\tmain_set: map[T]T{}\n+\t}\n+}\n+\n+// add lets you add an element to grow-only set.\n+pub fn (mut g GSet[T]) add(elem T) {\n+\tg.main_set[elem] = T{}\n+}\n+\n+// lookup returns true if an element exists within the\n+// set or false otherwise.\n+pub fn (mut g GSet[T]) lookup(elem T) bool {\n+\treturn elem in g.main_set\n+}\n+\n+// len returns the no. of elements present within GSet.\n+pub fn (mut g GSet[T]) len() int {\n+\treturn g.main_set.len\n+}\n+\n+// elements returns all the elements present in the set.\n+pub fn (mut g GSet[T]) elements() []T {\n+\tmut elements := []T{}\n+\tfor _, element in g.main_set {\n+\t\telements << element\n+\t}\n+\treturn elements",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1178254794",
        "repo_full_name": "vlang/v",
        "pr_number": 18046,
        "pr_file": "vlib/datatypes/crdt/gset.v",
        "discussion_id": "1178254794",
        "commented_code": "@@ -0,0 +1,53 @@\n+module crdt\n+\n+// Gset is a grow-only set.\n+struct GSet[T] {\n+mut:\n+\tmain_set map[T]T\n+}\n+\n+// new_gset returns an instance of GSet.\n+pub fn new_gset[T]() GSet[T] {\n+\treturn GSet[T]{\n+\t\tmain_set: map[T]T{}\n+\t}\n+}\n+\n+// add lets you add an element to grow-only set.\n+pub fn (mut g GSet[T]) add(elem T) {\n+\tg.main_set[elem] = T{}\n+}\n+\n+// lookup returns true if an element exists within the\n+// set or false otherwise.\n+pub fn (mut g GSet[T]) lookup(elem T) bool {\n+\treturn elem in g.main_set\n+}\n+\n+// len returns the no. of elements present within GSet.\n+pub fn (mut g GSet[T]) len() int {\n+\treturn g.main_set.len\n+}\n+\n+// elements returns all the elements present in the set.\n+pub fn (mut g GSet[T]) elements() []T {\n+\tmut elements := []T{}\n+\tfor _, element in g.main_set {\n+\t\telements << element\n+\t}\n+\treturn elements",
        "comment_created_at": "2023-04-26T18:34:42+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n\treturn g.main_set.keys()\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957290816",
    "pr_number": 23737,
    "pr_file": "vlib/strconv/atoi.v",
    "created_at": "2025-02-16T10:17:47+00:00",
    "commented_code": "}\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1957290816",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:17:47+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho do the intermediate calculations with i64, and only do one check at the end of the loop, right before the return of the result",
        "pr_file_module": null
      },
      {
        "comment_id": "1957292488",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:27:12+00:00",
        "comment_author": "Bruno-Vdr",
        "comment_body": "I did this with 32bits machines in mind, to avoid using soft 64bit arithmetic. I plan to implement later atoi 8/16/32/64, the problem will exist then on 64bits. Solving the problem of under/overflow with a maximum type length, had to be done. But if you want I can implements it using i64. Should I ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1957293229",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:31:11+00:00",
        "comment_author": "spytheman",
        "comment_body": "I am concerned about the performance for the most common case, which is currently 64 bit machines.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957293650",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:33:09+00:00",
        "comment_author": "Bruno-Vdr",
        "comment_body": "Ok, I'm on it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957293866",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:34:14+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho use i64 (or just one power of 2 higher size if you prefer), for the cases of numbers that are < 64 bit. See also `vlib/strconv/utilities.v` and `vlib/strconv/structs.v`, for the already defined operations on `Uint128` for the 64 bit case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957294273",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:37:06+00:00",
        "comment_author": "spytheman",
        "comment_body": "soft 64bit arithmetic on 32 bit machines, is still preferable in terms of performance than checking for overflows on each operation in the loop, generating errors, and then handling them in the caller (in the loop)",
        "pr_file_module": null
      },
      {
        "comment_id": "1957294863",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957290816",
        "commented_code": "@@ -218,34 +220,77 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n \t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n \t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\n+\tmut start_idx := 0\n+\tmut sign := 1\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n+\t\t}\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tmut x := int(0)\n+\tmut underscored := false\n+\tfor i in start_idx .. s.len {\n+\t\tc := s[i] - `0`\n+\t\tif c == 47 { // 47 = Ascii(`_`) -  ascii(`0`) = 95 - 48.\n+\t\t\tif underscored == true { // Two consecutives underscore\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n+\t\t\tunderscored = true\n+\t\t\tcontinue // Skip underscore\n+\t\t} else {\n+\t\t\tif c > 9 {\n \t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n \t\t\t}\n-\t\t\tn = n * 10 + int(ch)\n+\t\t\tunderscored = false\n+\t\t\tx = safe_mul10_32bits(x) or { return error('strconv.atoi: parsing \"${s}\": ${err}') }\n+\t\t\tx = safe_add_32bits(x, int(c * sign)) or {",
        "comment_created_at": "2025-02-16T10:40:13+00:00",
        "comment_author": "Bruno-Vdr",
        "comment_body": "I agree.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1855411068",
    "pr_number": 22957,
    "pr_file": "cmd/tools/vvet/vvet.v",
    "created_at": "2024-11-24T09:58:55+00:00",
    "commented_code": "}\n }\n \n+fn remove_duplicates[T](arr []T) []T {\n+\tmut results := []T{}\n+\tfor val in arr {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1855411068",
        "repo_full_name": "vlang/v",
        "pr_number": 22957,
        "pr_file": "cmd/tools/vvet/vvet.v",
        "discussion_id": "1855411068",
        "commented_code": "@@ -147,6 +148,16 @@ fn (mut vt Vet) vet_space_usage(line string, lnumber int) {\n \t}\n }\n \n+fn remove_duplicates[T](arr []T) []T {\n+\tmut results := []T{}\n+\tfor val in arr {",
        "comment_created_at": "2024-11-24T09:58:55+00:00",
        "comment_author": "spytheman",
        "comment_body": "That can get expensive for lots of files.\r\nUsing a map will scale better.",
        "pr_file_module": null
      },
      {
        "comment_id": "1855411857",
        "repo_full_name": "vlang/v",
        "pr_number": 22957,
        "pr_file": "cmd/tools/vvet/vvet.v",
        "discussion_id": "1855411068",
        "commented_code": "@@ -147,6 +148,16 @@ fn (mut vt Vet) vet_space_usage(line string, lnumber int) {\n \t}\n }\n \n+fn remove_duplicates[T](arr []T) []T {\n+\tmut results := []T{}\n+\tfor val in arr {",
        "comment_created_at": "2024-11-24T10:02:32+00:00",
        "comment_author": "spytheman",
        "comment_body": "Or you can just use `arrays.distinct()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1821988801",
    "pr_number": 22694,
    "pr_file": "vlib/x/json2/types.v",
    "created_at": "2024-10-30T06:59:20+00:00",
    "commented_code": "import time\n \n // `Any` is a sum type that lists the possible types to be decoded and used.\n-pub type Any = Null\n-\t| []Any\n+// `Any` priority order for numbers: floats -> signed integers -> unsigned integers\n+// `Any` priority order for strings: string -> time.Time\n+pub type Any = []Any",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1821988801",
        "repo_full_name": "vlang/v",
        "pr_number": 22694,
        "pr_file": "vlib/x/json2/types.v",
        "discussion_id": "1821988801",
        "commented_code": "@@ -3,23 +3,25 @@ module json2\n import time\n \n // `Any` is a sum type that lists the possible types to be decoded and used.\n-pub type Any = Null\n-\t| []Any\n+// `Any` priority order for numbers: floats -> signed integers -> unsigned integers\n+// `Any` priority order for strings: string -> time.Time\n+pub type Any = []Any",
        "comment_created_at": "2024-10-30T06:59:20+00:00",
        "comment_author": "spytheman",
        "comment_body": "Why put `[]Any` first?\r\n\r\nThe first type is going to be used for default initialization of Any values, and []Any is a container, that is relatively more expensive to create/initialize compared to say int or bool . ",
        "pr_file_module": null
      }
    ]
  }
]