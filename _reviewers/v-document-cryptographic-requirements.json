[
  {
    "discussion_id": "1918345165",
    "pr_number": 23463,
    "pr_file": "vlib/crypto/ecdsa/ecdsa.v",
    "created_at": "2025-01-16T12:11:34+00:00",
    "commented_code": "@[typedef]\n struct C.BN_CTX {}\n \n+// enum flag to allow flexible PrivateKey size\n+enum KeyFlag {\n+\t// flexible flag to allow flexible-size of seed bytes\n+\tflexible\n+\t// fixed flag for using underlying curve key size\n+\tfixed\n+}\n+\n+// PrivateKey represents ECDSA private key. Actually its a key pair,\n+// contains private key and public key parts.\n pub struct PrivateKey {\n \tkey &C.EC_KEY\n+mut:\n+\t// ks_flag with .flexible value allowing\n+\t// flexible-size seed bytes as key.\n+\t// When it .fixed will use underlying key size.\n+\tks_flag KeyFlag = .flexible\n+\t// ks_size stores size of the seed bytes when ks_flag was .flexible.\n+\t// You should set it to non null value\n+\tks_size int\n }\n \n+// PublicKey represents ECDSA public key for verifying message.\n pub struct PublicKey {\n \tkey &C.EC_KEY\n }\n \n-// Generate a new key pair. If opt was not provided, its default to prime256v1 curve.\n-pub fn generate_key(opt CurveOptions) !(PublicKey, PrivateKey) {\n+// PrivateKey.new creates a new ECDSA PrivateKey key pair. By default, it would create a prime256v1 curve.\n+// You can create another supported key by supplying it with options, for example `.new(nid: .secp256k1)`.\n+// If second options, ie, with_fixed_size was not set, it would be discarded and treated as fixed one.\n+// This differs with `generate_key` in the sense `generate_key` produces two different ec_key opaque.\n+// where this `.new()` only produces single opaque. You can get the public key part by calling `.public_key()`\n+// method on this object.\n+pub fn PrivateKey.new(opt CurveOptions) !PrivateKey {\n+\t// creates new empty key\n \tec_key := new_curve(opt)\n \tif ec_key == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n \t\treturn error('Failed to create new EC_KEY')\n \t}\n+\t// Generates new public and private key for the supplied ec_key object.\n \tres := C.EC_KEY_generate_key(ec_key)\n \tif res != 1 {\n \t\tC.EC_KEY_free(ec_key)\n \t\treturn error('Failed to generate EC_KEY')\n \t}\n+\t// performs explicit check\n+\tchk := C.EC_KEY_check_key(ec_key)\n+\tif chk == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\treturn error('EC_KEY_check_key failed')\n+\t}\n+\t// when using default EC_KEY_generate_key, its using underlying curve key size\n+\t// and discarded opt.with_fixed_size flag when its not set.\n+\tpriv_key := PrivateKey{\n+\t\tkey:     ec_key\n+\t\tks_flag: .fixed\n+\t}\n+\treturn priv_key\n+}\n \n+// generate_key generates a new key pair. If opt was not provided, its default to prime256v1 curve.\n+// If you want another curve, use in the following manner: `pubkey, pivkey := ecdsa.generate_key(nid: .secp384r1)!`\n+pub fn generate_key(opt CurveOptions) !(PublicKey, PrivateKey) {\n+\t// creates new empty key\n+\tec_key := new_curve(opt)\n+\tif ec_key == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\treturn error('Failed to create new EC_KEY')\n+\t}\n+\t// we duplicate the empty ec_key and shares similiar curve infos\n+\t// and used this as public key\n+\tpbkey := C.EC_KEY_dup(ec_key)\n+\tif pbkey == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed on EC_KEY_dup')\n+\t}\n+\tres := C.EC_KEY_generate_key(ec_key)\n+\tif res != 1 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to generate EC_KEY')\n+\t}\n+\t// we take public key bits from above generated key\n+\t// and stored in duplicated public key object before.\n+\tpubkey_point := voidptr(C.EC_KEY_get0_public_key(ec_key))\n+\tif pubkey_point == 0 {\n+\t\tC.EC_POINT_free(pubkey_point)\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to get public key BIGNUM')\n+\t}\n+\tnp := C.EC_KEY_set_public_key(pbkey, pubkey_point)\n+\tif np != 1 {\n+\t\tC.EC_POINT_free(pubkey_point)\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to set public key')\n+\t}\n+\t// when using default generate_key, its using underlying curve key size\n+\t// and discarded opt.with_fixed_size flag when its not set.\n \tpriv_key := PrivateKey{\n-\t\tkey: ec_key\n+\t\tkey:     ec_key\n+\t\tks_flag: .fixed\n \t}\n \tpub_key := PublicKey{\n-\t\tkey: ec_key\n+\t\tkey: pbkey\n \t}\n \treturn pub_key, priv_key\n }\n \n-// Create a new private key from a seed. If opt was not provided, its default to prime256v1 curve.\n+// new_key_from_seed creates a new private key from the seed bytes. If opt was not provided,\n+// its default to prime256v1 curve.\n+//\n+// Notes on the seed:\n+// You should make sure, the seed bytes was comes from cryptographically secure random generators,",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1918345165",
        "repo_full_name": "vlang/v",
        "pr_number": 23463,
        "pr_file": "vlib/crypto/ecdsa/ecdsa.v",
        "discussion_id": "1918345165",
        "commented_code": "@@ -95,42 +104,165 @@ struct C.ECDSA_SIG {}\n @[typedef]\n struct C.BN_CTX {}\n \n+// enum flag to allow flexible PrivateKey size\n+enum KeyFlag {\n+\t// flexible flag to allow flexible-size of seed bytes\n+\tflexible\n+\t// fixed flag for using underlying curve key size\n+\tfixed\n+}\n+\n+// PrivateKey represents ECDSA private key. Actually its a key pair,\n+// contains private key and public key parts.\n pub struct PrivateKey {\n \tkey &C.EC_KEY\n+mut:\n+\t// ks_flag with .flexible value allowing\n+\t// flexible-size seed bytes as key.\n+\t// When it .fixed will use underlying key size.\n+\tks_flag KeyFlag = .flexible\n+\t// ks_size stores size of the seed bytes when ks_flag was .flexible.\n+\t// You should set it to non null value\n+\tks_size int\n }\n \n+// PublicKey represents ECDSA public key for verifying message.\n pub struct PublicKey {\n \tkey &C.EC_KEY\n }\n \n-// Generate a new key pair. If opt was not provided, its default to prime256v1 curve.\n-pub fn generate_key(opt CurveOptions) !(PublicKey, PrivateKey) {\n+// PrivateKey.new creates a new ECDSA PrivateKey key pair. By default, it would create a prime256v1 curve.\n+// You can create another supported key by supplying it with options, for example `.new(nid: .secp256k1)`.\n+// If second options, ie, with_fixed_size was not set, it would be discarded and treated as fixed one.\n+// This differs with `generate_key` in the sense `generate_key` produces two different ec_key opaque.\n+// where this `.new()` only produces single opaque. You can get the public key part by calling `.public_key()`\n+// method on this object.\n+pub fn PrivateKey.new(opt CurveOptions) !PrivateKey {\n+\t// creates new empty key\n \tec_key := new_curve(opt)\n \tif ec_key == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n \t\treturn error('Failed to create new EC_KEY')\n \t}\n+\t// Generates new public and private key for the supplied ec_key object.\n \tres := C.EC_KEY_generate_key(ec_key)\n \tif res != 1 {\n \t\tC.EC_KEY_free(ec_key)\n \t\treturn error('Failed to generate EC_KEY')\n \t}\n+\t// performs explicit check\n+\tchk := C.EC_KEY_check_key(ec_key)\n+\tif chk == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\treturn error('EC_KEY_check_key failed')\n+\t}\n+\t// when using default EC_KEY_generate_key, its using underlying curve key size\n+\t// and discarded opt.with_fixed_size flag when its not set.\n+\tpriv_key := PrivateKey{\n+\t\tkey:     ec_key\n+\t\tks_flag: .fixed\n+\t}\n+\treturn priv_key\n+}\n \n+// generate_key generates a new key pair. If opt was not provided, its default to prime256v1 curve.\n+// If you want another curve, use in the following manner: `pubkey, pivkey := ecdsa.generate_key(nid: .secp384r1)!`\n+pub fn generate_key(opt CurveOptions) !(PublicKey, PrivateKey) {\n+\t// creates new empty key\n+\tec_key := new_curve(opt)\n+\tif ec_key == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\treturn error('Failed to create new EC_KEY')\n+\t}\n+\t// we duplicate the empty ec_key and shares similiar curve infos\n+\t// and used this as public key\n+\tpbkey := C.EC_KEY_dup(ec_key)\n+\tif pbkey == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed on EC_KEY_dup')\n+\t}\n+\tres := C.EC_KEY_generate_key(ec_key)\n+\tif res != 1 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to generate EC_KEY')\n+\t}\n+\t// we take public key bits from above generated key\n+\t// and stored in duplicated public key object before.\n+\tpubkey_point := voidptr(C.EC_KEY_get0_public_key(ec_key))\n+\tif pubkey_point == 0 {\n+\t\tC.EC_POINT_free(pubkey_point)\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to get public key BIGNUM')\n+\t}\n+\tnp := C.EC_KEY_set_public_key(pbkey, pubkey_point)\n+\tif np != 1 {\n+\t\tC.EC_POINT_free(pubkey_point)\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to set public key')\n+\t}\n+\t// when using default generate_key, its using underlying curve key size\n+\t// and discarded opt.with_fixed_size flag when its not set.\n \tpriv_key := PrivateKey{\n-\t\tkey: ec_key\n+\t\tkey:     ec_key\n+\t\tks_flag: .fixed\n \t}\n \tpub_key := PublicKey{\n-\t\tkey: ec_key\n+\t\tkey: pbkey\n \t}\n \treturn pub_key, priv_key\n }\n \n-// Create a new private key from a seed. If opt was not provided, its default to prime256v1 curve.\n+// new_key_from_seed creates a new private key from the seed bytes. If opt was not provided,\n+// its default to prime256v1 curve.\n+//\n+// Notes on the seed:\n+// You should make sure, the seed bytes was comes from cryptographically secure random generators,",
        "comment_created_at": "2025-01-16T12:11:34+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n// You should make sure, the seed bytes come from a cryptographically secure random generator,\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1918605335",
        "repo_full_name": "vlang/v",
        "pr_number": 23463,
        "pr_file": "vlib/crypto/ecdsa/ecdsa.v",
        "discussion_id": "1918345165",
        "commented_code": "@@ -95,42 +104,165 @@ struct C.ECDSA_SIG {}\n @[typedef]\n struct C.BN_CTX {}\n \n+// enum flag to allow flexible PrivateKey size\n+enum KeyFlag {\n+\t// flexible flag to allow flexible-size of seed bytes\n+\tflexible\n+\t// fixed flag for using underlying curve key size\n+\tfixed\n+}\n+\n+// PrivateKey represents ECDSA private key. Actually its a key pair,\n+// contains private key and public key parts.\n pub struct PrivateKey {\n \tkey &C.EC_KEY\n+mut:\n+\t// ks_flag with .flexible value allowing\n+\t// flexible-size seed bytes as key.\n+\t// When it .fixed will use underlying key size.\n+\tks_flag KeyFlag = .flexible\n+\t// ks_size stores size of the seed bytes when ks_flag was .flexible.\n+\t// You should set it to non null value\n+\tks_size int\n }\n \n+// PublicKey represents ECDSA public key for verifying message.\n pub struct PublicKey {\n \tkey &C.EC_KEY\n }\n \n-// Generate a new key pair. If opt was not provided, its default to prime256v1 curve.\n-pub fn generate_key(opt CurveOptions) !(PublicKey, PrivateKey) {\n+// PrivateKey.new creates a new ECDSA PrivateKey key pair. By default, it would create a prime256v1 curve.\n+// You can create another supported key by supplying it with options, for example `.new(nid: .secp256k1)`.\n+// If second options, ie, with_fixed_size was not set, it would be discarded and treated as fixed one.\n+// This differs with `generate_key` in the sense `generate_key` produces two different ec_key opaque.\n+// where this `.new()` only produces single opaque. You can get the public key part by calling `.public_key()`\n+// method on this object.\n+pub fn PrivateKey.new(opt CurveOptions) !PrivateKey {\n+\t// creates new empty key\n \tec_key := new_curve(opt)\n \tif ec_key == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n \t\treturn error('Failed to create new EC_KEY')\n \t}\n+\t// Generates new public and private key for the supplied ec_key object.\n \tres := C.EC_KEY_generate_key(ec_key)\n \tif res != 1 {\n \t\tC.EC_KEY_free(ec_key)\n \t\treturn error('Failed to generate EC_KEY')\n \t}\n+\t// performs explicit check\n+\tchk := C.EC_KEY_check_key(ec_key)\n+\tif chk == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\treturn error('EC_KEY_check_key failed')\n+\t}\n+\t// when using default EC_KEY_generate_key, its using underlying curve key size\n+\t// and discarded opt.with_fixed_size flag when its not set.\n+\tpriv_key := PrivateKey{\n+\t\tkey:     ec_key\n+\t\tks_flag: .fixed\n+\t}\n+\treturn priv_key\n+}\n \n+// generate_key generates a new key pair. If opt was not provided, its default to prime256v1 curve.\n+// If you want another curve, use in the following manner: `pubkey, pivkey := ecdsa.generate_key(nid: .secp384r1)!`\n+pub fn generate_key(opt CurveOptions) !(PublicKey, PrivateKey) {\n+\t// creates new empty key\n+\tec_key := new_curve(opt)\n+\tif ec_key == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\treturn error('Failed to create new EC_KEY')\n+\t}\n+\t// we duplicate the empty ec_key and shares similiar curve infos\n+\t// and used this as public key\n+\tpbkey := C.EC_KEY_dup(ec_key)\n+\tif pbkey == 0 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed on EC_KEY_dup')\n+\t}\n+\tres := C.EC_KEY_generate_key(ec_key)\n+\tif res != 1 {\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to generate EC_KEY')\n+\t}\n+\t// we take public key bits from above generated key\n+\t// and stored in duplicated public key object before.\n+\tpubkey_point := voidptr(C.EC_KEY_get0_public_key(ec_key))\n+\tif pubkey_point == 0 {\n+\t\tC.EC_POINT_free(pubkey_point)\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to get public key BIGNUM')\n+\t}\n+\tnp := C.EC_KEY_set_public_key(pbkey, pubkey_point)\n+\tif np != 1 {\n+\t\tC.EC_POINT_free(pubkey_point)\n+\t\tC.EC_KEY_free(ec_key)\n+\t\tC.EC_KEY_free(pbkey)\n+\t\treturn error('Failed to set public key')\n+\t}\n+\t// when using default generate_key, its using underlying curve key size\n+\t// and discarded opt.with_fixed_size flag when its not set.\n \tpriv_key := PrivateKey{\n-\t\tkey: ec_key\n+\t\tkey:     ec_key\n+\t\tks_flag: .fixed\n \t}\n \tpub_key := PublicKey{\n-\t\tkey: ec_key\n+\t\tkey: pbkey\n \t}\n \treturn pub_key, priv_key\n }\n \n-// Create a new private key from a seed. If opt was not provided, its default to prime256v1 curve.\n+// new_key_from_seed creates a new private key from the seed bytes. If opt was not provided,\n+// its default to prime256v1 curve.\n+//\n+// Notes on the seed:\n+// You should make sure, the seed bytes was comes from cryptographically secure random generators,",
        "comment_created_at": "2025-01-16T13:59:26+00:00",
        "comment_author": "blackshirt",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  }
]