[
  {
    "discussion_id": "2094375111",
    "pr_number": 24502,
    "pr_file": "vlib/v/tests/options/option_ptr_zero_test.v",
    "created_at": "2025-05-18T05:34:16+00:00",
    "commented_code": "+// Simple arena allocator\n+struct ArenaChunk {\n+mut:\n+\tnext ?&ArenaChunk\n+\tused int\n+\tcap  int\n+\tdata byteptr\n+}\n+\n+struct Arena {\n+mut:\n+\thead ?&ArenaChunk\n+}\n+\n+fn arena_init(mut arena Arena, first_capacity int) {\n+\tchunk := &ArenaChunk{\n+\t\tnext: 0\n+\t\tused: 0\n+\t\tcap:  first_capacity\n+\t\tdata: unsafe { malloc(first_capacity) }\n+\t}\n+\tarena.head = chunk\n+}\n+\n+fn test_main() {\n+\tmut green_arena := Arena{}\n+\tarena_init(mut green_arena, 64 * 1024)\n+}",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2094375111",
        "repo_full_name": "vlang/v",
        "pr_number": 24502,
        "pr_file": "vlib/v/tests/options/option_ptr_zero_test.v",
        "discussion_id": "2094375111",
        "commented_code": "@@ -0,0 +1,28 @@\n+// Simple arena allocator\n+struct ArenaChunk {\n+mut:\n+\tnext ?&ArenaChunk\n+\tused int\n+\tcap  int\n+\tdata byteptr\n+}\n+\n+struct Arena {\n+mut:\n+\thead ?&ArenaChunk\n+}\n+\n+fn arena_init(mut arena Arena, first_capacity int) {\n+\tchunk := &ArenaChunk{\n+\t\tnext: 0\n+\t\tused: 0\n+\t\tcap:  first_capacity\n+\t\tdata: unsafe { malloc(first_capacity) }\n+\t}\n+\tarena.head = chunk\n+}\n+\n+fn test_main() {\n+\tmut green_arena := Arena{}\n+\tarena_init(mut green_arena, 64 * 1024)\n+}",
        "comment_created_at": "2025-05-18T05:34:16+00:00",
        "comment_author": "spytheman",
        "comment_body": "Please assert that at least green_arena.data is not nil, and that green_arena.head is not nil .",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1900373815",
    "pr_number": 23326,
    "pr_file": "vlib/gg/gg.c.v",
    "created_at": "2025-01-01T11:02:22+00:00",
    "commented_code": "height: int(C.GetSystemMetrics(C.SM_CYSCREEN))\n \t\t}\n \t}\n-\t// TODO: linux, etc\n+\t$if linux {\n+\t\tdisplay := C.XOpenDisplay(0)",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1900373815",
        "repo_full_name": "vlang/v",
        "pr_number": 23326,
        "pr_file": "vlib/gg/gg.c.v",
        "discussion_id": "1900373815",
        "commented_code": "@@ -739,7 +746,14 @@ pub fn screen_size() Size {\n \t\t\theight: int(C.GetSystemMetrics(C.SM_CYSCREEN))\n \t\t}\n \t}\n-\t// TODO: linux, etc\n+\t$if linux {\n+\t\tdisplay := C.XOpenDisplay(0)",
        "comment_created_at": "2025-01-01T11:02:22+00:00",
        "comment_author": "spytheman",
        "comment_body": "I think that it needs `defer { C.XCloseDisplay(display) }` too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1900374287",
        "repo_full_name": "vlang/v",
        "pr_number": 23326,
        "pr_file": "vlib/gg/gg.c.v",
        "discussion_id": "1900373815",
        "commented_code": "@@ -739,7 +746,14 @@ pub fn screen_size() Size {\n \t\t\theight: int(C.GetSystemMetrics(C.SM_CYSCREEN))\n \t\t}\n \t}\n-\t// TODO: linux, etc\n+\t$if linux {\n+\t\tdisplay := C.XOpenDisplay(0)",
        "comment_created_at": "2025-01-01T11:05:48+00:00",
        "comment_author": "spytheman",
        "comment_body": "`XOpenDisplay` is also documented to return null on failure, that should be checked too",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1855567805",
    "pr_number": 22963,
    "pr_file": "vlib/v/gen/c/cgen.v",
    "created_at": "2024-11-24T22:59:40+00:00",
    "commented_code": "// the deferred statements are generated.\n \t\t\tg.write_defer_stmts()\n \t\t\t// Now that option types are distinct we need a cast here\n-\t\t\tif g.fn_decl.return_type == ast.void_type {\n+\t\t\tif g.fn_decl == unsafe { nil } || g.fn_decl.return_type == ast.void_type {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1855567805",
        "repo_full_name": "vlang/v",
        "pr_number": 22963,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1855567805",
        "commented_code": "@@ -7353,7 +7353,7 @@ fn (mut g Gen) or_block(var_name string, or_block ast.OrExpr, return_type ast.Ty\n \t\t\t// the deferred statements are generated.\n \t\t\tg.write_defer_stmts()\n \t\t\t// Now that option types are distinct we need a cast here\n-\t\t\tif g.fn_decl.return_type == ast.void_type {\n+\t\t\tif g.fn_decl == unsafe { nil } || g.fn_decl.return_type == ast.void_type {",
        "comment_created_at": "2024-11-24T22:59:40+00:00",
        "comment_author": "spytheman",
        "comment_body": "Wow ... that is a good find ... it may be better to turn `fn_decl` into `?&ast.FnDecl` to force the compiler into checking all places, where it is used unguarded",
        "pr_file_module": null
      },
      {
        "comment_id": "1855567883",
        "repo_full_name": "vlang/v",
        "pr_number": 22963,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1855567805",
        "commented_code": "@@ -7353,7 +7353,7 @@ fn (mut g Gen) or_block(var_name string, or_block ast.OrExpr, return_type ast.Ty\n \t\t\t// the deferred statements are generated.\n \t\t\tg.write_defer_stmts()\n \t\t\t// Now that option types are distinct we need a cast here\n-\t\t\tif g.fn_decl.return_type == ast.void_type {\n+\t\t\tif g.fn_decl == unsafe { nil } || g.fn_decl.return_type == ast.void_type {",
        "comment_created_at": "2024-11-24T23:00:05+00:00",
        "comment_author": "spytheman",
        "comment_body": "although that may have a non trivial performance impact",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1807255967",
    "pr_number": 22581,
    "pr_file": "vlib/x/json2/decoder2/decode.v",
    "created_at": "2024-10-19T09:19:48+00:00",
    "commented_code": "struct Decoder {\n \tjson string // json is the JSON data to be decoded.\n mut:\n-\tvalues_info    []ValueInfo\n-\tidx            int // idx is byte offset from the start in json\n-\tchecker_idx    int // checker_idx is the current index of the decoder.\n-\tvalue_info_idx int // value_info_idx is the current index of the values_info.\n+\tlinked_list_of_value_info LinkedList // A linked list to store ValueInfo.\n+\tchecker_idx               int        // checker_idx is the current index of the decoder.\n+\tcurrent_node              &Node = unsafe { nil } // The current node in the linked list.\n+}\n+\n+// LinkedList represents a linked list to store ValueInfo.\n+struct LinkedList {\n+mut:\n+\thead &Node = unsafe { nil } // head is the first node in the linked list.\n+\ttail &Node = unsafe { nil } // tail is the last node in the linked list.\n+\tlen  int // len is the length of the linked list.\n+}\n+\n+// push adds a new element to the linked list.\n+fn (mut list LinkedList) push(value ValueInfo) {\n+\tnew_node := &Node{\n+\t\tvalue: value\n+\t}\n+\tif list.head == unsafe { nil } {\n+\t\tlist.head = new_node\n+\t\tlist.tail = new_node\n+\t} else {\n+\t\tlist.tail.next = new_node\n+\t\tlist.tail = new_node\n+\t}\n+\tlist.len++\n }\n \n+// last returns the last element added to the linked list.\n+fn (list LinkedList) last() &ValueInfo {\n+\treturn &list.tail.value\n+}\n+\n+// str returns a string representation of the linked list.\n+fn (list LinkedList) str() string {\n+\tmut result := ''\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tresult += current.value.value_kind.str() + ' '\n+\t\tcurrent = current.next\n+\t}\n+\treturn result\n+}\n+\n+@[unsafe]\n+fn (list &LinkedList) free() {\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tmut next := current.next",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1807255967",
        "repo_full_name": "vlang/v",
        "pr_number": 22581,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1807255967",
        "commented_code": "@@ -21,12 +22,61 @@ mut:\n struct Decoder {\n \tjson string // json is the JSON data to be decoded.\n mut:\n-\tvalues_info    []ValueInfo\n-\tidx            int // idx is byte offset from the start in json\n-\tchecker_idx    int // checker_idx is the current index of the decoder.\n-\tvalue_info_idx int // value_info_idx is the current index of the values_info.\n+\tlinked_list_of_value_info LinkedList // A linked list to store ValueInfo.\n+\tchecker_idx               int        // checker_idx is the current index of the decoder.\n+\tcurrent_node              &Node = unsafe { nil } // The current node in the linked list.\n+}\n+\n+// LinkedList represents a linked list to store ValueInfo.\n+struct LinkedList {\n+mut:\n+\thead &Node = unsafe { nil } // head is the first node in the linked list.\n+\ttail &Node = unsafe { nil } // tail is the last node in the linked list.\n+\tlen  int // len is the length of the linked list.\n+}\n+\n+// push adds a new element to the linked list.\n+fn (mut list LinkedList) push(value ValueInfo) {\n+\tnew_node := &Node{\n+\t\tvalue: value\n+\t}\n+\tif list.head == unsafe { nil } {\n+\t\tlist.head = new_node\n+\t\tlist.tail = new_node\n+\t} else {\n+\t\tlist.tail.next = new_node\n+\t\tlist.tail = new_node\n+\t}\n+\tlist.len++\n }\n \n+// last returns the last element added to the linked list.\n+fn (list LinkedList) last() &ValueInfo {\n+\treturn &list.tail.value\n+}\n+\n+// str returns a string representation of the linked list.\n+fn (list LinkedList) str() string {\n+\tmut result := ''\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tresult += current.value.value_kind.str() + ' '\n+\t\tcurrent = current.next\n+\t}\n+\treturn result\n+}\n+\n+@[unsafe]\n+fn (list &LinkedList) free() {\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tmut next := current.next",
        "comment_created_at": "2024-10-19T09:19:48+00:00",
        "comment_author": "spytheman",
        "comment_body": "set current.next to nil right after this line",
        "pr_file_module": null
      },
      {
        "comment_id": "1807384714",
        "repo_full_name": "vlang/v",
        "pr_number": 22581,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1807255967",
        "commented_code": "@@ -21,12 +22,61 @@ mut:\n struct Decoder {\n \tjson string // json is the JSON data to be decoded.\n mut:\n-\tvalues_info    []ValueInfo\n-\tidx            int // idx is byte offset from the start in json\n-\tchecker_idx    int // checker_idx is the current index of the decoder.\n-\tvalue_info_idx int // value_info_idx is the current index of the values_info.\n+\tlinked_list_of_value_info LinkedList // A linked list to store ValueInfo.\n+\tchecker_idx               int        // checker_idx is the current index of the decoder.\n+\tcurrent_node              &Node = unsafe { nil } // The current node in the linked list.\n+}\n+\n+// LinkedList represents a linked list to store ValueInfo.\n+struct LinkedList {\n+mut:\n+\thead &Node = unsafe { nil } // head is the first node in the linked list.\n+\ttail &Node = unsafe { nil } // tail is the last node in the linked list.\n+\tlen  int // len is the length of the linked list.\n+}\n+\n+// push adds a new element to the linked list.\n+fn (mut list LinkedList) push(value ValueInfo) {\n+\tnew_node := &Node{\n+\t\tvalue: value\n+\t}\n+\tif list.head == unsafe { nil } {\n+\t\tlist.head = new_node\n+\t\tlist.tail = new_node\n+\t} else {\n+\t\tlist.tail.next = new_node\n+\t\tlist.tail = new_node\n+\t}\n+\tlist.len++\n }\n \n+// last returns the last element added to the linked list.\n+fn (list LinkedList) last() &ValueInfo {\n+\treturn &list.tail.value\n+}\n+\n+// str returns a string representation of the linked list.\n+fn (list LinkedList) str() string {\n+\tmut result := ''\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tresult += current.value.value_kind.str() + ' '\n+\t\tcurrent = current.next\n+\t}\n+\treturn result\n+}\n+\n+@[unsafe]\n+fn (list &LinkedList) free() {\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tmut next := current.next",
        "comment_created_at": "2024-10-19T15:20:15+00:00",
        "comment_author": "enghitalo",
        "comment_body": "```v\r\ncurrent.next = unsafe { nil } // Will not this affect the loop?\r\n```\r\nor \r\n```v\r\ndefer {\r\n    current.next = unsafe { nil }\r\n}\r\n```\r\n?",
        "pr_file_module": null
      },
      {
        "comment_id": "1807486807",
        "repo_full_name": "vlang/v",
        "pr_number": 22581,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1807255967",
        "commented_code": "@@ -21,12 +22,61 @@ mut:\n struct Decoder {\n \tjson string // json is the JSON data to be decoded.\n mut:\n-\tvalues_info    []ValueInfo\n-\tidx            int // idx is byte offset from the start in json\n-\tchecker_idx    int // checker_idx is the current index of the decoder.\n-\tvalue_info_idx int // value_info_idx is the current index of the values_info.\n+\tlinked_list_of_value_info LinkedList // A linked list to store ValueInfo.\n+\tchecker_idx               int        // checker_idx is the current index of the decoder.\n+\tcurrent_node              &Node = unsafe { nil } // The current node in the linked list.\n+}\n+\n+// LinkedList represents a linked list to store ValueInfo.\n+struct LinkedList {\n+mut:\n+\thead &Node = unsafe { nil } // head is the first node in the linked list.\n+\ttail &Node = unsafe { nil } // tail is the last node in the linked list.\n+\tlen  int // len is the length of the linked list.\n+}\n+\n+// push adds a new element to the linked list.\n+fn (mut list LinkedList) push(value ValueInfo) {\n+\tnew_node := &Node{\n+\t\tvalue: value\n+\t}\n+\tif list.head == unsafe { nil } {\n+\t\tlist.head = new_node\n+\t\tlist.tail = new_node\n+\t} else {\n+\t\tlist.tail.next = new_node\n+\t\tlist.tail = new_node\n+\t}\n+\tlist.len++\n }\n \n+// last returns the last element added to the linked list.\n+fn (list LinkedList) last() &ValueInfo {\n+\treturn &list.tail.value\n+}\n+\n+// str returns a string representation of the linked list.\n+fn (list LinkedList) str() string {\n+\tmut result := ''\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tresult += current.value.value_kind.str() + ' '\n+\t\tcurrent = current.next\n+\t}\n+\treturn result\n+}\n+\n+@[unsafe]\n+fn (list &LinkedList) free() {\n+\tmut current := list.head\n+\tfor current != unsafe { nil } {\n+\t\tmut next := current.next",
        "comment_created_at": "2024-10-19T21:51:30+00:00",
        "comment_author": "spytheman",
        "comment_body": "You are doing `free(current)` on the next line. It will not affect the loop.",
        "pr_file_module": null
      }
    ]
  }
]