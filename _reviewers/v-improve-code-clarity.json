[
  {
    "discussion_id": "2096537463",
    "pr_number": 24509,
    "pr_file": "vlib/v/fmt/fmt.v",
    "created_at": "2025-05-19T21:54:32+00:00",
    "commented_code": "f.or_expr(node.or_block)\n }\n \n+pub fn (mut f Fmt) align_of(node ast.AlignOf) {\n+\tf.write('alignof')\n+\tif node.is_type && !node.guessed_type {\n+\t\t// the new form was explicitly written in the source code; keep it:\n+\t\tf.write('[')\n+\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n+\t\tf.write(']()')\n+\t\treturn\n+\t}\n+\tif node.is_type {\n+\t\tf.write('(')\n+\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n+\t\tf.write(')')\n+\t} else {\n+\t\tf.write('(')\n+\t\tf.expr(node.expr)\n+\t\tf.write(')')\n+\t}",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2096537463",
        "repo_full_name": "vlang/v",
        "pr_number": 24509,
        "pr_file": "vlib/v/fmt/fmt.v",
        "discussion_id": "2096537463",
        "commented_code": "@@ -3043,6 +3046,26 @@ pub fn (mut f Fmt) selector_expr(node ast.SelectorExpr) {\n \tf.or_expr(node.or_block)\n }\n \n+pub fn (mut f Fmt) align_of(node ast.AlignOf) {\n+\tf.write('alignof')\n+\tif node.is_type && !node.guessed_type {\n+\t\t// the new form was explicitly written in the source code; keep it:\n+\t\tf.write('[')\n+\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n+\t\tf.write(']()')\n+\t\treturn\n+\t}\n+\tif node.is_type {\n+\t\tf.write('(')\n+\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n+\t\tf.write(')')\n+\t} else {\n+\t\tf.write('(')\n+\t\tf.expr(node.expr)\n+\t\tf.write(')')\n+\t}",
        "comment_created_at": "2025-05-19T21:54:32+00:00",
        "comment_author": "StunxFS",
        "comment_body": "```suggestion\n\tf.write('(')\n\tif node.is_type {\n\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n\t} else {\n\t\tf.expr(node.expr)\n\t}\n\tf.write(')')\n```\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2107927127",
        "repo_full_name": "vlang/v",
        "pr_number": 24509,
        "pr_file": "vlib/v/fmt/fmt.v",
        "discussion_id": "2096537463",
        "commented_code": "@@ -3043,6 +3046,26 @@ pub fn (mut f Fmt) selector_expr(node ast.SelectorExpr) {\n \tf.or_expr(node.or_block)\n }\n \n+pub fn (mut f Fmt) align_of(node ast.AlignOf) {\n+\tf.write('alignof')\n+\tif node.is_type && !node.guessed_type {\n+\t\t// the new form was explicitly written in the source code; keep it:\n+\t\tf.write('[')\n+\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n+\t\tf.write(']()')\n+\t\treturn\n+\t}\n+\tif node.is_type {\n+\t\tf.write('(')\n+\t\tf.write(f.table.type_to_str_using_aliases(node.typ, f.mod2alias))\n+\t\tf.write(')')\n+\t} else {\n+\t\tf.write('(')\n+\t\tf.expr(node.expr)\n+\t\tf.write(')')\n+\t}",
        "comment_created_at": "2025-05-26T23:51:07+00:00",
        "comment_author": "tritao",
        "comment_body": "It's my understanding that this suggestion would format it using old way syntax and I should be using new-way syntax for types, using `[`  and `]`. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2055165142",
    "pr_number": 24301,
    "pr_file": "vlib/os/filelock/lib_windows.c.v",
    "created_at": "2025-04-23T02:49:01+00:00",
    "commented_code": "pub fn (mut l FileLock) unlink() {\n \tif !isnil(l.cfile) {\n-\t\tret := C.CloseHandle(l.cfile)\n+\t\tC.CloseHandle(l.cfile)",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2055165142",
        "repo_full_name": "vlang/v",
        "pr_number": 24301,
        "pr_file": "vlib/os/filelock/lib_windows.c.v",
        "discussion_id": "2055165142",
        "commented_code": "@@ -6,11 +6,11 @@ fn C.CloseHandle(voidptr) bool\n \n pub fn (mut l FileLock) unlink() {\n \tif !isnil(l.cfile) {\n-\t\tret := C.CloseHandle(l.cfile)\n+\t\tC.CloseHandle(l.cfile)",
        "comment_created_at": "2025-04-23T02:49:01+00:00",
        "comment_author": "JalonSolov",
        "comment_body": "Technically, it would be better to have\r\n```suggestion\r\n\t\t_ = C.CloseHandle(l.cfile)\r\n```\r\nto explicitly show that the return code is being ignored, rather than not knowing there was a return code at all.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1609103600",
    "pr_number": 20650,
    "pr_file": "vlib/db/sqlite/sqlite.c.v",
    "created_at": "2024-05-22T00:36:37+00:00",
    "commented_code": "return rows\n }\n \n+// get_queryset returns the values resulting from a 'SELECT' query and the name of each column. If an alias is provided either through the 'as' command or not, the returned value becomes the alias.\n+@[manualfree]\n+pub fn (db &DB) get_queryset(query string) ![]QuerySet {\n+\tquery_lower := query.to_lower()\n+\n+\t// 'select' syntax verified on: https://www.sqlite.org/lang_select.html and\n+\t// https://www.sqlite.org/syntax/join-clause.html\n+\tmut select_header := regex_opt(r'select((\\s)+(all)|(distinct)(\\s)+)|(\\s)+')!\n+\tmut from := regex_opt(r'(\\s)+from(\\s)+')!\n+\n+\t// or do not include 'FROM', just like 'SELECT 1 + 1'\n+\tif query_lower.count('select') == 1 && query_lower.contains('from') {\n+\t\t// The execution of this function indicates that the passed\n+\t\t// query is syntactically correct, which is why no additional verification\n+\t\trows := db.exec(query)!\n+\n+\t\tdefer {\n+\t\t\tunsafe { rows.free() }\n+\t\t}\n+\n+\t\tif rows.len == 0 {\n+\t\t\treturn []QuerySet{}\n+\t\t} else {\n+\t\t\t// Finding final index of select((\\s)+(all)|(distinct)(\\s)+)|(\\s)+ inside query_lower string\n+\t\t\t_, end_select := select_header.match_string(query_lower)",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1609103600",
        "repo_full_name": "vlang/v",
        "pr_number": 20650,
        "pr_file": "vlib/db/sqlite/sqlite.c.v",
        "discussion_id": "1609103600",
        "commented_code": "@@ -248,6 +255,101 @@ pub fn (db &DB) exec(query string) ![]Row {\n \treturn rows\n }\n \n+// get_queryset returns the values resulting from a 'SELECT' query and the name of each column. If an alias is provided either through the 'as' command or not, the returned value becomes the alias.\n+@[manualfree]\n+pub fn (db &DB) get_queryset(query string) ![]QuerySet {\n+\tquery_lower := query.to_lower()\n+\n+\t// 'select' syntax verified on: https://www.sqlite.org/lang_select.html and\n+\t// https://www.sqlite.org/syntax/join-clause.html\n+\tmut select_header := regex_opt(r'select((\\s)+(all)|(distinct)(\\s)+)|(\\s)+')!\n+\tmut from := regex_opt(r'(\\s)+from(\\s)+')!\n+\n+\t// or do not include 'FROM', just like 'SELECT 1 + 1'\n+\tif query_lower.count('select') == 1 && query_lower.contains('from') {\n+\t\t// The execution of this function indicates that the passed\n+\t\t// query is syntactically correct, which is why no additional verification\n+\t\trows := db.exec(query)!\n+\n+\t\tdefer {\n+\t\t\tunsafe { rows.free() }\n+\t\t}\n+\n+\t\tif rows.len == 0 {\n+\t\t\treturn []QuerySet{}\n+\t\t} else {\n+\t\t\t// Finding final index of select((\\s)+(all)|(distinct)(\\s)+)|(\\s)+ inside query_lower string\n+\t\t\t_, end_select := select_header.match_string(query_lower)",
        "comment_created_at": "2024-05-22T00:36:37+00:00",
        "comment_author": "ttytm",
        "comment_body": "As an aspect of readability, I would mention avoiding unnecessary nested code, with a reference to the book [100 Go Mistakes and How to Avoid Them](https://100go.co/book/). \r\n> When an if block returns, we should omit the else block [...]",
        "pr_file_module": null
      },
      {
        "comment_id": "1609123100",
        "repo_full_name": "vlang/v",
        "pr_number": 20650,
        "pr_file": "vlib/db/sqlite/sqlite.c.v",
        "discussion_id": "1609103600",
        "commented_code": "@@ -248,6 +255,101 @@ pub fn (db &DB) exec(query string) ![]Row {\n \treturn rows\n }\n \n+// get_queryset returns the values resulting from a 'SELECT' query and the name of each column. If an alias is provided either through the 'as' command or not, the returned value becomes the alias.\n+@[manualfree]\n+pub fn (db &DB) get_queryset(query string) ![]QuerySet {\n+\tquery_lower := query.to_lower()\n+\n+\t// 'select' syntax verified on: https://www.sqlite.org/lang_select.html and\n+\t// https://www.sqlite.org/syntax/join-clause.html\n+\tmut select_header := regex_opt(r'select((\\s)+(all)|(distinct)(\\s)+)|(\\s)+')!\n+\tmut from := regex_opt(r'(\\s)+from(\\s)+')!\n+\n+\t// or do not include 'FROM', just like 'SELECT 1 + 1'\n+\tif query_lower.count('select') == 1 && query_lower.contains('from') {\n+\t\t// The execution of this function indicates that the passed\n+\t\t// query is syntactically correct, which is why no additional verification\n+\t\trows := db.exec(query)!\n+\n+\t\tdefer {\n+\t\t\tunsafe { rows.free() }\n+\t\t}\n+\n+\t\tif rows.len == 0 {\n+\t\t\treturn []QuerySet{}\n+\t\t} else {\n+\t\t\t// Finding final index of select((\\s)+(all)|(distinct)(\\s)+)|(\\s)+ inside query_lower string\n+\t\t\t_, end_select := select_header.match_string(query_lower)",
        "comment_created_at": "2024-05-22T00:43:51+00:00",
        "comment_author": "JalonSolov",
        "comment_body": "That should be common sense for any language.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2019738605",
    "pr_number": 24065,
    "pr_file": "vlib/veb/status/status.v",
    "created_at": "2025-03-29T06:55:16+00:00",
    "commented_code": "+module status\n+\n+import net.http\n+\n+// Status is a struct that contains the message, status, code, and status of the request\n+pub struct Status {\n+\t// msg is the message that will be returned to the user\n+\tmsg string\n+\t// resp is the status that will be returned to the user\n+\tresp string\n+\t// code is the status code that will be returned to the user\n+\tcode int\n+\t// status is the status of the request\n+\tstatus http.Status\n+}\n+\n+// status returns a new Status struct with the given message, status, and code\n+pub fn new_status(msg string, status http.Status) Status {\n+\treturn Status{\n+\t\tmsg:    msg\n+\t\tresp:   status.str()\n+\t\tcode:   status.int()\n+\t\tstatus: status\n+\t}\n+}\n+\n+// resp_code returns the status code and message as a string\n+// for example: \"200 OK\"\n+// this is used to return the status code and message to the user\n+pub fn (s Status) resp_code() string {\n+\treturn '${s.code} ${s.resp}'\n+}\n+\n+// is_success returns true if the status is a success\n+// this is used to check if the request was successful\n+pub fn (s Status) is_success() bool {\n+\tif s.status.is_success() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+// is_ok returns true if the status is a success\n+// this is used to check if the request was successful\n+pub fn (s Status) is_ok() bool {\n+\tif s.status.is_success() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+// is_error returns true if the status is an error\n+// this is used to check if the request was an error\n+pub fn (s Status) is_error() bool {\n+\tif s.status.is_error() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+// is_valid returns true if the status is valid\n+// this is used to check if the request was valid\n+pub fn (s Status) is_valid() bool {\n+\tif s.status.is_valid() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2019738605",
        "repo_full_name": "vlang/v",
        "pr_number": 24065,
        "pr_file": "vlib/veb/status/status.v",
        "discussion_id": "2019738605",
        "commented_code": "@@ -0,0 +1,72 @@\n+module status\n+\n+import net.http\n+\n+// Status is a struct that contains the message, status, code, and status of the request\n+pub struct Status {\n+\t// msg is the message that will be returned to the user\n+\tmsg string\n+\t// resp is the status that will be returned to the user\n+\tresp string\n+\t// code is the status code that will be returned to the user\n+\tcode int\n+\t// status is the status of the request\n+\tstatus http.Status\n+}\n+\n+// status returns a new Status struct with the given message, status, and code\n+pub fn new_status(msg string, status http.Status) Status {\n+\treturn Status{\n+\t\tmsg:    msg\n+\t\tresp:   status.str()\n+\t\tcode:   status.int()\n+\t\tstatus: status\n+\t}\n+}\n+\n+// resp_code returns the status code and message as a string\n+// for example: \"200 OK\"\n+// this is used to return the status code and message to the user\n+pub fn (s Status) resp_code() string {\n+\treturn '${s.code} ${s.resp}'\n+}\n+\n+// is_success returns true if the status is a success\n+// this is used to check if the request was successful\n+pub fn (s Status) is_success() bool {\n+\tif s.status.is_success() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+// is_ok returns true if the status is a success\n+// this is used to check if the request was successful\n+pub fn (s Status) is_ok() bool {\n+\tif s.status.is_success() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+// is_error returns true if the status is an error\n+// this is used to check if the request was an error\n+pub fn (s Status) is_error() bool {\n+\tif s.status.is_error() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}\n+\n+// is_valid returns true if the status is valid\n+// this is used to check if the request was valid\n+pub fn (s Status) is_valid() bool {\n+\tif s.status.is_valid() {\n+\t\treturn true\n+\t} else {\n+\t\treturn false\n+\t}\n+}",
        "comment_created_at": "2025-03-29T06:55:16+00:00",
        "comment_author": "spytheman",
        "comment_body": "Those methods have no utility at all, since they just delegate to methods of the underlying field, that could be just accessed directly, if it is public.\r\n\r\nThe code of the implementation also seems extremely verbose for what it does.\r\n```v\r\n\tif s.status.is_valid() {\r\n\t\treturn true\r\n\t} else {\r\n\t\treturn false\r\n\t}\r\n}\r\n```\r\n^ that could be just: `return s.status.is_valid()` ...\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1769480901",
    "pr_number": 22266,
    "pr_file": "vlib/crypto/rand/utils.v",
    "created_at": "2024-09-21T05:36:41+00:00",
    "commented_code": "}\n \treturn z\n }\n+\n+// int_big creates a random `big.Integer` with range [0, n)\n+// panics if `n` is 0 or negative.\n+pub fn int_big(n big.Integer) !big.Integer {\n+\tif n.signum < 1 {\n+\t\treturn error('`n` cannot be 0 or negative.')\n+\t}\n+\n+\tmax := n - big.integer_from_int(1)\n+\tlen := max.bit_len()\n+\n+\tif len == 0 {\n+\t\t// max must be 0\n+\t\treturn max\n+\t}\n+\n+\t// k is the maximum byte length needed to encode a value < n\n+\tk := (len + 7) / 8\n+\n+\t// b is the number of bits in the most significant byte of n-1\n+\tget_b := fn [len] () u64 {\n+\t\tb := u64(len % 8)\n+\t\tif b == 0 {\n+\t\t\treturn 8\n+\t\t}\n+\t\treturn b\n+\t}\n+\tb := get_b()",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1769480901",
        "repo_full_name": "vlang/v",
        "pr_number": 22266,
        "pr_file": "vlib/crypto/rand/utils.v",
        "discussion_id": "1769480901",
        "commented_code": "@@ -53,3 +54,46 @@ fn bytes_to_u64(b []u8) []u64 {\n \t}\n \treturn z\n }\n+\n+// int_big creates a random `big.Integer` with range [0, n)\n+// panics if `n` is 0 or negative.\n+pub fn int_big(n big.Integer) !big.Integer {\n+\tif n.signum < 1 {\n+\t\treturn error('`n` cannot be 0 or negative.')\n+\t}\n+\n+\tmax := n - big.integer_from_int(1)\n+\tlen := max.bit_len()\n+\n+\tif len == 0 {\n+\t\t// max must be 0\n+\t\treturn max\n+\t}\n+\n+\t// k is the maximum byte length needed to encode a value < n\n+\tk := (len + 7) / 8\n+\n+\t// b is the number of bits in the most significant byte of n-1\n+\tget_b := fn [len] () u64 {\n+\t\tb := u64(len % 8)\n+\t\tif b == 0 {\n+\t\t\treturn 8\n+\t\t}\n+\t\treturn b\n+\t}\n+\tb := get_b()",
        "comment_created_at": "2024-09-21T05:36:41+00:00",
        "comment_author": "spytheman",
        "comment_body": "why is this defining a closure, just to call it right away?\r\nimho just inline the code",
        "pr_file_module": null
      },
      {
        "comment_id": "1769497007",
        "repo_full_name": "vlang/v",
        "pr_number": 22266,
        "pr_file": "vlib/crypto/rand/utils.v",
        "discussion_id": "1769480901",
        "commented_code": "@@ -53,3 +54,46 @@ fn bytes_to_u64(b []u8) []u64 {\n \t}\n \treturn z\n }\n+\n+// int_big creates a random `big.Integer` with range [0, n)\n+// panics if `n` is 0 or negative.\n+pub fn int_big(n big.Integer) !big.Integer {\n+\tif n.signum < 1 {\n+\t\treturn error('`n` cannot be 0 or negative.')\n+\t}\n+\n+\tmax := n - big.integer_from_int(1)\n+\tlen := max.bit_len()\n+\n+\tif len == 0 {\n+\t\t// max must be 0\n+\t\treturn max\n+\t}\n+\n+\t// k is the maximum byte length needed to encode a value < n\n+\tk := (len + 7) / 8\n+\n+\t// b is the number of bits in the most significant byte of n-1\n+\tget_b := fn [len] () u64 {\n+\t\tb := u64(len % 8)\n+\t\tif b == 0 {\n+\t\t\treturn 8\n+\t\t}\n+\t\treturn b\n+\t}\n+\tb := get_b()",
        "comment_created_at": "2024-09-21T07:10:16+00:00",
        "comment_author": "einar-hjortdal",
        "comment_body": "Done, I tend to define closures over using mutable variables. A mut should be more efficient.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1885549032",
    "pr_number": 23171,
    "pr_file": "vlib/term/term_nix.c.v",
    "created_at": "2024-12-15T08:19:09+00:00",
    "commented_code": "}\n \treturn buf.bytestr().u16()\n }\n+\n+// enable_echo enable/disable echo input characters\n+pub fn enable_echo(enable bool) {\n+\tmut state := termios.Termios{}\n+\ttermios.tcgetattr(0, mut state)\n+\tif enable {\n+\t\tstate.c_lflag |= C.ECHO\n+\t} else {\n+\t\tstate.c_lflag &= ~C.ECHO\n+\t}\n+\ttermios.tcsetattr(0, C.TCSANOW, mut state)\n+}\n+\n+// key_pressed gives back a single character, read from the standard input.\n+// It returns -1 on error or no character in non-blocking mode\n+pub fn key_pressed(blocking bool, echo bool) int {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1885549032",
        "repo_full_name": "vlang/v",
        "pr_number": 23171,
        "pr_file": "vlib/term/term_nix.c.v",
        "discussion_id": "1885549032",
        "commented_code": "@@ -215,3 +216,60 @@ pub fn graphics_num_colors() u16 {\n \t}\n \treturn buf.bytestr().u16()\n }\n+\n+// enable_echo enable/disable echo input characters\n+pub fn enable_echo(enable bool) {\n+\tmut state := termios.Termios{}\n+\ttermios.tcgetattr(0, mut state)\n+\tif enable {\n+\t\tstate.c_lflag |= C.ECHO\n+\t} else {\n+\t\tstate.c_lflag &= ~C.ECHO\n+\t}\n+\ttermios.tcsetattr(0, C.TCSANOW, mut state)\n+}\n+\n+// key_pressed gives back a single character, read from the standard input.\n+// It returns -1 on error or no character in non-blocking mode\n+pub fn key_pressed(blocking bool, echo bool) int {",
        "comment_created_at": "2024-12-15T08:19:09+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho there is no need for the second argument, since it essentially duplicates what `enable_echo`, but for each key check.\r\n\r\nThat `state.c_lflag &= ~C.ICANON` can be moved inside enable_echo(false) too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1885550320",
        "repo_full_name": "vlang/v",
        "pr_number": 23171,
        "pr_file": "vlib/term/term_nix.c.v",
        "discussion_id": "1885549032",
        "commented_code": "@@ -215,3 +216,60 @@ pub fn graphics_num_colors() u16 {\n \t}\n \treturn buf.bytestr().u16()\n }\n+\n+// enable_echo enable/disable echo input characters\n+pub fn enable_echo(enable bool) {\n+\tmut state := termios.Termios{}\n+\ttermios.tcgetattr(0, mut state)\n+\tif enable {\n+\t\tstate.c_lflag |= C.ECHO\n+\t} else {\n+\t\tstate.c_lflag &= ~C.ECHO\n+\t}\n+\ttermios.tcsetattr(0, C.TCSANOW, mut state)\n+}\n+\n+// key_pressed gives back a single character, read from the standard input.\n+// It returns -1 on error or no character in non-blocking mode\n+pub fn key_pressed(blocking bool, echo bool) int {",
        "comment_created_at": "2024-12-15T08:24:48+00:00",
        "comment_author": "spytheman",
        "comment_body": "I also think that it will be clearer and easier for maintenance, if we have 2 functions:\r\n`pub fn key_pressed() int {`\r\nand\r\n`pub fn key_pressed_blocking() int {`\r\ninstead of a single one, with a bool argument to choose it - the places where you want each variant, are imho different, and having a mandatory boolean argument for each callsite does not seem very ergonomic to me.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1896869055",
    "pr_number": 23260,
    "pr_file": "vlib/v/gen/c/cgen.v",
    "created_at": "2024-12-24T16:44:06+00:00",
    "commented_code": "mut sum_type_dot := '.'\n \tmut field_typ := ast.void_type\n \tmut is_option_unwrap := false\n+\tmut is_dereferenced := node.expr is ast.SelectorExpr && node.expr.expr_type.is_ptr()\n+\t\t&& !node.expr.typ.is_ptr()\n+\t\t&& g.table.final_sym(node.expr.expr_type).kind in [.interface, .sum_type]",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1896869055",
        "repo_full_name": "vlang/v",
        "pr_number": 23260,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1896869055",
        "commented_code": "@@ -4208,6 +4208,9 @@ fn (mut g Gen) selector_expr(node ast.SelectorExpr) {\n \tmut sum_type_dot := '.'\n \tmut field_typ := ast.void_type\n \tmut is_option_unwrap := false\n+\tmut is_dereferenced := node.expr is ast.SelectorExpr && node.expr.expr_type.is_ptr()\n+\t\t&& !node.expr.typ.is_ptr()\n+\t\t&& g.table.final_sym(node.expr.expr_type).kind in [.interface, .sum_type]",
        "comment_created_at": "2024-12-24T16:44:06+00:00",
        "comment_author": "spytheman",
        "comment_body": "This is computed over 150 lines above the place where it is used.\r\nImho move it below, near the if condition that uses it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1887262460",
    "pr_number": 23179,
    "pr_file": "vlib/v/gen/c/cgen.v",
    "created_at": "2024-12-16T17:53:29+00:00",
    "commented_code": "return s.replace('\n', r'\n')\n }\n \n-fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string) {\n+fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string, with_argname bool) {\n \tret_styp := g.styp(func.func.return_type)\n \tg.write('${ret_styp} (*${ptr_name}) (')\n \targ_len := func.func.params.len\n \tfor i, arg in func.func.params {\n \t\targ_styp := g.styp(arg.typ)\n-\t\tg.write('${arg_styp} ${arg.name}')\n+\t\tg.write(arg_styp)\n+\t\tif with_argname {\n+\t\t\tg.write(' ${arg.name}')\n+\t\t}",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1887262460",
        "repo_full_name": "vlang/v",
        "pr_number": 23179,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1887262460",
        "commented_code": "@@ -3192,13 +3201,16 @@ fn cnewlines(s string) string {\n \treturn s.replace('\\n', r'\\n')\n }\n \n-fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string) {\n+fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string, with_argname bool) {\n \tret_styp := g.styp(func.func.return_type)\n \tg.write('${ret_styp} (*${ptr_name}) (')\n \targ_len := func.func.params.len\n \tfor i, arg in func.func.params {\n \t\targ_styp := g.styp(arg.typ)\n-\t\tg.write('${arg_styp} ${arg.name}')\n+\t\tg.write(arg_styp)\n+\t\tif with_argname {\n+\t\t\tg.write(' ${arg.name}')\n+\t\t}",
        "comment_created_at": "2024-12-16T17:53:29+00:00",
        "comment_author": "spytheman",
        "comment_body": "Is there a reason why it should miss an argname ?\r\nIn all existing cases, it produces one, and imho that makes reading the generated code and the potential errors that C compilers produce, much easier.\r\n\r\nImho just always write the name.",
        "pr_file_module": null
      },
      {
        "comment_id": "1887263551",
        "repo_full_name": "vlang/v",
        "pr_number": 23179,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1887262460",
        "commented_code": "@@ -3192,13 +3201,16 @@ fn cnewlines(s string) string {\n \treturn s.replace('\\n', r'\\n')\n }\n \n-fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string) {\n+fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string, with_argname bool) {\n \tret_styp := g.styp(func.func.return_type)\n \tg.write('${ret_styp} (*${ptr_name}) (')\n \targ_len := func.func.params.len\n \tfor i, arg in func.func.params {\n \t\targ_styp := g.styp(arg.typ)\n-\t\tg.write('${arg_styp} ${arg.name}')\n+\t\tg.write(arg_styp)\n+\t\tif with_argname {\n+\t\t\tg.write(' ${arg.name}')\n+\t\t}",
        "comment_created_at": "2024-12-16T17:54:20+00:00",
        "comment_author": "spytheman",
        "comment_body": "It will also eliminate the bool argument to write_fn_ptr_decl , which is true in all currently existing cases, and simplify the PR diff.",
        "pr_file_module": null
      },
      {
        "comment_id": "1887288367",
        "repo_full_name": "vlang/v",
        "pr_number": 23179,
        "pr_file": "vlib/v/gen/c/cgen.v",
        "discussion_id": "1887262460",
        "commented_code": "@@ -3192,13 +3201,16 @@ fn cnewlines(s string) string {\n \treturn s.replace('\\n', r'\\n')\n }\n \n-fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string) {\n+fn (mut g Gen) write_fn_ptr_decl(func &ast.FnType, ptr_name string, with_argname bool) {\n \tret_styp := g.styp(func.func.return_type)\n \tg.write('${ret_styp} (*${ptr_name}) (')\n \targ_len := func.func.params.len\n \tfor i, arg in func.func.params {\n \t\targ_styp := g.styp(arg.typ)\n-\t\tg.write('${arg_styp} ${arg.name}')\n+\t\tg.write(arg_styp)\n+\t\tif with_argname {\n+\t\t\tg.write(' ${arg.name}')\n+\t\t}",
        "comment_created_at": "2024-12-16T18:13:55+00:00",
        "comment_author": "felipensp",
        "comment_body": "Yeah, sometimes it looks providing superfluous extra info. But I can restore this part.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1826382404",
    "pr_number": 22704,
    "pr_file": "vlib/time/parse.c.v",
    "created_at": "2024-11-01T23:47:38+00:00",
    "commented_code": "// parse_rfc3339 returns the time from a date string in RFC 3339 datetime format.\n // See also https://ijmacd.github.io/rfc3339-iso8601/ for a visual reference of\n // the differences between ISO-8601 and RFC 3339.\n+\n+// parse_rfc3339 returns the time from a date string in RFC 3339 datetime format.\n+// See also https://ijmacd.github.io/rfc3339-iso8601/ for a visual reference of\n+// the differences between ISO-8601 and RFC 3339.\n+@[direct_array_access]\n pub fn parse_rfc3339(s string) !Time {\n-\tif s == '' {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1826382404",
        "repo_full_name": "vlang/v",
        "pr_number": 22704,
        "pr_file": "vlib/time/parse.c.v",
        "discussion_id": "1826382404",
        "commented_code": "@@ -129,8 +129,13 @@ fn check_and_extract_date(s string) !(int, int, int) {\n // parse_rfc3339 returns the time from a date string in RFC 3339 datetime format.\n // See also https://ijmacd.github.io/rfc3339-iso8601/ for a visual reference of\n // the differences between ISO-8601 and RFC 3339.\n+\n+// parse_rfc3339 returns the time from a date string in RFC 3339 datetime format.\n+// See also https://ijmacd.github.io/rfc3339-iso8601/ for a visual reference of\n+// the differences between ISO-8601 and RFC 3339.\n+@[direct_array_access]\n pub fn parse_rfc3339(s string) !Time {\n-\tif s == '' {",
        "comment_created_at": "2024-11-01T23:47:38+00:00",
        "comment_author": "ttytm",
        "comment_body": "The compiler is optimizing for this. Since the change is longer to write and is a bit less expressive (checking the `len` is not exclusive to strings; while it is fairly clear in this context, in others it can create more mental overhead to grasp what is happening when reading the code) using `== ''` has become something that v vet recommends to check for an empty string.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1829262207",
    "pr_number": 22764,
    "pr_file": "vlib/v/slow_tests/inout/in_expr_callexpr.vv",
    "created_at": "2024-11-05T12:23:52+00:00",
    "commented_code": "+fn t() bool {\n+\tprintln('${@FN}')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1829262207",
        "repo_full_name": "vlang/v",
        "pr_number": 22764,
        "pr_file": "vlib/v/slow_tests/inout/in_expr_callexpr.vv",
        "discussion_id": "1829262207",
        "commented_code": "@@ -0,0 +1,14 @@\n+fn t() bool {\n+\tprintln('${@FN}')",
        "comment_created_at": "2024-11-05T12:23:52+00:00",
        "comment_author": "spytheman",
        "comment_body": "`@FN` is already a string, there is no need to interpolate it.",
        "pr_file_module": null
      }
    ]
  }
]