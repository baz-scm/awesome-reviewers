[
  {
    "discussion_id": "2188127752",
    "pr_number": 24849,
    "pr_file": "vlib/sync/tls.v",
    "created_at": "2025-07-06T09:20:17+00:00",
    "commented_code": "+module sync\n+\n+// ThreadLocalStorage provides thread-local storage for values of type T\n+@[noinit]\n+struct ThreadLocalStorage[T] {\n+mut:\n+\tkey    u64  // TLS key identifier. Note: While Linux uses unsigned int, Darwin requires unsigned long. u64 accommodates both.\n+\tin_use bool // Allocation status flag\n+}\n+\n+// DataConversion convert voidptr to/from type T\n+union DataConversion {\n+mut:\n+\tf_u8  u8\n+\tf_u16 u16\n+\tf_u32 u32\n+\tf_u64 u64\n+\n+\tf_i8  i8\n+\tf_i16 i16\n+\tf_i32 i32\n+\tf_i64 i64\n+\n+\tf_voidptr voidptr\n+\tf_isize   isize\n+\tf_usize   usize\n+\tf_int     int\n+\tf_f32     f32\n+\tf_f64     f64\n+\tf_rune    rune\n+}\n+\n+// convert_t_to_voidptr convert value from type T to voidptr\n+@[inline]\n+fn convert_t_to_voidptr[T](value T) !voidptr {\n+\tmut f := DataConversion{}\n+\t$if T is i8 {\n+\t\tf.f_i8 = value\n+\t} $else $if T is i16 {\n+\t\tf.f_i16 = value\n+\t} $else $if T is i32 {\n+\t\tf.f_i32 = value\n+\t} $else $if T is i64 {\n+\t\tf.f_i64 = value\n+\t} $else $if T is u8 {\n+\t\tf.f_u8 = value\n+\t} $else $if T is u16 {\n+\t\tf.f_u16 = value\n+\t} $else $if T is u32 {\n+\t\tf.f_u32 = value\n+\t} $else $if T is u64 {\n+\t\tf.f_u64 = value\n+\t} $else $if T is $pointer {\n+\t\tf.f_voidptr = voidptr(value)\n+\t} $else $if T is isize {\n+\t\tf.f_isize = value\n+\t} $else $if T is usize {\n+\t\tf.f_usize = value\n+\t} $else $if T is int {\n+\t\tf.f_int = value\n+\t} $else $if T is f32 {\n+\t\tf.f_f32 = value\n+\t} $else $if T is f64 {\n+\t\tf.f_f64 = value\n+\t} $else $if T is rune {\n+\t\tf.f_rune = value\n+\t} $else {\n+\t\treturn error('Unsupport data type to voidptr')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2188127752",
        "repo_full_name": "vlang/v",
        "pr_number": 24849,
        "pr_file": "vlib/sync/tls.v",
        "discussion_id": "2188127752",
        "commented_code": "@@ -0,0 +1,111 @@\n+module sync\n+\n+// ThreadLocalStorage provides thread-local storage for values of type T\n+@[noinit]\n+struct ThreadLocalStorage[T] {\n+mut:\n+\tkey    u64  // TLS key identifier. Note: While Linux uses unsigned int, Darwin requires unsigned long. u64 accommodates both.\n+\tin_use bool // Allocation status flag\n+}\n+\n+// DataConversion convert voidptr to/from type T\n+union DataConversion {\n+mut:\n+\tf_u8  u8\n+\tf_u16 u16\n+\tf_u32 u32\n+\tf_u64 u64\n+\n+\tf_i8  i8\n+\tf_i16 i16\n+\tf_i32 i32\n+\tf_i64 i64\n+\n+\tf_voidptr voidptr\n+\tf_isize   isize\n+\tf_usize   usize\n+\tf_int     int\n+\tf_f32     f32\n+\tf_f64     f64\n+\tf_rune    rune\n+}\n+\n+// convert_t_to_voidptr convert value from type T to voidptr\n+@[inline]\n+fn convert_t_to_voidptr[T](value T) !voidptr {\n+\tmut f := DataConversion{}\n+\t$if T is i8 {\n+\t\tf.f_i8 = value\n+\t} $else $if T is i16 {\n+\t\tf.f_i16 = value\n+\t} $else $if T is i32 {\n+\t\tf.f_i32 = value\n+\t} $else $if T is i64 {\n+\t\tf.f_i64 = value\n+\t} $else $if T is u8 {\n+\t\tf.f_u8 = value\n+\t} $else $if T is u16 {\n+\t\tf.f_u16 = value\n+\t} $else $if T is u32 {\n+\t\tf.f_u32 = value\n+\t} $else $if T is u64 {\n+\t\tf.f_u64 = value\n+\t} $else $if T is $pointer {\n+\t\tf.f_voidptr = voidptr(value)\n+\t} $else $if T is isize {\n+\t\tf.f_isize = value\n+\t} $else $if T is usize {\n+\t\tf.f_usize = value\n+\t} $else $if T is int {\n+\t\tf.f_int = value\n+\t} $else $if T is f32 {\n+\t\tf.f_f32 = value\n+\t} $else $if T is f64 {\n+\t\tf.f_f64 = value\n+\t} $else $if T is rune {\n+\t\tf.f_rune = value\n+\t} $else {\n+\t\treturn error('Unsupport data type to voidptr')",
        "comment_created_at": "2025-07-06T09:20:17+00:00",
        "comment_author": "Delta456",
        "comment_body": "```suggestion\n\t\treturn error('Unsupported data type `${T}` to voidptr')\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957300068",
    "pr_number": 23737,
    "pr_file": "vlib/strconv/atoi.v",
    "created_at": "2025-02-16T11:09:29+00:00",
    "commented_code": null,
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1957300068",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957300068",
        "commented_code": null,
        "comment_created_at": "2025-02-16T11:09:29+00:00",
        "comment_author": "Delta456",
        "comment_body": "Can we have an explanation with each error message instead of the generic message `invalid syntax s`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1957310388",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957300068",
        "commented_code": null,
        "comment_created_at": "2025-02-16T12:07:34+00:00",
        "comment_author": "spytheman",
        "comment_body": "what would you want them to be?",
        "pr_file_module": null
      },
      {
        "comment_id": "1957311540",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957300068",
        "commented_code": null,
        "comment_created_at": "2025-02-16T12:14:09+00:00",
        "comment_author": "Delta456",
        "comment_body": "Like how we have different error messages when using `_` in the scanner stage.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957313621",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957300068",
        "commented_code": null,
        "comment_created_at": "2025-02-16T12:25:31+00:00",
        "comment_author": "JalonSolov",
        "comment_body": "For example:  When scanning for `_`, if it sees 2 in a row, it just says \"invalid syntax\" instead of something like \"cannot have 2 `_` in a row\" or \"2 `_` in a row is invalid syntax\".\r\n\r\nIf it subtracts `0` and finds something > 9, it just says \"invalid syntax\" instead of \"character ${s[i]} is not a valid digit\" or similar.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957352745",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957300068",
        "commented_code": null,
        "comment_created_at": "2025-02-16T15:30:23+00:00",
        "comment_author": "Bruno-Vdr",
        "comment_body": "I return now better error messages, but still simple. Feel free to make them clearer. This change may break code that rely on parsing theses messages (if any). ",
        "pr_file_module": null
      },
      {
        "comment_id": "1957353673",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957300068",
        "commented_code": null,
        "comment_created_at": "2025-02-16T15:34:54+00:00",
        "comment_author": "Delta456",
        "comment_body": "It is much better now!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957355007",
    "pr_number": 23737,
    "pr_file": "vlib/strconv/atoi.v",
    "created_at": "2025-02-16T15:41:11+00:00",
    "commented_code": "}\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n-\t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n-\t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n-\t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n-\t\t\t}\n+\t\treturn error('strconv.atoi: parsing \"\": empty string')\n+\t}\n+\n+\tmut start_idx := 0\n+\tmut sign := i64(1)\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n \t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n-\t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1957355007",
        "repo_full_name": "vlang/v",
        "pr_number": 23737,
        "pr_file": "vlib/strconv/atoi.v",
        "discussion_id": "1957355007",
        "commented_code": "@@ -218,34 +218,55 @@ pub fn parse_int(_s string, base int, _bit_size int) !i64 {\n }\n \n // atoi is equivalent to parse_int(s, 10, 0), converted to type int.\n+// It follows V scanner as much as observed.\n @[direct_array_access]\n pub fn atoi(s string) !int {\n \tif s == '' {\n-\t\treturn error('strconv.atoi: parsing \"\": invalid syntax')\n-\t}\n-\tif (int_size == 32 && (0 < s.len && s.len < 10))\n-\t\t|| (int_size == 64 && (0 < s.len && s.len < 19)) {\n-\t\t// Fast path for small integers that fit int type.\n-\t\tmut start_idx := 0\n-\t\tif s[0] == `-` || s[0] == `+` {\n-\t\t\tstart_idx++\n-\t\t\tif s.len - start_idx < 1 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n-\t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n-\t\t\t}\n+\t\treturn error('strconv.atoi: parsing \"\": empty string')\n+\t}\n+\n+\tmut start_idx := 0\n+\tmut sign := i64(1)\n+\n+\tif s[0] == `-` || s[0] == `+` {\n+\t\tstart_idx++\n+\t\tif s[0] == `-` {\n+\t\t\tsign = -1\n \t\t}\n-\t\tmut n := 0\n-\t\tfor i in start_idx .. s.len {\n-\t\t\tch := s[i] - `0`\n-\t\t\tif ch > 9 {\n-\t\t\t\t// return 0, &NumError{fnAtoi, s0, ErrSyntax}\n-\t\t\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s.len - start_idx < 1 {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')\n+\t}\n+\n+\tif s[start_idx] == `_` || s[s.len - 1] == `_` {\n+\t\treturn error('strconv.atoi: parsing \"${s}\": invalid syntax')",
        "comment_created_at": "2025-02-16T15:41:11+00:00",
        "comment_author": "JalonSolov",
        "comment_body": "```suggestion\r\n\t\treturn error('strconv.atoi: parsing \"${s}\": values cannot start or end with underscores')\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921065874",
    "pr_number": 23508,
    "pr_file": "vlib/v/checker/tests/match_generic_case_err.out",
    "created_at": "2025-01-18T13:36:12+00:00",
    "commented_code": "+vlib/v/checker/tests/match_generic_case_err.vv:16:4: error: return type mismatch, it should be `int`",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1921065874",
        "repo_full_name": "vlang/v",
        "pr_number": 23508,
        "pr_file": "vlib/v/checker/tests/match_generic_case_err.out",
        "discussion_id": "1921065874",
        "commented_code": "@@ -0,0 +1,7 @@\n+vlib/v/checker/tests/match_generic_case_err.vv:16:4: error: return type mismatch, it should be `int`",
        "comment_created_at": "2025-01-18T13:36:12+00:00",
        "comment_author": "spytheman",
        "comment_body": "That seems a bit unclear \ud83e\udd14 \r\nCan the error also show the type that the compiler thinks `v` is too?\r\nSomething like this can be less puzzling:\r\n```\r\nvlib/v/checker/tests/match_generic_case_err.vv:16:4: error: return type mismatch, it should be `int`, but it is instead `string`\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1921065953",
        "repo_full_name": "vlang/v",
        "pr_number": 23508,
        "pr_file": "vlib/v/checker/tests/match_generic_case_err.out",
        "discussion_id": "1921065874",
        "commented_code": "@@ -0,0 +1,7 @@\n+vlib/v/checker/tests/match_generic_case_err.vv:16:4: error: return type mismatch, it should be `int`",
        "comment_created_at": "2025-01-18T13:36:47+00:00",
        "comment_author": "spytheman",
        "comment_body": "(not in the same PR, but in general)",
        "pr_file_module": null
      },
      {
        "comment_id": "1921066072",
        "repo_full_name": "vlang/v",
        "pr_number": 23508,
        "pr_file": "vlib/v/checker/tests/match_generic_case_err.out",
        "discussion_id": "1921065874",
        "commented_code": "@@ -0,0 +1,7 @@\n+vlib/v/checker/tests/match_generic_case_err.vv:16:4: error: return type mismatch, it should be `int`",
        "comment_created_at": "2025-01-18T13:37:39+00:00",
        "comment_author": "spytheman",
        "comment_body": "especially for generic code, I think it will help a lot",
        "pr_file_module": null
      },
      {
        "comment_id": "1921092275",
        "repo_full_name": "vlang/v",
        "pr_number": 23508,
        "pr_file": "vlib/v/checker/tests/match_generic_case_err.out",
        "discussion_id": "1921065874",
        "commented_code": "@@ -0,0 +1,7 @@\n+vlib/v/checker/tests/match_generic_case_err.vv:16:4: error: return type mismatch, it should be `int`",
        "comment_created_at": "2025-01-18T15:30:21+00:00",
        "comment_author": "felipensp",
        "comment_body": "I do agree.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1804343405",
    "pr_number": 22545,
    "pr_file": "vlib/x/json2/decoder2/decode.v",
    "created_at": "2024-10-17T08:32:05+00:00",
    "commented_code": "string_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\n'\n+\tlast_new_line := json.last_index_u8(`\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1804343405",
        "repo_full_name": "vlang/v",
        "pr_number": 22545,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1804343405",
        "commented_code": "@@ -23,34 +34,466 @@ pub enum ValueKind {\n \tstring_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\\n'\n+\tlast_new_line := json.last_index_u8(`\\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')",
        "comment_created_at": "2024-10-17T08:32:05+00:00",
        "comment_author": "spytheman",
        "comment_body": "Nice. If you keep information about the position of the opening brace, it can be included too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1804389706",
        "repo_full_name": "vlang/v",
        "pr_number": 22545,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1804343405",
        "commented_code": "@@ -23,34 +34,466 @@ pub enum ValueKind {\n \tstring_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\\n'\n+\tlast_new_line := json.last_index_u8(`\\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')",
        "comment_created_at": "2024-10-17T09:01:52+00:00",
        "comment_author": "enghitalo",
        "comment_body": "Yes. Here is a message error for `'{\"key\": 123,'`, for example:\r\n```sh\r\n{\"key\": 123,\r\n           ^ EOF error: braces are not closed\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1804344703",
    "pr_number": 22545,
    "pr_file": "vlib/x/json2/decoder2/decode.v",
    "created_at": "2024-10-17T08:33:00+00:00",
    "commented_code": "string_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\n'\n+\tlast_new_line := json.last_index_u8(`\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `,` {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\t\t\t\t\treturn checker.error('Expecting object key')\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('invalid object value')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif checker.checker_idx < checker_end - 1 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\t\t}\n+\t\t.array {\n+\t\t\t// check if the JSON string is an empty array\n+\t\t\tif checker_end >= checker.checker_idx + 2 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\treturn checker.error('EOF error: There are not enough length for an array')\n+\t\t\t}\n+\n+\t\t\tfor val[checker.checker_idx] != `]` {\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\treturn checker.error('EOF error')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1804344703",
        "repo_full_name": "vlang/v",
        "pr_number": 22545,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1804344703",
        "commented_code": "@@ -23,34 +34,466 @@ pub enum ValueKind {\n \tstring_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\\n'\n+\tlast_new_line := json.last_index_u8(`\\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `,` {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\t\t\t\t\treturn checker.error('Expecting object key')\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('invalid object value')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif checker.checker_idx < checker_end - 1 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\t\t}\n+\t\t.array {\n+\t\t\t// check if the JSON string is an empty array\n+\t\t\tif checker_end >= checker.checker_idx + 2 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\treturn checker.error('EOF error: There are not enough length for an array')\n+\t\t\t}\n+\n+\t\t\tfor val[checker.checker_idx] != `]` {\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\treturn checker.error('EOF error')",
        "comment_created_at": "2024-10-17T08:33:00+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho provide information in the error, that `]` was expected too",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1804348772",
    "pr_number": 22545,
    "pr_file": "vlib/x/json2/decoder2/decode.v",
    "created_at": "2024-10-17T08:35:39+00:00",
    "commented_code": "string_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\n'\n+\tlast_new_line := json.last_index_u8(`\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `,` {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\t\t\t\t\treturn checker.error('Expecting object key')\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('invalid object value')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif checker.checker_idx < checker_end - 1 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\t\t}\n+\t\t.array {\n+\t\t\t// check if the JSON string is an empty array\n+\t\t\tif checker_end >= checker.checker_idx + 2 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\treturn checker.error('EOF error: There are not enough length for an array')\n+\t\t\t}\n+\n+\t\t\tfor val[checker.checker_idx] != `]` {\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t}\n+\n+\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t// whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\treturn checker.error('EOF error: braces are not closed')\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `,` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\n`] {\n+\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t}\n+\t\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\t\treturn checker.error('Cannot use `,`, before `]`')\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else {\n+\t\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn checker.error('`]` after value')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t.string_ {\n+\t\t\t// check if the JSON string is a valid string\n+\n+\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\treturn checker.error('EOF error: string not closed')\n+\t\t\t}\n+\n+\t\t\tchecker.checker_idx++\n+\n+\t\t\t// check if the JSON string is a valid escape sequence\n+\t\t\tfor val[checker.checker_idx] != `\"` && val[checker.checker_idx - 1] != `\\\\` {\n+\t\t\t\tif val[checker.checker_idx] == `\\\\` {\n+\t\t\t\t\tif checker.checker_idx + 1 >= checker_end - 1 {\n+\t\t\t\t\t\treturn checker.error('invalid escape sequence')\n+\t\t\t\t\t}\n+\t\t\t\t\tescaped_char := val[checker.checker_idx + 1]\n+\t\t\t\t\tmatch escaped_char {\n+\t\t\t\t\t\t`/`, `b`, `f`, `n`, `r`, `t`, `\"`, `\\\\` {}\n+\t\t\t\t\t\t`u` {\n+\t\t\t\t\t\t\t// check if the JSON string is a valid unicode escape sequence\n+\t\t\t\t\t\t\tescaped_char_last_index := checker.checker_idx + 5\n+\n+\t\t\t\t\t\t\tif escaped_char_last_index < checker_end - 1 {\n+\t\t\t\t\t\t\t\t// 2 bytes for the unicode escape sequence `\\u`\n+\t\t\t\t\t\t\t\tchecker.checker_idx += 2\n+\n+\t\t\t\t\t\t\t\tfor checker.checker_idx < escaped_char_last_index {\n+\t\t\t\t\t\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t\t\t\t\t\t`0`...`9`, `a`...`f`, `A`...`F` {\n+\t\t\t\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\t\t\treturn checker.error('invalid unicode escape sequence')\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t// REVIEW: Should we increment the index here?\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\treturn checker.error('short unicode escape sequence ${checker.json[checker.checker_idx..\n+\t\t\t\t\t\t\t\t\tescaped_char_last_index + 1]}')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\treturn checker.error('unknown escape sequence')\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\t\t}\n+\t\t.number {\n+\t\t\t// check if the JSON string is a valid float or integer\n+\t\t\tmut is_negative := val[0] == `-`\n+\t\t\tmut has_dot := false\n+\n+\t\t\tmut digits_count := 1\n+\n+\t\t\tif is_negative {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\n+\t\t\tfor checker.checker_idx < checker_end - 1\n+\t\t\t\t&& val[checker.checker_idx + 1] !in [`,`, `}`, `]`, ` `, `\\t`, `\n`]\n+\t\t\t\t&& checker.checker_idx < checker_end - 1 {\n+\t\t\t\tif val[checker.checker_idx] == `.` {\n+\t\t\t\t\tif has_dot {\n+\t\t\t\t\t\treturn checker.error('invalid float. Multiple dots')\n+\t\t\t\t\t}\n+\t\t\t\t\thas_dot = true\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else if val[checker.checker_idx] == `-` {\n+\t\t\t\t\tif is_negative {\n+\t\t\t\t\t\treturn checker.error('invalid float. Multiple negative signs')\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else {\n+\t\t\t\t\tif val[checker.checker_idx] < `0` || val[checker.checker_idx] > `9` {\n+\t\t\t\t\t\treturn checker.error('invalid number')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif digits_count >= 64 {\n+\t\t\t\t\treturn checker.error('number exceeds 64 digits')",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1804348772",
        "repo_full_name": "vlang/v",
        "pr_number": 22545,
        "pr_file": "vlib/x/json2/decoder2/decode.v",
        "discussion_id": "1804348772",
        "commented_code": "@@ -23,34 +34,466 @@ pub enum ValueKind {\n \tstring_\n \tnumber\n \tboolean\n+\tnull\n }\n \n // check_json checks if the JSON string is valid.\n-fn check_json(val string) ! {\n+fn check_if_json_match[T](val string) ! {\n+\t// check if the JSON string is empty\n \tif val == '' {\n \t\treturn error('empty string')\n \t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[0])\n+\n+\t$if T is $option {\n+\t\t// TODO\n+\t} $else $if T is $sumtype {\n+\t\t// TODO\n+\t} $else $if T is $alias {\n+\t\t// TODO\n+\t} $else $if T is $string {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is time.Time {\n+\t\tif value_kind != .string_ {\n+\t\t\treturn error('Expected string, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $map {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $array {\n+\t\tif value_kind != .array {\n+\t\t\treturn error('Expected array, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is $struct {\n+\t\tif value_kind != .object {\n+\t\t\treturn error('Expected object, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T in [$enum, $int, $float] {\n+\t\tif value_kind != .number {\n+\t\t\treturn error('Expected number, but got ${value_kind}')\n+\t\t}\n+\t} $else $if T is bool {\n+\t\tif value_kind != .boolean {\n+\t\t\treturn error('Expected boolean, but got ${value_kind}')\n+\t\t}\n+\t} $else {\n+\t\treturn error('cannot encode value with ${value_kind} type')\n+\t}\n+}\n+\n+fn (mut checker Decoder) error(message string) ! {\n+\tjson := if checker.json.len < checker.checker_idx + 5 {\n+\t\tchecker.json\n+\t} else {\n+\t\tchecker.json[0..checker.checker_idx + 5]\n+\t}\n+\n+\tmut error_message := '\\n'\n+\tlast_new_line := json.last_index_u8(`\\n`)\n+\tif last_new_line != -1 {\n+\t\terror_message += json[last_new_line..checker.checker_idx]\n+\t} else {\n+\t\terror_message += json[0..checker.checker_idx]\n+\t}\n+\terror_message += [json[checker.checker_idx]].bytestr()\n+\n+\terror_message += '\\n'\n+\n+\tif last_new_line != -1 {\n+\t\terror_message += ' '.repeat(checker.checker_idx - last_new_line)\n+\t} else {\n+\t\terror_message += ' '.repeat(checker.checker_idx)\n+\t}\n+\n+\terror_message += '^ ${message}'\n+\n+\treturn error(error_message)\n+}\n+\n+// check_json checks if the JSON string is valid.\n+fn (mut checker Decoder) check_json_format(val string) ! {\n+\tchecker_end := checker.json.len\n+\t// check if the JSON string is empty\n+\tif val == '' {\n+\t\treturn checker.error('empty string')\n+\t}\n+\n+\t// check if generic type matches the JSON type\n+\tvalue_kind := get_value_kind(val[checker.checker_idx])\n+\tstart_idx_position := checker.checker_idx\n+\tchecker.values_info << ValueInfo{\n+\t\tposition:   start_idx_position\n+\t\tlength:     0\n+\t\tvalue_kind: value_kind\n+\t}\n+\n+\tvalue_info_index := checker.values_info.len - 1\n+\tmatch value_kind {\n+\t\t.unknown {\n+\t\t\treturn checker.error('unknown value kind')\n+\t\t}\n+\t\t.null {\n+\t\t\t// check if the JSON string is a null value\n+\t\t\tif checker_end - checker.checker_idx <= 3 {\n+\t\t\t\treturn checker.error('EOF error')\n+\t\t\t}\n+\n+\t\t\tis_not_ok := unsafe {\n+\t\t\t\tvmemcmp(checker.json.str + checker.checker_idx, 'null'.str, 4)\n+\t\t\t}\n+\n+\t\t\tif is_not_ok != 0 {\n+\t\t\t\treturn checker.error('invalid null value. Got `${checker.json[checker.checker_idx..\n+\t\t\t\t\tchecker.checker_idx + 4]}` instead of `null`')\n+\t\t\t}\n+\t\t\tchecker.checker_idx += 3\n+\t\t}\n+\t\t.object {\n+\t\t\tchecker.checker_idx++\n+\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t// check if the JSON string is an empty object\n+\t\t\t\tif checker_end - checker.checker_idx <= 2 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"` {\n+\t\t\t\t\t\t// Object key\n+\t\t\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `:` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] !in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\treturn checker.error('invalid value after object key')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t`[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\t// skip\n+\t\t\t\t\t}\n+\t\t\t\t\t`}` {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t`]` {\n+\t\t\t\t\t\treturn checker.error('Expecting key. Found closing bracket')\n+\t\t\t\t\t}\n+\t\t\t\t\t`,` {\n+\t\t\t\t\t\treturn checker.error('invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t\t`:` {\n+\t\t\t\t\t\treturn checker.error('empty object key')\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('`${[val[checker.checker_idx]].bytestr()}` is an invalid object key')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] != `:` {\n+\t\t\t\t\treturn checker.error('Expecting `:` after object key')\n+\t\t\t\t}\n+\t\t\t\t// skip `:`\n+\t\t\t\tchecker.checker_idx++\n+\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t`\"`, `[`, `{`, `0`...`9`, `-`, `n`, `t`, `f` {\n+\t\t\t\t\t\tfor val[checker.checker_idx] != `}` {\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tchecker.check_json_format(val)!\n+\t\t\t\t\t\t\t// whitespace\n+\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\t\t\treturn checker.error('EOF error: braces are not closed')\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif val[checker.checker_idx] == `,` {\n+\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] != `\"` {\n+\t\t\t\t\t\t\t\t\treturn checker.error('Expecting object key')\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tif val[checker.checker_idx] == `}` {\n+\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn checker.error('invalid object value')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif checker.checker_idx < checker_end - 1 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\t\t}\n+\t\t.array {\n+\t\t\t// check if the JSON string is an empty array\n+\t\t\tif checker_end >= checker.checker_idx + 2 {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\treturn checker.error('EOF error: There are not enough length for an array')\n+\t\t\t}\n+\n+\t\t\tfor val[checker.checker_idx] != `]` {\n+\t\t\t\t// skip whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\treturn checker.error('EOF error')\n+\t\t\t\t}\n+\n+\t\t\t\tchecker.check_json_format(val)!\n+\n+\t\t\t\t// whitespace\n+\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t}\n+\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\t\treturn checker.error('EOF error: braces are not closed')\n+\t\t\t\t}\n+\n+\t\t\t\tif val[checker.checker_idx] == `,` {\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\tfor val[checker.checker_idx] in [` `, `\\t`, `\\n`] {\n+\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t}\n+\t\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\t\treturn checker.error('Cannot use `,`, before `]`')\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else {\n+\t\t\t\t\tif val[checker.checker_idx] == `]` {\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn checker.error('`]` after value')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t.string_ {\n+\t\t\t// check if the JSON string is a valid string\n+\n+\t\t\tif checker.checker_idx >= checker_end - 1 {\n+\t\t\t\treturn checker.error('EOF error: string not closed')\n+\t\t\t}\n+\n+\t\t\tchecker.checker_idx++\n+\n+\t\t\t// check if the JSON string is a valid escape sequence\n+\t\t\tfor val[checker.checker_idx] != `\"` && val[checker.checker_idx - 1] != `\\\\` {\n+\t\t\t\tif val[checker.checker_idx] == `\\\\` {\n+\t\t\t\t\tif checker.checker_idx + 1 >= checker_end - 1 {\n+\t\t\t\t\t\treturn checker.error('invalid escape sequence')\n+\t\t\t\t\t}\n+\t\t\t\t\tescaped_char := val[checker.checker_idx + 1]\n+\t\t\t\t\tmatch escaped_char {\n+\t\t\t\t\t\t`/`, `b`, `f`, `n`, `r`, `t`, `\"`, `\\\\` {}\n+\t\t\t\t\t\t`u` {\n+\t\t\t\t\t\t\t// check if the JSON string is a valid unicode escape sequence\n+\t\t\t\t\t\t\tescaped_char_last_index := checker.checker_idx + 5\n+\n+\t\t\t\t\t\t\tif escaped_char_last_index < checker_end - 1 {\n+\t\t\t\t\t\t\t\t// 2 bytes for the unicode escape sequence `\\u`\n+\t\t\t\t\t\t\t\tchecker.checker_idx += 2\n+\n+\t\t\t\t\t\t\t\tfor checker.checker_idx < escaped_char_last_index {\n+\t\t\t\t\t\t\t\t\tmatch val[checker.checker_idx] {\n+\t\t\t\t\t\t\t\t\t\t`0`...`9`, `a`...`f`, `A`...`F` {\n+\t\t\t\t\t\t\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\t\t\treturn checker.error('invalid unicode escape sequence')\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t// REVIEW: Should we increment the index here?\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\treturn checker.error('short unicode escape sequence ${checker.json[checker.checker_idx..\n+\t\t\t\t\t\t\t\t\tescaped_char_last_index + 1]}')\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\treturn checker.error('unknown escape sequence')\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\t\t}\n+\t\t.number {\n+\t\t\t// check if the JSON string is a valid float or integer\n+\t\t\tmut is_negative := val[0] == `-`\n+\t\t\tmut has_dot := false\n+\n+\t\t\tmut digits_count := 1\n+\n+\t\t\tif is_negative {\n+\t\t\t\tchecker.checker_idx++\n+\t\t\t}\n+\n+\t\t\tfor checker.checker_idx < checker_end - 1\n+\t\t\t\t&& val[checker.checker_idx + 1] !in [`,`, `}`, `]`, ` `, `\\t`, `\\n`]\n+\t\t\t\t&& checker.checker_idx < checker_end - 1 {\n+\t\t\t\tif val[checker.checker_idx] == `.` {\n+\t\t\t\t\tif has_dot {\n+\t\t\t\t\t\treturn checker.error('invalid float. Multiple dots')\n+\t\t\t\t\t}\n+\t\t\t\t\thas_dot = true\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else if val[checker.checker_idx] == `-` {\n+\t\t\t\t\tif is_negative {\n+\t\t\t\t\t\treturn checker.error('invalid float. Multiple negative signs')\n+\t\t\t\t\t}\n+\t\t\t\t\tchecker.checker_idx++\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else {\n+\t\t\t\t\tif val[checker.checker_idx] < `0` || val[checker.checker_idx] > `9` {\n+\t\t\t\t\t\treturn checker.error('invalid number')\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif digits_count >= 64 {\n+\t\t\t\t\treturn checker.error('number exceeds 64 digits')",
        "comment_created_at": "2024-10-17T08:35:39+00:00",
        "comment_author": "spytheman",
        "comment_body": "adding the actual number, that was checked so far, in the error message, would be informative",
        "pr_file_module": null
      }
    ]
  }
]