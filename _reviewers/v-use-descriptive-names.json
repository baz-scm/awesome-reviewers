[
  {
    "discussion_id": "2210477131",
    "pr_number": 24913,
    "pr_file": "vlib/runtime/used_memory_default.c.v",
    "created_at": "2025-07-16T13:40:07+00:00",
    "commented_code": "module runtime\n \n // used_memory retrieves the current physical memory usage of the process.\n+// Note: implementation available only on Darwin, Linux and Windows. Otherwise,",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2210477131",
        "repo_full_name": "vlang/v",
        "pr_number": 24913,
        "pr_file": "vlib/runtime/used_memory_default.c.v",
        "discussion_id": "2210477131",
        "commented_code": "@@ -1,6 +1,8 @@\n module runtime\n \n // used_memory retrieves the current physical memory usage of the process.\n+// Note: implementation available only on Darwin, Linux and Windows. Otherwise,",
        "comment_created_at": "2025-07-16T13:40:07+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n// Note: implementation available only on macOS, Linux and Windows. Otherwise,\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2210480268",
        "repo_full_name": "vlang/v",
        "pr_number": 24913,
        "pr_file": "vlib/runtime/used_memory_default.c.v",
        "discussion_id": "2210477131",
        "commented_code": "@@ -1,6 +1,8 @@\n module runtime\n \n // used_memory retrieves the current physical memory usage of the process.\n+// Note: implementation available only on Darwin, Linux and Windows. Otherwise,",
        "comment_created_at": "2025-07-16T13:41:10+00:00",
        "comment_author": "spytheman",
        "comment_body": "The name of the exact kernel is only slightly related; the popular name for the OS/platform is more important for the callers imho.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173150287",
    "pr_number": 24805,
    "pr_file": "vlib/v/scanner/scanner.v",
    "created_at": "2025-06-28T06:55:26+00:00",
    "commented_code": "is_inter_end                bool\n \tis_enclosed_inter           bool\n \tis_nested_enclosed_inter    bool\n+\tstring_count                int\n+\tis_str_dollor_need_rcbr     []bool = []",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2173150287",
        "repo_full_name": "vlang/v",
        "pr_number": 24805,
        "pr_file": "vlib/v/scanner/scanner.v",
        "discussion_id": "2173150287",
        "commented_code": "@@ -35,6 +35,8 @@ pub mut:\n \tis_inter_end                bool\n \tis_enclosed_inter           bool\n \tis_nested_enclosed_inter    bool\n+\tstring_count                int\n+\tis_str_dollor_need_rcbr     []bool = []",
        "comment_created_at": "2025-06-28T06:55:26+00:00",
        "comment_author": "spytheman",
        "comment_body": "```suggestion\r\n\tstr_dollar_needs_rcbr     []bool = []\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2173150638",
        "repo_full_name": "vlang/v",
        "pr_number": 24805,
        "pr_file": "vlib/v/scanner/scanner.v",
        "discussion_id": "2173150287",
        "commented_code": "@@ -35,6 +35,8 @@ pub mut:\n \tis_inter_end                bool\n \tis_enclosed_inter           bool\n \tis_nested_enclosed_inter    bool\n+\tstring_count                int\n+\tis_str_dollor_need_rcbr     []bool = []",
        "comment_created_at": "2025-06-28T06:56:49+00:00",
        "comment_author": "spytheman",
        "comment_body": "`is_` is usually used as a prefix for bools, not stacks of them, in the V codebase, and the expectation is that you can `if x.is_something {` later",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2069108700",
    "pr_number": 24369,
    "pr_file": "cmd/tools/vreduce.v",
    "created_at": "2025-04-30T16:57:24+00:00",
    "commented_code": "}\n \n // Return true if the command ran on the file produces the pattern\n-fn string_reproduces(file string, pattern string, command string, path string, debug bool, timeout int) bool {\n+fn string_reproduces(file_content string, pattern string, command string, dir string, debug bool, timeout int) bool {\n \tif !os.exists(tmp_folder) {\n \t\tos.mkdir(tmp_folder) or { panic(err) }\n \t}\n-\tos.write_file(path, file) or { panic(err) }\n+\tos.write_file(dir, file_content) or { panic(err) }",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2069108700",
        "repo_full_name": "vlang/v",
        "pr_number": 24369,
        "pr_file": "cmd/tools/vreduce.v",
        "discussion_id": "2069108700",
        "commented_code": "@@ -94,11 +94,11 @@ fn main() {\n }\n \n // Return true if the command ran on the file produces the pattern\n-fn string_reproduces(file string, pattern string, command string, path string, debug bool, timeout int) bool {\n+fn string_reproduces(file_content string, pattern string, command string, dir string, debug bool, timeout int) bool {\n \tif !os.exists(tmp_folder) {\n \t\tos.mkdir(tmp_folder) or { panic(err) }\n \t}\n-\tos.write_file(path, file) or { panic(err) }\n+\tos.write_file(dir, file_content) or { panic(err) }",
        "comment_created_at": "2025-04-30T16:57:24+00:00",
        "comment_author": "spytheman",
        "comment_body": "Renaming `file` to `file_content` is good, but `path` to `dir`, given the usage is not, since write_file expects a path or file name, not a dir in its first argument.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2067098464",
    "pr_number": 24359,
    "pr_file": "cmd/tools/vreduce.v",
    "created_at": "2025-04-29T18:17:56+00:00",
    "commented_code": "log.info(\"Starting to reduce the file: '${file_path}'\n    with command: `${command}`,\n    trying to reproduce: `${error_msg}`\")\n \n \tif do_fmt {\n-\t\tlog.info('Will do `v fmt -w rpdc.v` after the reduction.')\n+\t\tlog.info('Will do `v fmt -w rpdc_file_name.v` after the reduction.')\n \t} else {\n-\t\tlog.info('Will NOT do `v fmt -w rpdc.v` (use the `--fmt` or `-w` flag to enable it)')\n+\t\tlog.info('Will NOT do `v fmt -w rpdc_file_name.v` (use the `--fmt` or `-w` flag to enable it)')\n \t}\n \n \tcontent := os.read_file(file_path)!\n-\twarn_on_false(string_reproduces(content, error_msg, command), 'string_reproduces',\n-\t\t@LOCATION)\n \tshow_code_stats(content, label: 'Original code size')\n \n+\t// copy project\t\n+\tif os.exists(tmp_folder) {\n+\t\tos.rmdir_all(tmp_folder)!\n+\t}\n+\tos.mkdir(tmp_folder)!\n+\tif copy_project {\n+\t\tmut vmod_cacher := vmod.new_mod_file_cacher()\n+\t\tproject_folder := vmod_cacher.get_by_file(file_path).vmod_folder\n+\t\tos.cp_all('${project_folder}/.', tmp_folder + '/', true)!\n+\t\t// the path of the target file from the project folder\n+\t\tfile_path = os.walk_ext(project_folder, os.file_name(file_path))[0] or {\n+\t\t\tpanic('File not found in the project folder')\n+\t\t}\n+\t\tfile_path = file_path[project_folder.len + 1..] // will remove the / too\n+\t}\n+\tpath := '${tmp_folder}/${file_path}'\n+\tif command == default_command {\n+\t\tcommand = '${default_command} ${path}'\n+\t} else {\n+\t\tcommand = command.replace('PATH', '${tmp_folder}/')\n+\t}\n+\n \t// start tests\n \ttmp_code := create_code(parse(content))\n-\twarn_on_false(string_reproduces(tmp_code, error_msg, command), 'string_reproduces',\n-\t\t@LOCATION)\n+\twarn_on_false(string_reproduces(tmp_code, error_msg, command, path, true, timeout),\n+\t\t'string_reproduces', @LOCATION)\n \tshow_code_stats(tmp_code, label: 'Code size without comments')\n \n \t// reduce the code\n-\treduce_scope(content, error_msg, command, do_fmt)\n+\treduce_scope(content, error_msg, command, do_fmt, path, timeout)\n+\n+\t// cleanse\n+\tif os.exists(tmp_folder) {\n+\t\tos.rmdir_all(tmp_folder)!\n+\t}\n }\n \n // Return true if the command ran on the file produces the pattern\n-fn string_reproduces(file string, pattern string, command string) bool {\n+fn string_reproduces(file string, pattern string, command string, path string, debug bool, timeout int) bool {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2067098464",
        "repo_full_name": "vlang/v",
        "pr_number": 24359,
        "pr_file": "cmd/tools/vreduce.v",
        "discussion_id": "2067098464",
        "commented_code": "@@ -46,39 +48,107 @@ fn main() {\n \tlog.info(\"Starting to reduce the file: '${file_path}'\\n    with command: `${command}`,\\n    trying to reproduce: `${error_msg}`\")\n \n \tif do_fmt {\n-\t\tlog.info('Will do `v fmt -w rpdc.v` after the reduction.')\n+\t\tlog.info('Will do `v fmt -w rpdc_file_name.v` after the reduction.')\n \t} else {\n-\t\tlog.info('Will NOT do `v fmt -w rpdc.v` (use the `--fmt` or `-w` flag to enable it)')\n+\t\tlog.info('Will NOT do `v fmt -w rpdc_file_name.v` (use the `--fmt` or `-w` flag to enable it)')\n \t}\n \n \tcontent := os.read_file(file_path)!\n-\twarn_on_false(string_reproduces(content, error_msg, command), 'string_reproduces',\n-\t\t@LOCATION)\n \tshow_code_stats(content, label: 'Original code size')\n \n+\t// copy project\t\n+\tif os.exists(tmp_folder) {\n+\t\tos.rmdir_all(tmp_folder)!\n+\t}\n+\tos.mkdir(tmp_folder)!\n+\tif copy_project {\n+\t\tmut vmod_cacher := vmod.new_mod_file_cacher()\n+\t\tproject_folder := vmod_cacher.get_by_file(file_path).vmod_folder\n+\t\tos.cp_all('${project_folder}/.', tmp_folder + '/', true)!\n+\t\t// the path of the target file from the project folder\n+\t\tfile_path = os.walk_ext(project_folder, os.file_name(file_path))[0] or {\n+\t\t\tpanic('File not found in the project folder')\n+\t\t}\n+\t\tfile_path = file_path[project_folder.len + 1..] // will remove the / too\n+\t}\n+\tpath := '${tmp_folder}/${file_path}'\n+\tif command == default_command {\n+\t\tcommand = '${default_command} ${path}'\n+\t} else {\n+\t\tcommand = command.replace('PATH', '${tmp_folder}/')\n+\t}\n+\n \t// start tests\n \ttmp_code := create_code(parse(content))\n-\twarn_on_false(string_reproduces(tmp_code, error_msg, command), 'string_reproduces',\n-\t\t@LOCATION)\n+\twarn_on_false(string_reproduces(tmp_code, error_msg, command, path, true, timeout),\n+\t\t'string_reproduces', @LOCATION)\n \tshow_code_stats(tmp_code, label: 'Code size without comments')\n \n \t// reduce the code\n-\treduce_scope(content, error_msg, command, do_fmt)\n+\treduce_scope(content, error_msg, command, do_fmt, path, timeout)\n+\n+\t// cleanse\n+\tif os.exists(tmp_folder) {\n+\t\tos.rmdir_all(tmp_folder)!\n+\t}\n }\n \n // Return true if the command ran on the file produces the pattern\n-fn string_reproduces(file string, pattern string, command string) bool {\n+fn string_reproduces(file string, pattern string, command string, path string, debug bool, timeout int) bool {",
        "comment_created_at": "2025-04-29T18:17:56+00:00",
        "comment_author": "spytheman",
        "comment_body": "In general, it is better to have different names than a pair of `file`/`path` used as parameters, since that can be a bit confusing, because both can mean the same or not, depending on the context.\r\n\r\nI suggest using `folder` or `dir` here, instead of `path` or use `filename` instead of `file`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076879675",
    "pr_number": 24428,
    "pr_file": "vlib/arrays/diff/diff.v",
    "created_at": "2025-05-07T06:24:34+00:00",
    "commented_code": "+module diff\n+\n+import strings\n+\n+// A Change contains one or more deletions or inserts\n+// at one position in two arrays.\n+pub struct DiffChange {\n+pub mut:\n+\ta   int // position in input a []T\n+\tb   int // position in input b []T\n+\tdel int // delete Del elements from input a\n+\tins int // insert Ins elements from input b\n+}\n+\n+pub struct DiffContext[T] {\n+mut:\n+\ta     []T\n+\tb     []T\n+\tflags []u8 // element bits 1 delete, 2 insert\n+\tmax   int\n+\t// forward and reverse d-path endpoint x components\n+\tforward []int\n+\treverse []int\n+pub mut:\n+\tchanges []DiffChange\n+}\n+\n+// diff returns the difference of two arrays.\n+pub fn diff[T](a []T, b []T) &DiffContext[T] {\n+\tmut c := &DiffContext[T]{\n+\t\ta: a\n+\t\tb: b\n+\t}\n+\tc.flags = if a.len > b.len { []u8{len: a.len} } else { []u8{len: b.len} }\n+\tc.max = a.len + b.len + 1\n+\tc.forward = []int{len: 2 * c.max}\n+\tc.reverse = []int{len: 2 * c.max}\n+\tc.compare(0, 0, a.len, b.len)\n+\tc.changes = c.result(a.len, b.len)\n+\treturn c\n+}\n+\n+// A directly conversion from https://github.com/covrom/diff\n+// Fast diff library for Myers algorithm.\n+// The algorithm is described in \"An O(ND) Difference Algorithm and its Variations\", Eugene Myers, Algorithmica Vol. 1 No. 2, 1986, pp. 251-266\n+@[direct_array_access]\n+fn (mut c DiffContext[T]) compare(mut_aoffset int, mut_boffset int, mut_alimit int, mut_blimit int) {\n+\tmut aoffset := mut_aoffset\n+\tmut boffset := mut_boffset\n+\tmut alimit := mut_alimit\n+\tmut blimit := mut_blimit\n+\t// eat common prefix\n+\tfor aoffset < alimit && boffset < blimit && c.a[aoffset] == c.b[boffset] {\n+\t\taoffset++\n+\t\tboffset++\n+\t}\n+\t// eat common suffix\n+\tfor alimit > aoffset && blimit > boffset && c.a[alimit - 1] == c.b[blimit - 1] {\n+\t\talimit--\n+\t\tblimit--\n+\t}\n+\t// both equal or b inserts\n+\tif aoffset == alimit {\n+\t\tfor boffset < blimit {\n+\t\t\tc.flags[boffset] |= u8(2)\n+\t\t\tboffset++\n+\t\t}\n+\t\treturn\n+\t}\n+\t// a deletes\n+\tif boffset == blimit {\n+\t\tfor aoffset < alimit {\n+\t\t\tc.flags[aoffset] |= u8(1)\n+\t\t\taoffset++\n+\t\t}\n+\t\treturn\n+\t}\n+\tx, y := c.find_middle_snake(aoffset, boffset, alimit, blimit)\n+\tc.compare(aoffset, boffset, x, y)\n+\tc.compare(x, y, alimit, blimit)\n+}\n+\n+@[direct_array_access]\n+fn (mut c DiffContext[T]) find_middle_snake(aoffset int, boffset int, alimit int, blimit int) (int, int) {\n+\t// midpoints\n+\tfmid := aoffset - boffset\n+\trmid := alimit - blimit\n+\t// correct offset in d-path slices\n+\tfoff := c.max - fmid\n+\troff := c.max - rmid\n+\tisodd := (rmid - fmid) & 1 != 0\n+\tmaxd := (alimit - aoffset + blimit - boffset + 2) / 2\n+\tc.forward[c.max + 1] = aoffset\n+\tc.reverse[c.max - 1] = alimit\n+\tmut x, mut y := 0, 0\n+\tfor d := 0; d <= maxd; d++ {\n+\t\t// forward search\n+\t\tfor k := fmid - d; k <= fmid + d; k += 2 {\n+\t\t\tif k == fmid - d || (k != fmid + d && c.forward[foff + k + 1] > c.forward[foff + k - 1]) {\n+\t\t\t\tx = c.forward[foff + k + 1] // down\n+\t\t\t} else {\n+\t\t\t\tx = c.forward[foff + k - 1] + 1 // right\n+\t\t\t}\n+\t\t\ty = x - k\n+\t\t\tfor x < alimit && y < blimit && c.a[x] == c.b[y] {\n+\t\t\t\tx++\n+\t\t\t\ty++\n+\t\t\t}\n+\t\t\tc.forward[foff + k] = x\n+\t\t\tif isodd && k > rmid - d && k < rmid + d {\n+\t\t\t\tif c.reverse[roff + k] <= c.forward[foff + k] {\n+\t\t\t\t\treturn x, x - k\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// reverse search x,y correspond to u,v\n+\t\tfor k := rmid - d; k <= rmid + d; k += 2 {\n+\t\t\tif k == rmid + d || (k != rmid - d && c.reverse[roff + k - 1] < c.reverse[roff + k + 1]) {\n+\t\t\t\tx = c.reverse[roff + k - 1] // up\n+\t\t\t} else {\n+\t\t\t\tx = c.reverse[roff + k + 1] - 1 // left\n+\t\t\t}\n+\t\t\ty = x - k\n+\t\t\tfor x > aoffset && y > boffset && c.a[x - 1] == c.b[y - 1] {\n+\t\t\t\tx--\n+\t\t\t\ty--\n+\t\t\t}\n+\t\t\tc.reverse[roff + k] = x\n+\t\t\tif !isodd && k >= fmid - d && k <= fmid + d {\n+\t\t\t\tif c.reverse[roff + k] <= c.forward[foff + k] {\n+\t\t\t\t\t// lookup opposite end\n+\t\t\t\t\tx = c.forward[foff + k]\n+\t\t\t\t\treturn x, x - k\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpanic('diff.find_middle_snake: should never be reached')\n+}\n+\n+@[direct_array_access]\n+fn (c DiffContext[T]) result(n int, m int) []DiffChange {\n+\tmut x, mut y := 0, 0\n+\tmut res := []DiffChange{}\n+\tfor x < n || y < m {\n+\t\tif x < n && y < m && c.flags[x] & u8(1) == u8(0) && c.flags[y] & u8(2) == u8(0) {\n+\t\t\tx++\n+\t\t\ty++\n+\t\t} else {\n+\t\t\tmut a := x\n+\t\t\tmut b := y\n+\t\t\tfor x < n && (y >= m || c.flags[x] & u8(1) != u8(0)) {\n+\t\t\t\tx++\n+\t\t\t}\n+\t\t\tfor y < m && (x >= n || c.flags[y] & u8(2) != u8(0)) {\n+\t\t\t\ty++\n+\t\t\t}\n+\t\t\tif a < x || b < y {\n+\t\t\t\tres << DiffChange{a, b, x - a, y - b}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn res\n+}\n+\n+// merge_changes merges neighboring changes smaller than the specified context_lines.\n+// The changes must be ordered by ascending positions.\n+@[direct_array_access]\n+fn (mut c DiffContext[T]) merge_changes(context_lines int) {\n+\tif c.changes.len == 0 {\n+\t\treturn\n+\t}\n+\n+\tmut merged := []DiffChange{}\n+\tmut current := c.changes[0]\n+\n+\tfor i in 1 .. c.changes.len {\n+\t\tnext := c.changes[i]\n+\t\tif next.a <= current.a + current.del + context_lines {\n+\t\t\tcurrent = DiffChange{\n+\t\t\t\ta:   current.a\n+\t\t\t\tb:   current.b\n+\t\t\t\tdel: next.a + next.del - current.a\n+\t\t\t\tins: next.b + next.ins - current.b\n+\t\t\t}\n+\t\t} else {\n+\t\t\tmerged << current\n+\t\t\tcurrent = next\n+\t\t}\n+\t}\n+\tmerged << current\n+\tc.changes = merged\n+}\n+\n+@[params]\n+pub struct DiffGenStrParam {\n+pub mut:\n+\tcolorful     bool\n+\tunified      int = 3 // how many context lines before/after diff block\n+\tblock_header bool // output `@@ -3,4 +3,5 @@` or not\n+}\n+\n+// gen_str generate a colorful diff string of two arrays.\n+@[direct_array_access]\n+pub fn (mut c DiffContext[T]) gen_str(param DiffGenStrParam) string {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "2076879675",
        "repo_full_name": "vlang/v",
        "pr_number": 24428,
        "pr_file": "vlib/arrays/diff/diff.v",
        "discussion_id": "2076879675",
        "commented_code": "@@ -0,0 +1,296 @@\n+module diff\n+\n+import strings\n+\n+// A Change contains one or more deletions or inserts\n+// at one position in two arrays.\n+pub struct DiffChange {\n+pub mut:\n+\ta   int // position in input a []T\n+\tb   int // position in input b []T\n+\tdel int // delete Del elements from input a\n+\tins int // insert Ins elements from input b\n+}\n+\n+pub struct DiffContext[T] {\n+mut:\n+\ta     []T\n+\tb     []T\n+\tflags []u8 // element bits 1 delete, 2 insert\n+\tmax   int\n+\t// forward and reverse d-path endpoint x components\n+\tforward []int\n+\treverse []int\n+pub mut:\n+\tchanges []DiffChange\n+}\n+\n+// diff returns the difference of two arrays.\n+pub fn diff[T](a []T, b []T) &DiffContext[T] {\n+\tmut c := &DiffContext[T]{\n+\t\ta: a\n+\t\tb: b\n+\t}\n+\tc.flags = if a.len > b.len { []u8{len: a.len} } else { []u8{len: b.len} }\n+\tc.max = a.len + b.len + 1\n+\tc.forward = []int{len: 2 * c.max}\n+\tc.reverse = []int{len: 2 * c.max}\n+\tc.compare(0, 0, a.len, b.len)\n+\tc.changes = c.result(a.len, b.len)\n+\treturn c\n+}\n+\n+// A directly conversion from https://github.com/covrom/diff\n+// Fast diff library for Myers algorithm.\n+// The algorithm is described in \"An O(ND) Difference Algorithm and its Variations\", Eugene Myers, Algorithmica Vol. 1 No. 2, 1986, pp. 251-266\n+@[direct_array_access]\n+fn (mut c DiffContext[T]) compare(mut_aoffset int, mut_boffset int, mut_alimit int, mut_blimit int) {\n+\tmut aoffset := mut_aoffset\n+\tmut boffset := mut_boffset\n+\tmut alimit := mut_alimit\n+\tmut blimit := mut_blimit\n+\t// eat common prefix\n+\tfor aoffset < alimit && boffset < blimit && c.a[aoffset] == c.b[boffset] {\n+\t\taoffset++\n+\t\tboffset++\n+\t}\n+\t// eat common suffix\n+\tfor alimit > aoffset && blimit > boffset && c.a[alimit - 1] == c.b[blimit - 1] {\n+\t\talimit--\n+\t\tblimit--\n+\t}\n+\t// both equal or b inserts\n+\tif aoffset == alimit {\n+\t\tfor boffset < blimit {\n+\t\t\tc.flags[boffset] |= u8(2)\n+\t\t\tboffset++\n+\t\t}\n+\t\treturn\n+\t}\n+\t// a deletes\n+\tif boffset == blimit {\n+\t\tfor aoffset < alimit {\n+\t\t\tc.flags[aoffset] |= u8(1)\n+\t\t\taoffset++\n+\t\t}\n+\t\treturn\n+\t}\n+\tx, y := c.find_middle_snake(aoffset, boffset, alimit, blimit)\n+\tc.compare(aoffset, boffset, x, y)\n+\tc.compare(x, y, alimit, blimit)\n+}\n+\n+@[direct_array_access]\n+fn (mut c DiffContext[T]) find_middle_snake(aoffset int, boffset int, alimit int, blimit int) (int, int) {\n+\t// midpoints\n+\tfmid := aoffset - boffset\n+\trmid := alimit - blimit\n+\t// correct offset in d-path slices\n+\tfoff := c.max - fmid\n+\troff := c.max - rmid\n+\tisodd := (rmid - fmid) & 1 != 0\n+\tmaxd := (alimit - aoffset + blimit - boffset + 2) / 2\n+\tc.forward[c.max + 1] = aoffset\n+\tc.reverse[c.max - 1] = alimit\n+\tmut x, mut y := 0, 0\n+\tfor d := 0; d <= maxd; d++ {\n+\t\t// forward search\n+\t\tfor k := fmid - d; k <= fmid + d; k += 2 {\n+\t\t\tif k == fmid - d || (k != fmid + d && c.forward[foff + k + 1] > c.forward[foff + k - 1]) {\n+\t\t\t\tx = c.forward[foff + k + 1] // down\n+\t\t\t} else {\n+\t\t\t\tx = c.forward[foff + k - 1] + 1 // right\n+\t\t\t}\n+\t\t\ty = x - k\n+\t\t\tfor x < alimit && y < blimit && c.a[x] == c.b[y] {\n+\t\t\t\tx++\n+\t\t\t\ty++\n+\t\t\t}\n+\t\t\tc.forward[foff + k] = x\n+\t\t\tif isodd && k > rmid - d && k < rmid + d {\n+\t\t\t\tif c.reverse[roff + k] <= c.forward[foff + k] {\n+\t\t\t\t\treturn x, x - k\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// reverse search x,y correspond to u,v\n+\t\tfor k := rmid - d; k <= rmid + d; k += 2 {\n+\t\t\tif k == rmid + d || (k != rmid - d && c.reverse[roff + k - 1] < c.reverse[roff + k + 1]) {\n+\t\t\t\tx = c.reverse[roff + k - 1] // up\n+\t\t\t} else {\n+\t\t\t\tx = c.reverse[roff + k + 1] - 1 // left\n+\t\t\t}\n+\t\t\ty = x - k\n+\t\t\tfor x > aoffset && y > boffset && c.a[x - 1] == c.b[y - 1] {\n+\t\t\t\tx--\n+\t\t\t\ty--\n+\t\t\t}\n+\t\t\tc.reverse[roff + k] = x\n+\t\t\tif !isodd && k >= fmid - d && k <= fmid + d {\n+\t\t\t\tif c.reverse[roff + k] <= c.forward[foff + k] {\n+\t\t\t\t\t// lookup opposite end\n+\t\t\t\t\tx = c.forward[foff + k]\n+\t\t\t\t\treturn x, x - k\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpanic('diff.find_middle_snake: should never be reached')\n+}\n+\n+@[direct_array_access]\n+fn (c DiffContext[T]) result(n int, m int) []DiffChange {\n+\tmut x, mut y := 0, 0\n+\tmut res := []DiffChange{}\n+\tfor x < n || y < m {\n+\t\tif x < n && y < m && c.flags[x] & u8(1) == u8(0) && c.flags[y] & u8(2) == u8(0) {\n+\t\t\tx++\n+\t\t\ty++\n+\t\t} else {\n+\t\t\tmut a := x\n+\t\t\tmut b := y\n+\t\t\tfor x < n && (y >= m || c.flags[x] & u8(1) != u8(0)) {\n+\t\t\t\tx++\n+\t\t\t}\n+\t\t\tfor y < m && (x >= n || c.flags[y] & u8(2) != u8(0)) {\n+\t\t\t\ty++\n+\t\t\t}\n+\t\t\tif a < x || b < y {\n+\t\t\t\tres << DiffChange{a, b, x - a, y - b}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn res\n+}\n+\n+// merge_changes merges neighboring changes smaller than the specified context_lines.\n+// The changes must be ordered by ascending positions.\n+@[direct_array_access]\n+fn (mut c DiffContext[T]) merge_changes(context_lines int) {\n+\tif c.changes.len == 0 {\n+\t\treturn\n+\t}\n+\n+\tmut merged := []DiffChange{}\n+\tmut current := c.changes[0]\n+\n+\tfor i in 1 .. c.changes.len {\n+\t\tnext := c.changes[i]\n+\t\tif next.a <= current.a + current.del + context_lines {\n+\t\t\tcurrent = DiffChange{\n+\t\t\t\ta:   current.a\n+\t\t\t\tb:   current.b\n+\t\t\t\tdel: next.a + next.del - current.a\n+\t\t\t\tins: next.b + next.ins - current.b\n+\t\t\t}\n+\t\t} else {\n+\t\t\tmerged << current\n+\t\t\tcurrent = next\n+\t\t}\n+\t}\n+\tmerged << current\n+\tc.changes = merged\n+}\n+\n+@[params]\n+pub struct DiffGenStrParam {\n+pub mut:\n+\tcolorful     bool\n+\tunified      int = 3 // how many context lines before/after diff block\n+\tblock_header bool // output `@@ -3,4 +3,5 @@` or not\n+}\n+\n+// gen_str generate a colorful diff string of two arrays.\n+@[direct_array_access]\n+pub fn (mut c DiffContext[T]) gen_str(param DiffGenStrParam) string {",
        "comment_created_at": "2025-05-07T06:24:34+00:00",
        "comment_author": "spytheman",
        "comment_body": "Why `gen_str`?\r\nIt is a public method. I think that a longer, and more descriptive name like `generate_patch` may be better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1880806219",
    "pr_number": 23138,
    "pr_file": "vlib/gg/gg.c.v",
    "created_at": "2024-12-11T19:37:51+00:00",
    "commented_code": "// fail_userdata_cb: gg_fail_fn\n \t\t\tcleanup_userdata_cb: gg_cleanup_fn\n \t\t\twindow_title:        &char(cfg.window_title.str)\n+\t\t\ticon:                cfg.window_icon",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1880806219",
        "repo_full_name": "vlang/v",
        "pr_number": 23138,
        "pr_file": "vlib/gg/gg.c.v",
        "discussion_id": "1880806219",
        "commented_code": "@@ -477,6 +478,7 @@ pub fn new_context(cfg Config) &Context {\n \t\t\t// fail_userdata_cb: gg_fail_fn\n \t\t\tcleanup_userdata_cb: gg_cleanup_fn\n \t\t\twindow_title:        &char(cfg.window_title.str)\n+\t\t\ticon:                cfg.window_icon",
        "comment_created_at": "2024-12-11T19:37:51+00:00",
        "comment_author": "spytheman",
        "comment_body": "Why is this called `icon`, but the config name is `window_icon`?\r\nImho if you make both `icon`, it will be less confusing for people, similar to how the other properties are named the same.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1874228254",
    "pr_number": 23084,
    "pr_file": "vlib/v/ast/ast.v",
    "created_at": "2024-12-07T02:58:30+00:00",
    "commented_code": "return false\n }\n \n+@[inline]\n+pub fn (expr Expr) is_ascast() bool {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1874228254",
        "repo_full_name": "vlang/v",
        "pr_number": 23084,
        "pr_file": "vlib/v/ast/ast.v",
        "discussion_id": "1874228254",
        "commented_code": "@@ -2148,6 +2148,17 @@ pub fn (expr Expr) is_blank_ident() bool {\n \treturn false\n }\n \n+@[inline]\n+pub fn (expr Expr) is_ascast() bool {",
        "comment_created_at": "2024-12-07T02:58:30+00:00",
        "comment_author": "Delta456",
        "comment_body": "```suggestion\npub fn (expr Expr) is_as_cast() bool {\n```\n\nLooks more readable",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1867229059",
    "pr_number": 23054,
    "pr_file": "vlib/builtin/array.v",
    "created_at": "2024-12-03T08:12:46+00:00",
    "commented_code": "// Example: array.any(it.name == 'Bob') // will yield `true` if any element has `.name == 'Bob'`\n pub fn (a array) any(predicate fn (voidptr) bool) bool\n \n+// count counts how many elements in array pass the test.\n+// Ignore the function signature. `count` does not take an actual callback. Rather, it\n+// takes an `it` expression.\n+//\n+// Example: array.count(it % 2 == 1) // will return how many elements are odd\n+pub fn (a array) count(predicate fn (voidptr) bool) bool",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1867229059",
        "repo_full_name": "vlang/v",
        "pr_number": 23054,
        "pr_file": "vlib/builtin/array.v",
        "discussion_id": "1867229059",
        "commented_code": "@@ -807,6 +807,13 @@ pub fn (a array) filter(predicate fn (voidptr) bool) array\n // Example: array.any(it.name == 'Bob') // will yield `true` if any element has `.name == 'Bob'`\n pub fn (a array) any(predicate fn (voidptr) bool) bool\n \n+// count counts how many elements in array pass the test.\n+// Ignore the function signature. `count` does not take an actual callback. Rather, it\n+// takes an `it` expression.\n+//\n+// Example: array.count(it % 2 == 1) // will return how many elements are odd\n+pub fn (a array) count(predicate fn (voidptr) bool) bool",
        "comment_created_at": "2024-12-03T08:12:46+00:00",
        "comment_author": "spytheman",
        "comment_body": "it should return `int`, not bool",
        "pr_file_module": null
      },
      {
        "comment_id": "1867231087",
        "repo_full_name": "vlang/v",
        "pr_number": 23054,
        "pr_file": "vlib/builtin/array.v",
        "discussion_id": "1867229059",
        "commented_code": "@@ -807,6 +807,13 @@ pub fn (a array) filter(predicate fn (voidptr) bool) array\n // Example: array.any(it.name == 'Bob') // will yield `true` if any element has `.name == 'Bob'`\n pub fn (a array) any(predicate fn (voidptr) bool) bool\n \n+// count counts how many elements in array pass the test.\n+// Ignore the function signature. `count` does not take an actual callback. Rather, it\n+// takes an `it` expression.\n+//\n+// Example: array.count(it % 2 == 1) // will return how many elements are odd\n+pub fn (a array) count(predicate fn (voidptr) bool) bool",
        "comment_created_at": "2024-12-03T08:14:16+00:00",
        "comment_author": "spytheman",
        "comment_body": "The signature is ignored by the compiler currently, but is used by tooling to show usage tips and to infer the result type of the method, so it should be correct.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1838213309",
    "pr_number": 22842,
    "pr_file": "vlib/v/ast/scope.v",
    "created_at": "2024-11-12T14:35:02+00:00",
    "commented_code": "return out\n }\n \n+pub fn (mut sc Scope) mark_used(varname string) bool {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1838213309",
        "repo_full_name": "vlang/v",
        "pr_number": 22842,
        "pr_file": "vlib/v/ast/scope.v",
        "discussion_id": "1838213309",
        "commented_code": "@@ -262,6 +262,17 @@ pub fn (sc &Scope) show(depth int, max_depth int) string {\n \treturn out\n }\n \n+pub fn (mut sc Scope) mark_used(varname string) bool {",
        "comment_created_at": "2024-11-12T14:35:02+00:00",
        "comment_author": "spytheman",
        "comment_body": "imho `mark_var_as_used` was a clearer name",
        "pr_file_module": null
      },
      {
        "comment_id": "1838217438",
        "repo_full_name": "vlang/v",
        "pr_number": 22842,
        "pr_file": "vlib/v/ast/scope.v",
        "discussion_id": "1838213309",
        "commented_code": "@@ -262,6 +262,17 @@ pub fn (sc &Scope) show(depth int, max_depth int) string {\n \treturn out\n }\n \n+pub fn (mut sc Scope) mark_used(varname string) bool {",
        "comment_created_at": "2024-11-12T14:37:28+00:00",
        "comment_author": "felipensp",
        "comment_body": "Ok.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1816845185",
    "pr_number": 22647,
    "pr_file": "vlib/encoding/utf8/utf8_is_punct_test.v",
    "created_at": "2024-10-25T14:58:46+00:00",
    "commented_code": "+module main\n+\n+import encoding.utf8 as u8",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1816845185",
        "repo_full_name": "vlang/v",
        "pr_number": 22647,
        "pr_file": "vlib/encoding/utf8/utf8_is_punct_test.v",
        "discussion_id": "1816845185",
        "commented_code": "@@ -0,0 +1,21 @@\n+module main\n+\n+import encoding.utf8 as u8",
        "comment_created_at": "2024-10-25T14:58:46+00:00",
        "comment_author": "spytheman",
        "comment_body": "That is a bit misleading, since `u8` is also a type name, and saves only 2 characters. Please use the full module name `utf8` below, and remove the module alias.",
        "pr_file_module": null
      },
      {
        "comment_id": "1817036600",
        "repo_full_name": "vlang/v",
        "pr_number": 22647,
        "pr_file": "vlib/encoding/utf8/utf8_is_punct_test.v",
        "discussion_id": "1816845185",
        "commented_code": "@@ -0,0 +1,21 @@\n+module main\n+\n+import encoding.utf8 as u8",
        "comment_created_at": "2024-10-25T16:48:50+00:00",
        "comment_author": "felipensp",
        "comment_body": "Yeah, totally. But I just copy&paste the report case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1810941875",
    "pr_number": 22614,
    "pr_file": "vlib/v/gen/c/cheaders.v",
    "created_at": "2024-10-22T15:23:49+00:00",
    "commented_code": "#define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n #define _SLEN(s, n) ((string){.str=(byteptr)(\"\" s), .len=n, .is_lit=1})\n // optimized way to compare literal strings\n-#define _SLIT_EQ(s, op, l) (s##op##len == sizeof(l)-1 && !vmemcmp(s##op##str, l, sizeof(l)-1))\n-#define _SLIT_NE(s, op, l) (s##op##len != sizeof(l)-1 || vmemcmp(s##op##str, l, sizeof(l)-1))\n+#define _SLIT_EQ(s, n, l) (n == sizeof(l)-1 && !vmemcmp(s, l, sizeof(l)-1))\n+#define _SLIT_NE(s, n, l) (n != sizeof(l)-1 || vmemcmp(s, l, sizeof(l)-1))",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1810941875",
        "repo_full_name": "vlang/v",
        "pr_number": 22614,
        "pr_file": "vlib/v/gen/c/cheaders.v",
        "discussion_id": "1810941875",
        "commented_code": "@@ -499,8 +499,8 @@ const c_helper_macros = '//============================== HELPER C MACROS ======\n #define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n #define _SLEN(s, n) ((string){.str=(byteptr)(\"\" s), .len=n, .is_lit=1})\n // optimized way to compare literal strings\n-#define _SLIT_EQ(s, op, l) (s##op##len == sizeof(l)-1 && !vmemcmp(s##op##str, l, sizeof(l)-1))\n-#define _SLIT_NE(s, op, l) (s##op##len != sizeof(l)-1 || vmemcmp(s##op##str, l, sizeof(l)-1))\n+#define _SLIT_EQ(s, n, l) (n == sizeof(l)-1 && !vmemcmp(s, l, sizeof(l)-1))\n+#define _SLIT_NE(s, n, l) (n != sizeof(l)-1 || vmemcmp(s, l, sizeof(l)-1))",
        "comment_created_at": "2024-10-22T15:23:49+00:00",
        "comment_author": "spytheman",
        "comment_body": "It would be clearer if `s` is the actual string literal, i.e. rename `l` to `s` or to `lit`.\r\nWhat is now `s` could be `sptr` for example.",
        "pr_file_module": null
      },
      {
        "comment_id": "1811470173",
        "repo_full_name": "vlang/v",
        "pr_number": 22614,
        "pr_file": "vlib/v/gen/c/cheaders.v",
        "discussion_id": "1810941875",
        "commented_code": "@@ -499,8 +499,8 @@ const c_helper_macros = '//============================== HELPER C MACROS ======\n #define _SLIT(s) ((string){.str=(byteptr)(\"\" s), .len=(sizeof(s)-1), .is_lit=1})\n #define _SLEN(s, n) ((string){.str=(byteptr)(\"\" s), .len=n, .is_lit=1})\n // optimized way to compare literal strings\n-#define _SLIT_EQ(s, op, l) (s##op##len == sizeof(l)-1 && !vmemcmp(s##op##str, l, sizeof(l)-1))\n-#define _SLIT_NE(s, op, l) (s##op##len != sizeof(l)-1 || vmemcmp(s##op##str, l, sizeof(l)-1))\n+#define _SLIT_EQ(s, n, l) (n == sizeof(l)-1 && !vmemcmp(s, l, sizeof(l)-1))\n+#define _SLIT_NE(s, n, l) (n != sizeof(l)-1 || vmemcmp(s, l, sizeof(l)-1))",
        "comment_created_at": "2024-10-22T21:33:51+00:00",
        "comment_author": "felipensp",
        "comment_body": "Hmm nice, I've updated it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1807259409",
    "pr_number": 22581,
    "pr_file": "vlib/x/json2/decoder2/tests/decode_object_test.v",
    "created_at": "2024-10-19T09:30:39+00:00",
    "commented_code": "+import x.json2.decoder2 as json\n+\n+pub struct Stru {\n+\tval  int\n+\tval2 string\n+\tval3 Stru2\n+}\n+\n+pub struct Stru2 {\n+\ta         int\n+\tchurrasco string",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1807259409",
        "repo_full_name": "vlang/v",
        "pr_number": 22581,
        "pr_file": "vlib/x/json2/decoder2/tests/decode_object_test.v",
        "discussion_id": "1807259409",
        "commented_code": "@@ -0,0 +1,56 @@\n+import x.json2.decoder2 as json\n+\n+pub struct Stru {\n+\tval  int\n+\tval2 string\n+\tval3 Stru2\n+}\n+\n+pub struct Stru2 {\n+\ta         int\n+\tchurrasco string",
        "comment_created_at": "2024-10-19T09:30:39+00:00",
        "comment_author": "spytheman",
        "comment_body": "Use names in English for the fields. `name` for example is perfectly fine.\r\n\r\nThe code base would become an unmaintainable mess, if everyone starts using their local names/terms :-| (in the code).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1807244471",
    "pr_number": 22572,
    "pr_file": "vlib/v/gen/c/auto_str_methods.v",
    "created_at": "2024-10-19T08:26:26+00:00",
    "commented_code": "return kind in [.struct, .alias, .array, .array_fixed, .map, .sum_type, .interface]\n }\n \n-fn (mut g Gen) get_enum_type_idx_from_fn_name(fn_name string) (string, int) {\n+fn (mut g Gen) get_enum_type_idx_from_fn_name(fn_name string) (string, ast.Type) {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1807244471",
        "repo_full_name": "vlang/v",
        "pr_number": 22572,
        "pr_file": "vlib/v/gen/c/auto_str_methods.v",
        "discussion_id": "1807244471",
        "commented_code": "@@ -1244,7 +1244,7 @@ fn should_use_indent_func(kind ast.Kind) bool {\n \treturn kind in [.struct, .alias, .array, .array_fixed, .map, .sum_type, .interface]\n }\n \n-fn (mut g Gen) get_enum_type_idx_from_fn_name(fn_name string) (string, int) {\n+fn (mut g Gen) get_enum_type_idx_from_fn_name(fn_name string) (string, ast.Type) {",
        "comment_created_at": "2024-10-19T08:26:26+00:00",
        "comment_author": "spytheman",
        "comment_body": "the name is `get_enum_type_idx`, it should return int; if you make it return ast.Type, change the name too",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1807247817",
    "pr_number": 22572,
    "pr_file": "vlib/v/gen/native/gen.v",
    "created_at": "2024-10-19T08:40:32+00:00",
    "commented_code": "ast.Var { ident.obj.typ }\n \t}\n \tif typ != 0 {\n-\t\treturn g.get_type_size(typ)\n+\t\treturn g.get_type_size(ast.idx_to_type(typ))",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1807247817",
        "repo_full_name": "vlang/v",
        "pr_number": 22572,
        "pr_file": "vlib/v/gen/native/gen.v",
        "discussion_id": "1807247817",
        "commented_code": "@@ -826,7 +826,7 @@ fn (mut g Gen) get_sizeof_ident(ident ast.Ident) i32 {\n \t\tast.Var { ident.obj.typ }\n \t}\n \tif typ != 0 {\n-\t\treturn g.get_type_size(typ)\n+\t\treturn g.get_type_size(ast.idx_to_type(typ))",
        "comment_created_at": "2024-10-19T08:40:32+00:00",
        "comment_author": "spytheman",
        "comment_body": "change the name to `typ_idx`, it is misleading otherwise",
        "pr_file_module": null
      },
      {
        "comment_id": "1807248261",
        "repo_full_name": "vlang/v",
        "pr_number": 22572,
        "pr_file": "vlib/v/gen/native/gen.v",
        "discussion_id": "1807247817",
        "commented_code": "@@ -826,7 +826,7 @@ fn (mut g Gen) get_sizeof_ident(ident ast.Ident) i32 {\n \t\tast.Var { ident.obj.typ }\n \t}\n \tif typ != 0 {\n-\t\treturn g.get_type_size(typ)\n+\t\treturn g.get_type_size(ast.idx_to_type(typ))",
        "comment_created_at": "2024-10-19T08:41:11+00:00",
        "comment_author": "spytheman",
        "comment_body": "or just `idx`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1791176698",
    "pr_number": 22442,
    "pr_file": "vlib/x/json2/json2.v",
    "created_at": "2024-10-08T04:43:33+00:00",
    "commented_code": "}\n \treturn m\n }\n+\n+// map_from_values convert a array of values to map of Any\n+@[inline]\n+fn map_from_values[T](t []T) []Any {",
    "repo_full_name": "vlang/v",
    "discussion_comments": [
      {
        "comment_id": "1791176698",
        "repo_full_name": "vlang/v",
        "pr_number": 22442,
        "pr_file": "vlib/x/json2/json2.v",
        "discussion_id": "1791176698",
        "commented_code": "@@ -310,3 +314,21 @@ pub fn map_from[T](t T) map[string]Any {\n \t}\n \treturn m\n }\n+\n+// map_from_values convert a array of values to map of Any\n+@[inline]\n+fn map_from_values[T](t []T) []Any {",
        "comment_created_at": "2024-10-08T04:43:33+00:00",
        "comment_author": "spytheman",
        "comment_body": "There are no maps anywhere: the input is an array, the output is an array, the body of the function also does not use maps.\r\n\r\nA better name could be `flatten_array`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1791263747",
        "repo_full_name": "vlang/v",
        "pr_number": 22442,
        "pr_file": "vlib/x/json2/json2.v",
        "discussion_id": "1791176698",
        "commented_code": "@@ -310,3 +314,21 @@ pub fn map_from[T](t T) map[string]Any {\n \t}\n \treturn m\n }\n+\n+// map_from_values convert a array of values to map of Any\n+@[inline]\n+fn map_from_values[T](t []T) []Any {",
        "comment_created_at": "2024-10-08T06:20:28+00:00",
        "comment_author": "esquerbatua",
        "comment_body": "changed",
        "pr_file_module": null
      }
    ]
  }
]