[
  {
    "discussion_id": "1906446525",
    "pr_number": 19143,
    "pr_file": "packages/vite/src/node/plugins/html.ts",
    "created_at": "2025-01-08T04:15:30+00:00",
    "commented_code": "chunk: OutputChunk,\n         toOutputPath: (filename: string) => string,\n         seen: Set<string> = new Set(),\n+        parentImports?: Set<string>,\n+        circle: Set<OutputChunk> = new Set(),\n       ): HtmlTagDescriptor[] => {\n         const tags: HtmlTagDescriptor[] = []\n+        if (circle.has(chunk)) {\n+          return tags\n+        }\n+        circle.add(chunk)\n+        let analyzedChunkImportCss: Set<string>\n+        const processImportedCss = (files: Set<string>): void => {\n+          files.forEach((file) => {\n+            if (parentImports) {\n+              parentImports.add(file)\n+            }\n+            if (!seen.has(file)) {\n+              seen.add(file)\n+              tags.push({\n+                tag: 'link',\n+                attrs: {\n+                  rel: 'stylesheet',\n+                  crossorigin: true,\n+                  href: toOutputPath(file),\n+                },\n+              })\n+            }\n+          })\n+        }\n         if (!analyzedChunk.has(chunk)) {\n-          analyzedChunk.set(chunk, 1)\n+          analyzedChunkImportCss = new Set()\n           chunk.imports.forEach((file) => {\n             const importee = bundle[file]\n             if (importee?.type === 'chunk') {\n-              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen))\n+              tags.push(\n+                ...getCssTagsForChunk(\n+                  importee,\n+                  toOutputPath,\n+                  seen,\n+                  analyzedChunkImportCss,\n+                  circle,\n+                ),\n+              )\n             }\n           })\n-        }\n-\n-        chunk.viteMetadata!.importedCss.forEach((file) => {\n-          if (!seen.has(file)) {\n-            seen.add(file)\n-            tags.push({\n-              tag: 'link',\n-              attrs: {\n-                rel: 'stylesheet',\n-                crossorigin: true,\n-                href: toOutputPath(file),\n-              },\n+          analyzedChunk.set(chunk, analyzedChunkImportCss)\n+          if (parentImports) {\n+            analyzedChunkImportCss.forEach((file) => {\n+              parentImports.add(file)\n             })\n           }\n-        })\n+        } else {\n+          analyzedChunkImportCss = analyzedChunk.get(chunk)!\n+          processImportedCss(analyzedChunkImportCss)\n+        }\n \n+        processImportedCss(chunk.viteMetadata!.importedCss)\n         return tags\n       }",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1906446525",
        "repo_full_name": "vitejs/vite",
        "pr_number": 19143,
        "pr_file": "packages/vite/src/node/plugins/html.ts",
        "discussion_id": "1906446525",
        "commented_code": "@@ -781,32 +781,61 @@ export function buildHtmlPlugin(config: ResolvedConfig): Plugin {\n         chunk: OutputChunk,\n         toOutputPath: (filename: string) => string,\n         seen: Set<string> = new Set(),\n+        parentImports?: Set<string>,\n+        circle: Set<OutputChunk> = new Set(),\n       ): HtmlTagDescriptor[] => {\n         const tags: HtmlTagDescriptor[] = []\n+        if (circle.has(chunk)) {\n+          return tags\n+        }\n+        circle.add(chunk)\n+        let analyzedChunkImportCss: Set<string>\n+        const processImportedCss = (files: Set<string>): void => {\n+          files.forEach((file) => {\n+            if (parentImports) {\n+              parentImports.add(file)\n+            }\n+            if (!seen.has(file)) {\n+              seen.add(file)\n+              tags.push({\n+                tag: 'link',\n+                attrs: {\n+                  rel: 'stylesheet',\n+                  crossorigin: true,\n+                  href: toOutputPath(file),\n+                },\n+              })\n+            }\n+          })\n+        }\n         if (!analyzedChunk.has(chunk)) {\n-          analyzedChunk.set(chunk, 1)\n+          analyzedChunkImportCss = new Set()\n           chunk.imports.forEach((file) => {\n             const importee = bundle[file]\n             if (importee?.type === 'chunk') {\n-              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen))\n+              tags.push(\n+                ...getCssTagsForChunk(\n+                  importee,\n+                  toOutputPath,\n+                  seen,\n+                  analyzedChunkImportCss,\n+                  circle,\n+                ),\n+              )\n             }\n           })\n-        }\n-\n-        chunk.viteMetadata!.importedCss.forEach((file) => {\n-          if (!seen.has(file)) {\n-            seen.add(file)\n-            tags.push({\n-              tag: 'link',\n-              attrs: {\n-                rel: 'stylesheet',\n-                crossorigin: true,\n-                href: toOutputPath(file),\n-              },\n+          analyzedChunk.set(chunk, analyzedChunkImportCss)\n+          if (parentImports) {\n+            analyzedChunkImportCss.forEach((file) => {\n+              parentImports.add(file)\n             })\n           }\n-        })\n+        } else {\n+          analyzedChunkImportCss = analyzedChunk.get(chunk)!\n+          processImportedCss(analyzedChunkImportCss)\n+        }\n \n+        processImportedCss(chunk.viteMetadata!.importedCss)\n         return tags\n       }",
        "comment_created_at": "2025-01-08T04:15:30+00:00",
        "comment_author": "sapphi-red",
        "comment_body": "I think splitting the function into 3 like this will make the function more easier to understand\r\n```ts\r\nconst toStyleSheetLinkTag = (\r\n  file: string,\r\n  toOutputPath: (filename: string) => string,\r\n): HtmlTagDescriptor => ({\r\n  tag: 'link',\r\n  attrs: {\r\n    rel: 'stylesheet',\r\n    crossorigin: true,\r\n    href: toOutputPath(file),\r\n  },\r\n})\r\n\r\nconst getCssFilesForChunk = (\r\n  chunk: OutputChunk,\r\n  seenChunks: Set<string> = new Set(),\r\n  seenCss: Set<string> = new Set(),\r\n): string[] => {\r\n  if (seenChunks.has(chunk.fileName)) {\r\n    return []\r\n  }\r\n  seenChunks.add(chunk.fileName)\r\n\r\n  if (analyzedChunk.has(chunk)) {\r\n    return analyzedChunk.get(chunk)!\r\n  }\r\n\r\n  const files: string[] = []\r\n  chunk.imports.forEach((file) => {\r\n    const importee = bundle[file]\r\n    if (importee?.type === 'chunk') {\r\n      files.push(...getCssFilesForChunk(importee, seenChunks, seenCss))\r\n    }\r\n  })\r\n  analyzedChunk.set(chunk, files)\r\n\r\n  chunk.viteMetadata!.importedCss.forEach((file) => {\r\n    if (!seenCss.has(file)) {\r\n      seenCss.add(file)\r\n      files.push(file)\r\n    }\r\n  })\r\n\r\n  return files\r\n}\r\n\r\nconst getCssTagsForChunk = (\r\n  chunk: OutputChunk,\r\n  toOutputPath: (filename: string) => string,\r\n) =>\r\n  getCssFilesForChunk(chunk).map((file) =>\r\n    toStyleSheetLinkTag(file, toOutputPath),\r\n  )\r\n```\r\nI think `analyzedChunk` should be renamed to `analyzedImportedCssFiles` in this case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1908230998",
        "repo_full_name": "vitejs/vite",
        "pr_number": 19143,
        "pr_file": "packages/vite/src/node/plugins/html.ts",
        "discussion_id": "1906446525",
        "commented_code": "@@ -781,32 +781,61 @@ export function buildHtmlPlugin(config: ResolvedConfig): Plugin {\n         chunk: OutputChunk,\n         toOutputPath: (filename: string) => string,\n         seen: Set<string> = new Set(),\n+        parentImports?: Set<string>,\n+        circle: Set<OutputChunk> = new Set(),\n       ): HtmlTagDescriptor[] => {\n         const tags: HtmlTagDescriptor[] = []\n+        if (circle.has(chunk)) {\n+          return tags\n+        }\n+        circle.add(chunk)\n+        let analyzedChunkImportCss: Set<string>\n+        const processImportedCss = (files: Set<string>): void => {\n+          files.forEach((file) => {\n+            if (parentImports) {\n+              parentImports.add(file)\n+            }\n+            if (!seen.has(file)) {\n+              seen.add(file)\n+              tags.push({\n+                tag: 'link',\n+                attrs: {\n+                  rel: 'stylesheet',\n+                  crossorigin: true,\n+                  href: toOutputPath(file),\n+                },\n+              })\n+            }\n+          })\n+        }\n         if (!analyzedChunk.has(chunk)) {\n-          analyzedChunk.set(chunk, 1)\n+          analyzedChunkImportCss = new Set()\n           chunk.imports.forEach((file) => {\n             const importee = bundle[file]\n             if (importee?.type === 'chunk') {\n-              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen))\n+              tags.push(\n+                ...getCssTagsForChunk(\n+                  importee,\n+                  toOutputPath,\n+                  seen,\n+                  analyzedChunkImportCss,\n+                  circle,\n+                ),\n+              )\n             }\n           })\n-        }\n-\n-        chunk.viteMetadata!.importedCss.forEach((file) => {\n-          if (!seen.has(file)) {\n-            seen.add(file)\n-            tags.push({\n-              tag: 'link',\n-              attrs: {\n-                rel: 'stylesheet',\n-                crossorigin: true,\n-                href: toOutputPath(file),\n-              },\n+          analyzedChunk.set(chunk, analyzedChunkImportCss)\n+          if (parentImports) {\n+            analyzedChunkImportCss.forEach((file) => {\n+              parentImports.add(file)\n             })\n           }\n-        })\n+        } else {\n+          analyzedChunkImportCss = analyzedChunk.get(chunk)!\n+          processImportedCss(analyzedChunkImportCss)\n+        }\n \n+        processImportedCss(chunk.viteMetadata!.importedCss)\n         return tags\n       }",
        "comment_created_at": "2025-01-09T06:31:39+00:00",
        "comment_author": "thy486",
        "comment_body": "> I think splitting the function into 3 like this will make the function more easier to understand\r\n> \r\n> ```ts\r\n> const toStyleSheetLinkTag = (\r\n>   file: string,\r\n>   toOutputPath: (filename: string) => string,\r\n> ): HtmlTagDescriptor => ({\r\n>   tag: 'link',\r\n>   attrs: {\r\n>     rel: 'stylesheet',\r\n>     crossorigin: true,\r\n>     href: toOutputPath(file),\r\n>   },\r\n> })\r\n> \r\n> const getCssFilesForChunk = (\r\n>   chunk: OutputChunk,\r\n>   seenChunks: Set<string> = new Set(),\r\n>   seenCss: Set<string> = new Set(),\r\n> ): string[] => {\r\n>   if (seenChunks.has(chunk.fileName)) {\r\n>     return []\r\n>   }\r\n>   seenChunks.add(chunk.fileName)\r\n> \r\n>   if (analyzedChunk.has(chunk)) {\r\n>     return analyzedChunk.get(chunk)!\r\n>   }\r\n> \r\n>   const files: string[] = []\r\n>   chunk.imports.forEach((file) => {\r\n>     const importee = bundle[file]\r\n>     if (importee?.type === 'chunk') {\r\n>       files.push(...getCssFilesForChunk(importee, seenChunks, seenCss))\r\n>     }\r\n>   })\r\n>   analyzedChunk.set(chunk, files)\r\n> \r\n>   chunk.viteMetadata!.importedCss.forEach((file) => {\r\n>     if (!seenCss.has(file)) {\r\n>       seenCss.add(file)\r\n>       files.push(file)\r\n>     }\r\n>   })\r\n> \r\n>   return files\r\n> }\r\n> \r\n> const getCssTagsForChunk = (\r\n>   chunk: OutputChunk,\r\n>   toOutputPath: (filename: string) => string,\r\n> ) =>\r\n>   getCssFilesForChunk(chunk).map((file) =>\r\n>     toStyleSheetLinkTag(file, toOutputPath),\r\n>   )\r\n> ```\r\n> \r\n> I think `analyzedChunk` should be renamed to `analyzedImportedCssFiles` in this case.\r\n\r\nGot it! But for the following situation, the current code still has a little problem\r\n\r\n\r\n### Comparison: `entryA` vs `entryB` (All import ChunkC, ChunkD)\r\n\r\n#### **entryA**:\r\n- **ChunkC**(ChunkC import (ChunkD)):\r\n   - seen: false\r\n   - analized: false\r\n   - generate: c.css, d.css\r\n   - analizedCache: c.css, d.css\r\n- **ChunkD**: \r\n   - seen: true\r\n   - analized: true\r\n   - generate: null\r\n   - analizedCache: d.css\r\n\r\n- **Final generated files**: `c.css, d.css` \u2705\r\n\r\n---\r\n\r\n#### **entryB**:\r\n**ChunkB import (ChunkC)**:\r\n- **ChunkC**(ChunkC import (ChunkD)):\r\n   - seen: false\r\n   - analized: true\r\n   - generate: c.css, d.css\r\n   - analizedCache: c.css, d.css\r\n- **ChunkD**: \r\n   - seen: false\ud83e\udd14\r\n   - analized: true\r\n   - generate: d.css\u274c\r\n   - analizedCache: d.css\r\n\r\n- **Final generated files**: `c.css, d.css, d.css` \u274c\r\n  - Note: `d.css` is repeated.\r\n\r\nThe following code is my improvement measure\r\n\r\n```\r\n        const seenFiles = new Set<string>();\r\n        const addFile = (file: string) => {\r\n          if (!seenFiles.has(file)) {\r\n            seenFiles.add(file);\r\n            files.push(file);\r\n          }\r\n        };\r\n\r\n        chunk.imports.forEach((file) => {\r\n          const importee = bundle[file]\r\n          if (importee?.type === 'chunk') {\r\n            getCssFilesForChunk(importee, seenChunks, seenCss).forEach((file) => {\r\n              addFile(file)\r\n            })\r\n          }\r\n        })\r\n        analyzedImportedCssFiles.set(chunk, files)\r\n\r\n        chunk.viteMetadata!.importedCss.forEach((file) => {\r\n          addFile(file)\r\n        })\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1909708417",
        "repo_full_name": "vitejs/vite",
        "pr_number": 19143,
        "pr_file": "packages/vite/src/node/plugins/html.ts",
        "discussion_id": "1906446525",
        "commented_code": "@@ -781,32 +781,61 @@ export function buildHtmlPlugin(config: ResolvedConfig): Plugin {\n         chunk: OutputChunk,\n         toOutputPath: (filename: string) => string,\n         seen: Set<string> = new Set(),\n+        parentImports?: Set<string>,\n+        circle: Set<OutputChunk> = new Set(),\n       ): HtmlTagDescriptor[] => {\n         const tags: HtmlTagDescriptor[] = []\n+        if (circle.has(chunk)) {\n+          return tags\n+        }\n+        circle.add(chunk)\n+        let analyzedChunkImportCss: Set<string>\n+        const processImportedCss = (files: Set<string>): void => {\n+          files.forEach((file) => {\n+            if (parentImports) {\n+              parentImports.add(file)\n+            }\n+            if (!seen.has(file)) {\n+              seen.add(file)\n+              tags.push({\n+                tag: 'link',\n+                attrs: {\n+                  rel: 'stylesheet',\n+                  crossorigin: true,\n+                  href: toOutputPath(file),\n+                },\n+              })\n+            }\n+          })\n+        }\n         if (!analyzedChunk.has(chunk)) {\n-          analyzedChunk.set(chunk, 1)\n+          analyzedChunkImportCss = new Set()\n           chunk.imports.forEach((file) => {\n             const importee = bundle[file]\n             if (importee?.type === 'chunk') {\n-              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen))\n+              tags.push(\n+                ...getCssTagsForChunk(\n+                  importee,\n+                  toOutputPath,\n+                  seen,\n+                  analyzedChunkImportCss,\n+                  circle,\n+                ),\n+              )\n             }\n           })\n-        }\n-\n-        chunk.viteMetadata!.importedCss.forEach((file) => {\n-          if (!seen.has(file)) {\n-            seen.add(file)\n-            tags.push({\n-              tag: 'link',\n-              attrs: {\n-                rel: 'stylesheet',\n-                crossorigin: true,\n-                href: toOutputPath(file),\n-              },\n+          analyzedChunk.set(chunk, analyzedChunkImportCss)\n+          if (parentImports) {\n+            analyzedChunkImportCss.forEach((file) => {\n+              parentImports.add(file)\n             })\n           }\n-        })\n+        } else {\n+          analyzedChunkImportCss = analyzedChunk.get(chunk)!\n+          processImportedCss(analyzedChunkImportCss)\n+        }\n \n+        processImportedCss(chunk.viteMetadata!.importedCss)\n         return tags\n       }",
        "comment_created_at": "2025-01-10T02:35:53+00:00",
        "comment_author": "sapphi-red",
        "comment_body": "Ah, yeah, `getCssFilesForChunk` should be\r\n```diff\r\nconst getCssFilesForChunk = (\r\n  chunk: OutputChunk,\r\n  seenChunks: Set<string> = new Set(),\r\n  seenCss: Set<string> = new Set(),\r\n): string[] => {\r\n  if (seenChunks.has(chunk.fileName)) {\r\n    return []\r\n  }\r\n  seenChunks.add(chunk.fileName)\r\n\r\n  if (analyzedChunk.has(chunk)) {\r\n+    const files = analyzedChunk.get(chunk)!\r\n+    const additionals = files.filter(file => !seenCss.has(file))\r\n+    additionals.forEach(file => seenCss.add(file))\r\n+    return additionals\r\n-    return analyzedChunk.get(chunk)!\r\n  }\r\n\r\n  const files: string[] = []\r\n  chunk.imports.forEach((file) => {\r\n    const importee = bundle[file]\r\n    if (importee?.type === 'chunk') {\r\n      files.push(...getCssFilesForChunk(importee, seenChunks, seenCss))\r\n    }\r\n  })\r\n  analyzedChunk.set(chunk, files)\r\n\r\n  chunk.viteMetadata!.importedCss.forEach((file) => {\r\n    if (!seenCss.has(file)) {\r\n      seenCss.add(file)\r\n      files.push(file)\r\n    }\r\n  })\r\n\r\n  return files\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1909736773",
        "repo_full_name": "vitejs/vite",
        "pr_number": 19143,
        "pr_file": "packages/vite/src/node/plugins/html.ts",
        "discussion_id": "1906446525",
        "commented_code": "@@ -781,32 +781,61 @@ export function buildHtmlPlugin(config: ResolvedConfig): Plugin {\n         chunk: OutputChunk,\n         toOutputPath: (filename: string) => string,\n         seen: Set<string> = new Set(),\n+        parentImports?: Set<string>,\n+        circle: Set<OutputChunk> = new Set(),\n       ): HtmlTagDescriptor[] => {\n         const tags: HtmlTagDescriptor[] = []\n+        if (circle.has(chunk)) {\n+          return tags\n+        }\n+        circle.add(chunk)\n+        let analyzedChunkImportCss: Set<string>\n+        const processImportedCss = (files: Set<string>): void => {\n+          files.forEach((file) => {\n+            if (parentImports) {\n+              parentImports.add(file)\n+            }\n+            if (!seen.has(file)) {\n+              seen.add(file)\n+              tags.push({\n+                tag: 'link',\n+                attrs: {\n+                  rel: 'stylesheet',\n+                  crossorigin: true,\n+                  href: toOutputPath(file),\n+                },\n+              })\n+            }\n+          })\n+        }\n         if (!analyzedChunk.has(chunk)) {\n-          analyzedChunk.set(chunk, 1)\n+          analyzedChunkImportCss = new Set()\n           chunk.imports.forEach((file) => {\n             const importee = bundle[file]\n             if (importee?.type === 'chunk') {\n-              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen))\n+              tags.push(\n+                ...getCssTagsForChunk(\n+                  importee,\n+                  toOutputPath,\n+                  seen,\n+                  analyzedChunkImportCss,\n+                  circle,\n+                ),\n+              )\n             }\n           })\n-        }\n-\n-        chunk.viteMetadata!.importedCss.forEach((file) => {\n-          if (!seen.has(file)) {\n-            seen.add(file)\n-            tags.push({\n-              tag: 'link',\n-              attrs: {\n-                rel: 'stylesheet',\n-                crossorigin: true,\n-                href: toOutputPath(file),\n-              },\n+          analyzedChunk.set(chunk, analyzedChunkImportCss)\n+          if (parentImports) {\n+            analyzedChunkImportCss.forEach((file) => {\n+              parentImports.add(file)\n             })\n           }\n-        })\n+        } else {\n+          analyzedChunkImportCss = analyzedChunk.get(chunk)!\n+          processImportedCss(analyzedChunkImportCss)\n+        }\n \n+        processImportedCss(chunk.viteMetadata!.importedCss)\n         return tags\n       }",
        "comment_created_at": "2025-01-10T03:06:18+00:00",
        "comment_author": "thy486",
        "comment_body": "I have optimized my code as per the requirement. Please check it again when you have time",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1360445814",
    "pr_number": 14643,
    "pr_file": "packages/vite/src/node/plugins/asset.ts",
    "created_at": "2023-10-16T10:20:17+00:00",
    "commented_code": ")\n     }\n \n-    const mimeType = mrmime.lookup(file) ?? 'application/octet-stream'\n-    // base64 inlined as a string\n-    url = `data:${mimeType};base64,${content.toString('base64')}`\n+    if (file.endsWith('.svg')) {\n+      let dataUri = content.toString()\n+      // If the SVG contains some text any transformation is unsafe, and given that double quotes would then\n+      // need to be escaped, the gain to use a data URI would be ridiculous if not negative\n+      if (dataUri.includes('<text')) {\n+        url = `data:image/svg+xml;base64,${content.toString('base64')}`\n+      } else {\n+        // Simplified version of https://github.com/tigt/mini-svg-data-uri without colors minification\n+        // This kind of minification should be done ahead of time or with a plugin with other optimizations (using svgo for example)\n+        dataUri = dataUri.trim().replace(/\\s+/g, ' ').replaceAll('\"', \"'\")\n+        dataUri = encodeURIComponent(dataUri).replace(\n+          /%[\\dA-F]{2}/g,\n+          (match) => svgDataURISupportedHexCode[match] || match.toLowerCase(),\n+        )\n+        url = 'data:image/svg+xml,' + dataUri",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1360445814",
        "repo_full_name": "vitejs/vite",
        "pr_number": 14643,
        "pr_file": "packages/vite/src/node/plugins/asset.ts",
        "discussion_id": "1360445814",
        "commented_code": "@@ -363,9 +370,27 @@ async function fileToBuiltUrl(\n       )\n     }\n \n-    const mimeType = mrmime.lookup(file) ?? 'application/octet-stream'\n-    // base64 inlined as a string\n-    url = `data:${mimeType};base64,${content.toString('base64')}`\n+    if (file.endsWith('.svg')) {\n+      let dataUri = content.toString()\n+      // If the SVG contains some text any transformation is unsafe, and given that double quotes would then\n+      // need to be escaped, the gain to use a data URI would be ridiculous if not negative\n+      if (dataUri.includes('<text')) {\n+        url = `data:image/svg+xml;base64,${content.toString('base64')}`\n+      } else {\n+        // Simplified version of https://github.com/tigt/mini-svg-data-uri without colors minification\n+        // This kind of minification should be done ahead of time or with a plugin with other optimizations (using svgo for example)\n+        dataUri = dataUri.trim().replace(/\\s+/g, ' ').replaceAll('\"', \"'\")\n+        dataUri = encodeURIComponent(dataUri).replace(\n+          /%[\\dA-F]{2}/g,\n+          (match) => svgDataURISupportedHexCode[match] || match.toLowerCase(),\n+        )\n+        url = 'data:image/svg+xml,' + dataUri",
        "comment_created_at": "2023-10-16T10:20:17+00:00",
        "comment_author": "bluwy",
        "comment_body": "Would be good to extract this out as a function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1812051144",
    "pr_number": 18432,
    "pr_file": "packages/vite/src/node/build.ts",
    "created_at": "2024-10-23T07:26:19+00:00",
    "commented_code": "*/\n export async function createBuilder(\n   inlineConfig: InlineConfig = {},\n+  useLegacyBuilder: null | boolean = false,\n ): Promise<ViteBuilder> {\n-  const config = await resolveConfigToBuild(inlineConfig)\n-  return createBuilderWithResolvedConfig(inlineConfig, config)\n-}\n+  const patchConfig = (resolved: ResolvedConfig) => {\n+    if (!(useLegacyBuilder ?? !resolved.builder)) return\n+\n+    // Until the ecosystem updates to use `environment.config.build` instead of `config.build`,\n+    // we need to make override `config.build` for the current environment.\n+    // We can deprecate `config.build` in ResolvedConfig and push everyone to upgrade, and later\n+    // remove the default values that shouldn't be used at all once the config is resolved\n+    const environmentName = resolved.build.ssr ? 'ssr' : 'client'\n+    ;(resolved.build as ResolvedBuildOptions) = {\n+      ...resolved.environments[environmentName].build,\n+    }\n+  }\n+  const config = await resolveConfigToBuild(inlineConfig, patchConfig)\n+  useLegacyBuilder ??= !config.builder\n+  const configBuilder = config.builder ?? resolveBuilderOptions({})!\n \n-/**\n- * Used to implement the `vite build` command without resolving the config twice\n- * @internal\n- */\n-export async function createBuilderWithResolvedConfig(\n-  inlineConfig: InlineConfig,\n-  config: ResolvedConfig,\n-): Promise<ViteBuilder> {\n   const environments: Record<string, BuildEnvironment> = {}\n+  const selectedEnvironmentName = useLegacyBuilder\n+    ? config.build.ssr\n+      ? 'ssr'\n+      : 'client'\n+    : undefined\n \n   const builder: ViteBuilder = {\n     environments,\n     config,\n     async buildApp() {\n-      return config.builder.buildApp(builder)\n+      return configBuilder.buildApp(builder)\n     },\n     async build(environment: BuildEnvironment) {\n       return buildEnvironment(environment)\n     },\n   }\n \n   for (const environmentName of Object.keys(config.environments)) {\n+    if (selectedEnvironmentName && selectedEnvironmentName !== environmentName)\n+      continue",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1812051144",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18432,
        "pr_file": "packages/vite/src/node/build.ts",
        "discussion_id": "1812051144",
        "commented_code": "@@ -1531,40 +1508,53 @@ export type ResolvedBuilderOptions = Required<BuilderOptions>\n  */\n export async function createBuilder(\n   inlineConfig: InlineConfig = {},\n+  useLegacyBuilder: null | boolean = false,\n ): Promise<ViteBuilder> {\n-  const config = await resolveConfigToBuild(inlineConfig)\n-  return createBuilderWithResolvedConfig(inlineConfig, config)\n-}\n+  const patchConfig = (resolved: ResolvedConfig) => {\n+    if (!(useLegacyBuilder ?? !resolved.builder)) return\n+\n+    // Until the ecosystem updates to use `environment.config.build` instead of `config.build`,\n+    // we need to make override `config.build` for the current environment.\n+    // We can deprecate `config.build` in ResolvedConfig and push everyone to upgrade, and later\n+    // remove the default values that shouldn't be used at all once the config is resolved\n+    const environmentName = resolved.build.ssr ? 'ssr' : 'client'\n+    ;(resolved.build as ResolvedBuildOptions) = {\n+      ...resolved.environments[environmentName].build,\n+    }\n+  }\n+  const config = await resolveConfigToBuild(inlineConfig, patchConfig)\n+  useLegacyBuilder ??= !config.builder\n+  const configBuilder = config.builder ?? resolveBuilderOptions({})!\n \n-/**\n- * Used to implement the `vite build` command without resolving the config twice\n- * @internal\n- */\n-export async function createBuilderWithResolvedConfig(\n-  inlineConfig: InlineConfig,\n-  config: ResolvedConfig,\n-): Promise<ViteBuilder> {\n   const environments: Record<string, BuildEnvironment> = {}\n+  const selectedEnvironmentName = useLegacyBuilder\n+    ? config.build.ssr\n+      ? 'ssr'\n+      : 'client'\n+    : undefined\n \n   const builder: ViteBuilder = {\n     environments,\n     config,\n     async buildApp() {\n-      return config.builder.buildApp(builder)\n+      return configBuilder.buildApp(builder)\n     },\n     async build(environment: BuildEnvironment) {\n       return buildEnvironment(environment)\n     },\n   }\n \n   for (const environmentName of Object.keys(config.environments)) {\n+    if (selectedEnvironmentName && selectedEnvironmentName !== environmentName)\n+      continue",
        "comment_created_at": "2024-10-23T07:26:19+00:00",
        "comment_author": "patak-dev",
        "comment_body": "Maybe this would be more clear with a condition out of the for loop:\r\n```js\r\n  function setupEnvironment(environmentName, environmentConfig) {\r\n    const environment = await environmentConfig.build.createEnvironment(\r\n      environmentName,\r\n      environmentConfig,\r\n    )\r\n    await environment.init()\r\n    environments[environmentName] = environment\r\n  }\r\n\r\n  if (selectedEnvironmentName) {\r\n    setupEnvironment(selectedEnvironmentName, config)\r\n  }\r\n  else {\r\n    // ... current for loop using setupEnvironment(environmentName, environmentConfig)\r\n  }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1687365507",
    "pr_number": 17728,
    "pr_file": "packages/vite/src/node/plugins/css.ts",
    "created_at": "2024-07-23T03:16:18+00:00",
    "commented_code": "// eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker\n         const sass: typeof Sass = require(sassPath)\n         // eslint-disable-next-line no-restricted-globals\n-        const path = require('node:path')\n+        const path: typeof import('node:path') = require('node:path')\n+\n+        if (options.api === 'modern') {",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1687365507",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17728,
        "pr_file": "packages/vite/src/node/plugins/css.ts",
        "discussion_id": "1687365507",
        "commented_code": "@@ -2108,7 +2128,58 @@ const makeScssWorker = (\n         // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker\n         const sass: typeof Sass = require(sassPath)\n         // eslint-disable-next-line no-restricted-globals\n-        const path = require('node:path')\n+        const path: typeof import('node:path') = require('node:path')\n+\n+        if (options.api === 'modern') {",
        "comment_created_at": "2024-07-23T03:16:18+00:00",
        "comment_author": "bluwy",
        "comment_body": "Is it possible to move this new modern code out as a separate `makeModernScssWorker` function? This feels quite packed. This can also help make way when we support `modern-compiler`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1687403733",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17728,
        "pr_file": "packages/vite/src/node/plugins/css.ts",
        "discussion_id": "1687365507",
        "commented_code": "@@ -2108,7 +2128,58 @@ const makeScssWorker = (\n         // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker\n         const sass: typeof Sass = require(sassPath)\n         // eslint-disable-next-line no-restricted-globals\n-        const path = require('node:path')\n+        const path: typeof import('node:path') = require('node:path')\n+\n+        if (options.api === 'modern') {",
        "comment_created_at": "2024-07-23T04:24:44+00:00",
        "comment_author": "hi-ogawa",
        "comment_body": "Good point :+1:  I thought I can reuse current worker but it turned out it needs a different `parentFunctions`, so it's probably cleaner to split it out. The new one looks like this https://github.com/vitejs/vite/pull/17728/commits/7338db42add4052863a598029a79c58f236c1f7f",
        "pr_file_module": null
      }
    ]
  }
]