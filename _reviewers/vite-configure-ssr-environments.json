[
  {
    "discussion_id": "1583924679",
    "pr_number": 16471,
    "pr_file": "docs/guide/api-vite-environment.md",
    "created_at": "2024-04-29T23:40:41+00:00",
    "commented_code": "+# Vite Environment API\n+\n+:::warning Low-level API\n+Initial work for this API was introduced in Vite 5.1 with the name \"Vite Runtime API\". This guide describes a revised API, renamed to Vite Environment API. This API will be released in Vite 6. You can already test it in the latest `vite@6.0.0-alpha.x` version.\n+\n+Resources:\n+\n+- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API is implemented and reviewed.\n+- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.\n+\n+Feel free to send us PRs against the `v6/environment-api` branch to fix the issues you discover. Please share with us your feedback as you test the proposal.\n+:::\n+\n+A single Vite dev server can be used to interact with different module execution environments concurrently. We'll use the word environment to refer to a configured Vite processing pipeline that can resolve ids, load, and process source code and is connected to a runtime where the code is executed. The transformed source code is called a module, and the relationships between the modules processed in each environment are kept in a module graph. The code for these modules is sent to the runtimes associated with each environment to be executed. When a module is evaluated, the runtime will request its imported modules triggering the processing of a section of the module graph. In a typical Vite app, an environments will be used for the ES modules served to the client and for the server program that does SSR. An app can do SSR on a Node server, but also on an edge runtime like Workerd. So we can have different types of environments on the same Vite server: browser environments, node environments, and workerd environments, to name a few.\n+\n+A Vite Module Runner allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runner implementation is decoupled from the server. This allows library and framework authors to implement their layer of communication between the Vite server and the runner. The browser communicates with its corresponding environment using the server Web Socket and through HTTP requests. The Node Module runner can directly do function calls to process modules as it is running in the same process. Other environments could run modules connecting to an edge runtime like workerd, or a Worker Thread as Vitest does.\n+\n+All these environments share Vite's HTTP server, middlewares, and Web Socket. The resolved config and plugins pipeline are also shared, but plugins can use `apply` so its hooks are only called for certain environments. The environment can also be accessed inside hooks for fine-grained control.\n+\n+![Vite Environments](../images/vite-environments.svg)\n+\n+## Using environments in the Vite server\n+\n+A Vite dev server exposes two environments by default: a Client environment and a SSR environment. The client environment is a browser environment by default, and the module runner is implemented by importing the virtual module `/@vite/client` to client apps. The SSR environment runs in the same Node runtime as the Vite server by default and allows application servers to be used to render requests during dev with full HMR support. We'll discuss later how frameworks and users can change the environment types for the default client and SSR environments, or register new environments (for example to have a separate module graph for RSC).\n+\n+The available environments can be accessed using `server.environments`:\n+\n+```js\n+const environment = server.environments.client\n+\n+environment.transformRequest(url)\n+\n+console.log(server.environments.ssr.moduleGraph)\n+```\n+\n+Most of the time, the current `environment` instance will be available as part of the context of the code being run so the need to access them through `server.environments` should be rare. For example, inside plugin hooks the enviornment is exposed as part of the `PluginContext`, so it can be accessed using `this.environment`.\n+\n+A dev environment is an instance of the `DevEnvironment` class:\n+\n+```ts\n+class DevEnvironment {\n+  /**\n+   * Unique identifier for the environment in a Vite server.\n+   * By default Vite exposes 'client' and 'ssr' environments.\n+   */\n+  name: string\n+  /**\n+   * Communication channel to send and receive messages from the\n+   * associated module runner in the target runtime.\n+   */\n+  hot: HMRChannel | null\n+  /**\n+   * Graph of module nodes, with the imported relationship between\n+   * processed modules and the cached result of the processed code.\n+   */\n+  moduleGraph: EnvironmentModuleGraph\n+  /**\n+   * Resolved plugins for this environment, including the ones\n+   * created using the per-environment `create` hook\n+   */\n+  plugins: BoundedPlugin[]\n+  /**\n+   * Allows to resolve, load, and transform code through the\n+   * environment plugins pipeline\n+   */\n+  pluginContainer: BoundedPluginContatiner\n+  /**\n+   * TBD: This abstraction isn't yet clear\n+   * Trigger the execution of a module using the associated module runner\n+   * in the target runtime.\n+   */\n+  run: ModuleRunFunction\n+  /**\n+   * Resolved config options for this environment. Options at the server\n+   * global scope are taken as defaults for all environments, and can\n+   * be overridden (resolve conditions, external, optimizedDeps)\n+   */\n+  config: ResolvedDevEnvironmentConfig\n+\n+  constructor(name, config, { hot, run, options }: DevEnvironmentOptions)\n+\n+  /**\n+   * Resolve the URL to an id, load it, and process the code using the\n+   * plugins pipeline. The module graph is also updated.\n+   */\n+  async transformRequest(url: string): TransformResult\n+\n+  /**\n+   * Register a request to be processed with low priority. This is useful\n+   * to avoid waterfalls. The Vite server has information about the imported\n+   * modules by other requests, so it can warmup the module graph so the\n+   * modules are already processed when they are requested.\n+   */\n+  async warmupRequest(url: string): void\n+\n+  /**\n+   * Fetch information about a module from the module runner without running it.\n+   * Note: This method may not be needed\n+   */\n+  async fetchModuleInfo(url: string)\n+}\n+```\n+\n+With `TransformResult` being:\n+\n+```ts\n+interface TransformResult {\n+  code: string\n+  map: SourceMap | { mappings: '' } | null\n+  etag?: string\n+  deps?: string[]\n+  dynamicDeps?: string[]\n+}\n+```\n+\n+An environment instance in the Vite server lets you process a URL using the `environment.transformRequest(url)` method. This function will use the plugin pipeline to resolve the `url` to a module `id`, load it (reading the file from the file system or through a plugin that implements a virtual module), and then transform the code. While transforming the module, imports and other metadata will be recorded in the environment module graph by creating or updating the corresponding module node. When processing is done, the transform result is also stored in the module.\n+\n+But the environment instance can't execute the code itself, as the runtime where the module will be run could be different from the one the Vite server is running in. This is the case for the browser environment. When a html is loaded in the browser, its scripts are executed triggering the evaluation of the entire static module graph. Each imported URL generates a request to the Vite server to get the module code, which ends up handled by the Transform Middleware by calling `server.environments.client.transformRequest(url)`. The connection between the environment instance in the server and the module runner in the browser is carried out through HTTP in this case.\n+\n+:::info transformRequest naming\n+We are using `transformRequest(url)` and `warmupRequest(url)` in the current version of this proposal so it is easier to discuss and understand for users used to Vite's current API. Before releasing, we can take the opportunity to review these names too. For example, it could be named `environment.processModule(url)` or `environment.loadModule(url)` taking a page from Rollup's `context.load(id)` in plugin hooks. For the moment, we think keeping the current names and delaying this discussion is better.\n+:::\n+\n+For the default Node environment, Vite creates a module runner that implements evaluation using `new AsyncFunction` running in the same runtime as the server. This runner is an instance of `ModuleRunner` that exposes:\n+\n+```ts\n+class ModuleRunner {\n+  /**\n+   * URL to execute. Accepts file path, server path, or id relative to the root.\n+   * Returns an instantiated module (same as in ssrLoadModule)\n+   */\n+  public async import(url: string): Promise<Record<string, any>>\n+  /**\n+   * Other ModuleRunner methods...\n+   */\n+```\n+\n+:::info\n+In the v5.1 Runtime API, there were `executeUrl` and `executeEntryPoint` methods - they are now merged into a single `import` method. If you want to opt-out of the HMR support, create a runner with `hmr: false` flag.\n+:::\n+\n+The default SSR Node module runner is not exposed. You can use `createNodeEnvironment` API with `createServerModuleRunner` together to create a runner that runs code in the same thread, supports HMR and doesn't conflict with the SSR implementation (in case it's been overriden in the config). Given a Vite server configured in middleware mode as described by the [SSR setup guide](/guide/ssr#setting-up-the-dev-server), let's implement the SSR middleware using the environment API. Error handling is omitted.\n+\n+```js\n+import {\n+  createServer,\n+  createServerModuleRunner,\n+  createNodeEnvironment,\n+} from 'vite'\n+\n+const server = await createServer({\n+  server: { middlewareMode: true },\n+  appType: 'custom',\n+  environments: {\n+    node: {\n+      dev: {\n+        // Default Vite SSR environment can be overriden in the config, so\n+        // make sure you have a Node environment before the request is received.\n+        createEnvironment: createNodeEnvironment,\n+      },\n+    },\n+  },\n+})\n+\n+const runner = createServerModuleRunner(server.environments.node)\n+\n+app.use('*', async (req, res, next) => {\n+  const url = req.originalUrl\n+\n+  // 1. Read index.html\n+  let template = fs.readFileSync(path.resolve(__dirname, 'index.html'), 'utf-8')\n+\n+  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n+  //    and also applies HTML transforms from Vite plugins, e.g. global\n+  //    preambles from @vitejs/plugin-react\n+  template = await server.transformIndexHtml(url, template)\n+\n+  // 3. Load the server entry. import(url) automatically transforms\n+  //    ESM source code to be usable in Node.js! There is no bundling\n+  //    required, and provides full HMR support.\n+  const { render } = await runner.import('/src/entry-server.js')\n+\n+  // 4. render the app HTML. This assumes entry-server.js's exported\n+  //     `render` function calls appropriate framework SSR APIs,\n+  //    e.g. ReactDOMServer.renderToString()\n+  const appHtml = await render(url)\n+\n+  // 5. Inject the app-rendered HTML into the template.\n+  const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n+\n+  // 6. Send the rendered HTML back.\n+  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n+})\n+```\n+\n+## Environment agnostic SSR\n+\n+::: info\n+It isn't clear yet what APIs Vite should provide to cover the most common SSR use cases. We are thinking on releasing the Environment API without an official way to do environment agnostic SSR to let the ecosystem explore common patterns first.",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1583924679",
        "repo_full_name": "vitejs/vite",
        "pr_number": 16471,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1583924679",
        "commented_code": "@@ -0,0 +1,874 @@\n+# Vite Environment API\n+\n+:::warning Low-level API\n+Initial work for this API was introduced in Vite 5.1 with the name \"Vite Runtime API\". This guide describes a revised API, renamed to Vite Environment API. This API will be released in Vite 6. You can already test it in the latest `vite@6.0.0-alpha.x` version.\n+\n+Resources:\n+\n+- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API is implemented and reviewed.\n+- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.\n+\n+Feel free to send us PRs against the `v6/environment-api` branch to fix the issues you discover. Please share with us your feedback as you test the proposal.\n+:::\n+\n+A single Vite dev server can be used to interact with different module execution environments concurrently. We'll use the word environment to refer to a configured Vite processing pipeline that can resolve ids, load, and process source code and is connected to a runtime where the code is executed. The transformed source code is called a module, and the relationships between the modules processed in each environment are kept in a module graph. The code for these modules is sent to the runtimes associated with each environment to be executed. When a module is evaluated, the runtime will request its imported modules triggering the processing of a section of the module graph. In a typical Vite app, an environments will be used for the ES modules served to the client and for the server program that does SSR. An app can do SSR on a Node server, but also on an edge runtime like Workerd. So we can have different types of environments on the same Vite server: browser environments, node environments, and workerd environments, to name a few.\n+\n+A Vite Module Runner allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runner implementation is decoupled from the server. This allows library and framework authors to implement their layer of communication between the Vite server and the runner. The browser communicates with its corresponding environment using the server Web Socket and through HTTP requests. The Node Module runner can directly do function calls to process modules as it is running in the same process. Other environments could run modules connecting to an edge runtime like workerd, or a Worker Thread as Vitest does.\n+\n+All these environments share Vite's HTTP server, middlewares, and Web Socket. The resolved config and plugins pipeline are also shared, but plugins can use `apply` so its hooks are only called for certain environments. The environment can also be accessed inside hooks for fine-grained control.\n+\n+![Vite Environments](../images/vite-environments.svg)\n+\n+## Using environments in the Vite server\n+\n+A Vite dev server exposes two environments by default: a Client environment and a SSR environment. The client environment is a browser environment by default, and the module runner is implemented by importing the virtual module `/@vite/client` to client apps. The SSR environment runs in the same Node runtime as the Vite server by default and allows application servers to be used to render requests during dev with full HMR support. We'll discuss later how frameworks and users can change the environment types for the default client and SSR environments, or register new environments (for example to have a separate module graph for RSC).\n+\n+The available environments can be accessed using `server.environments`:\n+\n+```js\n+const environment = server.environments.client\n+\n+environment.transformRequest(url)\n+\n+console.log(server.environments.ssr.moduleGraph)\n+```\n+\n+Most of the time, the current `environment` instance will be available as part of the context of the code being run so the need to access them through `server.environments` should be rare. For example, inside plugin hooks the enviornment is exposed as part of the `PluginContext`, so it can be accessed using `this.environment`.\n+\n+A dev environment is an instance of the `DevEnvironment` class:\n+\n+```ts\n+class DevEnvironment {\n+  /**\n+   * Unique identifier for the environment in a Vite server.\n+   * By default Vite exposes 'client' and 'ssr' environments.\n+   */\n+  name: string\n+  /**\n+   * Communication channel to send and receive messages from the\n+   * associated module runner in the target runtime.\n+   */\n+  hot: HMRChannel | null\n+  /**\n+   * Graph of module nodes, with the imported relationship between\n+   * processed modules and the cached result of the processed code.\n+   */\n+  moduleGraph: EnvironmentModuleGraph\n+  /**\n+   * Resolved plugins for this environment, including the ones\n+   * created using the per-environment `create` hook\n+   */\n+  plugins: BoundedPlugin[]\n+  /**\n+   * Allows to resolve, load, and transform code through the\n+   * environment plugins pipeline\n+   */\n+  pluginContainer: BoundedPluginContatiner\n+  /**\n+   * TBD: This abstraction isn't yet clear\n+   * Trigger the execution of a module using the associated module runner\n+   * in the target runtime.\n+   */\n+  run: ModuleRunFunction\n+  /**\n+   * Resolved config options for this environment. Options at the server\n+   * global scope are taken as defaults for all environments, and can\n+   * be overridden (resolve conditions, external, optimizedDeps)\n+   */\n+  config: ResolvedDevEnvironmentConfig\n+\n+  constructor(name, config, { hot, run, options }: DevEnvironmentOptions)\n+\n+  /**\n+   * Resolve the URL to an id, load it, and process the code using the\n+   * plugins pipeline. The module graph is also updated.\n+   */\n+  async transformRequest(url: string): TransformResult\n+\n+  /**\n+   * Register a request to be processed with low priority. This is useful\n+   * to avoid waterfalls. The Vite server has information about the imported\n+   * modules by other requests, so it can warmup the module graph so the\n+   * modules are already processed when they are requested.\n+   */\n+  async warmupRequest(url: string): void\n+\n+  /**\n+   * Fetch information about a module from the module runner without running it.\n+   * Note: This method may not be needed\n+   */\n+  async fetchModuleInfo(url: string)\n+}\n+```\n+\n+With `TransformResult` being:\n+\n+```ts\n+interface TransformResult {\n+  code: string\n+  map: SourceMap | { mappings: '' } | null\n+  etag?: string\n+  deps?: string[]\n+  dynamicDeps?: string[]\n+}\n+```\n+\n+An environment instance in the Vite server lets you process a URL using the `environment.transformRequest(url)` method. This function will use the plugin pipeline to resolve the `url` to a module `id`, load it (reading the file from the file system or through a plugin that implements a virtual module), and then transform the code. While transforming the module, imports and other metadata will be recorded in the environment module graph by creating or updating the corresponding module node. When processing is done, the transform result is also stored in the module.\n+\n+But the environment instance can't execute the code itself, as the runtime where the module will be run could be different from the one the Vite server is running in. This is the case for the browser environment. When a html is loaded in the browser, its scripts are executed triggering the evaluation of the entire static module graph. Each imported URL generates a request to the Vite server to get the module code, which ends up handled by the Transform Middleware by calling `server.environments.client.transformRequest(url)`. The connection between the environment instance in the server and the module runner in the browser is carried out through HTTP in this case.\n+\n+:::info transformRequest naming\n+We are using `transformRequest(url)` and `warmupRequest(url)` in the current version of this proposal so it is easier to discuss and understand for users used to Vite's current API. Before releasing, we can take the opportunity to review these names too. For example, it could be named `environment.processModule(url)` or `environment.loadModule(url)` taking a page from Rollup's `context.load(id)` in plugin hooks. For the moment, we think keeping the current names and delaying this discussion is better.\n+:::\n+\n+For the default Node environment, Vite creates a module runner that implements evaluation using `new AsyncFunction` running in the same runtime as the server. This runner is an instance of `ModuleRunner` that exposes:\n+\n+```ts\n+class ModuleRunner {\n+  /**\n+   * URL to execute. Accepts file path, server path, or id relative to the root.\n+   * Returns an instantiated module (same as in ssrLoadModule)\n+   */\n+  public async import(url: string): Promise<Record<string, any>>\n+  /**\n+   * Other ModuleRunner methods...\n+   */\n+```\n+\n+:::info\n+In the v5.1 Runtime API, there were `executeUrl` and `executeEntryPoint` methods - they are now merged into a single `import` method. If you want to opt-out of the HMR support, create a runner with `hmr: false` flag.\n+:::\n+\n+The default SSR Node module runner is not exposed. You can use `createNodeEnvironment` API with `createServerModuleRunner` together to create a runner that runs code in the same thread, supports HMR and doesn't conflict with the SSR implementation (in case it's been overriden in the config). Given a Vite server configured in middleware mode as described by the [SSR setup guide](/guide/ssr#setting-up-the-dev-server), let's implement the SSR middleware using the environment API. Error handling is omitted.\n+\n+```js\n+import {\n+  createServer,\n+  createServerModuleRunner,\n+  createNodeEnvironment,\n+} from 'vite'\n+\n+const server = await createServer({\n+  server: { middlewareMode: true },\n+  appType: 'custom',\n+  environments: {\n+    node: {\n+      dev: {\n+        // Default Vite SSR environment can be overriden in the config, so\n+        // make sure you have a Node environment before the request is received.\n+        createEnvironment: createNodeEnvironment,\n+      },\n+    },\n+  },\n+})\n+\n+const runner = createServerModuleRunner(server.environments.node)\n+\n+app.use('*', async (req, res, next) => {\n+  const url = req.originalUrl\n+\n+  // 1. Read index.html\n+  let template = fs.readFileSync(path.resolve(__dirname, 'index.html'), 'utf-8')\n+\n+  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n+  //    and also applies HTML transforms from Vite plugins, e.g. global\n+  //    preambles from @vitejs/plugin-react\n+  template = await server.transformIndexHtml(url, template)\n+\n+  // 3. Load the server entry. import(url) automatically transforms\n+  //    ESM source code to be usable in Node.js! There is no bundling\n+  //    required, and provides full HMR support.\n+  const { render } = await runner.import('/src/entry-server.js')\n+\n+  // 4. render the app HTML. This assumes entry-server.js's exported\n+  //     `render` function calls appropriate framework SSR APIs,\n+  //    e.g. ReactDOMServer.renderToString()\n+  const appHtml = await render(url)\n+\n+  // 5. Inject the app-rendered HTML into the template.\n+  const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n+\n+  // 6. Send the rendered HTML back.\n+  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n+})\n+```\n+\n+## Environment agnostic SSR\n+\n+::: info\n+It isn't clear yet what APIs Vite should provide to cover the most common SSR use cases. We are thinking on releasing the Environment API without an official way to do environment agnostic SSR to let the ecosystem explore common patterns first.",
        "comment_created_at": "2024-04-29T23:40:41+00:00",
        "comment_author": "IgorMinar",
        "comment_body": "What is the purpose of the built-in `ssr` environment then?",
        "pr_file_module": null
      },
      {
        "comment_id": "1624225758",
        "repo_full_name": "vitejs/vite",
        "pr_number": 16471,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1583924679",
        "commented_code": "@@ -0,0 +1,874 @@\n+# Vite Environment API\n+\n+:::warning Low-level API\n+Initial work for this API was introduced in Vite 5.1 with the name \"Vite Runtime API\". This guide describes a revised API, renamed to Vite Environment API. This API will be released in Vite 6. You can already test it in the latest `vite@6.0.0-alpha.x` version.\n+\n+Resources:\n+\n+- [Environment API PR](https://github.com/vitejs/vite/pull/16471) where the new API is implemented and reviewed.\n+- [Feedback discussion](https://github.com/vitejs/vite/discussions/16358) where we are gathering feedback about the new APIs.\n+\n+Feel free to send us PRs against the `v6/environment-api` branch to fix the issues you discover. Please share with us your feedback as you test the proposal.\n+:::\n+\n+A single Vite dev server can be used to interact with different module execution environments concurrently. We'll use the word environment to refer to a configured Vite processing pipeline that can resolve ids, load, and process source code and is connected to a runtime where the code is executed. The transformed source code is called a module, and the relationships between the modules processed in each environment are kept in a module graph. The code for these modules is sent to the runtimes associated with each environment to be executed. When a module is evaluated, the runtime will request its imported modules triggering the processing of a section of the module graph. In a typical Vite app, an environments will be used for the ES modules served to the client and for the server program that does SSR. An app can do SSR on a Node server, but also on an edge runtime like Workerd. So we can have different types of environments on the same Vite server: browser environments, node environments, and workerd environments, to name a few.\n+\n+A Vite Module Runner allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runner implementation is decoupled from the server. This allows library and framework authors to implement their layer of communication between the Vite server and the runner. The browser communicates with its corresponding environment using the server Web Socket and through HTTP requests. The Node Module runner can directly do function calls to process modules as it is running in the same process. Other environments could run modules connecting to an edge runtime like workerd, or a Worker Thread as Vitest does.\n+\n+All these environments share Vite's HTTP server, middlewares, and Web Socket. The resolved config and plugins pipeline are also shared, but plugins can use `apply` so its hooks are only called for certain environments. The environment can also be accessed inside hooks for fine-grained control.\n+\n+![Vite Environments](../images/vite-environments.svg)\n+\n+## Using environments in the Vite server\n+\n+A Vite dev server exposes two environments by default: a Client environment and a SSR environment. The client environment is a browser environment by default, and the module runner is implemented by importing the virtual module `/@vite/client` to client apps. The SSR environment runs in the same Node runtime as the Vite server by default and allows application servers to be used to render requests during dev with full HMR support. We'll discuss later how frameworks and users can change the environment types for the default client and SSR environments, or register new environments (for example to have a separate module graph for RSC).\n+\n+The available environments can be accessed using `server.environments`:\n+\n+```js\n+const environment = server.environments.client\n+\n+environment.transformRequest(url)\n+\n+console.log(server.environments.ssr.moduleGraph)\n+```\n+\n+Most of the time, the current `environment` instance will be available as part of the context of the code being run so the need to access them through `server.environments` should be rare. For example, inside plugin hooks the enviornment is exposed as part of the `PluginContext`, so it can be accessed using `this.environment`.\n+\n+A dev environment is an instance of the `DevEnvironment` class:\n+\n+```ts\n+class DevEnvironment {\n+  /**\n+   * Unique identifier for the environment in a Vite server.\n+   * By default Vite exposes 'client' and 'ssr' environments.\n+   */\n+  name: string\n+  /**\n+   * Communication channel to send and receive messages from the\n+   * associated module runner in the target runtime.\n+   */\n+  hot: HMRChannel | null\n+  /**\n+   * Graph of module nodes, with the imported relationship between\n+   * processed modules and the cached result of the processed code.\n+   */\n+  moduleGraph: EnvironmentModuleGraph\n+  /**\n+   * Resolved plugins for this environment, including the ones\n+   * created using the per-environment `create` hook\n+   */\n+  plugins: BoundedPlugin[]\n+  /**\n+   * Allows to resolve, load, and transform code through the\n+   * environment plugins pipeline\n+   */\n+  pluginContainer: BoundedPluginContatiner\n+  /**\n+   * TBD: This abstraction isn't yet clear\n+   * Trigger the execution of a module using the associated module runner\n+   * in the target runtime.\n+   */\n+  run: ModuleRunFunction\n+  /**\n+   * Resolved config options for this environment. Options at the server\n+   * global scope are taken as defaults for all environments, and can\n+   * be overridden (resolve conditions, external, optimizedDeps)\n+   */\n+  config: ResolvedDevEnvironmentConfig\n+\n+  constructor(name, config, { hot, run, options }: DevEnvironmentOptions)\n+\n+  /**\n+   * Resolve the URL to an id, load it, and process the code using the\n+   * plugins pipeline. The module graph is also updated.\n+   */\n+  async transformRequest(url: string): TransformResult\n+\n+  /**\n+   * Register a request to be processed with low priority. This is useful\n+   * to avoid waterfalls. The Vite server has information about the imported\n+   * modules by other requests, so it can warmup the module graph so the\n+   * modules are already processed when they are requested.\n+   */\n+  async warmupRequest(url: string): void\n+\n+  /**\n+   * Fetch information about a module from the module runner without running it.\n+   * Note: This method may not be needed\n+   */\n+  async fetchModuleInfo(url: string)\n+}\n+```\n+\n+With `TransformResult` being:\n+\n+```ts\n+interface TransformResult {\n+  code: string\n+  map: SourceMap | { mappings: '' } | null\n+  etag?: string\n+  deps?: string[]\n+  dynamicDeps?: string[]\n+}\n+```\n+\n+An environment instance in the Vite server lets you process a URL using the `environment.transformRequest(url)` method. This function will use the plugin pipeline to resolve the `url` to a module `id`, load it (reading the file from the file system or through a plugin that implements a virtual module), and then transform the code. While transforming the module, imports and other metadata will be recorded in the environment module graph by creating or updating the corresponding module node. When processing is done, the transform result is also stored in the module.\n+\n+But the environment instance can't execute the code itself, as the runtime where the module will be run could be different from the one the Vite server is running in. This is the case for the browser environment. When a html is loaded in the browser, its scripts are executed triggering the evaluation of the entire static module graph. Each imported URL generates a request to the Vite server to get the module code, which ends up handled by the Transform Middleware by calling `server.environments.client.transformRequest(url)`. The connection between the environment instance in the server and the module runner in the browser is carried out through HTTP in this case.\n+\n+:::info transformRequest naming\n+We are using `transformRequest(url)` and `warmupRequest(url)` in the current version of this proposal so it is easier to discuss and understand for users used to Vite's current API. Before releasing, we can take the opportunity to review these names too. For example, it could be named `environment.processModule(url)` or `environment.loadModule(url)` taking a page from Rollup's `context.load(id)` in plugin hooks. For the moment, we think keeping the current names and delaying this discussion is better.\n+:::\n+\n+For the default Node environment, Vite creates a module runner that implements evaluation using `new AsyncFunction` running in the same runtime as the server. This runner is an instance of `ModuleRunner` that exposes:\n+\n+```ts\n+class ModuleRunner {\n+  /**\n+   * URL to execute. Accepts file path, server path, or id relative to the root.\n+   * Returns an instantiated module (same as in ssrLoadModule)\n+   */\n+  public async import(url: string): Promise<Record<string, any>>\n+  /**\n+   * Other ModuleRunner methods...\n+   */\n+```\n+\n+:::info\n+In the v5.1 Runtime API, there were `executeUrl` and `executeEntryPoint` methods - they are now merged into a single `import` method. If you want to opt-out of the HMR support, create a runner with `hmr: false` flag.\n+:::\n+\n+The default SSR Node module runner is not exposed. You can use `createNodeEnvironment` API with `createServerModuleRunner` together to create a runner that runs code in the same thread, supports HMR and doesn't conflict with the SSR implementation (in case it's been overriden in the config). Given a Vite server configured in middleware mode as described by the [SSR setup guide](/guide/ssr#setting-up-the-dev-server), let's implement the SSR middleware using the environment API. Error handling is omitted.\n+\n+```js\n+import {\n+  createServer,\n+  createServerModuleRunner,\n+  createNodeEnvironment,\n+} from 'vite'\n+\n+const server = await createServer({\n+  server: { middlewareMode: true },\n+  appType: 'custom',\n+  environments: {\n+    node: {\n+      dev: {\n+        // Default Vite SSR environment can be overriden in the config, so\n+        // make sure you have a Node environment before the request is received.\n+        createEnvironment: createNodeEnvironment,\n+      },\n+    },\n+  },\n+})\n+\n+const runner = createServerModuleRunner(server.environments.node)\n+\n+app.use('*', async (req, res, next) => {\n+  const url = req.originalUrl\n+\n+  // 1. Read index.html\n+  let template = fs.readFileSync(path.resolve(__dirname, 'index.html'), 'utf-8')\n+\n+  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n+  //    and also applies HTML transforms from Vite plugins, e.g. global\n+  //    preambles from @vitejs/plugin-react\n+  template = await server.transformIndexHtml(url, template)\n+\n+  // 3. Load the server entry. import(url) automatically transforms\n+  //    ESM source code to be usable in Node.js! There is no bundling\n+  //    required, and provides full HMR support.\n+  const { render } = await runner.import('/src/entry-server.js')\n+\n+  // 4. render the app HTML. This assumes entry-server.js's exported\n+  //     `render` function calls appropriate framework SSR APIs,\n+  //    e.g. ReactDOMServer.renderToString()\n+  const appHtml = await render(url)\n+\n+  // 5. Inject the app-rendered HTML into the template.\n+  const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n+\n+  // 6. Send the rendered HTML back.\n+  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n+})\n+```\n+\n+## Environment agnostic SSR\n+\n+::: info\n+It isn't clear yet what APIs Vite should provide to cover the most common SSR use cases. We are thinking on releasing the Environment API without an official way to do environment agnostic SSR to let the ecosystem explore common patterns first.",
        "comment_created_at": "2024-06-03T10:58:49+00:00",
        "comment_author": "patak-dev",
        "comment_body": "Backward compatibility. `server.moduleGraph` has nodes from the `client` and `ssr` environment. And `server.ssrLoadModule(url)` transform the code in the `ssr` environment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797093068",
    "pr_number": 18334,
    "pr_file": "docs/guide/api-environment-frameworks.md",
    "created_at": "2024-10-11T15:07:44+00:00",
    "commented_code": "## Environments and frameworks\n \n-The implicit `ssr` environment and other non-client environments use a `RunnableDevEnvironment` by default during dev. While this is only implementable for some runtimes as it requires the runtime to be the same with the one the Vite server is running in, this works similarly with `ssrLoadModule` and allows frameworks for to migrate and enable HMR during for their SSR dev story. You can guard any runnable environment with an `isRunnableDevEnvironment` function.\n+The implicit `ssr` environment and other non-client environments use a `RunnableDevEnvironment` by default during dev. While this requires the runtime to be the same with the one the Vite server is running in, this works similarly with `ssrLoadModule` and allows frameworks for to migrate and enable HMR during for their SSR dev story. You can guard any runnable environment with an `isRunnableDevEnvironment` function.",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1797093068",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18334,
        "pr_file": "docs/guide/api-environment-frameworks.md",
        "discussion_id": "1797093068",
        "commented_code": "@@ -13,7 +13,7 @@ Please share with us your feedback as you test the proposal.\n \n ## Environments and frameworks\n \n-The implicit `ssr` environment and other non-client environments use a `RunnableDevEnvironment` by default during dev. While this is only implementable for some runtimes as it requires the runtime to be the same with the one the Vite server is running in, this works similarly with `ssrLoadModule` and allows frameworks for to migrate and enable HMR during for their SSR dev story. You can guard any runnable environment with an `isRunnableDevEnvironment` function.\n+The implicit `ssr` environment and other non-client environments use a `RunnableDevEnvironment` by default during dev. While this requires the runtime to be the same with the one the Vite server is running in, this works similarly with `ssrLoadModule` and allows frameworks for to migrate and enable HMR during for their SSR dev story. You can guard any runnable environment with an `isRunnableDevEnvironment` function.",
        "comment_created_at": "2024-10-11T15:07:44+00:00",
        "comment_author": "patak-dev",
        "comment_body": "```suggestion\r\nThe implicit `ssr` environment and other non-client environments use a `RunnableDevEnvironment` by default during dev. While this requires the runtime to be the same with the one the Vite server is running in, this works similarly with `ssrLoadModule` and allows frameworks to migrate and enable HMR for their SSR dev story. You can guard any runnable environment with an `isRunnableDevEnvironment` function.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]