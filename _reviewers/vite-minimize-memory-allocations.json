[
  {
    "discussion_id": "1978495844",
    "pr_number": 19561,
    "pr_file": "packages/vite/src/node/plugins/reporter.ts",
    "created_at": "2025-03-04T02:10:49+00:00",
    "commented_code": "return {\n                       name: chunk.fileName,\n                       group: 'JS',\n-                      size: chunk.code.length,\n+                      size: Buffer.from(chunk.code).length,",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1978495844",
        "repo_full_name": "vitejs/vite",
        "pr_number": 19561,
        "pr_file": "packages/vite/src/node/plugins/reporter.ts",
        "discussion_id": "1978495844",
        "commented_code": "@@ -148,9 +148,11 @@ export function buildReporterPlugin(config: ResolvedConfig): Plugin {\n                     return {\n                       name: chunk.fileName,\n                       group: 'JS',\n-                      size: chunk.code.length,\n+                      size: Buffer.from(chunk.code).length,",
        "comment_created_at": "2025-03-04T02:10:49+00:00",
        "comment_author": "sapphi-red",
        "comment_body": "```suggestion\r\n                      size: Buffer.byteLength(chunk.code),\r\n```\r\n`Buffer.byteLength` should be performant than `Buffer.from().length` as it doesn't require the whole converted value to be held in the memory.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "619794601",
    "pr_number": 2909,
    "pr_file": "packages/vite/src/node/plugins/asset.ts",
    "created_at": "2021-04-25T10:50:07+00:00",
    "commented_code": "let url\n   if (\n     config.build.lib ||\n-    (!file.endsWith('.svg') &&\n-      content.length < Number(config.build.assetsInlineLimit))\n+    Buffer.byteLength(content) < config.build.assetsInlineLimit",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "619794601",
        "repo_full_name": "vitejs/vite",
        "pr_number": 2909,
        "pr_file": "packages/vite/src/node/plugins/asset.ts",
        "discussion_id": "619794601",
        "commented_code": "@@ -199,11 +199,13 @@ async function fileToBuiltUrl(\n   let url\n   if (\n     config.build.lib ||\n-    (!file.endsWith('.svg') &&\n-      content.length < Number(config.build.assetsInlineLimit))\n+    Buffer.byteLength(content) < config.build.assetsInlineLimit",
        "comment_created_at": "2021-04-25T10:50:07+00:00",
        "comment_author": "polarathene",
        "comment_body": "The change to [`byteLength` shouldn't be necessary](https://nodejs.org/api/buffer.html#buffer_static_method_buffer_bytelength_string_encoding). `content` is already [read in as a Buffer as no encoding was specified](https://nodejs.org/api/fs.html#fs_filehandle_readfile_options), thus [`length` should report the same size](https://nodejs.org/api/buffer.html#buffer_buf_length).\r\n\r\nI don't mind it personally as it's more explicit of intent.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1837490798",
    "pr_number": 18550,
    "pr_file": "packages/vite/src/node/utils.ts",
    "created_at": "2024-11-12T05:11:11+00:00",
    "commented_code": "return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)\n+}\n+\n+type MaybeFallback<D, V> = undefined extends V ? Exclude<V, undefined> | D : V\n+\n+type MergeWithDefaultsResult<D, V> =\n+  Equal<D, undefined> extends true\n+    ? V\n+    : D extends Function | Array<any>\n+      ? MaybeFallback<D, V>\n+      : V extends Function | Array<any>\n+        ? MaybeFallback<D, V>\n+        : D extends Record<string, any>\n+          ? V extends Record<string, any>\n+            ? {\n+                [K in keyof D | keyof V]: K extends keyof D\n+                  ? K extends keyof V\n+                    ? MergeWithDefaultsResult<D[K], V[K]>\n+                    : D[K]\n+                  : K extends keyof V\n+                    ? V[K]\n+                    : never\n+              }\n+            : MaybeFallback<D, V>\n+          : MaybeFallback<D, V>\n+\n+export function mergeWithDefaults<\n+  D extends Record<string, any>,\n+  V extends Record<string, any>,\n+>(defaults: D, values: V): MergeWithDefaultsResult<D, V> {\n+  // NOTE: we need to clone the value here to avoid mutating the defaults\n+  const merged: Record<string, any> = deepClone(defaults)\n+  for (const key in values) {",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1837490798",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18550,
        "pr_file": "packages/vite/src/node/utils.ts",
        "discussion_id": "1837490798",
        "commented_code": "@@ -1069,6 +1070,74 @@ function backwardCompatibleWorkerPlugins(plugins: any) {\n   return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)\n+}\n+\n+type MaybeFallback<D, V> = undefined extends V ? Exclude<V, undefined> | D : V\n+\n+type MergeWithDefaultsResult<D, V> =\n+  Equal<D, undefined> extends true\n+    ? V\n+    : D extends Function | Array<any>\n+      ? MaybeFallback<D, V>\n+      : V extends Function | Array<any>\n+        ? MaybeFallback<D, V>\n+        : D extends Record<string, any>\n+          ? V extends Record<string, any>\n+            ? {\n+                [K in keyof D | keyof V]: K extends keyof D\n+                  ? K extends keyof V\n+                    ? MergeWithDefaultsResult<D[K], V[K]>\n+                    : D[K]\n+                  : K extends keyof V\n+                    ? V[K]\n+                    : never\n+              }\n+            : MaybeFallback<D, V>\n+          : MaybeFallback<D, V>\n+\n+export function mergeWithDefaults<\n+  D extends Record<string, any>,\n+  V extends Record<string, any>,\n+>(defaults: D, values: V): MergeWithDefaultsResult<D, V> {\n+  // NOTE: we need to clone the value here to avoid mutating the defaults\n+  const merged: Record<string, any> = deepClone(defaults)\n+  for (const key in values) {",
        "comment_created_at": "2024-11-12T05:11:11+00:00",
        "comment_author": "bluwy",
        "comment_body": "Since `mergeWithDefaults` is being called recursively, when merging nested objects, wouldn't the object be cloned twice? Should we try to optimize this here? I think we'd have to make the cloning inside of `mergeWithDefaults`, and only clone for keys that are in `defaults` but not in `values`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1837546861",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18550,
        "pr_file": "packages/vite/src/node/utils.ts",
        "discussion_id": "1837490798",
        "commented_code": "@@ -1069,6 +1070,74 @@ function backwardCompatibleWorkerPlugins(plugins: any) {\n   return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)\n+}\n+\n+type MaybeFallback<D, V> = undefined extends V ? Exclude<V, undefined> | D : V\n+\n+type MergeWithDefaultsResult<D, V> =\n+  Equal<D, undefined> extends true\n+    ? V\n+    : D extends Function | Array<any>\n+      ? MaybeFallback<D, V>\n+      : V extends Function | Array<any>\n+        ? MaybeFallback<D, V>\n+        : D extends Record<string, any>\n+          ? V extends Record<string, any>\n+            ? {\n+                [K in keyof D | keyof V]: K extends keyof D\n+                  ? K extends keyof V\n+                    ? MergeWithDefaultsResult<D[K], V[K]>\n+                    : D[K]\n+                  : K extends keyof V\n+                    ? V[K]\n+                    : never\n+              }\n+            : MaybeFallback<D, V>\n+          : MaybeFallback<D, V>\n+\n+export function mergeWithDefaults<\n+  D extends Record<string, any>,\n+  V extends Record<string, any>,\n+>(defaults: D, values: V): MergeWithDefaultsResult<D, V> {\n+  // NOTE: we need to clone the value here to avoid mutating the defaults\n+  const merged: Record<string, any> = deepClone(defaults)\n+  for (const key in values) {",
        "comment_created_at": "2024-11-12T06:30:34+00:00",
        "comment_author": "sapphi-red",
        "comment_body": "Good catch! Instead of doing that, I made the `deepClone` to be call only once before merging with defaults (ffb92fdf743026c98edd8830e0868878db36f060, 2d6bc9cc73f15e4b7e551af649bc69c3265e4e0d). This way, the properties of defaults that would be overridden with the values will be cloned unnecessarily compared to your suggestion, but I think that's negligible.\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1837559368",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18550,
        "pr_file": "packages/vite/src/node/utils.ts",
        "discussion_id": "1837490798",
        "commented_code": "@@ -1069,6 +1070,74 @@ function backwardCompatibleWorkerPlugins(plugins: any) {\n   return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)\n+}\n+\n+type MaybeFallback<D, V> = undefined extends V ? Exclude<V, undefined> | D : V\n+\n+type MergeWithDefaultsResult<D, V> =\n+  Equal<D, undefined> extends true\n+    ? V\n+    : D extends Function | Array<any>\n+      ? MaybeFallback<D, V>\n+      : V extends Function | Array<any>\n+        ? MaybeFallback<D, V>\n+        : D extends Record<string, any>\n+          ? V extends Record<string, any>\n+            ? {\n+                [K in keyof D | keyof V]: K extends keyof D\n+                  ? K extends keyof V\n+                    ? MergeWithDefaultsResult<D[K], V[K]>\n+                    : D[K]\n+                  : K extends keyof V\n+                    ? V[K]\n+                    : never\n+              }\n+            : MaybeFallback<D, V>\n+          : MaybeFallback<D, V>\n+\n+export function mergeWithDefaults<\n+  D extends Record<string, any>,\n+  V extends Record<string, any>,\n+>(defaults: D, values: V): MergeWithDefaultsResult<D, V> {\n+  // NOTE: we need to clone the value here to avoid mutating the defaults\n+  const merged: Record<string, any> = deepClone(defaults)\n+  for (const key in values) {",
        "comment_created_at": "2024-11-12T06:45:12+00:00",
        "comment_author": "bluwy",
        "comment_body": "Works for me!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1837561593",
    "pr_number": 18550,
    "pr_file": "packages/vite/src/node/utils.ts",
    "created_at": "2024-11-12T06:47:44+00:00",
    "commented_code": "return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1837561593",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18550,
        "pr_file": "packages/vite/src/node/utils.ts",
        "discussion_id": "1837561593",
        "commented_code": "@@ -1069,6 +1070,82 @@ function backwardCompatibleWorkerPlugins(plugins: any) {\n   return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)",
        "comment_created_at": "2024-11-12T06:47:44+00:00",
        "comment_author": "bluwy",
        "comment_body": "Since arrays, objects and functions are already handled above, what cases are covered here with the `structuredClone`? From a [quick test](https://perf.link/#eyJpZCI6InhtNWliaWk2ajN6IiwidGl0bGUiOiJzdHJ1Y3R1cmVkQ2xvbmUgaW1wYWN0IiwiYmVmb3JlIjoiY29uc3QgZGF0YSA9IFsuLi5BcnJheSgxMDAwKS5rZXlzKCldIiwidGVzdHMiOlt7Im5hbWUiOiJTaW1wbGUiLCJjb2RlIjoiZGF0YS5maW5kKHggPT4geCA9PT0gMTAwKSIsInJ1bnMiOlsxMDAwLDg3NDAwMCw2MTAwMCwxNTQwMDAsMTQ4NTAwMCw2MTMwMDAsMTA3NTAwMCwxMDAwLDE0MzAwMDAsMjIyMDAwMCwxMzQwMDAsMTM3MDAwLDEwMDAwLDUwMDAsNjkwMDAsMjE5MDAwLDMwMzAwMCwzMzIwMDAsMjQxMDAwLDIwMDAsMjU4MDAwLDU5ODAwMCwzNzAwMDAsNTAwMCw1NDAwMCwxMzgwMDAsNDgwMDAsNDAwMDAsMTQ5MDAwLDY5MzAwMCwzMTAwMCw2NDEwMDAsMTM1MDAwLDM0NzAwMCwxNDEwMDAsMTcwMDAsMTEwMDAwLDE3MzAwMCw1MzcwMDAsNzAwMCwxMzAwMCwyMjcwMDAsMTQxMDAwLDEzNDAwMCwxNTgwMDAsMTM1MDAwLDEzMjAwMCwxNTIwMDAsMjUwMDAsODAwMDAsNjcwMDAsMTIwNDAwMCwyMDM5MDAwLDIzMjAwMCwxMTAwMDAsNTQwMDAsNjcwMDAsMTg5MDAwLDkwMjAwMCwxNjYwMDAsNTgwMDAsNDYwMDAsMTAyMDAwLDQyNjAwMCwyNzAwMCwxOTgwMDAsMTYyMDAwLDIxMjkwMDAsMTQwMDAsMjMzMDAwLDExNzAwMCwyNDcwMDAsNTEwMDAsMTEyMDAwLDIwMzAwMCwxNTEwMDAsNTE0MDAwLDEwODAwMCw4MTAwMCw1NDUwMDAsMTUyMDAwLDQ3MDAwLDMxMDAwMCw1MDAwLDEzMjAwMCwyMzAwMDAsMTczMDAwLDUxODAwMCw4MjAwMCwyMDAwLDE5MDAwMCwzNjIwMDAsMjA0MDAwLDI1ODAwMCwyMDAwLDEyNzAwMCwxNDQwMDAsMTAzMDAwLDU2MjAwMCwzMTYwMDBdLCJvcHMiOjI5NTI4MH0seyJuYW1lIjoic3R1Y3R1cmVkQ2xvbmUiLCJjb2RlIjoiZGF0YS5maW5kKHggPT4gc3RydWN0dXJlZENsb25lKHgpID09PSAxMDApIiwicnVucyI6WzIwMDAsMzAwMCwyNTAwMCwxNjAwMCwyNDAwMCwyNjAwMCwyNDAwMCwzMTAwMCwyMTAwMCwzODAwMCw1MDAwLDQwMDAsMTAwMCwxMDAwLDMwMDAsODAwMCwxMjAwMCw2MDAwLDQwMDAsMzAwMCwxMTAwMCw1MDAwLDEyMDAwLDYwMDAsNjAwMCw1MDAwLDcwMDAsNjAwMCw5MDAwLDE4MDAwLDMwMDAsNTAwMCwxMjAwMCwxMDAwMCwxMjAwMCwyMDAwLDYwMDAsNzAwMCwxNjAwMCwyMDAwLDUwMDAsMTAwMDAsNDAwMCw1MDAwLDEyMDAwLDE5MDAwLDcwMDAsNzAwMCw4MDAwLDExMDAwLDUwMDAsMjQwMDAsMzYwMDAsMTAwMDAsMTMwMDAsNDAwMCw0MDAwLDgwMDAsNDAwMCw4MDAwLDcwMDAsMTAwMDAsNDAwMCwxNTAwMCw4MDAwLDEwMDAwLDUwMDAsMjcwMDAsMTQwMDAsNjAwMCw2MDAwLDYwMDAsMjAwMCw1MDAwLDgwMDAsNjAwMCwxNDAwMCwxMDAwLDcwMDAsOTAwMCw3MDAwLDgwMDAsODAwMCwzMDAwLDYwMDAsMTEwMDAsMTIwMDAsOTAwMCwxMDAwMCwxMDAwLDcwMDAsNzAwMCw5MDAwLDkwMDAsMTQwMDAsMzAwMCw3MDAwLDgwMDAsOTAwMCw4MDAwXSwib3BzIjo5NDcwfV0sInVwZGF0ZWQiOiIyMDI0LTExLTEyVDA2OjQzOjA1LjAyOFoifQ%3D%3D), `structuredClone` seems to have a big perf impact when used on basic primitives.",
        "pr_file_module": null
      },
      {
        "comment_id": "1837594231",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18550,
        "pr_file": "packages/vite/src/node/utils.ts",
        "discussion_id": "1837561593",
        "commented_code": "@@ -1069,6 +1070,82 @@ function backwardCompatibleWorkerPlugins(plugins: any) {\n   return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)",
        "comment_created_at": "2024-11-12T07:23:56+00:00",
        "comment_author": "sapphi-red",
        "comment_body": "It was mainly for `RegExp`. I put the `structuredClone` in a condition \ud83d\udc4d (38162a0a1603da5de06d683d97a1b175289caeeb, e4364e59fbd760c2f7f6e63a2cc137720cd2690d).",
        "pr_file_module": null
      },
      {
        "comment_id": "1837644681",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18550,
        "pr_file": "packages/vite/src/node/utils.ts",
        "discussion_id": "1837561593",
        "commented_code": "@@ -1069,6 +1070,82 @@ function backwardCompatibleWorkerPlugins(plugins: any) {\n   return []\n }\n \n+function deepClone<T>(value: T): T {\n+  if (Array.isArray(value)) {\n+    return value.map((v) => deepClone(v)) as T\n+  }\n+  if (isObject(value)) {\n+    const cloned: Record<string, any> = {}\n+    for (const key in value) {\n+      cloned[key] = deepClone(value[key])\n+    }\n+    return cloned as T\n+  }\n+  if (typeof value === 'function') {\n+    return value as T\n+  }\n+  return structuredClone(value)",
        "comment_created_at": "2024-11-12T08:08:47+00:00",
        "comment_author": "bluwy",
        "comment_body": "I don't think it's likely for someone to mutate a `RegExp`, but I don't mind having the code for it either ways.",
        "pr_file_module": null
      }
    ]
  }
]