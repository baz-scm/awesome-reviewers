[
  {
    "discussion_id": "1796787223",
    "pr_number": 18334,
    "pr_file": "docs/guide/api-environment-frameworks.md",
    "created_at": "2024-10-11T10:53:29+00:00",
    "commented_code": "})\n ```\n \n-::: warning Accessing Module on the Server\n-We do not want to encourage communication between the server and the runner. One of the problems that was exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since user environment might have no access to server APIs. For example, this code assumes that Vite server and user code can run in the same context:\n+## Runtime agnostic SSR\n+\n+Since the `RunnableDevEnvironment` can only be used to run the code in the same runtime as the Vite server, it requires a runtime that can run the Vite Server (a runtime that is compatible with Node.js). This means that you will need to use the raw `DevEnvironment` to make it runtime agnostic.\n+\n+:::info `FetchableDevEnvironment` proposal\n+\n+The initial proposal had a `run` method on the `DevEnvironment` class that would allow consumers to invoke an import on the runner side by using the `transport` option. During our testing we found out that the API was not universal enough to start recommending it. At the moment, we are looking for feedback on [the `FetchableDevEnvironment` proposal](https://github.com/vitejs/vite/discussions/18191).\n+\n+:::\n+\n+`RunnableDevEnvironment` has a `runner.import` function that returns the value of the module. But this function is not available in the raw `DevEnvironment` and requires the code using the Vite's APIs and the user modules to be decoupled.\n+\n+For example, the following example uses the value of the user module from the code using the Vite's APIs:\n \n ```ts\n-const vite = createServer()\n-const routes = collectRoutes()\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n+\n+const server = createServer()\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+const { createHandler } = await ssrEnvironment.runner.import('./entrypoint.js')\n+const handler = createHandler(input)\n+const response = handler(new Request('/'))\n \n-const { processRoutes } = await vite.ssrLoadModule('internal:routes-processor')\n-processRoutes(routes)\n+// -------------------------------------\n+// ./entrypoint.js\n+export function createHandler(input) {\n+  return function handler(req) {\n+    return new Response('hello')\n+  }\n+}\n ```\n \n-This makes it impossible to run user code in the same way it might run in production (for example, on the edge) because the server state and user state are coupled. So instead, we recommend using virtual modules to import the state and process it inside the user module:\n+If your code can run in the same runtime with the user modules (= does not rely on Node.js specific APIs), you can use a virtual module so that you don't need to access the value from the code using the Vite's APIs.\n \n ```ts\n-// this code runs on another machine or in another thread\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n \n-import { runner } from './ssr-module-runner.js'\n-import { processRoutes } from './routes-processor.js'\n+const server = createServer({\n+  plugins: [\n+    // a plugin that handles `virtual:entrypoint`\n+    {\n+      name: 'virtual-module',\n+      /* plugin implementation */\n+    },\n+  ],\n+})\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+// use exposed functions by each environment factories that runs the code\n+// check for each environment factories what they provide\n+if (ssrEnvironment instanceof RunnableDevEnvironment) {\n+  ssrEnvironment.runner.import('virtual:entrypoint')\n+} else if (ssrEnvironment instanceof CloudflareDevEnvironment) {\n+  ssrEnvironment.evaluate('virtual:entrypoint')",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1796787223",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18334,
        "pr_file": "docs/guide/api-environment-frameworks.md",
        "discussion_id": "1796787223",
        "commented_code": "@@ -86,30 +86,85 @@ app.use('*', async (req, res, next) => {\n })\n ```\n \n-::: warning Accessing Module on the Server\n-We do not want to encourage communication between the server and the runner. One of the problems that was exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since user environment might have no access to server APIs. For example, this code assumes that Vite server and user code can run in the same context:\n+## Runtime agnostic SSR\n+\n+Since the `RunnableDevEnvironment` can only be used to run the code in the same runtime as the Vite server, it requires a runtime that can run the Vite Server (a runtime that is compatible with Node.js). This means that you will need to use the raw `DevEnvironment` to make it runtime agnostic.\n+\n+:::info `FetchableDevEnvironment` proposal\n+\n+The initial proposal had a `run` method on the `DevEnvironment` class that would allow consumers to invoke an import on the runner side by using the `transport` option. During our testing we found out that the API was not universal enough to start recommending it. At the moment, we are looking for feedback on [the `FetchableDevEnvironment` proposal](https://github.com/vitejs/vite/discussions/18191).\n+\n+:::\n+\n+`RunnableDevEnvironment` has a `runner.import` function that returns the value of the module. But this function is not available in the raw `DevEnvironment` and requires the code using the Vite's APIs and the user modules to be decoupled.\n+\n+For example, the following example uses the value of the user module from the code using the Vite's APIs:\n \n ```ts\n-const vite = createServer()\n-const routes = collectRoutes()\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n+\n+const server = createServer()\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+const { createHandler } = await ssrEnvironment.runner.import('./entrypoint.js')\n+const handler = createHandler(input)\n+const response = handler(new Request('/'))\n \n-const { processRoutes } = await vite.ssrLoadModule('internal:routes-processor')\n-processRoutes(routes)\n+// -------------------------------------\n+// ./entrypoint.js\n+export function createHandler(input) {\n+  return function handler(req) {\n+    return new Response('hello')\n+  }\n+}\n ```\n \n-This makes it impossible to run user code in the same way it might run in production (for example, on the edge) because the server state and user state are coupled. So instead, we recommend using virtual modules to import the state and process it inside the user module:\n+If your code can run in the same runtime with the user modules (= does not rely on Node.js specific APIs), you can use a virtual module so that you don't need to access the value from the code using the Vite's APIs.\n \n ```ts\n-// this code runs on another machine or in another thread\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n \n-import { runner } from './ssr-module-runner.js'\n-import { processRoutes } from './routes-processor.js'\n+const server = createServer({\n+  plugins: [\n+    // a plugin that handles `virtual:entrypoint`\n+    {\n+      name: 'virtual-module',\n+      /* plugin implementation */\n+    },\n+  ],\n+})\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+// use exposed functions by each environment factories that runs the code\n+// check for each environment factories what they provide\n+if (ssrEnvironment instanceof RunnableDevEnvironment) {\n+  ssrEnvironment.runner.import('virtual:entrypoint')\n+} else if (ssrEnvironment instanceof CloudflareDevEnvironment) {\n+  ssrEnvironment.evaluate('virtual:entrypoint')",
        "comment_created_at": "2024-10-11T10:53:29+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "maybe it's better to have a fetchable API here? The `evaluate` and `cloudflare` are a bit confusing here - especially because `cloudflare` is a fetchable environment",
        "pr_file_module": null
      },
      {
        "comment_id": "1797043517",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18334,
        "pr_file": "docs/guide/api-environment-frameworks.md",
        "discussion_id": "1796787223",
        "commented_code": "@@ -86,30 +86,85 @@ app.use('*', async (req, res, next) => {\n })\n ```\n \n-::: warning Accessing Module on the Server\n-We do not want to encourage communication between the server and the runner. One of the problems that was exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since user environment might have no access to server APIs. For example, this code assumes that Vite server and user code can run in the same context:\n+## Runtime agnostic SSR\n+\n+Since the `RunnableDevEnvironment` can only be used to run the code in the same runtime as the Vite server, it requires a runtime that can run the Vite Server (a runtime that is compatible with Node.js). This means that you will need to use the raw `DevEnvironment` to make it runtime agnostic.\n+\n+:::info `FetchableDevEnvironment` proposal\n+\n+The initial proposal had a `run` method on the `DevEnvironment` class that would allow consumers to invoke an import on the runner side by using the `transport` option. During our testing we found out that the API was not universal enough to start recommending it. At the moment, we are looking for feedback on [the `FetchableDevEnvironment` proposal](https://github.com/vitejs/vite/discussions/18191).\n+\n+:::\n+\n+`RunnableDevEnvironment` has a `runner.import` function that returns the value of the module. But this function is not available in the raw `DevEnvironment` and requires the code using the Vite's APIs and the user modules to be decoupled.\n+\n+For example, the following example uses the value of the user module from the code using the Vite's APIs:\n \n ```ts\n-const vite = createServer()\n-const routes = collectRoutes()\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n+\n+const server = createServer()\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+const { createHandler } = await ssrEnvironment.runner.import('./entrypoint.js')\n+const handler = createHandler(input)\n+const response = handler(new Request('/'))\n \n-const { processRoutes } = await vite.ssrLoadModule('internal:routes-processor')\n-processRoutes(routes)\n+// -------------------------------------\n+// ./entrypoint.js\n+export function createHandler(input) {\n+  return function handler(req) {\n+    return new Response('hello')\n+  }\n+}\n ```\n \n-This makes it impossible to run user code in the same way it might run in production (for example, on the edge) because the server state and user state are coupled. So instead, we recommend using virtual modules to import the state and process it inside the user module:\n+If your code can run in the same runtime with the user modules (= does not rely on Node.js specific APIs), you can use a virtual module so that you don't need to access the value from the code using the Vite's APIs.\n \n ```ts\n-// this code runs on another machine or in another thread\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n \n-import { runner } from './ssr-module-runner.js'\n-import { processRoutes } from './routes-processor.js'\n+const server = createServer({\n+  plugins: [\n+    // a plugin that handles `virtual:entrypoint`\n+    {\n+      name: 'virtual-module',\n+      /* plugin implementation */\n+    },\n+  ],\n+})\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+// use exposed functions by each environment factories that runs the code\n+// check for each environment factories what they provide\n+if (ssrEnvironment instanceof RunnableDevEnvironment) {\n+  ssrEnvironment.runner.import('virtual:entrypoint')\n+} else if (ssrEnvironment instanceof CloudflareDevEnvironment) {\n+  ssrEnvironment.evaluate('virtual:entrypoint')",
        "comment_created_at": "2024-10-11T14:29:38+00:00",
        "comment_author": "sapphi-red",
        "comment_body": "I've pushed a commit that replaces them with `CustomDevEnvironment` and `.runEntrypoint` so that it doesn't look like it can satisfy the `FetchableDevEnvironment` interface.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797072711",
    "pr_number": 18334,
    "pr_file": "docs/guide/api-environment-frameworks.md",
    "created_at": "2024-10-11T14:51:59+00:00",
    "commented_code": "})\n ```\n \n-::: warning Accessing Module on the Server\n-We do not want to encourage communication between the server and the runner. One of the problems that was exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since user environment might have no access to server APIs. For example, this code assumes that Vite server and user code can run in the same context:\n+## Runtime agnostic SSR\n+\n+Since the `RunnableDevEnvironment` can only be used to run the code in the same runtime as the Vite server, it requires a runtime that can run the Vite Server (a runtime that is compatible with Node.js). This means that you will need to use the raw `DevEnvironment` to make it runtime agnostic.\n+\n+:::info `FetchableDevEnvironment` proposal\n+\n+The initial proposal had a `run` method on the `DevEnvironment` class that would allow consumers to invoke an import on the runner side by using the `transport` option. During our testing we found out that the API was not universal enough to start recommending it. At the moment, we are looking for feedback on [the `FetchableDevEnvironment` proposal](https://github.com/vitejs/vite/discussions/18191).\n+\n+:::\n+\n+`RunnableDevEnvironment` has a `runner.import` function that returns the value of the module. But this function is not available in the raw `DevEnvironment` and requires the code using the Vite's APIs and the user modules to be decoupled.\n+\n+For example, the following example uses the value of the user module from the code using the Vite's APIs:\n \n ```ts\n-const vite = createServer()\n-const routes = collectRoutes()\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n+\n+const server = createServer()\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+const { createHandler } = await ssrEnvironment.runner.import('./entrypoint.js')\n+const handler = createHandler(input)\n+const response = handler(new Request('/'))\n \n-const { processRoutes } = await vite.ssrLoadModule('internal:routes-processor')\n-processRoutes(routes)\n+// -------------------------------------\n+// ./entrypoint.js\n+export function createHandler(input) {\n+  return function handler(req) {\n+    return new Response('hello')\n+  }\n+}\n ```\n \n-This makes it impossible to run user code in the same way it might run in production (for example, on the edge) because the server state and user state are coupled. So instead, we recommend using virtual modules to import the state and process it inside the user module:\n+If your code can run in the same runtime with the user modules (= does not rely on Node.js specific APIs), you can use a virtual module so that you don't need to access the value from the code using the Vite's APIs.",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1797072711",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18334,
        "pr_file": "docs/guide/api-environment-frameworks.md",
        "discussion_id": "1797072711",
        "commented_code": "@@ -86,30 +86,85 @@ app.use('*', async (req, res, next) => {\n })\n ```\n \n-::: warning Accessing Module on the Server\n-We do not want to encourage communication between the server and the runner. One of the problems that was exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since user environment might have no access to server APIs. For example, this code assumes that Vite server and user code can run in the same context:\n+## Runtime agnostic SSR\n+\n+Since the `RunnableDevEnvironment` can only be used to run the code in the same runtime as the Vite server, it requires a runtime that can run the Vite Server (a runtime that is compatible with Node.js). This means that you will need to use the raw `DevEnvironment` to make it runtime agnostic.\n+\n+:::info `FetchableDevEnvironment` proposal\n+\n+The initial proposal had a `run` method on the `DevEnvironment` class that would allow consumers to invoke an import on the runner side by using the `transport` option. During our testing we found out that the API was not universal enough to start recommending it. At the moment, we are looking for feedback on [the `FetchableDevEnvironment` proposal](https://github.com/vitejs/vite/discussions/18191).\n+\n+:::\n+\n+`RunnableDevEnvironment` has a `runner.import` function that returns the value of the module. But this function is not available in the raw `DevEnvironment` and requires the code using the Vite's APIs and the user modules to be decoupled.\n+\n+For example, the following example uses the value of the user module from the code using the Vite's APIs:\n \n ```ts\n-const vite = createServer()\n-const routes = collectRoutes()\n+// code using the Vite's APIs\n+import { createServer } from 'vite'\n+\n+const server = createServer()\n+const ssrEnvironment = server.environment.ssr\n+const input = {}\n+\n+const { createHandler } = await ssrEnvironment.runner.import('./entrypoint.js')\n+const handler = createHandler(input)\n+const response = handler(new Request('/'))\n \n-const { processRoutes } = await vite.ssrLoadModule('internal:routes-processor')\n-processRoutes(routes)\n+// -------------------------------------\n+// ./entrypoint.js\n+export function createHandler(input) {\n+  return function handler(req) {\n+    return new Response('hello')\n+  }\n+}\n ```\n \n-This makes it impossible to run user code in the same way it might run in production (for example, on the edge) because the server state and user state are coupled. So instead, we recommend using virtual modules to import the state and process it inside the user module:\n+If your code can run in the same runtime with the user modules (= does not rely on Node.js specific APIs), you can use a virtual module so that you don't need to access the value from the code using the Vite's APIs.",
        "comment_created_at": "2024-10-11T14:51:59+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "```suggestion\r\nIf your code can run in the same runtime as the user modules (i.e., it does not rely on Node.js-specific APIs), you can use a virtual module. This approach eliminates the need to access the value from the code using Vite's APIs.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797073963",
    "pr_number": 18334,
    "pr_file": "docs/guide/api-environment-frameworks.md",
    "created_at": "2024-10-11T14:53:02+00:00",
    "commented_code": "}\n ```\n \n-Then in SSR entry point you can call `import('virtual:index-html')` to retrieve the processed HTML:\n+If your code requires Node.js APIs, you can use `hot.send` to communicate with the code that uses Vite's APIs from the user modules. Note that you might not achieve the same thing after build.",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1797073963",
        "repo_full_name": "vitejs/vite",
        "pr_number": 18334,
        "pr_file": "docs/guide/api-environment-frameworks.md",
        "discussion_id": "1797073963",
        "commented_code": "@@ -140,35 +195,68 @@ function vitePluginVirtualIndexHtml(): Plugin {\n }\n ```\n \n-Then in SSR entry point you can call `import('virtual:index-html')` to retrieve the processed HTML:\n+If your code requires Node.js APIs, you can use `hot.send` to communicate with the code that uses Vite's APIs from the user modules. Note that you might not achieve the same thing after build.",
        "comment_created_at": "2024-10-11T14:53:02+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "```suggestion\r\nIf your code requires Node.js APIs, you can use `hot.send` to communicate with the code that uses Vite's APIs from the user modules. However, be aware that this approach may not work the same way after the build process.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1673900777",
    "pr_number": 17660,
    "pr_file": "docs/guide/api-vite-environment.md",
    "created_at": "2024-07-11T12:06:45+00:00",
    "commented_code": ":::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('ssr:routes')\n+processRoutes(routes)\n+```\n+\n+You can also use virtual modules to load HTML:\n+\n+```ts {13-21}\n+function vitePluginVirtualIndexHtml(): Plugin {\n+  let server: ViteDevServer | undefined\n+  return {\n+    name: vitePluginVirtualIndexHtml.name,\n+    configureServer(server_) {\n+      server = server_\n+    },\n+    resolveId(source, _importer, _options) {\n+      return source === 'virtual:index-html' ? '\\0' + source : undefined\n+    },\n+    async load(id, _options) {\n+      if (id === '\\0' + 'virtual:index-html') {",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1673900777",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1673900777",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('ssr:routes')\n+processRoutes(routes)\n+```\n+\n+You can also use virtual modules to load HTML:\n+\n+```ts {13-21}\n+function vitePluginVirtualIndexHtml(): Plugin {\n+  let server: ViteDevServer | undefined\n+  return {\n+    name: vitePluginVirtualIndexHtml.name,\n+    configureServer(server_) {\n+      server = server_\n+    },\n+    resolveId(source, _importer, _options) {\n+      return source === 'virtual:index-html' ? '\\0' + source : undefined\n+    },\n+    async load(id, _options) {\n+      if (id === '\\0' + 'virtual:index-html') {",
        "comment_created_at": "2024-07-11T12:06:45+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "Should we expose this as something like `runner.html(url, htmlPath)`? Feels weird that every framework now has to implement this\r\n\r\ncc @patak-dev @hi-ogawa ",
        "pr_file_module": null
      },
      {
        "comment_id": "1673903423",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1673900777",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('ssr:routes')\n+processRoutes(routes)\n+```\n+\n+You can also use virtual modules to load HTML:\n+\n+```ts {13-21}\n+function vitePluginVirtualIndexHtml(): Plugin {\n+  let server: ViteDevServer | undefined\n+  return {\n+    name: vitePluginVirtualIndexHtml.name,\n+    configureServer(server_) {\n+      server = server_\n+    },\n+    resolveId(source, _importer, _options) {\n+      return source === 'virtual:index-html' ? '\\0' + source : undefined\n+    },\n+    async load(id, _options) {\n+      if (id === '\\0' + 'virtual:index-html') {",
        "comment_created_at": "2024-07-11T12:09:00+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "To support `runner.html()`, we would have to ask for `fetchHtml` method alongside `fetchModule` (right now transport only requires `fetchModule`) - or I guess we can also have an option like `html: true` 🤔 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1674894090",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1673900777",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('ssr:routes')\n+processRoutes(routes)\n+```\n+\n+You can also use virtual modules to load HTML:\n+\n+```ts {13-21}\n+function vitePluginVirtualIndexHtml(): Plugin {\n+  let server: ViteDevServer | undefined\n+  return {\n+    name: vitePluginVirtualIndexHtml.name,\n+    configureServer(server_) {\n+      server = server_\n+    },\n+    resolveId(source, _importer, _options) {\n+      return source === 'virtual:index-html' ? '\\0' + source : undefined\n+    },\n+    async load(id, _options) {\n+      if (id === '\\0' + 'virtual:index-html') {",
        "comment_created_at": "2024-07-12T00:40:59+00:00",
        "comment_author": "hi-ogawa",
        "comment_body": "I use `index.html` for my quick setup (and also create-vite-extra template too e.g. https://github.com/bluwy/create-vite-extra/blob/master/template-ssr-react/server.js), but in practice, I'm not sure if actual framework would benefit from this since they usually have more opinionated way to generate the html shell.\r\n\r\nAt least for the frameworks I'm aware of, they don't have `index.html` convention. Instead, they have only \"client entry\" script and they can use it as `rollupOpitons.input`. They also have an access to client build manifest, so they can find \"production client entry\" asset path from manifest and renders `<script>` (also `<link>` for css, preload, etc...) on their own into their html shell.\r\n\r\nSo, I think having `runner.html()` would help only \"entry level\" ssr framework exploration and I'm not sure if it's worth it to have in core. For that case, showing this `virtual:index-html` idea here is probably helpful enough.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1674928197",
    "pr_number": 17660,
    "pr_file": "docs/guide/api-vite-environment.md",
    "created_at": "2024-07-12T01:19:09+00:00",
    "commented_code": ":::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('virtual:ssr-routes')\n+processRoutes(routes)\n+```",
    "repo_full_name": "vitejs/vite",
    "discussion_comments": [
      {
        "comment_id": "1674928197",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1674928197",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('virtual:ssr-routes')\n+processRoutes(routes)\n+```",
        "comment_created_at": "2024-07-12T01:19:09+00:00",
        "comment_author": "hi-ogawa",
        "comment_body": "I'm not sure what code was the anti-pattern from this sample code. If you have something concrete in your mind, can you add that too?",
        "pr_file_module": null
      },
      {
        "comment_id": "1676185809",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1674928197",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('virtual:ssr-routes')\n+processRoutes(routes)\n+```",
        "comment_created_at": "2024-07-12T16:40:19+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "Added an example",
        "pr_file_module": null
      },
      {
        "comment_id": "1677245222",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1674928197",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('virtual:ssr-routes')\n+processRoutes(routes)\n+```",
        "comment_created_at": "2024-07-15T01:06:32+00:00",
        "comment_author": "hi-ogawa",
        "comment_body": "I'm not sure if this example explains the best. What I think is an anti-pattern (i.e. not remote runner compatible) is how \"runtime\" code accesses resources on dev server.\r\n\r\nOne simplest example is `index.html`. If it weren't sandboxed environment, `entry-server.js` (this is what I mean by runtime code) can simply access it by `fs.readFile(\"index.html\")`. But this can be easily make it remote-runner-compatible by using `import(\"/index.html?raw\")` instead.\r\n\r\nThen additionally, If users need to make use of `transformIndexHtml`, then previously it's possible to do `configureServer(server) { globalThis.__vite_server = server }` in the plugin then runtime code to access `__vite_server.transformIndexHtml`. To make this remote-runner-compatible, users need to make this part as virtual module instead of simple `?raw` import.\r\n\r\nIn this aspect, I think Remix is the most \"remote runner compatible\" framework and thus Frandiox (hydrogen), Dario, and I are able to run Remix on Cloudflare workerd. \r\n\r\nActually, there's one thing Remix relies on `globalThis` to let server runtime easily collect css, but I was thinking that this should be rewritten as virtual module like `virtual:remix-critical-css/(path)`. Currently, I think Frandiox dealt with this by proxying `globalThis.__remix_devServerHooks` between two worlds by https://github.com/Shopify/hydrogen/blob/7d0bfe8cdf7dc333fba3c16c37bd3497e996bfb3/packages/hydrogen/src/vite/plugin.ts#L136-L160 and I also did something similar https://github.com/hi-ogawa/vite-plugins/blob/d1a1e2ac81260e9c426b33ee3bd318e6454fe913/packages/vite-node-miniflare/examples/remix/vite.config.ts#L32-L38\r\nThis could be an anti-pattern example, but probably it's rather too specific.",
        "pr_file_module": null
      },
      {
        "comment_id": "1677512605",
        "repo_full_name": "vitejs/vite",
        "pr_number": 17660,
        "pr_file": "docs/guide/api-vite-environment.md",
        "discussion_id": "1674928197",
        "commented_code": "@@ -804,7 +804,74 @@ await createServer({\n \n :::\n \n-`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together. If you don't use either of them, then you can define your own function to communicate between the runner and the server.\n+`RemoteRunnerTransport` and `RemoteEnvironmentTransport` are meant to be used together, but you don't have to use them at all. You can define your own function to communicate between the runner and the server. For example, if you connect to the environment via an HTTP request, you can call `fetch().json()` in `fetchModule` function:\n+\n+```ts\n+import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n+\n+const runner = new ModuleRunner(\n+  {\n+    root: fileURLToPath(new URL('./', import.meta.url)),\n+    transport: {\n+      async fetchModule(id, importer) {\n+        const response = await fetch(\n+          `http://my-vite-server/fetch?id=${id}&importer=${importer}`,\n+        )\n+        return response.json()\n+      },\n+    },\n+  },\n+  new ESModulesEvaluator(),\n+)\n+\n+await runner.import('/entry.js')\n+```\n+\n+::: warning Acessing Module on the Server\n+We do not want to encourage communication between the server and the runner. One of the problems that were exposed with `vite.ssrLoadModule` is over-reliance on the server state inside the processed modules. This makes it harder to implement runtime-agnostic SSR since there might be no direct access to the server APIs that are available in Node.js.\n+\n+Instead, we recommend using virtual modules to import the state and process it inside the loaded environment module:\n+\n+```ts\n+import { runner } from './ssr-module-runner.js'\n+import { processRoutes } from './routes.js'\n+\n+const { routes } = await runner.import('virtual:ssr-routes')\n+processRoutes(routes)\n+```",
        "comment_created_at": "2024-07-15T09:00:37+00:00",
        "comment_author": "sheremet-va",
        "comment_body": "My example shows that the server state is not tied to Vite, but is still stored on the server (by loading a config, for example) - this is quite easy to show as an example because it's easy to migrate. The problems I see with `index.html` example:\r\n- you said that not every framework needs this method, so the example can be rather obscure if you don't know what it is (I was very confused by this function for a long time until I figured out why it's needed)\r\n- the example with `index.html` doesn't call `ssrLoadModule` which is crucial to showcase in the module runner example\r\n- I don't think it showcases the coupling with the server enough (the current example also suffers from it)\r\n\r\nMaybe have an example with `.moduleGraph`? It would also be transformed into a virtual module, I guess",
        "pr_file_module": null
      }
    ]
  }
]