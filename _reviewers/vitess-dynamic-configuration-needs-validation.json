[
  {
    "discussion_id": "2020520295",
    "pr_number": 18005,
    "pr_file": "go/vt/vtorc/config/config.go",
    "created_at": "2025-03-31T07:23:59+00:00",
    "commented_code": "},\n \t)\n \n+\tallowRecovery = viperutil.Configure(\n+\t\t\"allow-recovery\",\n+\t\tviperutil.Options[bool]{\n+\t\t\tFlagName: \"allow-recovery\",\n+\t\t\tDefault:  true,\n+\t\t\tDynamic:  true,",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2020520295",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18005,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "2020520295",
        "commented_code": "@@ -192,6 +192,15 @@ var (\n \t\t},\n \t)\n \n+\tallowRecovery = viperutil.Configure(\n+\t\t\"allow-recovery\",\n+\t\tviperutil.Options[bool]{\n+\t\t\tFlagName: \"allow-recovery\",\n+\t\t\tDefault:  true,\n+\t\t\tDynamic:  true,",
        "comment_created_at": "2025-03-31T07:23:59+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "The flag is not really dynamic, in the sense that its value is not checked after the vtorc has started, so keeping it dynamic is a little misleading.",
        "pr_file_module": null
      },
      {
        "comment_id": "2021719475",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18005,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "2020520295",
        "commented_code": "@@ -192,6 +192,15 @@ var (\n \t\t},\n \t)\n \n+\tallowRecovery = viperutil.Configure(\n+\t\t\"allow-recovery\",\n+\t\tviperutil.Options[bool]{\n+\t\t\tFlagName: \"allow-recovery\",\n+\t\t\tDefault:  true,\n+\t\t\tDynamic:  true,",
        "comment_created_at": "2025-03-31T20:25:26+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "@GuptaManan100 good point, updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175835194",
    "pr_number": 18005,
    "pr_file": "go/vt/vtorc/config/config.go",
    "created_at": "2025-06-30T20:26:44+00:00",
    "commented_code": "},\n \t)\n \n+\tallowRecovery = viperutil.Configure(\n+\t\t\"allow-recovery\",\n+\t\tviperutil.Options[bool]{\n+\t\t\tFlagName: \"allow-recovery\",\n+\t\t\tDefault:  true,\n+\t\t\tDynamic:  false,",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2175835194",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18005,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "2175835194",
        "commented_code": "@@ -192,6 +192,15 @@ var (\n \t\t},\n \t)\n \n+\tallowRecovery = viperutil.Configure(\n+\t\t\"allow-recovery\",\n+\t\tviperutil.Options[bool]{\n+\t\t\tFlagName: \"allow-recovery\",\n+\t\t\tDefault:  true,\n+\t\t\tDynamic:  false,",
        "comment_created_at": "2025-06-30T20:26:44+00:00",
        "comment_author": "deepthi",
        "comment_body": "Is it intentional to require a process restart to change this? To me, it makes sense to try to make as many flags dynamic as possible going forward because it is so much easier to do them one at a time rather an all at once.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175873792",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18005,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "2175835194",
        "commented_code": "@@ -192,6 +192,15 @@ var (\n \t\t},\n \t)\n \n+\tallowRecovery = viperutil.Configure(\n+\t\t\"allow-recovery\",\n+\t\tviperutil.Options[bool]{\n+\t\t\tFlagName: \"allow-recovery\",\n+\t\t\tDefault:  true,\n+\t\t\tDynamic:  false,",
        "comment_created_at": "2025-06-30T20:42:48+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "@deepthi that's a good idea. There's nothing preventing this from being a dynamic flag \ud83d\udc4d \r\n\r\nUpdated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2022543000",
    "pr_number": 18076,
    "pr_file": "go/test/endtoend/vtgate/misc_test.go",
    "created_at": "2025-04-01T09:57:30+00:00",
    "commented_code": "require.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2022543000",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18076,
        "pr_file": "go/test/endtoend/vtgate/misc_test.go",
        "discussion_id": "2022543000",
        "commented_code": "@@ -834,6 +834,24 @@ func TestDynamicConfig(t *testing.T) {\n \t\trequire.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
        "comment_created_at": "2025-04-01T09:57:30+00:00",
        "comment_author": "deepthi",
        "comment_body": "This is strange. We are looking for `1` here, but on line 851, we are looking for `REPLICA`. Is this just how it works, or are you testing something else?",
        "pr_file_module": null
      },
      {
        "comment_id": "2022556574",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18076,
        "pr_file": "go/test/endtoend/vtgate/misc_test.go",
        "discussion_id": "2022543000",
        "commented_code": "@@ -834,6 +834,24 @@ func TestDynamicConfig(t *testing.T) {\n \t\trequire.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
        "comment_created_at": "2025-04-01T10:06:16+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "1 looks equivalent to `Primary` ",
        "pr_file_module": null
      },
      {
        "comment_id": "2022557296",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18076,
        "pr_file": "go/test/endtoend/vtgate/misc_test.go",
        "discussion_id": "2022543000",
        "commented_code": "@@ -834,6 +834,24 @@ func TestDynamicConfig(t *testing.T) {\n \t\trequire.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
        "comment_created_at": "2025-04-01T10:06:46+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "we should use enum name over int values.",
        "pr_file_module": null
      },
      {
        "comment_id": "2036705371",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18076,
        "pr_file": "go/test/endtoend/vtgate/misc_test.go",
        "discussion_id": "2022543000",
        "commented_code": "@@ -834,6 +834,24 @@ func TestDynamicConfig(t *testing.T) {\n \t\trequire.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
        "comment_created_at": "2025-04-10T07:37:55+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "I have been looking at this for a while to see how to do this, but its not straight-forward.\r\n\r\nSo, what's happening is that in our endpoint, for `debug/config`, if we don't provide a format, then we call `case format == \"\":\r\n\t\tv.DebugTo(w)`\r\n\r\nThis `DebugTo` is an internal function of viper which prints the config like `fmt.Fprintf(w, \"Config:\\n%#v\\n\", v.config)`. Since it is using `%#v` and not `%v` it doesn't respect the String() method defined on the data type and gets the underlying type value.\r\n\r\nSo for a tablet type defined as `type TabletType int32`, it prints the value as the underlying type (int32) even though the value if printed via a call to `.String()` method would print `PRIMARY`.\r\n\r\nOne way of seeing \u261d\ufe0f in action is to run the following small test - \r\n```\r\nfunc TestOne(t *testing.T) {\r\n\tx := topodatapb.TabletType_PRIMARY\r\n\tmp := map[string]any{\r\n\t\t\"Val\": x,\r\n\t}\r\n\tval := x.String()\r\n\trequire.Equal(t, \"PRIMARY\", val)\r\n\tstr := fmt.Sprintf(\"Config:%v\", mp)\r\n\trequire.EqualValues(t, str, \"Config:map[Val:PRIMARY]\")\r\n}\r\n```\r\n\r\nIf you change the `%v` to `%#v` you will see that we start printing 1 instead of PRIMARY",
        "pr_file_module": null
      },
      {
        "comment_id": "2036708300",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18076,
        "pr_file": "go/test/endtoend/vtgate/misc_test.go",
        "discussion_id": "2022543000",
        "commented_code": "@@ -834,6 +834,24 @@ func TestDynamicConfig(t *testing.T) {\n \t\trequire.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
        "comment_created_at": "2025-04-10T07:39:05+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "When we explicitly set the value, then it is set as a string and not a tablet_type value, it is during reading it that we parse the string to a tablet type, so after we set it once, then we actually see what we wrote. Its a big weird I know, and it took a while for me to understand what was going on,",
        "pr_file_module": null
      },
      {
        "comment_id": "2036709842",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18076,
        "pr_file": "go/test/endtoend/vtgate/misc_test.go",
        "discussion_id": "2022543000",
        "commented_code": "@@ -834,6 +834,24 @@ func TestDynamicConfig(t *testing.T) {\n \t\trequire.NoError(t, err)\n \t})\n \n+\tt.Run(\"DefaultTabletType\", func(t *testing.T) {\n+\t\t// Test initial config value\n+\t\terr := clusterInstance.VtgateProcess.WaitForConfig(`\"default_tablet_type\":1`)",
        "comment_created_at": "2025-04-10T07:39:53+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "We could change the `v.DebugTo` call, to instead do something like `v.AllSettings()` and print them out on our own, but I don't if we want to do that, and even if we do, if that would go into this PR.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967069409",
    "pr_number": 17825,
    "pr_file": "go/vt/vtorc/config/config.go",
    "created_at": "2025-02-24T05:54:23+00:00",
    "commented_code": "},\n \t)\n \n+\tdiscoveryMaxConcurrency = viperutil.Configure(\n+\t\t\"discovery-max-concurrency\",\n+\t\tviperutil.Options[int]{\n+\t\t\tFlagName: \"discovery-max-concurrency\",\n+\t\t\tDefault:  300,\n+\t\t\tDynamic:  true,",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1967069409",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17825,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "1967069409",
        "commented_code": "@@ -58,6 +57,15 @@ var (\n \t\t},\n \t)\n \n+\tdiscoveryMaxConcurrency = viperutil.Configure(\n+\t\t\"discovery-max-concurrency\",\n+\t\tviperutil.Options[int]{\n+\t\t\tFlagName: \"discovery-max-concurrency\",\n+\t\t\tDefault:  300,\n+\t\t\tDynamic:  true,",
        "comment_created_at": "2025-02-24T05:54:23+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "This probably shouldn't be a dynamic variable since we don't change the discovery queue capacity after its been initialized.",
        "pr_file_module": null
      },
      {
        "comment_id": "1974512544",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17825,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "1967069409",
        "commented_code": "@@ -58,6 +57,15 @@ var (\n \t\t},\n \t)\n \n+\tdiscoveryMaxConcurrency = viperutil.Configure(\n+\t\t\"discovery-max-concurrency\",\n+\t\tviperutil.Options[int]{\n+\t\t\tFlagName: \"discovery-max-concurrency\",\n+\t\t\tDefault:  300,\n+\t\t\tDynamic:  true,",
        "comment_created_at": "2025-02-27T23:57:36+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "Good point, updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1966447400",
    "pr_number": 17837,
    "pr_file": "go/vt/vtorc/config/config.go",
    "created_at": "2025-02-22T05:40:12+00:00",
    "commented_code": "},\n \t)\n \n+\tbackendReadConcurrency = viperutil.Configure(\n+\t\t\"backend-read-concurrency\",\n+\t\tviperutil.Options[int64]{\n+\t\t\tFlagName: \"backend-read-concurrency\",\n+\t\t\tDefault:  32,\n+\t\t\tDynamic:  true,",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1966447400",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17837,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "1966447400",
        "commented_code": "@@ -121,6 +121,24 @@ var (\n \t\t},\n \t)\n \n+\tbackendReadConcurrency = viperutil.Configure(\n+\t\t\"backend-read-concurrency\",\n+\t\tviperutil.Options[int64]{\n+\t\t\tFlagName: \"backend-read-concurrency\",\n+\t\t\tDefault:  32,\n+\t\t\tDynamic:  true,",
        "comment_created_at": "2025-02-22T05:40:12+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "Rest is all good, but I don't think this field should be dynamic. Since we initialize the semaphore with value we read for this config once, even if the users change it later, the change won't be affected.",
        "pr_file_module": null
      },
      {
        "comment_id": "1970679895",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17837,
        "pr_file": "go/vt/vtorc/config/config.go",
        "discussion_id": "1966447400",
        "commented_code": "@@ -121,6 +121,24 @@ var (\n \t\t},\n \t)\n \n+\tbackendReadConcurrency = viperutil.Configure(\n+\t\t\"backend-read-concurrency\",\n+\t\tviperutil.Options[int64]{\n+\t\t\tFlagName: \"backend-read-concurrency\",\n+\t\t\tDefault:  32,\n+\t\t\tDynamic:  true,",
        "comment_created_at": "2025-02-25T23:24:34+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "@GuptaManan100 good point, updated \ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1200840279",
    "pr_number": 11456,
    "pr_file": "go/viperutil/config.go",
    "created_at": "2023-05-22T17:48:43+00:00",
    "commented_code": "+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package viperutil\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/funcs\"\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+\t\"vitess.io/vitess/go/viperutil/internal/registry\"\n+\t\"vitess.io/vitess/go/viperutil/internal/value\"\n+)\n+\n+var (\n+\tconfigPaths = Configure(\n+\t\t\"config.paths\",\n+\t\tOptions[[]string]{\n+\t\t\tGetFunc:  funcs.GetPath,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PATH\"},\n+\t\t\tFlagName: \"config-path\",\n+\t\t},\n+\t)\n+\tconfigType = Configure(\n+\t\t\"config.type\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_TYPE\"},\n+\t\t\tFlagName: \"config-type\",\n+\t\t},\n+\t)\n+\tconfigName = Configure(\n+\t\t\"config.name\",\n+\t\tOptions[string]{\n+\t\t\tDefault:  \"vtconfig\",\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_NAME\"},\n+\t\t\tFlagName: \"config-name\",\n+\t\t},\n+\t)\n+\tconfigFile = Configure(\n+\t\t\"config.file\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_FILE\"},\n+\t\t\tFlagName: \"config-file\",\n+\t\t},\n+\t)\n+\tconfigFileNotFoundHandling = Configure(\n+\t\t\"config.notfound.handling\",\n+\t\tOptions[ConfigFileNotFoundHandling]{\n+\t\t\tDefault: WarnOnConfigFileNotFound,\n+\t\t\tGetFunc: getHandlingValue,\n+\t\t},\n+\t)\n+\tconfigPersistenceMinInterval = Configure(\n+\t\t\"config.persistence.min_interval\",\n+\t\tOptions[time.Duration]{\n+\t\t\tDefault:  time.Second,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PERSISTENCE_MIN_INTERVAL\"},\n+\t\t\tFlagName: \"config-persistence-min-interval\",\n+\t\t},\n+\t)\n+)\n+\n+func init() {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tlog.WARN(\"failed to get working directory (err=%s), not appending to default config-paths\", err)\n+\t\treturn\n+\t}\n+\n+\tconfigPaths.(*value.Static[[]string]).DefaultVal = []string{wd}\n+\t// Need to re-trigger the SetDefault call done during Configure.\n+\tregistry.Static.SetDefault(configPaths.Key(), configPaths.Default())\n+}\n+\n+// RegisterFlags installs the flags that control viper config-loading behavior.\n+// It is exported to be called by servenv before parsing flags for all binaries.\n+//\n+// It cannot be registered here via servenv.OnParse since this causes an import\n+// cycle.\n+func RegisterFlags(fs *pflag.FlagSet) {\n+\tfs.StringSlice(\"config-path\", configPaths.Default(), \"Paths to search for config files in.\")\n+\tfs.String(\"config-type\", configType.Default(), \"Config file type (omit to infer config type from file extension).\")\n+\tfs.String(\"config-name\", configName.Default(), \"Name of the config file (without extension) to search for.\")\n+\tfs.String(\"config-file\", configFile.Default(), \"Full path of the config file (with extension) to use. If set, --config-path, --config-type, and --config-name are ignored.\")\n+\tfs.Duration(\"config-persistence-min-interval\", configPersistenceMinInterval.Default(), \"minimum interval between persisting dynamic config changes back to disk (if no change has occurred, nothing is done).\")",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1200840279",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1200840279",
        "commented_code": "@@ -0,0 +1,297 @@\n+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package viperutil\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/funcs\"\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+\t\"vitess.io/vitess/go/viperutil/internal/registry\"\n+\t\"vitess.io/vitess/go/viperutil/internal/value\"\n+)\n+\n+var (\n+\tconfigPaths = Configure(\n+\t\t\"config.paths\",\n+\t\tOptions[[]string]{\n+\t\t\tGetFunc:  funcs.GetPath,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PATH\"},\n+\t\t\tFlagName: \"config-path\",\n+\t\t},\n+\t)\n+\tconfigType = Configure(\n+\t\t\"config.type\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_TYPE\"},\n+\t\t\tFlagName: \"config-type\",\n+\t\t},\n+\t)\n+\tconfigName = Configure(\n+\t\t\"config.name\",\n+\t\tOptions[string]{\n+\t\t\tDefault:  \"vtconfig\",\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_NAME\"},\n+\t\t\tFlagName: \"config-name\",\n+\t\t},\n+\t)\n+\tconfigFile = Configure(\n+\t\t\"config.file\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_FILE\"},\n+\t\t\tFlagName: \"config-file\",\n+\t\t},\n+\t)\n+\tconfigFileNotFoundHandling = Configure(\n+\t\t\"config.notfound.handling\",\n+\t\tOptions[ConfigFileNotFoundHandling]{\n+\t\t\tDefault: WarnOnConfigFileNotFound,\n+\t\t\tGetFunc: getHandlingValue,\n+\t\t},\n+\t)\n+\tconfigPersistenceMinInterval = Configure(\n+\t\t\"config.persistence.min_interval\",\n+\t\tOptions[time.Duration]{\n+\t\t\tDefault:  time.Second,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PERSISTENCE_MIN_INTERVAL\"},\n+\t\t\tFlagName: \"config-persistence-min-interval\",\n+\t\t},\n+\t)\n+)\n+\n+func init() {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tlog.WARN(\"failed to get working directory (err=%s), not appending to default config-paths\", err)\n+\t\treturn\n+\t}\n+\n+\tconfigPaths.(*value.Static[[]string]).DefaultVal = []string{wd}\n+\t// Need to re-trigger the SetDefault call done during Configure.\n+\tregistry.Static.SetDefault(configPaths.Key(), configPaths.Default())\n+}\n+\n+// RegisterFlags installs the flags that control viper config-loading behavior.\n+// It is exported to be called by servenv before parsing flags for all binaries.\n+//\n+// It cannot be registered here via servenv.OnParse since this causes an import\n+// cycle.\n+func RegisterFlags(fs *pflag.FlagSet) {\n+\tfs.StringSlice(\"config-path\", configPaths.Default(), \"Paths to search for config files in.\")\n+\tfs.String(\"config-type\", configType.Default(), \"Config file type (omit to infer config type from file extension).\")\n+\tfs.String(\"config-name\", configName.Default(), \"Name of the config file (without extension) to search for.\")\n+\tfs.String(\"config-file\", configFile.Default(), \"Full path of the config file (with extension) to use. If set, --config-path, --config-type, and --config-name are ignored.\")\n+\tfs.Duration(\"config-persistence-min-interval\", configPersistenceMinInterval.Default(), \"minimum interval between persisting dynamic config changes back to disk (if no change has occurred, nothing is done).\")",
        "comment_created_at": "2023-05-22T17:48:43+00:00",
        "comment_author": "mattlord",
        "comment_body": "A consideration we can add in the docs somewhere -- that setting the in-memory value does not guarantee it persists as this could only be in the process memory, before being written to the FS, and the FS write may not be flushed or sync'd either (?). A brief info section in the docs could help users think about how to deal with this if e.g. they update a setting in a hundred tablets (maybe one crashes or is e.g. replaced by k8s shorter thereafter).\r\n\r\nI would guess that on process normal shutdown all of these pending in-memory changes are flushed? Although I believe we do kill the process in some cases after a period of time and in those cases we can't know for sure.\r\n\r\nThese considerations also make the trade-off with this flag value here more clear.\r\n\r\nFWIW, I don't consider this an issue in any way. I don't think too many people are even aware of `/debug/env`, we don't support a lot of config options there, and this is clearly an improvement. :-) \r\n\r\nAlthough this does make me think... what if you want to play with different settings in a running process w/o affecting the persistent config? Is there a way to do that? I suspect (don't know for sure) there are two primary uses of `/debug/env` today:\r\n1. Change setting in the running process w/o having to restart. You persisted it yourself separately. Clearly this new behavior is an improvement there.\r\n2. Try different settings in the running process to see which one seems to offer better behavior. You may or may not end up persisting a different flag value.\r\n\r\nDo we effectively lose num 2? I guess we could simply document the breaking change in that it's up to the user to reset it back to the default when they're done with their testing (since intermediate temporary test values were likely persisted in the config file). And when choosing to use a config file, you must become aware of this anyway and change your process accordingly. I think that's totally fine and reasonable FWIW. \r\n\r\nPrecedence also comes into play -- we should document that somewhere in the docs (you may already have some place) -- as if they specify the value as a cmd-line flag then that value may override anything that's persisted in the config file anyway (which they may want for a core set of flags).",
        "pr_file_module": null
      },
      {
        "comment_id": "1201262692",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1200840279",
        "commented_code": "@@ -0,0 +1,297 @@\n+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package viperutil\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/funcs\"\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+\t\"vitess.io/vitess/go/viperutil/internal/registry\"\n+\t\"vitess.io/vitess/go/viperutil/internal/value\"\n+)\n+\n+var (\n+\tconfigPaths = Configure(\n+\t\t\"config.paths\",\n+\t\tOptions[[]string]{\n+\t\t\tGetFunc:  funcs.GetPath,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PATH\"},\n+\t\t\tFlagName: \"config-path\",\n+\t\t},\n+\t)\n+\tconfigType = Configure(\n+\t\t\"config.type\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_TYPE\"},\n+\t\t\tFlagName: \"config-type\",\n+\t\t},\n+\t)\n+\tconfigName = Configure(\n+\t\t\"config.name\",\n+\t\tOptions[string]{\n+\t\t\tDefault:  \"vtconfig\",\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_NAME\"},\n+\t\t\tFlagName: \"config-name\",\n+\t\t},\n+\t)\n+\tconfigFile = Configure(\n+\t\t\"config.file\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_FILE\"},\n+\t\t\tFlagName: \"config-file\",\n+\t\t},\n+\t)\n+\tconfigFileNotFoundHandling = Configure(\n+\t\t\"config.notfound.handling\",\n+\t\tOptions[ConfigFileNotFoundHandling]{\n+\t\t\tDefault: WarnOnConfigFileNotFound,\n+\t\t\tGetFunc: getHandlingValue,\n+\t\t},\n+\t)\n+\tconfigPersistenceMinInterval = Configure(\n+\t\t\"config.persistence.min_interval\",\n+\t\tOptions[time.Duration]{\n+\t\t\tDefault:  time.Second,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PERSISTENCE_MIN_INTERVAL\"},\n+\t\t\tFlagName: \"config-persistence-min-interval\",\n+\t\t},\n+\t)\n+)\n+\n+func init() {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tlog.WARN(\"failed to get working directory (err=%s), not appending to default config-paths\", err)\n+\t\treturn\n+\t}\n+\n+\tconfigPaths.(*value.Static[[]string]).DefaultVal = []string{wd}\n+\t// Need to re-trigger the SetDefault call done during Configure.\n+\tregistry.Static.SetDefault(configPaths.Key(), configPaths.Default())\n+}\n+\n+// RegisterFlags installs the flags that control viper config-loading behavior.\n+// It is exported to be called by servenv before parsing flags for all binaries.\n+//\n+// It cannot be registered here via servenv.OnParse since this causes an import\n+// cycle.\n+func RegisterFlags(fs *pflag.FlagSet) {\n+\tfs.StringSlice(\"config-path\", configPaths.Default(), \"Paths to search for config files in.\")\n+\tfs.String(\"config-type\", configType.Default(), \"Config file type (omit to infer config type from file extension).\")\n+\tfs.String(\"config-name\", configName.Default(), \"Name of the config file (without extension) to search for.\")\n+\tfs.String(\"config-file\", configFile.Default(), \"Full path of the config file (with extension) to use. If set, --config-path, --config-type, and --config-name are ignored.\")\n+\tfs.Duration(\"config-persistence-min-interval\", configPersistenceMinInterval.Default(), \"minimum interval between persisting dynamic config changes back to disk (if no change has occurred, nothing is done).\")",
        "comment_created_at": "2023-05-22T22:48:10+00:00",
        "comment_author": "ajm188",
        "comment_body": "> that setting the in-memory value does not guarantee it persists as this could only be in the process memory, before being written to the FS, and the FS write may not be \r\n\r\ncorrect\r\n\r\n> Do we effectively lose num 2? I guess we could simply document the breaking change in that it's up to the user to reset it back to the default when they're done with their testing (since intermediate temporary test values were likely persisted in the config file). And when choosing to use a config file, you must become aware of this anyway and change your process accordingly. I think that's totally fine and reasonable FWIW.\r\n\r\ncurrently yes. one thing we could do to bring that back is say something like \"if `interval` is a negative value then we never persist to disk\" but then you run the reverse problem (change `X` in memory, then change `Y` in the file, and when we reload `X` goes back to the original value)\r\n\r\n> Precedence also comes into play \r\n\r\ncorrect, the flag wins if a value is in both spots (including here)",
        "pr_file_module": null
      },
      {
        "comment_id": "1202012144",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1200840279",
        "commented_code": "@@ -0,0 +1,297 @@\n+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package viperutil\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/funcs\"\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+\t\"vitess.io/vitess/go/viperutil/internal/registry\"\n+\t\"vitess.io/vitess/go/viperutil/internal/value\"\n+)\n+\n+var (\n+\tconfigPaths = Configure(\n+\t\t\"config.paths\",\n+\t\tOptions[[]string]{\n+\t\t\tGetFunc:  funcs.GetPath,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PATH\"},\n+\t\t\tFlagName: \"config-path\",\n+\t\t},\n+\t)\n+\tconfigType = Configure(\n+\t\t\"config.type\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_TYPE\"},\n+\t\t\tFlagName: \"config-type\",\n+\t\t},\n+\t)\n+\tconfigName = Configure(\n+\t\t\"config.name\",\n+\t\tOptions[string]{\n+\t\t\tDefault:  \"vtconfig\",\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_NAME\"},\n+\t\t\tFlagName: \"config-name\",\n+\t\t},\n+\t)\n+\tconfigFile = Configure(\n+\t\t\"config.file\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_FILE\"},\n+\t\t\tFlagName: \"config-file\",\n+\t\t},\n+\t)\n+\tconfigFileNotFoundHandling = Configure(\n+\t\t\"config.notfound.handling\",\n+\t\tOptions[ConfigFileNotFoundHandling]{\n+\t\t\tDefault: WarnOnConfigFileNotFound,\n+\t\t\tGetFunc: getHandlingValue,\n+\t\t},\n+\t)\n+\tconfigPersistenceMinInterval = Configure(\n+\t\t\"config.persistence.min_interval\",\n+\t\tOptions[time.Duration]{\n+\t\t\tDefault:  time.Second,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PERSISTENCE_MIN_INTERVAL\"},\n+\t\t\tFlagName: \"config-persistence-min-interval\",\n+\t\t},\n+\t)\n+)\n+\n+func init() {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tlog.WARN(\"failed to get working directory (err=%s), not appending to default config-paths\", err)\n+\t\treturn\n+\t}\n+\n+\tconfigPaths.(*value.Static[[]string]).DefaultVal = []string{wd}\n+\t// Need to re-trigger the SetDefault call done during Configure.\n+\tregistry.Static.SetDefault(configPaths.Key(), configPaths.Default())\n+}\n+\n+// RegisterFlags installs the flags that control viper config-loading behavior.\n+// It is exported to be called by servenv before parsing flags for all binaries.\n+//\n+// It cannot be registered here via servenv.OnParse since this causes an import\n+// cycle.\n+func RegisterFlags(fs *pflag.FlagSet) {\n+\tfs.StringSlice(\"config-path\", configPaths.Default(), \"Paths to search for config files in.\")\n+\tfs.String(\"config-type\", configType.Default(), \"Config file type (omit to infer config type from file extension).\")\n+\tfs.String(\"config-name\", configName.Default(), \"Name of the config file (without extension) to search for.\")\n+\tfs.String(\"config-file\", configFile.Default(), \"Full path of the config file (with extension) to use. If set, --config-path, --config-type, and --config-name are ignored.\")\n+\tfs.Duration(\"config-persistence-min-interval\", configPersistenceMinInterval.Default(), \"minimum interval between persisting dynamic config changes back to disk (if no change has occurred, nothing is done).\")",
        "comment_created_at": "2023-05-23T10:20:39+00:00",
        "comment_author": "ajm188",
        "comment_body": "also, realizing that\r\n\r\n> I would guess that on process normal shutdown all of these pending in-memory changes are flushed? \r\n\r\nwe currently don't, but i can do something like:\r\n\r\n```go\r\ndefer func() {\r\n    select {\r\n        case <-v.setCh:\r\n            persistOnce()\r\n        default:\r\n    }\r\n}()\r\n```\r\n\r\ndoesn't handle the \"killed\" case, since `servenv` only provides OnTerm, but also at the end of the day, if the OS decides it's really gonna kill it, and it's not done, well, too bad for us\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1202802535",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1200840279",
        "commented_code": "@@ -0,0 +1,297 @@\n+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package viperutil\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/funcs\"\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+\t\"vitess.io/vitess/go/viperutil/internal/registry\"\n+\t\"vitess.io/vitess/go/viperutil/internal/value\"\n+)\n+\n+var (\n+\tconfigPaths = Configure(\n+\t\t\"config.paths\",\n+\t\tOptions[[]string]{\n+\t\t\tGetFunc:  funcs.GetPath,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PATH\"},\n+\t\t\tFlagName: \"config-path\",\n+\t\t},\n+\t)\n+\tconfigType = Configure(\n+\t\t\"config.type\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_TYPE\"},\n+\t\t\tFlagName: \"config-type\",\n+\t\t},\n+\t)\n+\tconfigName = Configure(\n+\t\t\"config.name\",\n+\t\tOptions[string]{\n+\t\t\tDefault:  \"vtconfig\",\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_NAME\"},\n+\t\t\tFlagName: \"config-name\",\n+\t\t},\n+\t)\n+\tconfigFile = Configure(\n+\t\t\"config.file\",\n+\t\tOptions[string]{\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_FILE\"},\n+\t\t\tFlagName: \"config-file\",\n+\t\t},\n+\t)\n+\tconfigFileNotFoundHandling = Configure(\n+\t\t\"config.notfound.handling\",\n+\t\tOptions[ConfigFileNotFoundHandling]{\n+\t\t\tDefault: WarnOnConfigFileNotFound,\n+\t\t\tGetFunc: getHandlingValue,\n+\t\t},\n+\t)\n+\tconfigPersistenceMinInterval = Configure(\n+\t\t\"config.persistence.min_interval\",\n+\t\tOptions[time.Duration]{\n+\t\t\tDefault:  time.Second,\n+\t\t\tEnvVars:  []string{\"VT_CONFIG_PERSISTENCE_MIN_INTERVAL\"},\n+\t\t\tFlagName: \"config-persistence-min-interval\",\n+\t\t},\n+\t)\n+)\n+\n+func init() {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tlog.WARN(\"failed to get working directory (err=%s), not appending to default config-paths\", err)\n+\t\treturn\n+\t}\n+\n+\tconfigPaths.(*value.Static[[]string]).DefaultVal = []string{wd}\n+\t// Need to re-trigger the SetDefault call done during Configure.\n+\tregistry.Static.SetDefault(configPaths.Key(), configPaths.Default())\n+}\n+\n+// RegisterFlags installs the flags that control viper config-loading behavior.\n+// It is exported to be called by servenv before parsing flags for all binaries.\n+//\n+// It cannot be registered here via servenv.OnParse since this causes an import\n+// cycle.\n+func RegisterFlags(fs *pflag.FlagSet) {\n+\tfs.StringSlice(\"config-path\", configPaths.Default(), \"Paths to search for config files in.\")\n+\tfs.String(\"config-type\", configType.Default(), \"Config file type (omit to infer config type from file extension).\")\n+\tfs.String(\"config-name\", configName.Default(), \"Name of the config file (without extension) to search for.\")\n+\tfs.String(\"config-file\", configFile.Default(), \"Full path of the config file (with extension) to use. If set, --config-path, --config-type, and --config-name are ignored.\")\n+\tfs.Duration(\"config-persistence-min-interval\", configPersistenceMinInterval.Default(), \"minimum interval between persisting dynamic config changes back to disk (if no change has occurred, nothing is done).\")",
        "comment_created_at": "2023-05-23T18:07:17+00:00",
        "comment_author": "mattlord",
        "comment_body": "These are all fine. Just considerations that we can internalize and potentially document if needed. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1850381253",
    "pr_number": 17244,
    "pr_file": "go/vt/vttablet/tabletserver/tabletenv/config.go",
    "created_at": "2024-11-20T14:07:40+00:00",
    "commented_code": "Consolidator:                Enable,\n \tConsolidatorStreamTotalSize: 128 * 1024 * 1024,\n \tConsolidatorStreamQuerySize: 2 * 1024 * 1024,\n+\tConsolidatorMaxQueryWait:    256,",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1850381253",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17244,
        "pr_file": "go/vt/vttablet/tabletserver/tabletenv/config.go",
        "discussion_id": "1850381253",
        "commented_code": "@@ -1014,6 +1016,7 @@ var defaultConfig = TabletConfig{\n \tConsolidator:                Enable,\n \tConsolidatorStreamTotalSize: 128 * 1024 * 1024,\n \tConsolidatorStreamQuerySize: 2 * 1024 * 1024,\n+\tConsolidatorMaxQueryWait:    256,",
        "comment_created_at": "2024-11-20T14:07:40+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "We have to keep the default 0 that should point to unlimited wait. Otherwise it will cause regression with system who depends on high number and during upgrade they would not be able to set this as it is a new configuration.",
        "pr_file_module": null
      },
      {
        "comment_id": "1851122138",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17244,
        "pr_file": "go/vt/vttablet/tabletserver/tabletenv/config.go",
        "discussion_id": "1850381253",
        "commented_code": "@@ -1014,6 +1016,7 @@ var defaultConfig = TabletConfig{\n \tConsolidator:                Enable,\n \tConsolidatorStreamTotalSize: 128 * 1024 * 1024,\n \tConsolidatorStreamQuerySize: 2 * 1024 * 1024,\n+\tConsolidatorMaxQueryWait:    256,",
        "comment_created_at": "2024-11-20T23:37:30+00:00",
        "comment_author": "jwangace",
        "comment_body": "Thanks @harshit-gangal,  it's a good idea, I will going to update that.",
        "pr_file_module": null
      }
    ]
  }
]