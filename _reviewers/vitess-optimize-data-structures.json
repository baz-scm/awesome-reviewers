[
  {
    "discussion_id": "2056111896",
    "pr_number": 18196,
    "pr_file": "go/mysql/replication/mysql56_gtid_set.go",
    "created_at": "2025-04-23T13:52:10+00:00",
    "commented_code": "return newSet\n }\n \n+// AddGTID implements GTIDSet.\n+func (set Mysql56GTIDSet) AddGTIDInPlace(gtid GTID) GTIDSet {\n+\tgtid56, ok := gtid.(Mysql56GTID)\n+\tif !ok {\n+\t\treturn set\n+\t}\n+\n+\tadded := false\n+\tintervals, ok := set[gtid56.Server]\n+\tif !ok {\n+\t\tset[gtid56.Server] = []interval{{start: gtid56.Sequence, end: gtid56.Sequence}}\n+\t\treturn set\n+\t}\n+\n+\tvar newIntervals []interval\n+\t// Look for the right place to add this GTID.\n+\tfor _, iv := range intervals {",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2056111896",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18196,
        "pr_file": "go/mysql/replication/mysql56_gtid_set.go",
        "discussion_id": "2056111896",
        "commented_code": "@@ -370,6 +378,66 @@ func (set Mysql56GTIDSet) AddGTID(gtid GTID) GTIDSet {\n \treturn newSet\n }\n \n+// AddGTID implements GTIDSet.\n+func (set Mysql56GTIDSet) AddGTIDInPlace(gtid GTID) GTIDSet {\n+\tgtid56, ok := gtid.(Mysql56GTID)\n+\tif !ok {\n+\t\treturn set\n+\t}\n+\n+\tadded := false\n+\tintervals, ok := set[gtid56.Server]\n+\tif !ok {\n+\t\tset[gtid56.Server] = []interval{{start: gtid56.Sequence, end: gtid56.Sequence}}\n+\t\treturn set\n+\t}\n+\n+\tvar newIntervals []interval\n+\t// Look for the right place to add this GTID.\n+\tfor _, iv := range intervals {",
        "comment_created_at": "2025-04-23T13:52:10+00:00",
        "comment_author": "Copilot",
        "comment_body": "The assignment to set[gtid56.Server] inside the loop could lead to repeated reassignments. Consider moving this update outside the loop once the newIntervals are fully constructed to ensure consistent and efficient merging of intervals.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2059214506",
    "pr_number": 18196,
    "pr_file": "go/mysql/replication/mysql56_gtid_set.go",
    "created_at": "2025-04-24T20:52:12+00:00",
    "commented_code": "return newSet\n }\n \n+// AddGTID implements GTIDSet.\n+func (set Mysql56GTIDSet) AddGTIDInPlace(gtid GTID) GTIDSet {\n+\tgtid56, ok := gtid.(Mysql56GTID)\n+\tif !ok {\n+\t\treturn set\n+\t}\n+\n+\tadded := false\n+\tintervals, ok := set[gtid56.Server]\n+\tif !ok {\n+\t\tset[gtid56.Server] = []interval{{start: gtid56.Sequence, end: gtid56.Sequence}}\n+\t\treturn set\n+\t}\n+\n+\tvar newIntervals []interval\n+\t// Look for the right place to add this GTID.\n+\tfor _, iv := range intervals {\n+\t\tif gtid56.Sequence >= iv.start && gtid56.Sequence <= iv.end {\n+\t\t\t// GTID already exists in the set.\n+\t\t\treturn set\n+\t\t}\n+\t\tif !added {\n+\t\t\tswitch {\n+\t\t\tcase gtid56.Sequence == iv.start-1:\n+\t\t\t\t// Expand the interval at the beginning.\n+\t\t\t\tiv.start = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence == iv.end+1:\n+\t\t\t\t// Expand the interval at the end.\n+\t\t\t\tiv.end = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence < iv.start-1:\n+\t\t\t\t// The next interval is beyond the new GTID, but it can't\n+\t\t\t\t// be expanded, so we have to insert a new interval.\n+\t\t\t\tnewIntervals = append(newIntervals, interval{start: gtid56.Sequence, end: gtid56.Sequence})\n+\t\t\t\tadded = true\n+\t\t\t}\n+\t\t}\n+\t\t// Check if this interval can be merged with the previous one.\n+\t\tcount := len(newIntervals)\n+\t\tif count != 0 && iv.start == newIntervals[count-1].end+1 {\n+\t\t\t// Merge instead of appending.\n+\t\t\tnewIntervals[count-1].end = iv.end\n+\t\t} else {\n+\t\t\t// Can't be merged.\n+\t\t\tnewIntervals = append(newIntervals, iv)\n+\t\t}\n+\n+\t\tset[gtid56.Server] = newIntervals",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2059214506",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18196,
        "pr_file": "go/mysql/replication/mysql56_gtid_set.go",
        "discussion_id": "2059214506",
        "commented_code": "@@ -370,6 +378,66 @@ func (set Mysql56GTIDSet) AddGTID(gtid GTID) GTIDSet {\n \treturn newSet\n }\n \n+// AddGTID implements GTIDSet.\n+func (set Mysql56GTIDSet) AddGTIDInPlace(gtid GTID) GTIDSet {\n+\tgtid56, ok := gtid.(Mysql56GTID)\n+\tif !ok {\n+\t\treturn set\n+\t}\n+\n+\tadded := false\n+\tintervals, ok := set[gtid56.Server]\n+\tif !ok {\n+\t\tset[gtid56.Server] = []interval{{start: gtid56.Sequence, end: gtid56.Sequence}}\n+\t\treturn set\n+\t}\n+\n+\tvar newIntervals []interval\n+\t// Look for the right place to add this GTID.\n+\tfor _, iv := range intervals {\n+\t\tif gtid56.Sequence >= iv.start && gtid56.Sequence <= iv.end {\n+\t\t\t// GTID already exists in the set.\n+\t\t\treturn set\n+\t\t}\n+\t\tif !added {\n+\t\t\tswitch {\n+\t\t\tcase gtid56.Sequence == iv.start-1:\n+\t\t\t\t// Expand the interval at the beginning.\n+\t\t\t\tiv.start = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence == iv.end+1:\n+\t\t\t\t// Expand the interval at the end.\n+\t\t\t\tiv.end = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence < iv.start-1:\n+\t\t\t\t// The next interval is beyond the new GTID, but it can't\n+\t\t\t\t// be expanded, so we have to insert a new interval.\n+\t\t\t\tnewIntervals = append(newIntervals, interval{start: gtid56.Sequence, end: gtid56.Sequence})\n+\t\t\t\tadded = true\n+\t\t\t}\n+\t\t}\n+\t\t// Check if this interval can be merged with the previous one.\n+\t\tcount := len(newIntervals)\n+\t\tif count != 0 && iv.start == newIntervals[count-1].end+1 {\n+\t\t\t// Merge instead of appending.\n+\t\t\tnewIntervals[count-1].end = iv.end\n+\t\t} else {\n+\t\t\t// Can't be merged.\n+\t\t\tnewIntervals = append(newIntervals, iv)\n+\t\t}\n+\n+\t\tset[gtid56.Server] = newIntervals",
        "comment_created_at": "2025-04-24T20:52:12+00:00",
        "comment_author": "arthurschreiber",
        "comment_body": "I guess copilot is right and this assignment here should happen outside of the `for` loop. \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2062266608",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18196,
        "pr_file": "go/mysql/replication/mysql56_gtid_set.go",
        "discussion_id": "2059214506",
        "commented_code": "@@ -370,6 +378,66 @@ func (set Mysql56GTIDSet) AddGTID(gtid GTID) GTIDSet {\n \treturn newSet\n }\n \n+// AddGTID implements GTIDSet.\n+func (set Mysql56GTIDSet) AddGTIDInPlace(gtid GTID) GTIDSet {\n+\tgtid56, ok := gtid.(Mysql56GTID)\n+\tif !ok {\n+\t\treturn set\n+\t}\n+\n+\tadded := false\n+\tintervals, ok := set[gtid56.Server]\n+\tif !ok {\n+\t\tset[gtid56.Server] = []interval{{start: gtid56.Sequence, end: gtid56.Sequence}}\n+\t\treturn set\n+\t}\n+\n+\tvar newIntervals []interval\n+\t// Look for the right place to add this GTID.\n+\tfor _, iv := range intervals {\n+\t\tif gtid56.Sequence >= iv.start && gtid56.Sequence <= iv.end {\n+\t\t\t// GTID already exists in the set.\n+\t\t\treturn set\n+\t\t}\n+\t\tif !added {\n+\t\t\tswitch {\n+\t\t\tcase gtid56.Sequence == iv.start-1:\n+\t\t\t\t// Expand the interval at the beginning.\n+\t\t\t\tiv.start = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence == iv.end+1:\n+\t\t\t\t// Expand the interval at the end.\n+\t\t\t\tiv.end = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence < iv.start-1:\n+\t\t\t\t// The next interval is beyond the new GTID, but it can't\n+\t\t\t\t// be expanded, so we have to insert a new interval.\n+\t\t\t\tnewIntervals = append(newIntervals, interval{start: gtid56.Sequence, end: gtid56.Sequence})\n+\t\t\t\tadded = true\n+\t\t\t}\n+\t\t}\n+\t\t// Check if this interval can be merged with the previous one.\n+\t\tcount := len(newIntervals)\n+\t\tif count != 0 && iv.start == newIntervals[count-1].end+1 {\n+\t\t\t// Merge instead of appending.\n+\t\t\tnewIntervals[count-1].end = iv.end\n+\t\t} else {\n+\t\t\t// Can't be merged.\n+\t\t\tnewIntervals = append(newIntervals, iv)\n+\t\t}\n+\n+\t\tset[gtid56.Server] = newIntervals",
        "comment_created_at": "2025-04-27T05:11:40+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "Agreed",
        "pr_file_module": null
      },
      {
        "comment_id": "2062905694",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18196,
        "pr_file": "go/mysql/replication/mysql56_gtid_set.go",
        "discussion_id": "2059214506",
        "commented_code": "@@ -370,6 +378,66 @@ func (set Mysql56GTIDSet) AddGTID(gtid GTID) GTIDSet {\n \treturn newSet\n }\n \n+// AddGTID implements GTIDSet.\n+func (set Mysql56GTIDSet) AddGTIDInPlace(gtid GTID) GTIDSet {\n+\tgtid56, ok := gtid.(Mysql56GTID)\n+\tif !ok {\n+\t\treturn set\n+\t}\n+\n+\tadded := false\n+\tintervals, ok := set[gtid56.Server]\n+\tif !ok {\n+\t\tset[gtid56.Server] = []interval{{start: gtid56.Sequence, end: gtid56.Sequence}}\n+\t\treturn set\n+\t}\n+\n+\tvar newIntervals []interval\n+\t// Look for the right place to add this GTID.\n+\tfor _, iv := range intervals {\n+\t\tif gtid56.Sequence >= iv.start && gtid56.Sequence <= iv.end {\n+\t\t\t// GTID already exists in the set.\n+\t\t\treturn set\n+\t\t}\n+\t\tif !added {\n+\t\t\tswitch {\n+\t\t\tcase gtid56.Sequence == iv.start-1:\n+\t\t\t\t// Expand the interval at the beginning.\n+\t\t\t\tiv.start = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence == iv.end+1:\n+\t\t\t\t// Expand the interval at the end.\n+\t\t\t\tiv.end = gtid56.Sequence\n+\t\t\t\tadded = true\n+\t\t\tcase gtid56.Sequence < iv.start-1:\n+\t\t\t\t// The next interval is beyond the new GTID, but it can't\n+\t\t\t\t// be expanded, so we have to insert a new interval.\n+\t\t\t\tnewIntervals = append(newIntervals, interval{start: gtid56.Sequence, end: gtid56.Sequence})\n+\t\t\t\tadded = true\n+\t\t\t}\n+\t\t}\n+\t\t// Check if this interval can be merged with the previous one.\n+\t\tcount := len(newIntervals)\n+\t\tif count != 0 && iv.start == newIntervals[count-1].end+1 {\n+\t\t\t// Merge instead of appending.\n+\t\t\tnewIntervals[count-1].end = iv.end\n+\t\t} else {\n+\t\t\t// Can't be merged.\n+\t\t\tnewIntervals = append(newIntervals, iv)\n+\t\t}\n+\n+\t\tset[gtid56.Server] = newIntervals",
        "comment_created_at": "2025-04-28T05:22:27+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "Turns out it was wrong. Moving the assignment outside the loop ~~skipped~~ caused a scenario where the loop would `return` without making the assignment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2000626970",
    "pr_number": 17978,
    "pr_file": "go/vt/vtgate/semantics/transitive_closures.go",
    "created_at": "2025-03-18T09:54:32+00:00",
    "commented_code": "+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semantics\n+\n+import (\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+)\n+\n+type (\n+\t// TransitiveClosures expression equality, so we can rewrite expressions efficiently\n+\t// It allows for transitive closures (e.g., if a == b and b == c, then a == c).\n+\tTransitiveClosures struct {\n+\t\t// ExprIDs stores the IDs of the expressions.\n+\t\t// The ID can then be used to get other equivalent expressions from the Equalities slice\n+\t\texprIDs map[sqlparser.Expr]int",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2000626970",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17978,
        "pr_file": "go/vt/vtgate/semantics/transitive_closures.go",
        "discussion_id": "2000626970",
        "commented_code": "@@ -0,0 +1,197 @@\n+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semantics\n+\n+import (\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+)\n+\n+type (\n+\t// TransitiveClosures expression equality, so we can rewrite expressions efficiently\n+\t// It allows for transitive closures (e.g., if a == b and b == c, then a == c).\n+\tTransitiveClosures struct {\n+\t\t// ExprIDs stores the IDs of the expressions.\n+\t\t// The ID can then be used to get other equivalent expressions from the Equalities slice\n+\t\texprIDs map[sqlparser.Expr]int",
        "comment_created_at": "2025-03-18T09:54:32+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "We discussed a more optimal implementation for this using Disjoin set unions - https://en.wikipedia.org/wiki/Disjoint-set_data_structure. Left that to be done later, just pointing out so that we have the reference to it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1974801841",
    "pr_number": 17825,
    "pr_file": "go/vt/vtorc/discovery/queue.go",
    "created_at": "2025-02-28T05:26:01+00:00",
    "commented_code": "\"vitess.io/vitess/go/vt/vtorc/config\"\n )\n \n-// Queue contains information for managing discovery requests\n-type Queue struct {\n-\tsync.Mutex\n+// queueItem represents an item in the discovery.Queue.\n+type queueItem struct {\n+\tPushedAt time.Time\n+\tKey      string\n+}\n \n-\tname         string\n-\tdone         chan struct{}\n-\tqueue        chan string\n-\tqueuedKeys   map[string]time.Time\n-\tconsumedKeys map[string]time.Time\n+// Queue is an ordered queue with deduplication.\n+type Queue struct {\n+\tmu       sync.Mutex\n+\tenqueued map[string]struct{}\n+\tqueue    chan queueItem\n }\n \n-// CreateQueue allows for creation of a new discovery queue\n-func CreateQueue(name string) *Queue {\n+// NewQueue creates a new queue.\n+func NewQueue() *Queue {\n \treturn &Queue{\n-\t\tname:         name,\n-\t\tqueuedKeys:   make(map[string]time.Time),\n-\t\tconsumedKeys: make(map[string]time.Time),\n-\t\tqueue:        make(chan string, config.DiscoveryQueueCapacity),\n+\t\tenqueued: make(map[string]struct{}),\n+\t\tqueue:    make(chan queueItem, config.DiscoveryQueueCapacity),\n+\t}\n+}\n+\n+// setKeyCheckEnqueued returns true if a key is already enqueued, if\n+// not the key will be marked as enqueued and false is returned.\n+func (q *Queue) setKeyCheckEnqueued(key string) (alreadyEnqueued bool) {\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n+\n+\t_, alreadyEnqueued = q.enqueued[key]\n+\tif !alreadyEnqueued {\n+\t\tq.enqueued[key] = struct{}{}\n \t}\n+\treturn alreadyEnqueued\n }\n \n-// QueueLen returns the length of the queue (channel size + queued size)\n+// QueueLen returns the length of the queue.\n func (q *Queue) QueueLen() int {\n-\tq.Lock()\n-\tdefer q.Unlock()\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n \n-\treturn len(q.queue) + len(q.queuedKeys)\n+\treturn len(q.queue) + len(q.enqueued)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1974801841",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17825,
        "pr_file": "go/vt/vtorc/discovery/queue.go",
        "discussion_id": "1974801841",
        "commented_code": "@@ -33,85 +33,78 @@ import (\n \t\"vitess.io/vitess/go/vt/vtorc/config\"\n )\n \n-// Queue contains information for managing discovery requests\n-type Queue struct {\n-\tsync.Mutex\n+// queueItem represents an item in the discovery.Queue.\n+type queueItem struct {\n+\tPushedAt time.Time\n+\tKey      string\n+}\n \n-\tname         string\n-\tdone         chan struct{}\n-\tqueue        chan string\n-\tqueuedKeys   map[string]time.Time\n-\tconsumedKeys map[string]time.Time\n+// Queue is an ordered queue with deduplication.\n+type Queue struct {\n+\tmu       sync.Mutex\n+\tenqueued map[string]struct{}\n+\tqueue    chan queueItem\n }\n \n-// CreateQueue allows for creation of a new discovery queue\n-func CreateQueue(name string) *Queue {\n+// NewQueue creates a new queue.\n+func NewQueue() *Queue {\n \treturn &Queue{\n-\t\tname:         name,\n-\t\tqueuedKeys:   make(map[string]time.Time),\n-\t\tconsumedKeys: make(map[string]time.Time),\n-\t\tqueue:        make(chan string, config.DiscoveryQueueCapacity),\n+\t\tenqueued: make(map[string]struct{}),\n+\t\tqueue:    make(chan queueItem, config.DiscoveryQueueCapacity),\n+\t}\n+}\n+\n+// setKeyCheckEnqueued returns true if a key is already enqueued, if\n+// not the key will be marked as enqueued and false is returned.\n+func (q *Queue) setKeyCheckEnqueued(key string) (alreadyEnqueued bool) {\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n+\n+\t_, alreadyEnqueued = q.enqueued[key]\n+\tif !alreadyEnqueued {\n+\t\tq.enqueued[key] = struct{}{}\n \t}\n+\treturn alreadyEnqueued\n }\n \n-// QueueLen returns the length of the queue (channel size + queued size)\n+// QueueLen returns the length of the queue.\n func (q *Queue) QueueLen() int {\n-\tq.Lock()\n-\tdefer q.Unlock()\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n \n-\treturn len(q.queue) + len(q.queuedKeys)\n+\treturn len(q.queue) + len(q.enqueued)",
        "comment_created_at": "2025-02-28T05:26:01+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "This is actually incorrect. The length of of enqueued should be enough.\r\n\r\nBecause `enqueued` will have all the elements that are queued and also the ones that are currently running. By adding the length of queue, we are countint the former elements twice.",
        "pr_file_module": null
      },
      {
        "comment_id": "1975511430",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17825,
        "pr_file": "go/vt/vtorc/discovery/queue.go",
        "discussion_id": "1974801841",
        "commented_code": "@@ -33,85 +33,78 @@ import (\n \t\"vitess.io/vitess/go/vt/vtorc/config\"\n )\n \n-// Queue contains information for managing discovery requests\n-type Queue struct {\n-\tsync.Mutex\n+// queueItem represents an item in the discovery.Queue.\n+type queueItem struct {\n+\tPushedAt time.Time\n+\tKey      string\n+}\n \n-\tname         string\n-\tdone         chan struct{}\n-\tqueue        chan string\n-\tqueuedKeys   map[string]time.Time\n-\tconsumedKeys map[string]time.Time\n+// Queue is an ordered queue with deduplication.\n+type Queue struct {\n+\tmu       sync.Mutex\n+\tenqueued map[string]struct{}\n+\tqueue    chan queueItem\n }\n \n-// CreateQueue allows for creation of a new discovery queue\n-func CreateQueue(name string) *Queue {\n+// NewQueue creates a new queue.\n+func NewQueue() *Queue {\n \treturn &Queue{\n-\t\tname:         name,\n-\t\tqueuedKeys:   make(map[string]time.Time),\n-\t\tconsumedKeys: make(map[string]time.Time),\n-\t\tqueue:        make(chan string, config.DiscoveryQueueCapacity),\n+\t\tenqueued: make(map[string]struct{}),\n+\t\tqueue:    make(chan queueItem, config.DiscoveryQueueCapacity),\n+\t}\n+}\n+\n+// setKeyCheckEnqueued returns true if a key is already enqueued, if\n+// not the key will be marked as enqueued and false is returned.\n+func (q *Queue) setKeyCheckEnqueued(key string) (alreadyEnqueued bool) {\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n+\n+\t_, alreadyEnqueued = q.enqueued[key]\n+\tif !alreadyEnqueued {\n+\t\tq.enqueued[key] = struct{}{}\n \t}\n+\treturn alreadyEnqueued\n }\n \n-// QueueLen returns the length of the queue (channel size + queued size)\n+// QueueLen returns the length of the queue.\n func (q *Queue) QueueLen() int {\n-\tq.Lock()\n-\tdefer q.Unlock()\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n \n-\treturn len(q.queue) + len(q.queuedKeys)\n+\treturn len(q.queue) + len(q.enqueued)",
        "comment_created_at": "2025-02-28T14:31:28+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "@GuptaManan100 yeah, this is what the previous code did but it's pretty confusing\r\n\r\nIt seems to be measuring how much is sitting in the channel buffer plus what is queued. The size of the channel buffer is interesting, but confusing to include\r\n\r\nI might add a new metric for the channel buffer in a new PR and a method like `.BufferLen() int`. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1975512346",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17825,
        "pr_file": "go/vt/vtorc/discovery/queue.go",
        "discussion_id": "1974801841",
        "commented_code": "@@ -33,85 +33,78 @@ import (\n \t\"vitess.io/vitess/go/vt/vtorc/config\"\n )\n \n-// Queue contains information for managing discovery requests\n-type Queue struct {\n-\tsync.Mutex\n+// queueItem represents an item in the discovery.Queue.\n+type queueItem struct {\n+\tPushedAt time.Time\n+\tKey      string\n+}\n \n-\tname         string\n-\tdone         chan struct{}\n-\tqueue        chan string\n-\tqueuedKeys   map[string]time.Time\n-\tconsumedKeys map[string]time.Time\n+// Queue is an ordered queue with deduplication.\n+type Queue struct {\n+\tmu       sync.Mutex\n+\tenqueued map[string]struct{}\n+\tqueue    chan queueItem\n }\n \n-// CreateQueue allows for creation of a new discovery queue\n-func CreateQueue(name string) *Queue {\n+// NewQueue creates a new queue.\n+func NewQueue() *Queue {\n \treturn &Queue{\n-\t\tname:         name,\n-\t\tqueuedKeys:   make(map[string]time.Time),\n-\t\tconsumedKeys: make(map[string]time.Time),\n-\t\tqueue:        make(chan string, config.DiscoveryQueueCapacity),\n+\t\tenqueued: make(map[string]struct{}),\n+\t\tqueue:    make(chan queueItem, config.DiscoveryQueueCapacity),\n+\t}\n+}\n+\n+// setKeyCheckEnqueued returns true if a key is already enqueued, if\n+// not the key will be marked as enqueued and false is returned.\n+func (q *Queue) setKeyCheckEnqueued(key string) (alreadyEnqueued bool) {\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n+\n+\t_, alreadyEnqueued = q.enqueued[key]\n+\tif !alreadyEnqueued {\n+\t\tq.enqueued[key] = struct{}{}\n \t}\n+\treturn alreadyEnqueued\n }\n \n-// QueueLen returns the length of the queue (channel size + queued size)\n+// QueueLen returns the length of the queue.\n func (q *Queue) QueueLen() int {\n-\tq.Lock()\n-\tdefer q.Unlock()\n+\tq.mu.Lock()\n+\tdefer q.mu.Unlock()\n \n-\treturn len(q.queue) + len(q.queuedKeys)\n+\treturn len(q.queue) + len(q.enqueued)",
        "comment_created_at": "2025-02-28T14:32:04+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "Updated the code",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1975398019",
    "pr_number": 17777,
    "pr_file": "go/vt/vthash/highway/highwayhash.go",
    "created_at": "2025-02-28T13:17:38+00:00",
    "commented_code": "return\n }\n \n+func (d *Digest) WriteUint16(x uint16) (int, error) {\n+\tvar b [2]byte\n+\tbinary.LittleEndian.PutUint16(b[:], x)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1975398019",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17777,
        "pr_file": "go/vt/vthash/highway/highwayhash.go",
        "discussion_id": "1975398019",
        "commented_code": "@@ -142,6 +142,12 @@ func (d *Digest) Write(p []byte) (n int, err error) {\n \treturn\n }\n \n+func (d *Digest) WriteUint16(x uint16) (int, error) {\n+\tvar b [2]byte\n+\tbinary.LittleEndian.PutUint16(b[:], x)",
        "comment_created_at": "2025-02-28T13:17:38+00:00",
        "comment_author": "dbussink",
        "comment_body": "This can use https://pkg.go.dev/encoding/binary#Write, or is that much slower here? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1977290581",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17777,
        "pr_file": "go/vt/vthash/highway/highwayhash.go",
        "discussion_id": "1975398019",
        "commented_code": "@@ -142,6 +142,12 @@ func (d *Digest) Write(p []byte) (n int, err error) {\n \treturn\n }\n \n+func (d *Digest) WriteUint16(x uint16) (int, error) {\n+\tvar b [2]byte\n+\tbinary.LittleEndian.PutUint16(b[:], x)",
        "comment_created_at": "2025-03-03T10:45:31+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "binary.Write uses reflection, this is simple and efficient in those terms. Do not see a reason to add a benchmark to validate it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1828945357",
    "pr_number": 17135,
    "pr_file": "go/vt/servenv/grpc_codec.go",
    "created_at": "2024-11-05T08:41:49+00:00",
    "commented_code": "return nil, err\n \t\t}\n \t\treturn mem.BufferSlice{mem.NewBuffer(buf, defaultBufferPool)}, nil\n+\tcase vtprotoMemBuffer:\n+\t\treturn m.MarshalToMemBufferVT()",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1828945357",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17135,
        "pr_file": "go/vt/servenv/grpc_codec.go",
        "discussion_id": "1828945357",
        "commented_code": "@@ -58,9 +63,11 @@ func (c *Codec) Marshal(v any) (mem.BufferSlice, error) {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn mem.BufferSlice{mem.NewBuffer(buf, defaultBufferPool)}, nil\n+\tcase vtprotoMemBuffer:\n+\t\treturn m.MarshalToMemBufferVT()",
        "comment_created_at": "2024-11-05T08:41:49+00:00",
        "comment_author": "vmg",
        "comment_body": "This is not the right ordering; all the messages that implement `vtprotoMemBuffer` also implement `vtprotoMessage`, so this branch will never be used. You need to move this above.",
        "pr_file_module": null
      }
    ]
  }
]