[
  {
    "discussion_id": "2160426858",
    "pr_number": 18389,
    "pr_file": "go/vt/vtorc/discovery/queue.go",
    "created_at": "2025-06-22T18:36:35+00:00",
    "commented_code": "\"time\"\n \n \t\"vitess.io/vitess/go/vt/log\"\n+\ttopodatapb \"vitess.io/vitess/go/vt/proto/topodata\"\n+\t\"vitess.io/vitess/go/vt/topo/topoproto\"\n \t\"vitess.io/vitess/go/vt/vtorc/config\"\n )\n \n // queueItem represents an item in the discovery.Queue.\n type queueItem struct {\n-\tKey      string\n-\tPushedAt time.Time\n+\tTabletAlias *topodatapb.TabletAlias",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2160426858",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18389,
        "pr_file": "go/vt/vtorc/discovery/queue.go",
        "discussion_id": "2160426858",
        "commented_code": "@@ -30,39 +30,41 @@ import (\n \t\"time\"\n \n \t\"vitess.io/vitess/go/vt/log\"\n+\ttopodatapb \"vitess.io/vitess/go/vt/proto/topodata\"\n+\t\"vitess.io/vitess/go/vt/topo/topoproto\"\n \t\"vitess.io/vitess/go/vt/vtorc/config\"\n )\n \n // queueItem represents an item in the discovery.Queue.\n type queueItem struct {\n-\tKey      string\n-\tPushedAt time.Time\n+\tTabletAlias *topodatapb.TabletAlias",
        "comment_created_at": "2025-06-22T18:36:35+00:00",
        "comment_author": "timvaillancourt",
        "comment_body": "Interestingly, this reduces the size of the `enqueued` map keys by 50%:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n        \"fmt\"\r\n        \"unsafe\"\r\n\r\n        \"vitess.io/vitess/go/vt/topo/topoproto\"\r\n        topodatapb \"vitess.io/vitess/go/vt/proto/topodata\"\r\n)\r\n\r\nfunc main() {\r\n        tabletAlias := &topodatapb.TabletAlias{Cell: \"zone1\", Uid: 12345}\r\n        fmt.Println(unsafe.Sizeof(tabletAlias))\r\n\r\n        tabletAliasString := topoproto.TabletAliasString(tabletAlias)\r\n        fmt.Println(unsafe.Sizeof(tabletAliasString))\r\n}\r\n```\r\nReturns:\r\n```bash\r\n8\r\n16\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1918717493",
    "pr_number": 17556,
    "pr_file": "go/sqltypes/cached_size.go",
    "created_at": "2025-01-16T15:02:08+00:00",
    "commented_code": "// field Rows []vitess.io/vitess/go/sqltypes.Row\n \t{\n \t\tsize += hack.RuntimeAllocSize(int64(cap(cached.Rows)) * int64(24))\n+\t\tfor _, elem := range cached.Rows {\n+\t\t\t{\n+\t\t\t\tsize += hack.RuntimeAllocSize(int64(cap(elem)) * int64(32))\n+\t\t\t\tfor _, elem := range elem {\n+\t\t\t\t\tsize += elem.CachedSize(false)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1918717493",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17556,
        "pr_file": "go/sqltypes/cached_size.go",
        "discussion_id": "1918717493",
        "commented_code": "@@ -37,6 +37,14 @@ func (cached *Result) CachedSize(alloc bool) int64 {\n \t// field Rows []vitess.io/vitess/go/sqltypes.Row\n \t{\n \t\tsize += hack.RuntimeAllocSize(int64(cap(cached.Rows)) * int64(24))\n+\t\tfor _, elem := range cached.Rows {\n+\t\t\t{\n+\t\t\t\tsize += hack.RuntimeAllocSize(int64(cap(elem)) * int64(32))\n+\t\t\t\tfor _, elem := range elem {\n+\t\t\t\t\tsize += elem.CachedSize(false)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}",
        "comment_created_at": "2025-01-16T15:02:08+00:00",
        "comment_author": "vmg",
        "comment_body": "This was the big missing memory calculation for the size of in-memory query results.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1624570000",
    "pr_number": 16022,
    "pr_file": "go/vt/mysqlctl/replication.go",
    "created_at": "2024-06-03T14:32:55+00:00",
    "commented_code": "return conn.Conn.GetServerUUID()\n }\n \n+// GetGlobalStatusVars returns the server's global status variables asked for.\n+// An empty/nil variable name parameter slice means you want all of them.\n+func (mysqld *Mysqld) GetGlobalStatusVars(ctx context.Context, statuses []string) (map[string]string, error) {\n+\tquery := \"SELECT variable_name, variable_value FROM performance_schema.global_status\"\n+\tif len(statuses) != 0 {\n+\t\t// The format specifier is for any optional predicates.\n+\t\tstatusBv, err := sqltypes.BuildBindVariable(statuses)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tquery, err = sqlparser.ParseAndBind(\"SELECT variable_name, variable_value FROM performance_schema.global_status WHERE variable_name IN %a\",\n+\t\t\tstatusBv,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tqr, err := mysqld.FetchSuperQuery(ctx, query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfinalRes := make(map[string]string)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1624570000",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1624570000",
        "commented_code": "@@ -228,6 +230,38 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetGlobalStatusVars returns the server's global status variables asked for.\n+// An empty/nil variable name parameter slice means you want all of them.\n+func (mysqld *Mysqld) GetGlobalStatusVars(ctx context.Context, statuses []string) (map[string]string, error) {\n+\tquery := \"SELECT variable_name, variable_value FROM performance_schema.global_status\"\n+\tif len(statuses) != 0 {\n+\t\t// The format specifier is for any optional predicates.\n+\t\tstatusBv, err := sqltypes.BuildBindVariable(statuses)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tquery, err = sqlparser.ParseAndBind(\"SELECT variable_name, variable_value FROM performance_schema.global_status WHERE variable_name IN %a\",\n+\t\t\tstatusBv,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tqr, err := mysqld.FetchSuperQuery(ctx, query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfinalRes := make(map[string]string)",
        "comment_created_at": "2024-06-03T14:32:55+00:00",
        "comment_author": "mattlord",
        "comment_body": "We can allocate this in one shot: `finalRes := make(map[string]string, len(qr.Rows))`",
        "pr_file_module": null
      },
      {
        "comment_id": "1625056179",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1624570000",
        "commented_code": "@@ -228,6 +230,38 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetGlobalStatusVars returns the server's global status variables asked for.\n+// An empty/nil variable name parameter slice means you want all of them.\n+func (mysqld *Mysqld) GetGlobalStatusVars(ctx context.Context, statuses []string) (map[string]string, error) {\n+\tquery := \"SELECT variable_name, variable_value FROM performance_schema.global_status\"\n+\tif len(statuses) != 0 {\n+\t\t// The format specifier is for any optional predicates.\n+\t\tstatusBv, err := sqltypes.BuildBindVariable(statuses)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tquery, err = sqlparser.ParseAndBind(\"SELECT variable_name, variable_value FROM performance_schema.global_status WHERE variable_name IN %a\",\n+\t\t\tstatusBv,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tqr, err := mysqld.FetchSuperQuery(ctx, query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfinalRes := make(map[string]string)",
        "comment_created_at": "2024-06-03T21:11:10+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1871622349",
    "pr_number": 17271,
    "pr_file": "go/vt/mysqlctl/errorsbackup/errors.go",
    "created_at": "2024-12-05T15:46:14+00:00",
    "commented_code": "+/*\n+Copyright 2024 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package errorsbackup\n+\n+import (\n+\t\"errors\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+type BackupErrorRecorder interface {\n+\tRecordError(string, error)\n+\tHasErrors() bool\n+\tError() error\n+\tGetFailedFiles() []string\n+\tResetErrorForFile(string)\n+}\n+\n+// PerFileErrorRecorder records errors and group them by filename.\n+// This is particularly useful when processing several files at the same time\n+// and wanting to know which files failed.\n+type PerFileErrorRecorder struct {\n+\tmu     sync.Mutex\n+\terrors map[string][]error\n+}\n+\n+// RecordError records a possible error:\n+// - does nothing if err is nil\n+func (pfer *PerFileErrorRecorder) RecordError(filename string, err error) {\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\n+\tpfer.mu.Lock()\n+\tdefer pfer.mu.Unlock()\n+\n+\tif pfer.errors == nil {\n+\t\tpfer.errors = make(map[string][]error)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1871622349",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17271,
        "pr_file": "go/vt/mysqlctl/errorsbackup/errors.go",
        "discussion_id": "1871622349",
        "commented_code": "@@ -0,0 +1,106 @@\n+/*\n+Copyright 2024 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package errorsbackup\n+\n+import (\n+\t\"errors\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+type BackupErrorRecorder interface {\n+\tRecordError(string, error)\n+\tHasErrors() bool\n+\tError() error\n+\tGetFailedFiles() []string\n+\tResetErrorForFile(string)\n+}\n+\n+// PerFileErrorRecorder records errors and group them by filename.\n+// This is particularly useful when processing several files at the same time\n+// and wanting to know which files failed.\n+type PerFileErrorRecorder struct {\n+\tmu     sync.Mutex\n+\terrors map[string][]error\n+}\n+\n+// RecordError records a possible error:\n+// - does nothing if err is nil\n+func (pfer *PerFileErrorRecorder) RecordError(filename string, err error) {\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\n+\tpfer.mu.Lock()\n+\tdefer pfer.mu.Unlock()\n+\n+\tif pfer.errors == nil {\n+\t\tpfer.errors = make(map[string][]error)",
        "comment_created_at": "2024-12-05T15:46:14+00:00",
        "comment_author": "mattlord",
        "comment_body": "Probably worth setting the initial capacity to 1.",
        "pr_file_module": null
      },
      {
        "comment_id": "1872221328",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17271,
        "pr_file": "go/vt/mysqlctl/errorsbackup/errors.go",
        "discussion_id": "1871622349",
        "commented_code": "@@ -0,0 +1,106 @@\n+/*\n+Copyright 2024 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package errorsbackup\n+\n+import (\n+\t\"errors\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+type BackupErrorRecorder interface {\n+\tRecordError(string, error)\n+\tHasErrors() bool\n+\tError() error\n+\tGetFailedFiles() []string\n+\tResetErrorForFile(string)\n+}\n+\n+// PerFileErrorRecorder records errors and group them by filename.\n+// This is particularly useful when processing several files at the same time\n+// and wanting to know which files failed.\n+type PerFileErrorRecorder struct {\n+\tmu     sync.Mutex\n+\terrors map[string][]error\n+}\n+\n+// RecordError records a possible error:\n+// - does nothing if err is nil\n+func (pfer *PerFileErrorRecorder) RecordError(filename string, err error) {\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\n+\tpfer.mu.Lock()\n+\tdefer pfer.mu.Unlock()\n+\n+\tif pfer.errors == nil {\n+\t\tpfer.errors = make(map[string][]error)",
        "comment_created_at": "2024-12-05T22:06:16+00:00",
        "comment_author": "frouioui",
        "comment_body": "Fixed via 19d6e2866dc",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1856693483",
    "pr_number": 17166,
    "pr_file": "go/vt/vttablet/tabletmanager/vreplication/replicator_plan.go",
    "created_at": "2024-11-25T14:16:59+00:00",
    "commented_code": "func (tp *TablePlan) appendFromRow(buf *bytes2.Buffer, row *querypb.Row) error {\n \tbindLocations := tp.BulkInsertValues.BindLocations()\n \tif len(tp.Fields) < len(bindLocations) {\n-\t\treturn vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"wrong number of fields: got %d fields for %d bind locations \",\n+\t\treturn vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"wrong number of fields: got %d fields for %d bind locations\",\n \t\t\tlen(tp.Fields), len(bindLocations))\n \t}\n \n-\ttype colInfo struct {\n-\t\ttyp    querypb.Type\n-\t\tlength int64\n-\t\toffset int64\n-\t\tfield  *querypb.Field\n-\t}\n-\trowInfo := make([]*colInfo, 0)\n-\n-\toffset := int64(0)\n-\tfor i, field := range tp.Fields { // collect info required for fields to be bound\n-\t\tlength := row.Lengths[i]\n-\t\tif !tp.FieldsToSkip[strings.ToLower(field.Name)] {\n-\t\t\trowInfo = append(rowInfo, &colInfo{\n-\t\t\t\ttyp:    field.Type,\n-\t\t\t\tlength: length,\n-\t\t\t\toffset: offset,\n-\t\t\t\tfield:  field,\n-\t\t\t})\n-\t\t}\n-\t\tif length > 0 {\n-\t\t\toffset += row.Lengths[i]\n+\t// Bind field values to locations.\n+\tvar (\n+\t\toffset      int64\n+\t\toffsetQuery int\n+\t\tfieldsIndex int\n+\t\tfield       *querypb.Field\n+\t)\n+\tfor i, loc := range bindLocations {\n+\t\tfield = tp.Fields[fieldsIndex]\n+\t\tlength := row.Lengths[fieldsIndex]\n+\t\tfor tp.FieldsToSkip[strings.ToLower(field.Name)] {\n+\t\t\tif length > 0 {\n+\t\t\t\toffset += length\n+\t\t\t}\n+\t\t\tfieldsIndex++\n+\t\t\tfield = tp.Fields[fieldsIndex]\n+\t\t\tlength = row.Lengths[fieldsIndex]",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1856693483",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17166,
        "pr_file": "go/vt/vttablet/tabletmanager/vreplication/replicator_plan.go",
        "discussion_id": "1856693483",
        "commented_code": "@@ -618,66 +618,57 @@ func valsEqual(v1, v2 sqltypes.Value) bool {\n func (tp *TablePlan) appendFromRow(buf *bytes2.Buffer, row *querypb.Row) error {\n \tbindLocations := tp.BulkInsertValues.BindLocations()\n \tif len(tp.Fields) < len(bindLocations) {\n-\t\treturn vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"wrong number of fields: got %d fields for %d bind locations \",\n+\t\treturn vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"wrong number of fields: got %d fields for %d bind locations\",\n \t\t\tlen(tp.Fields), len(bindLocations))\n \t}\n \n-\ttype colInfo struct {\n-\t\ttyp    querypb.Type\n-\t\tlength int64\n-\t\toffset int64\n-\t\tfield  *querypb.Field\n-\t}\n-\trowInfo := make([]*colInfo, 0)\n-\n-\toffset := int64(0)\n-\tfor i, field := range tp.Fields { // collect info required for fields to be bound\n-\t\tlength := row.Lengths[i]\n-\t\tif !tp.FieldsToSkip[strings.ToLower(field.Name)] {\n-\t\t\trowInfo = append(rowInfo, &colInfo{\n-\t\t\t\ttyp:    field.Type,\n-\t\t\t\tlength: length,\n-\t\t\t\toffset: offset,\n-\t\t\t\tfield:  field,\n-\t\t\t})\n-\t\t}\n-\t\tif length > 0 {\n-\t\t\toffset += row.Lengths[i]\n+\t// Bind field values to locations.\n+\tvar (\n+\t\toffset      int64\n+\t\toffsetQuery int\n+\t\tfieldsIndex int\n+\t\tfield       *querypb.Field\n+\t)\n+\tfor i, loc := range bindLocations {\n+\t\tfield = tp.Fields[fieldsIndex]\n+\t\tlength := row.Lengths[fieldsIndex]\n+\t\tfor tp.FieldsToSkip[strings.ToLower(field.Name)] {\n+\t\t\tif length > 0 {\n+\t\t\t\toffset += length\n+\t\t\t}\n+\t\t\tfieldsIndex++\n+\t\t\tfield = tp.Fields[fieldsIndex]\n+\t\t\tlength = row.Lengths[fieldsIndex]",
        "comment_created_at": "2024-11-25T14:16:59+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "This looks fine. I don't have the context to understand why this change is necessarily faster. Can you please explain?",
        "pr_file_module": null
      },
      {
        "comment_id": "1865838556",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17166,
        "pr_file": "go/vt/vttablet/tabletmanager/vreplication/replicator_plan.go",
        "discussion_id": "1856693483",
        "commented_code": "@@ -618,66 +618,57 @@ func valsEqual(v1, v2 sqltypes.Value) bool {\n func (tp *TablePlan) appendFromRow(buf *bytes2.Buffer, row *querypb.Row) error {\n \tbindLocations := tp.BulkInsertValues.BindLocations()\n \tif len(tp.Fields) < len(bindLocations) {\n-\t\treturn vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"wrong number of fields: got %d fields for %d bind locations \",\n+\t\treturn vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"wrong number of fields: got %d fields for %d bind locations\",\n \t\t\tlen(tp.Fields), len(bindLocations))\n \t}\n \n-\ttype colInfo struct {\n-\t\ttyp    querypb.Type\n-\t\tlength int64\n-\t\toffset int64\n-\t\tfield  *querypb.Field\n-\t}\n-\trowInfo := make([]*colInfo, 0)\n-\n-\toffset := int64(0)\n-\tfor i, field := range tp.Fields { // collect info required for fields to be bound\n-\t\tlength := row.Lengths[i]\n-\t\tif !tp.FieldsToSkip[strings.ToLower(field.Name)] {\n-\t\t\trowInfo = append(rowInfo, &colInfo{\n-\t\t\t\ttyp:    field.Type,\n-\t\t\t\tlength: length,\n-\t\t\t\toffset: offset,\n-\t\t\t\tfield:  field,\n-\t\t\t})\n-\t\t}\n-\t\tif length > 0 {\n-\t\t\toffset += row.Lengths[i]\n+\t// Bind field values to locations.\n+\tvar (\n+\t\toffset      int64\n+\t\toffsetQuery int\n+\t\tfieldsIndex int\n+\t\tfield       *querypb.Field\n+\t)\n+\tfor i, loc := range bindLocations {\n+\t\tfield = tp.Fields[fieldsIndex]\n+\t\tlength := row.Lengths[fieldsIndex]\n+\t\tfor tp.FieldsToSkip[strings.ToLower(field.Name)] {\n+\t\t\tif length > 0 {\n+\t\t\t\toffset += length\n+\t\t\t}\n+\t\t\tfieldsIndex++\n+\t\t\tfield = tp.Fields[fieldsIndex]\n+\t\t\tlength = row.Lengths[fieldsIndex]",
        "comment_created_at": "2024-12-02T13:17:51+00:00",
        "comment_author": "rohit-nayak-ps",
        "comment_body": "It cuts out the overhead of the intermediate data structure `colInfo`: mainly in memory allocation and also a bit of cpu because of the large number of rows inserted during the copy phase.",
        "pr_file_module": null
      }
    ]
  }
]