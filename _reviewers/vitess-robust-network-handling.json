[
  {
    "discussion_id": "1962188675",
    "pr_number": 17763,
    "pr_file": "go/vt/vttablet/tabletmanager/semisyncmonitor/monitor.go",
    "created_at": "2025-02-19T18:35:16+00:00",
    "commented_code": "+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semisyncmonitor\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"vitess.io/vitess/go/constants/sidecar\"\n+\t\"vitess.io/vitess/go/mysql/fakesqldb\"\n+\t\"vitess.io/vitess/go/stats\"\n+\t\"vitess.io/vitess/go/timer\"\n+\t\"vitess.io/vitess/go/vt/dbconfigs\"\n+\t\"vitess.io/vitess/go/vt/dbconnpool\"\n+\t\"vitess.io/vitess/go/vt/log\"\n+\t\"vitess.io/vitess/go/vt/mysqlctl\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+\t\"vitess.io/vitess/go/vt/vttablet/tabletserver/tabletenv\"\n+)\n+\n+const (\n+\tsemiSyncWaitSessionsRead = \"SHOW STATUS LIKE 'Rpl_semi_sync_%_wait_sessions'\"\n+\tsemiSyncRecoverWrite     = \"INSERT INTO %s.semisync_recover (ts) VALUES (NOW())\"\n+\tsemiSyncRecoverClear     = \"TRUNCATE TABLE %s.semisync_recover\"\n+\tmaxWritesPermitted       = 15\n+\tclearTimerDuration       = 24 * time.Hour\n+)\n+\n+var (\n+\t// waitBetweenWrites is the time to wait between consecutive writes.\n+\t// This is a variable instead of a constant only to be tweaked in tests.\n+\twaitBetweenWrites = 1 * time.Second\n+)\n+\n+// Monitor is a monitor that checks if the primary tablet\n+// is blocked on a semi-sync ack from the replica.\n+// If the semi-sync ACK is lost in the network,\n+// it is possible that the primary is indefinitely stuck,\n+// blocking PRS. The monitor looks for this situation and manufactures a write\n+// periodically to unblock the primary.\n+type Monitor struct {\n+\t// config is used to get the connection parameters.\n+\tconfig *tabletenv.TabletConfig\n+\t// ticks is the ticker on which we'll check\n+\t// if the primary is blocked on semi-sync ACKs or not.\n+\tticks *timer.Timer\n+\t// clearTicks is the ticker to clear the data in\n+\t// the semisync_recover table.\n+\tclearTicks *timer.Timer\n+\n+\t// mu protects the fields below.\n+\tmu      sync.Mutex\n+\tappPool *dbconnpool.ConnectionPool\n+\tisOpen  bool\n+\t// isWriting stores if the monitor is currently writing to the DB.\n+\t// We don't want two different threads initiating writes, so we use this\n+\t// for synchronization.\n+\tisWriting bool\n+\t// inProgressWriteCount is the number of writes currently in progress.\n+\t// The writes from the monitor themselves might get blocked and hence a count for them is required.\n+\t// After enough writes are blocked, we want to notify VTOrc to run an ERS.\n+\tinProgressWriteCount int\n+\t// isBlocked stores if the primary is blocked on semi-sync ack.\n+\tisBlocked bool\n+\t// waiters stores the list of waiters that are waiting for the primary to be unblocked.\n+\twaiters []chan any\n+\t// writesBlockedGauge is a gauge tracking the number of writes the monitor is blocked on.\n+\twritesBlockedGauge *stats.Gauge\n+}\n+\n+// NewMonitor creates a new Monitor.\n+func NewMonitor(config *tabletenv.TabletConfig, exporter *servenv.Exporter) *Monitor {\n+\treturn &Monitor{\n+\t\tconfig: config,\n+\t\tticks:  timer.NewTimer(config.SemiSyncMonitor.Interval),\n+\t\t// We clear the data every day. We can make it configurable in the future,\n+\t\t// but this seams fine for now.\n+\t\tclearTicks:         timer.NewTimer(clearTimerDuration),\n+\t\twritesBlockedGauge: exporter.NewGauge(\"SemiSyncMonitorWritesBlocked\", \"Number of writes blocked in the semi-sync monitor\"),\n+\t\tappPool:            dbconnpool.NewConnectionPool(\"SemiSyncMonitorAppPool\", exporter, 20, mysqlctl.DbaIdleTimeout, 0, mysqlctl.PoolDynamicHostnameResolution),\n+\t\twaiters:            make([]chan any, 0),\n+\t}\n+}\n+\n+// CreateTestSemiSyncMonitor created a monitor for testing.\n+// It takes an optional fake db.\n+func CreateTestSemiSyncMonitor(db *fakesqldb.DB, exporter *servenv.Exporter) *Monitor {\n+\tvar dbc *dbconfigs.DBConfigs\n+\tif db != nil {\n+\t\tparams := db.ConnParams()\n+\t\tcp := *params\n+\t\tdbc = dbconfigs.NewTestDBConfigs(cp, cp, \"\")\n+\t}\n+\treturn NewMonitor(&tabletenv.TabletConfig{\n+\t\tDB: dbc,\n+\t\tSemiSyncMonitor: tabletenv.SemiSyncMonitorConfig{\n+\t\t\tInterval: 1 * time.Second,\n+\t\t},\n+\t}, exporter)\n+}\n+\n+// Open starts the monitor.\n+func (m *Monitor) Open() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\t// The check for config being nil is only requried for tests.\n+\tif m.isOpen || m.config == nil || m.config.DB == nil {\n+\t\t// If we are already open, then there is nothing to do\n+\t\treturn\n+\t}\n+\t// Set the monitor to be open.\n+\tm.isOpen = true\n+\tlog.Info(\"SemiSync Monitor: opening\")\n+\n+\t// This function could be running from within a unit test scope, in which case we use\n+\t// mock pools that are already open. This is why we test for the pool being open.\n+\tif !m.appPool.IsOpen() {\n+\t\tm.appPool.Open(m.config.DB.AppWithDB())\n+\t}\n+\tm.clearTicks.Start(m.clearAllData)\n+\tm.ticks.Start(m.checkAndFixSemiSyncBlocked)\n+}\n+\n+// Close stops the monitor.\n+func (m *Monitor) Close() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\tif !m.isOpen {\n+\t\t// If we are already closed, then there is nothing to do\n+\t\treturn\n+\t}\n+\tm.isOpen = false\n+\tlog.Info(\"SemiSync Monitor: closing\")\n+\tm.clearTicks.Stop()\n+\tm.ticks.Stop()\n+\tm.appPool.Close()\n+}\n+\n+// checkAndFixSemiSyncBlocked checks if the primary is blocked on semi-sync ack\n+// and manufactures a write to unblock the primary. This function is safe to\n+// be called multiple times in parallel.\n+func (m *Monitor) checkAndFixSemiSyncBlocked() {\n+\t// Check if semi-sync is blocked or not\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1962188675",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17763,
        "pr_file": "go/vt/vttablet/tabletmanager/semisyncmonitor/monitor.go",
        "discussion_id": "1962188675",
        "commented_code": "@@ -0,0 +1,390 @@\n+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semisyncmonitor\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"vitess.io/vitess/go/constants/sidecar\"\n+\t\"vitess.io/vitess/go/mysql/fakesqldb\"\n+\t\"vitess.io/vitess/go/stats\"\n+\t\"vitess.io/vitess/go/timer\"\n+\t\"vitess.io/vitess/go/vt/dbconfigs\"\n+\t\"vitess.io/vitess/go/vt/dbconnpool\"\n+\t\"vitess.io/vitess/go/vt/log\"\n+\t\"vitess.io/vitess/go/vt/mysqlctl\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+\t\"vitess.io/vitess/go/vt/vttablet/tabletserver/tabletenv\"\n+)\n+\n+const (\n+\tsemiSyncWaitSessionsRead = \"SHOW STATUS LIKE 'Rpl_semi_sync_%_wait_sessions'\"\n+\tsemiSyncRecoverWrite     = \"INSERT INTO %s.semisync_recover (ts) VALUES (NOW())\"\n+\tsemiSyncRecoverClear     = \"TRUNCATE TABLE %s.semisync_recover\"\n+\tmaxWritesPermitted       = 15\n+\tclearTimerDuration       = 24 * time.Hour\n+)\n+\n+var (\n+\t// waitBetweenWrites is the time to wait between consecutive writes.\n+\t// This is a variable instead of a constant only to be tweaked in tests.\n+\twaitBetweenWrites = 1 * time.Second\n+)\n+\n+// Monitor is a monitor that checks if the primary tablet\n+// is blocked on a semi-sync ack from the replica.\n+// If the semi-sync ACK is lost in the network,\n+// it is possible that the primary is indefinitely stuck,\n+// blocking PRS. The monitor looks for this situation and manufactures a write\n+// periodically to unblock the primary.\n+type Monitor struct {\n+\t// config is used to get the connection parameters.\n+\tconfig *tabletenv.TabletConfig\n+\t// ticks is the ticker on which we'll check\n+\t// if the primary is blocked on semi-sync ACKs or not.\n+\tticks *timer.Timer\n+\t// clearTicks is the ticker to clear the data in\n+\t// the semisync_recover table.\n+\tclearTicks *timer.Timer\n+\n+\t// mu protects the fields below.\n+\tmu      sync.Mutex\n+\tappPool *dbconnpool.ConnectionPool\n+\tisOpen  bool\n+\t// isWriting stores if the monitor is currently writing to the DB.\n+\t// We don't want two different threads initiating writes, so we use this\n+\t// for synchronization.\n+\tisWriting bool\n+\t// inProgressWriteCount is the number of writes currently in progress.\n+\t// The writes from the monitor themselves might get blocked and hence a count for them is required.\n+\t// After enough writes are blocked, we want to notify VTOrc to run an ERS.\n+\tinProgressWriteCount int\n+\t// isBlocked stores if the primary is blocked on semi-sync ack.\n+\tisBlocked bool\n+\t// waiters stores the list of waiters that are waiting for the primary to be unblocked.\n+\twaiters []chan any\n+\t// writesBlockedGauge is a gauge tracking the number of writes the monitor is blocked on.\n+\twritesBlockedGauge *stats.Gauge\n+}\n+\n+// NewMonitor creates a new Monitor.\n+func NewMonitor(config *tabletenv.TabletConfig, exporter *servenv.Exporter) *Monitor {\n+\treturn &Monitor{\n+\t\tconfig: config,\n+\t\tticks:  timer.NewTimer(config.SemiSyncMonitor.Interval),\n+\t\t// We clear the data every day. We can make it configurable in the future,\n+\t\t// but this seams fine for now.\n+\t\tclearTicks:         timer.NewTimer(clearTimerDuration),\n+\t\twritesBlockedGauge: exporter.NewGauge(\"SemiSyncMonitorWritesBlocked\", \"Number of writes blocked in the semi-sync monitor\"),\n+\t\tappPool:            dbconnpool.NewConnectionPool(\"SemiSyncMonitorAppPool\", exporter, 20, mysqlctl.DbaIdleTimeout, 0, mysqlctl.PoolDynamicHostnameResolution),\n+\t\twaiters:            make([]chan any, 0),\n+\t}\n+}\n+\n+// CreateTestSemiSyncMonitor created a monitor for testing.\n+// It takes an optional fake db.\n+func CreateTestSemiSyncMonitor(db *fakesqldb.DB, exporter *servenv.Exporter) *Monitor {\n+\tvar dbc *dbconfigs.DBConfigs\n+\tif db != nil {\n+\t\tparams := db.ConnParams()\n+\t\tcp := *params\n+\t\tdbc = dbconfigs.NewTestDBConfigs(cp, cp, \"\")\n+\t}\n+\treturn NewMonitor(&tabletenv.TabletConfig{\n+\t\tDB: dbc,\n+\t\tSemiSyncMonitor: tabletenv.SemiSyncMonitorConfig{\n+\t\t\tInterval: 1 * time.Second,\n+\t\t},\n+\t}, exporter)\n+}\n+\n+// Open starts the monitor.\n+func (m *Monitor) Open() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\t// The check for config being nil is only requried for tests.\n+\tif m.isOpen || m.config == nil || m.config.DB == nil {\n+\t\t// If we are already open, then there is nothing to do\n+\t\treturn\n+\t}\n+\t// Set the monitor to be open.\n+\tm.isOpen = true\n+\tlog.Info(\"SemiSync Monitor: opening\")\n+\n+\t// This function could be running from within a unit test scope, in which case we use\n+\t// mock pools that are already open. This is why we test for the pool being open.\n+\tif !m.appPool.IsOpen() {\n+\t\tm.appPool.Open(m.config.DB.AppWithDB())\n+\t}\n+\tm.clearTicks.Start(m.clearAllData)\n+\tm.ticks.Start(m.checkAndFixSemiSyncBlocked)\n+}\n+\n+// Close stops the monitor.\n+func (m *Monitor) Close() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\tif !m.isOpen {\n+\t\t// If we are already closed, then there is nothing to do\n+\t\treturn\n+\t}\n+\tm.isOpen = false\n+\tlog.Info(\"SemiSync Monitor: closing\")\n+\tm.clearTicks.Stop()\n+\tm.ticks.Stop()\n+\tm.appPool.Close()\n+}\n+\n+// checkAndFixSemiSyncBlocked checks if the primary is blocked on semi-sync ack\n+// and manufactures a write to unblock the primary. This function is safe to\n+// be called multiple times in parallel.\n+func (m *Monitor) checkAndFixSemiSyncBlocked() {\n+\t// Check if semi-sync is blocked or not\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)",
        "comment_created_at": "2025-02-19T18:35:16+00:00",
        "comment_author": "deepthi",
        "comment_body": "Why are we hardcoding the timeout and not using `RemoteOperationTimeout`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1963021855",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17763,
        "pr_file": "go/vt/vttablet/tabletmanager/semisyncmonitor/monitor.go",
        "discussion_id": "1962188675",
        "commented_code": "@@ -0,0 +1,390 @@\n+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semisyncmonitor\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"vitess.io/vitess/go/constants/sidecar\"\n+\t\"vitess.io/vitess/go/mysql/fakesqldb\"\n+\t\"vitess.io/vitess/go/stats\"\n+\t\"vitess.io/vitess/go/timer\"\n+\t\"vitess.io/vitess/go/vt/dbconfigs\"\n+\t\"vitess.io/vitess/go/vt/dbconnpool\"\n+\t\"vitess.io/vitess/go/vt/log\"\n+\t\"vitess.io/vitess/go/vt/mysqlctl\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+\t\"vitess.io/vitess/go/vt/vttablet/tabletserver/tabletenv\"\n+)\n+\n+const (\n+\tsemiSyncWaitSessionsRead = \"SHOW STATUS LIKE 'Rpl_semi_sync_%_wait_sessions'\"\n+\tsemiSyncRecoverWrite     = \"INSERT INTO %s.semisync_recover (ts) VALUES (NOW())\"\n+\tsemiSyncRecoverClear     = \"TRUNCATE TABLE %s.semisync_recover\"\n+\tmaxWritesPermitted       = 15\n+\tclearTimerDuration       = 24 * time.Hour\n+)\n+\n+var (\n+\t// waitBetweenWrites is the time to wait between consecutive writes.\n+\t// This is a variable instead of a constant only to be tweaked in tests.\n+\twaitBetweenWrites = 1 * time.Second\n+)\n+\n+// Monitor is a monitor that checks if the primary tablet\n+// is blocked on a semi-sync ack from the replica.\n+// If the semi-sync ACK is lost in the network,\n+// it is possible that the primary is indefinitely stuck,\n+// blocking PRS. The monitor looks for this situation and manufactures a write\n+// periodically to unblock the primary.\n+type Monitor struct {\n+\t// config is used to get the connection parameters.\n+\tconfig *tabletenv.TabletConfig\n+\t// ticks is the ticker on which we'll check\n+\t// if the primary is blocked on semi-sync ACKs or not.\n+\tticks *timer.Timer\n+\t// clearTicks is the ticker to clear the data in\n+\t// the semisync_recover table.\n+\tclearTicks *timer.Timer\n+\n+\t// mu protects the fields below.\n+\tmu      sync.Mutex\n+\tappPool *dbconnpool.ConnectionPool\n+\tisOpen  bool\n+\t// isWriting stores if the monitor is currently writing to the DB.\n+\t// We don't want two different threads initiating writes, so we use this\n+\t// for synchronization.\n+\tisWriting bool\n+\t// inProgressWriteCount is the number of writes currently in progress.\n+\t// The writes from the monitor themselves might get blocked and hence a count for them is required.\n+\t// After enough writes are blocked, we want to notify VTOrc to run an ERS.\n+\tinProgressWriteCount int\n+\t// isBlocked stores if the primary is blocked on semi-sync ack.\n+\tisBlocked bool\n+\t// waiters stores the list of waiters that are waiting for the primary to be unblocked.\n+\twaiters []chan any\n+\t// writesBlockedGauge is a gauge tracking the number of writes the monitor is blocked on.\n+\twritesBlockedGauge *stats.Gauge\n+}\n+\n+// NewMonitor creates a new Monitor.\n+func NewMonitor(config *tabletenv.TabletConfig, exporter *servenv.Exporter) *Monitor {\n+\treturn &Monitor{\n+\t\tconfig: config,\n+\t\tticks:  timer.NewTimer(config.SemiSyncMonitor.Interval),\n+\t\t// We clear the data every day. We can make it configurable in the future,\n+\t\t// but this seams fine for now.\n+\t\tclearTicks:         timer.NewTimer(clearTimerDuration),\n+\t\twritesBlockedGauge: exporter.NewGauge(\"SemiSyncMonitorWritesBlocked\", \"Number of writes blocked in the semi-sync monitor\"),\n+\t\tappPool:            dbconnpool.NewConnectionPool(\"SemiSyncMonitorAppPool\", exporter, 20, mysqlctl.DbaIdleTimeout, 0, mysqlctl.PoolDynamicHostnameResolution),\n+\t\twaiters:            make([]chan any, 0),\n+\t}\n+}\n+\n+// CreateTestSemiSyncMonitor created a monitor for testing.\n+// It takes an optional fake db.\n+func CreateTestSemiSyncMonitor(db *fakesqldb.DB, exporter *servenv.Exporter) *Monitor {\n+\tvar dbc *dbconfigs.DBConfigs\n+\tif db != nil {\n+\t\tparams := db.ConnParams()\n+\t\tcp := *params\n+\t\tdbc = dbconfigs.NewTestDBConfigs(cp, cp, \"\")\n+\t}\n+\treturn NewMonitor(&tabletenv.TabletConfig{\n+\t\tDB: dbc,\n+\t\tSemiSyncMonitor: tabletenv.SemiSyncMonitorConfig{\n+\t\t\tInterval: 1 * time.Second,\n+\t\t},\n+\t}, exporter)\n+}\n+\n+// Open starts the monitor.\n+func (m *Monitor) Open() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\t// The check for config being nil is only requried for tests.\n+\tif m.isOpen || m.config == nil || m.config.DB == nil {\n+\t\t// If we are already open, then there is nothing to do\n+\t\treturn\n+\t}\n+\t// Set the monitor to be open.\n+\tm.isOpen = true\n+\tlog.Info(\"SemiSync Monitor: opening\")\n+\n+\t// This function could be running from within a unit test scope, in which case we use\n+\t// mock pools that are already open. This is why we test for the pool being open.\n+\tif !m.appPool.IsOpen() {\n+\t\tm.appPool.Open(m.config.DB.AppWithDB())\n+\t}\n+\tm.clearTicks.Start(m.clearAllData)\n+\tm.ticks.Start(m.checkAndFixSemiSyncBlocked)\n+}\n+\n+// Close stops the monitor.\n+func (m *Monitor) Close() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\tif !m.isOpen {\n+\t\t// If we are already closed, then there is nothing to do\n+\t\treturn\n+\t}\n+\tm.isOpen = false\n+\tlog.Info(\"SemiSync Monitor: closing\")\n+\tm.clearTicks.Stop()\n+\tm.ticks.Stop()\n+\tm.appPool.Close()\n+}\n+\n+// checkAndFixSemiSyncBlocked checks if the primary is blocked on semi-sync ack\n+// and manufactures a write to unblock the primary. This function is safe to\n+// be called multiple times in parallel.\n+func (m *Monitor) checkAndFixSemiSyncBlocked() {\n+\t// Check if semi-sync is blocked or not\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)",
        "comment_created_at": "2025-02-20T07:52:59+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "Should we use RemoteOperationTimeout here? Its not a remote operation. Its just talking to MySQL. I initially had no timeout whatsoever. Matt suggested I add one, so I added an abritrary one.",
        "pr_file_module": null
      },
      {
        "comment_id": "1965982936",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17763,
        "pr_file": "go/vt/vttablet/tabletmanager/semisyncmonitor/monitor.go",
        "discussion_id": "1962188675",
        "commented_code": "@@ -0,0 +1,390 @@\n+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semisyncmonitor\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"vitess.io/vitess/go/constants/sidecar\"\n+\t\"vitess.io/vitess/go/mysql/fakesqldb\"\n+\t\"vitess.io/vitess/go/stats\"\n+\t\"vitess.io/vitess/go/timer\"\n+\t\"vitess.io/vitess/go/vt/dbconfigs\"\n+\t\"vitess.io/vitess/go/vt/dbconnpool\"\n+\t\"vitess.io/vitess/go/vt/log\"\n+\t\"vitess.io/vitess/go/vt/mysqlctl\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+\t\"vitess.io/vitess/go/vt/vttablet/tabletserver/tabletenv\"\n+)\n+\n+const (\n+\tsemiSyncWaitSessionsRead = \"SHOW STATUS LIKE 'Rpl_semi_sync_%_wait_sessions'\"\n+\tsemiSyncRecoverWrite     = \"INSERT INTO %s.semisync_recover (ts) VALUES (NOW())\"\n+\tsemiSyncRecoverClear     = \"TRUNCATE TABLE %s.semisync_recover\"\n+\tmaxWritesPermitted       = 15\n+\tclearTimerDuration       = 24 * time.Hour\n+)\n+\n+var (\n+\t// waitBetweenWrites is the time to wait between consecutive writes.\n+\t// This is a variable instead of a constant only to be tweaked in tests.\n+\twaitBetweenWrites = 1 * time.Second\n+)\n+\n+// Monitor is a monitor that checks if the primary tablet\n+// is blocked on a semi-sync ack from the replica.\n+// If the semi-sync ACK is lost in the network,\n+// it is possible that the primary is indefinitely stuck,\n+// blocking PRS. The monitor looks for this situation and manufactures a write\n+// periodically to unblock the primary.\n+type Monitor struct {\n+\t// config is used to get the connection parameters.\n+\tconfig *tabletenv.TabletConfig\n+\t// ticks is the ticker on which we'll check\n+\t// if the primary is blocked on semi-sync ACKs or not.\n+\tticks *timer.Timer\n+\t// clearTicks is the ticker to clear the data in\n+\t// the semisync_recover table.\n+\tclearTicks *timer.Timer\n+\n+\t// mu protects the fields below.\n+\tmu      sync.Mutex\n+\tappPool *dbconnpool.ConnectionPool\n+\tisOpen  bool\n+\t// isWriting stores if the monitor is currently writing to the DB.\n+\t// We don't want two different threads initiating writes, so we use this\n+\t// for synchronization.\n+\tisWriting bool\n+\t// inProgressWriteCount is the number of writes currently in progress.\n+\t// The writes from the monitor themselves might get blocked and hence a count for them is required.\n+\t// After enough writes are blocked, we want to notify VTOrc to run an ERS.\n+\tinProgressWriteCount int\n+\t// isBlocked stores if the primary is blocked on semi-sync ack.\n+\tisBlocked bool\n+\t// waiters stores the list of waiters that are waiting for the primary to be unblocked.\n+\twaiters []chan any\n+\t// writesBlockedGauge is a gauge tracking the number of writes the monitor is blocked on.\n+\twritesBlockedGauge *stats.Gauge\n+}\n+\n+// NewMonitor creates a new Monitor.\n+func NewMonitor(config *tabletenv.TabletConfig, exporter *servenv.Exporter) *Monitor {\n+\treturn &Monitor{\n+\t\tconfig: config,\n+\t\tticks:  timer.NewTimer(config.SemiSyncMonitor.Interval),\n+\t\t// We clear the data every day. We can make it configurable in the future,\n+\t\t// but this seams fine for now.\n+\t\tclearTicks:         timer.NewTimer(clearTimerDuration),\n+\t\twritesBlockedGauge: exporter.NewGauge(\"SemiSyncMonitorWritesBlocked\", \"Number of writes blocked in the semi-sync monitor\"),\n+\t\tappPool:            dbconnpool.NewConnectionPool(\"SemiSyncMonitorAppPool\", exporter, 20, mysqlctl.DbaIdleTimeout, 0, mysqlctl.PoolDynamicHostnameResolution),\n+\t\twaiters:            make([]chan any, 0),\n+\t}\n+}\n+\n+// CreateTestSemiSyncMonitor created a monitor for testing.\n+// It takes an optional fake db.\n+func CreateTestSemiSyncMonitor(db *fakesqldb.DB, exporter *servenv.Exporter) *Monitor {\n+\tvar dbc *dbconfigs.DBConfigs\n+\tif db != nil {\n+\t\tparams := db.ConnParams()\n+\t\tcp := *params\n+\t\tdbc = dbconfigs.NewTestDBConfigs(cp, cp, \"\")\n+\t}\n+\treturn NewMonitor(&tabletenv.TabletConfig{\n+\t\tDB: dbc,\n+\t\tSemiSyncMonitor: tabletenv.SemiSyncMonitorConfig{\n+\t\t\tInterval: 1 * time.Second,\n+\t\t},\n+\t}, exporter)\n+}\n+\n+// Open starts the monitor.\n+func (m *Monitor) Open() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\t// The check for config being nil is only requried for tests.\n+\tif m.isOpen || m.config == nil || m.config.DB == nil {\n+\t\t// If we are already open, then there is nothing to do\n+\t\treturn\n+\t}\n+\t// Set the monitor to be open.\n+\tm.isOpen = true\n+\tlog.Info(\"SemiSync Monitor: opening\")\n+\n+\t// This function could be running from within a unit test scope, in which case we use\n+\t// mock pools that are already open. This is why we test for the pool being open.\n+\tif !m.appPool.IsOpen() {\n+\t\tm.appPool.Open(m.config.DB.AppWithDB())\n+\t}\n+\tm.clearTicks.Start(m.clearAllData)\n+\tm.ticks.Start(m.checkAndFixSemiSyncBlocked)\n+}\n+\n+// Close stops the monitor.\n+func (m *Monitor) Close() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\tif !m.isOpen {\n+\t\t// If we are already closed, then there is nothing to do\n+\t\treturn\n+\t}\n+\tm.isOpen = false\n+\tlog.Info(\"SemiSync Monitor: closing\")\n+\tm.clearTicks.Stop()\n+\tm.ticks.Stop()\n+\tm.appPool.Close()\n+}\n+\n+// checkAndFixSemiSyncBlocked checks if the primary is blocked on semi-sync ack\n+// and manufactures a write to unblock the primary. This function is safe to\n+// be called multiple times in parallel.\n+func (m *Monitor) checkAndFixSemiSyncBlocked() {\n+\t// Check if semi-sync is blocked or not\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)",
        "comment_created_at": "2025-02-21T18:23:11+00:00",
        "comment_author": "deepthi",
        "comment_body": "RemoteOperationTimeout is the standard timeout for all RPC calls. This is an RPC from vttablet to mysqld.",
        "pr_file_module": null
      },
      {
        "comment_id": "1967080664",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17763,
        "pr_file": "go/vt/vttablet/tabletmanager/semisyncmonitor/monitor.go",
        "discussion_id": "1962188675",
        "commented_code": "@@ -0,0 +1,390 @@\n+/*\n+Copyright 2025 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package semisyncmonitor\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"vitess.io/vitess/go/constants/sidecar\"\n+\t\"vitess.io/vitess/go/mysql/fakesqldb\"\n+\t\"vitess.io/vitess/go/stats\"\n+\t\"vitess.io/vitess/go/timer\"\n+\t\"vitess.io/vitess/go/vt/dbconfigs\"\n+\t\"vitess.io/vitess/go/vt/dbconnpool\"\n+\t\"vitess.io/vitess/go/vt/log\"\n+\t\"vitess.io/vitess/go/vt/mysqlctl\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+\t\"vitess.io/vitess/go/vt/sqlparser\"\n+\t\"vitess.io/vitess/go/vt/vttablet/tabletserver/tabletenv\"\n+)\n+\n+const (\n+\tsemiSyncWaitSessionsRead = \"SHOW STATUS LIKE 'Rpl_semi_sync_%_wait_sessions'\"\n+\tsemiSyncRecoverWrite     = \"INSERT INTO %s.semisync_recover (ts) VALUES (NOW())\"\n+\tsemiSyncRecoverClear     = \"TRUNCATE TABLE %s.semisync_recover\"\n+\tmaxWritesPermitted       = 15\n+\tclearTimerDuration       = 24 * time.Hour\n+)\n+\n+var (\n+\t// waitBetweenWrites is the time to wait between consecutive writes.\n+\t// This is a variable instead of a constant only to be tweaked in tests.\n+\twaitBetweenWrites = 1 * time.Second\n+)\n+\n+// Monitor is a monitor that checks if the primary tablet\n+// is blocked on a semi-sync ack from the replica.\n+// If the semi-sync ACK is lost in the network,\n+// it is possible that the primary is indefinitely stuck,\n+// blocking PRS. The monitor looks for this situation and manufactures a write\n+// periodically to unblock the primary.\n+type Monitor struct {\n+\t// config is used to get the connection parameters.\n+\tconfig *tabletenv.TabletConfig\n+\t// ticks is the ticker on which we'll check\n+\t// if the primary is blocked on semi-sync ACKs or not.\n+\tticks *timer.Timer\n+\t// clearTicks is the ticker to clear the data in\n+\t// the semisync_recover table.\n+\tclearTicks *timer.Timer\n+\n+\t// mu protects the fields below.\n+\tmu      sync.Mutex\n+\tappPool *dbconnpool.ConnectionPool\n+\tisOpen  bool\n+\t// isWriting stores if the monitor is currently writing to the DB.\n+\t// We don't want two different threads initiating writes, so we use this\n+\t// for synchronization.\n+\tisWriting bool\n+\t// inProgressWriteCount is the number of writes currently in progress.\n+\t// The writes from the monitor themselves might get blocked and hence a count for them is required.\n+\t// After enough writes are blocked, we want to notify VTOrc to run an ERS.\n+\tinProgressWriteCount int\n+\t// isBlocked stores if the primary is blocked on semi-sync ack.\n+\tisBlocked bool\n+\t// waiters stores the list of waiters that are waiting for the primary to be unblocked.\n+\twaiters []chan any\n+\t// writesBlockedGauge is a gauge tracking the number of writes the monitor is blocked on.\n+\twritesBlockedGauge *stats.Gauge\n+}\n+\n+// NewMonitor creates a new Monitor.\n+func NewMonitor(config *tabletenv.TabletConfig, exporter *servenv.Exporter) *Monitor {\n+\treturn &Monitor{\n+\t\tconfig: config,\n+\t\tticks:  timer.NewTimer(config.SemiSyncMonitor.Interval),\n+\t\t// We clear the data every day. We can make it configurable in the future,\n+\t\t// but this seams fine for now.\n+\t\tclearTicks:         timer.NewTimer(clearTimerDuration),\n+\t\twritesBlockedGauge: exporter.NewGauge(\"SemiSyncMonitorWritesBlocked\", \"Number of writes blocked in the semi-sync monitor\"),\n+\t\tappPool:            dbconnpool.NewConnectionPool(\"SemiSyncMonitorAppPool\", exporter, 20, mysqlctl.DbaIdleTimeout, 0, mysqlctl.PoolDynamicHostnameResolution),\n+\t\twaiters:            make([]chan any, 0),\n+\t}\n+}\n+\n+// CreateTestSemiSyncMonitor created a monitor for testing.\n+// It takes an optional fake db.\n+func CreateTestSemiSyncMonitor(db *fakesqldb.DB, exporter *servenv.Exporter) *Monitor {\n+\tvar dbc *dbconfigs.DBConfigs\n+\tif db != nil {\n+\t\tparams := db.ConnParams()\n+\t\tcp := *params\n+\t\tdbc = dbconfigs.NewTestDBConfigs(cp, cp, \"\")\n+\t}\n+\treturn NewMonitor(&tabletenv.TabletConfig{\n+\t\tDB: dbc,\n+\t\tSemiSyncMonitor: tabletenv.SemiSyncMonitorConfig{\n+\t\t\tInterval: 1 * time.Second,\n+\t\t},\n+\t}, exporter)\n+}\n+\n+// Open starts the monitor.\n+func (m *Monitor) Open() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\t// The check for config being nil is only requried for tests.\n+\tif m.isOpen || m.config == nil || m.config.DB == nil {\n+\t\t// If we are already open, then there is nothing to do\n+\t\treturn\n+\t}\n+\t// Set the monitor to be open.\n+\tm.isOpen = true\n+\tlog.Info(\"SemiSync Monitor: opening\")\n+\n+\t// This function could be running from within a unit test scope, in which case we use\n+\t// mock pools that are already open. This is why we test for the pool being open.\n+\tif !m.appPool.IsOpen() {\n+\t\tm.appPool.Open(m.config.DB.AppWithDB())\n+\t}\n+\tm.clearTicks.Start(m.clearAllData)\n+\tm.ticks.Start(m.checkAndFixSemiSyncBlocked)\n+}\n+\n+// Close stops the monitor.\n+func (m *Monitor) Close() {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\tif !m.isOpen {\n+\t\t// If we are already closed, then there is nothing to do\n+\t\treturn\n+\t}\n+\tm.isOpen = false\n+\tlog.Info(\"SemiSync Monitor: closing\")\n+\tm.clearTicks.Stop()\n+\tm.ticks.Stop()\n+\tm.appPool.Close()\n+}\n+\n+// checkAndFixSemiSyncBlocked checks if the primary is blocked on semi-sync ack\n+// and manufactures a write to unblock the primary. This function is safe to\n+// be called multiple times in parallel.\n+func (m *Monitor) checkAndFixSemiSyncBlocked() {\n+\t// Check if semi-sync is blocked or not\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)",
        "comment_created_at": "2025-02-24T06:12:35+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959527897",
    "pr_number": 17818,
    "pr_file": "go/pools/smartconnpool/pool.go",
    "created_at": "2025-02-18T11:08:12+00:00",
    "commented_code": "if conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1959527897",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-18T11:08:12+00:00",
        "comment_author": "dbussink",
        "comment_body": "Should use a timeout here so it doesn't hang potentially indefinitely it can't connect here due to some network issue? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1959570140",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-18T11:38:50+00:00",
        "comment_author": "arthurschreiber",
        "comment_body": "I agree that this should use a timeout, and then just retry in case the timeout gets hit.",
        "pr_file_module": null
      },
      {
        "comment_id": "1959882286",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-18T14:37:11+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "I agree as well, will update it",
        "pr_file_module": null
      },
      {
        "comment_id": "1960021906",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-18T15:47:28+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "FYI, in vttablet we have `db_connect_timeout_ms` cli param that can be used to have connect timeout for all the connections created with MySQL.",
        "pr_file_module": null
      },
      {
        "comment_id": "1960139671",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-18T16:54:18+00:00",
        "comment_author": "dbussink",
        "comment_body": "@harshit-gangal Can we pass that setting into the pool? So that we can use that timeout here? We shouldn't here access the cli param, but pass it in explicitly then since that better decouples things and makes it easier to test as well. \r\n\r\nLooks like we should maybe also honor that in other places here where we connect?",
        "pr_file_module": null
      },
      {
        "comment_id": "1960930954",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-19T04:24:00+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "The CLI parameter is already honoured at a lower level where the actual MySQL connection happens. I can pass it here as well for testing.",
        "pr_file_module": null
      },
      {
        "comment_id": "1961456487",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17818,
        "pr_file": "go/pools/smartconnpool/pool.go",
        "discussion_id": "1959527897",
        "commented_code": "@@ -764,7 +772,9 @@ func (pool *ConnPool[C]) closeIdleResources(now time.Time) {\n \t\t\tif conn.timeUsed.expired(mono, timeout) {\n \t\t\t\tpool.Metrics.idleClosed.Add(1)\n \t\t\t\tconn.Close()\n-\t\t\t\tpool.closedConn()\n+\t\t\t\tif err := pool.connReopen(context.Background(), conn, mono); err != nil {",
        "comment_created_at": "2025-02-19T10:53:09+00:00",
        "comment_author": "vmg",
        "comment_body": "Huuuh I really don't like this change. Can you elaborate a bit on the rationale, @harshit-gangal? As you've already pointed out, the connection timeout for new MySQL connections is a property of the connection's settings, and _not_ of the pool.\r\n\r\nYou can see how opening a connection handles the connection open timeout set for the connection already:\r\n\r\nhttps://github.com/vitessio/vitess/blob/0c6ad63126012a7bb3daa6b86b2736dd30e65a9d/go/mysql/client.go#L50-L55\r\n\r\nThis applies to all the connections on the pool. I don't think adding a pool specific override here wins us anything. It adds a lot of complexity and potential bugs, and from what I'm seeing we're only using it for testing. I would prefer to keep connection timeouts as they're already implemented, because they work reliably atm. Thanks!\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "991538640",
    "pr_number": 11456,
    "pr_file": "go/trace/plugin_datadog.go",
    "created_at": "2022-10-10T18:11:32+00:00",
    "commented_code": "\"github.com/opentracing/opentracing-go\"\n \t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n \t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/opentracer\"\n \tddtracer \"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n )\n \n var (\n-\tdataDogHost string\n-\tdataDogPort string\n+\tdataDogConfigKey = viperutil.KeyPartial(configKey(\"datadog\"))\n+\n+\tdataDogHost = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.host\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-host\"),\n+\t)\n+\tdataDogPort = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.port\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-port\"),\n+\t)\n )\n \n func init() {\n \t// If compiled with plugin_datadaog, ensure that trace.RegisterFlags\n \t// includes datadaog tracing flags.\n \tpluginFlags = append(pluginFlags, func(fs *pflag.FlagSet) {\n-\t\tfs.StringVar(&dataDogHost, \"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n-\t\tfs.StringVar(&dataDogPort, \"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tfs.String(\"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogHost.Bind(nil, fs)\n+\n+\t\tfs.String(\"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogPort.Bind(nil, fs)\n \t})\n }\n \n func newDatadogTracer(serviceName string) (tracingService, io.Closer, error) {\n-\tif dataDogHost == \"\" || dataDogPort == \"\" {\n+\thost, port := dataDogHost.Get(), dataDogPort.Get()\n+\tif host == \"\" || port == \"\" {\n \t\treturn nil, nil, fmt.Errorf(\"need host and port to datadog agent to use datadog tracing\")\n \t}\n \n \topts := []ddtracer.StartOption{\n-\t\tddtracer.WithAgentAddr(dataDogHost + \":\" + dataDogPort),\n+\t\tddtracer.WithAgentAddr(host + \":\" + port),",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "991538640",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/trace/plugin_datadog.go",
        "discussion_id": "991538640",
        "commented_code": "@@ -6,37 +6,54 @@ import (\n \n \t\"github.com/opentracing/opentracing-go\"\n \t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n \t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/opentracer\"\n \tddtracer \"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n )\n \n var (\n-\tdataDogHost string\n-\tdataDogPort string\n+\tdataDogConfigKey = viperutil.KeyPartial(configKey(\"datadog\"))\n+\n+\tdataDogHost = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.host\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-host\"),\n+\t)\n+\tdataDogPort = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.port\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-port\"),\n+\t)\n )\n \n func init() {\n \t// If compiled with plugin_datadaog, ensure that trace.RegisterFlags\n \t// includes datadaog tracing flags.\n \tpluginFlags = append(pluginFlags, func(fs *pflag.FlagSet) {\n-\t\tfs.StringVar(&dataDogHost, \"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n-\t\tfs.StringVar(&dataDogPort, \"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tfs.String(\"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogHost.Bind(nil, fs)\n+\n+\t\tfs.String(\"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogPort.Bind(nil, fs)\n \t})\n }\n \n func newDatadogTracer(serviceName string) (tracingService, io.Closer, error) {\n-\tif dataDogHost == \"\" || dataDogPort == \"\" {\n+\thost, port := dataDogHost.Get(), dataDogPort.Get()\n+\tif host == \"\" || port == \"\" {\n \t\treturn nil, nil, fmt.Errorf(\"need host and port to datadog agent to use datadog tracing\")\n \t}\n \n \topts := []ddtracer.StartOption{\n-\t\tddtracer.WithAgentAddr(dataDogHost + \":\" + dataDogPort),\n+\t\tddtracer.WithAgentAddr(host + \":\" + port),",
        "comment_created_at": "2022-10-10T18:11:32+00:00",
        "comment_author": "mattlord",
        "comment_body": "We should get into the habit of using `net.JoinHostPort()` in places like this (supports ipv4 and ipv6):\r\n```\r\nddtracer.WithAgentAddr(net.JoinHostPort(host, port)),\r\n``` ",
        "pr_file_module": null
      },
      {
        "comment_id": "991679016",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/trace/plugin_datadog.go",
        "discussion_id": "991538640",
        "commented_code": "@@ -6,37 +6,54 @@ import (\n \n \t\"github.com/opentracing/opentracing-go\"\n \t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n \t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/opentracer\"\n \tddtracer \"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n )\n \n var (\n-\tdataDogHost string\n-\tdataDogPort string\n+\tdataDogConfigKey = viperutil.KeyPartial(configKey(\"datadog\"))\n+\n+\tdataDogHost = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.host\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-host\"),\n+\t)\n+\tdataDogPort = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.port\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-port\"),\n+\t)\n )\n \n func init() {\n \t// If compiled with plugin_datadaog, ensure that trace.RegisterFlags\n \t// includes datadaog tracing flags.\n \tpluginFlags = append(pluginFlags, func(fs *pflag.FlagSet) {\n-\t\tfs.StringVar(&dataDogHost, \"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n-\t\tfs.StringVar(&dataDogPort, \"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tfs.String(\"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogHost.Bind(nil, fs)\n+\n+\t\tfs.String(\"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogPort.Bind(nil, fs)\n \t})\n }\n \n func newDatadogTracer(serviceName string) (tracingService, io.Closer, error) {\n-\tif dataDogHost == \"\" || dataDogPort == \"\" {\n+\thost, port := dataDogHost.Get(), dataDogPort.Get()\n+\tif host == \"\" || port == \"\" {\n \t\treturn nil, nil, fmt.Errorf(\"need host and port to datadog agent to use datadog tracing\")\n \t}\n \n \topts := []ddtracer.StartOption{\n-\t\tddtracer.WithAgentAddr(dataDogHost + \":\" + dataDogPort),\n+\t\tddtracer.WithAgentAddr(host + \":\" + port),",
        "comment_created_at": "2022-10-10T22:30:55+00:00",
        "comment_author": "ajm188",
        "comment_body": "yeah for sure! i'll make sure that goes in with this (or separate if it ends up taking a while)",
        "pr_file_module": null
      },
      {
        "comment_id": "1202018431",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/trace/plugin_datadog.go",
        "discussion_id": "991538640",
        "commented_code": "@@ -6,37 +6,54 @@ import (\n \n \t\"github.com/opentracing/opentracing-go\"\n \t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n \t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/opentracer\"\n \tddtracer \"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n )\n \n var (\n-\tdataDogHost string\n-\tdataDogPort string\n+\tdataDogConfigKey = viperutil.KeyPartial(configKey(\"datadog\"))\n+\n+\tdataDogHost = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.host\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-host\"),\n+\t)\n+\tdataDogPort = viperutil.NewValue(\n+\t\tdataDogConfigKey(\"agent.port\"),\n+\t\tviper.GetString,\n+\t\tviperutil.WithFlags[string](\"datadog-agent-port\"),\n+\t)\n )\n \n func init() {\n \t// If compiled with plugin_datadaog, ensure that trace.RegisterFlags\n \t// includes datadaog tracing flags.\n \tpluginFlags = append(pluginFlags, func(fs *pflag.FlagSet) {\n-\t\tfs.StringVar(&dataDogHost, \"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n-\t\tfs.StringVar(&dataDogPort, \"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tfs.String(\"datadog-agent-host\", \"\", \"host to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogHost.Bind(nil, fs)\n+\n+\t\tfs.String(\"datadog-agent-port\", \"\", \"port to send spans to. if empty, no tracing will be done\")\n+\t\tdataDogPort.Bind(nil, fs)\n \t})\n }\n \n func newDatadogTracer(serviceName string) (tracingService, io.Closer, error) {\n-\tif dataDogHost == \"\" || dataDogPort == \"\" {\n+\thost, port := dataDogHost.Get(), dataDogPort.Get()\n+\tif host == \"\" || port == \"\" {\n \t\treturn nil, nil, fmt.Errorf(\"need host and port to datadog agent to use datadog tracing\")\n \t}\n \n \topts := []ddtracer.StartOption{\n-\t\tddtracer.WithAgentAddr(dataDogHost + \":\" + dataDogPort),\n+\t\tddtracer.WithAgentAddr(host + \":\" + port),",
        "comment_created_at": "2023-05-23T10:23:39+00:00",
        "comment_author": "ajm188",
        "comment_body": "\u2705 ",
        "pr_file_module": null
      }
    ]
  }
]