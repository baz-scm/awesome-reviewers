[
  {
    "discussion_id": "1200979268",
    "pr_number": 11456,
    "pr_file": "go/viperutil/internal/sync/sync.go",
    "created_at": "2023-05-22T19:50:56+00:00",
    "commented_code": "+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package sync\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/fsnotify/fsnotify\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+)\n+\n+// Viper is a wrapper around a pair of viper.Viper instances to provide config-\n+// reloading in a threadsafe manner.\n+//\n+// It maintains one viper, called \"disk\", which does the actual config watch and\n+// reload (via viper's WatchConfig), and a second viper, called \"live\", which\n+// Values (registered via viperutil.Configure with Dynamic=true) access their\n+// settings from. The \"live\" config only updates after blocking all values from\n+// reading in order to swap in the most recently-loaded config from the \"disk\".\n+type Viper struct {\n+\tm    sync.Mutex // prevents races between loadFromDisk and AllSettings\n+\tdisk *viper.Viper\n+\tlive *viper.Viper\n+\tkeys map[string]*sync.RWMutex\n+\n+\tsubscribers    []chan<- struct{}\n+\twatchingConfig bool\n+\n+\tsetCh chan struct{}\n+}\n+\n+// New returns a new synced Viper.\n+func New() *Viper {\n+\treturn &Viper{\n+\t\tdisk:  viper.New(),\n+\t\tlive:  viper.New(),\n+\t\tkeys:  map[string]*sync.RWMutex{},\n+\t\tsetCh: make(chan struct{}, 1),\n+\t}\n+}\n+\n+// Set sets the given key to the given value, in both the disk and live vipers.\n+func (v *Viper) Set(key string, value any) {\n+\tm, ok := v.keys[key]\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\n+\tv.m.Lock()\n+\tdefer v.m.Unlock()\n+\n+\t// We must not update v.disk here; explicit calls to Set will supercede all\n+\t// future config reloads.\n+\tv.live.Set(key, value)\n+\tselect {\n+\tcase v.setCh <- struct{}{}:\n+\tdefault:\n+\t}\n+}\n+\n+// ErrDuplicateWatch is returned when Watch is called on a synced Viper which\n+// has already started a watch.\n+var ErrDuplicateWatch = errors.New(\"duplicate watch\")\n+\n+// Watch starts watching the config used by the passed-in Viper. Before starting\n+// the watch, the synced viper will perform an initial read and load from disk\n+// so that the live config is ready for use without requiring an initial config\n+// change.\n+//\n+// If the given static viper did not load a config file (and is instead relying\n+// purely on defaults, flags, and environment variables), then the settings of\n+// that viper are merged over, and this synced Viper may be used to set up an\n+// actual watch later. Additionally, this starts a background goroutine to\n+// persist changes made in-memory back to disk. It returns a cancel func to stop\n+// the persist loop, which the caller is responsible for calling during\n+// shutdown (see package servenv for an example).\n+//\n+// This does two things — one which is a nice-to-have, and another which is\n+// necessary for correctness.\n+//\n+// 1. Writing in-memory changes (which usually occur through a request to a\n+// /debug/env endpoint) ensures they are persisted across process restarts.\n+// 2. Writing in-memory changes ensures that subsequent modifications to the\n+// config file do not clobber those changes. Because viper loads the entire\n+// config on-change, rather than an incremental (diff) load, if a user were to\n+// edit an unrelated key (keyA) in the file, and we did not persist the\n+// in-memory change (keyB), then future calls to keyB.Get() would return the\n+// older value.\n+//\n+// If this synced viper is already watching a config file, this function returns\n+// an ErrDuplicateWatch. Other errors may be returned via underlying viper code\n+// to ensure the config file can be read in properly.\n+func (v *Viper) Watch(ctx context.Context, static *viper.Viper, minWaitInterval time.Duration) (cancel context.CancelFunc, err error) {\n+\tif v.watchingConfig {\n+\t\treturn nil, fmt.Errorf(\"%w: viper is already watching %s\", ErrDuplicateWatch, v.disk.ConfigFileUsed())",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1200979268",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "go/viperutil/internal/sync/sync.go",
        "discussion_id": "1200979268",
        "commented_code": "@@ -0,0 +1,302 @@\n+/*\n+Copyright 2022 The Vitess Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package sync\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/fsnotify/fsnotify\"\n+\t\"github.com/spf13/pflag\"\n+\t\"github.com/spf13/viper\"\n+\n+\t\"vitess.io/vitess/go/viperutil/internal/log\"\n+)\n+\n+// Viper is a wrapper around a pair of viper.Viper instances to provide config-\n+// reloading in a threadsafe manner.\n+//\n+// It maintains one viper, called \"disk\", which does the actual config watch and\n+// reload (via viper's WatchConfig), and a second viper, called \"live\", which\n+// Values (registered via viperutil.Configure with Dynamic=true) access their\n+// settings from. The \"live\" config only updates after blocking all values from\n+// reading in order to swap in the most recently-loaded config from the \"disk\".\n+type Viper struct {\n+\tm    sync.Mutex // prevents races between loadFromDisk and AllSettings\n+\tdisk *viper.Viper\n+\tlive *viper.Viper\n+\tkeys map[string]*sync.RWMutex\n+\n+\tsubscribers    []chan<- struct{}\n+\twatchingConfig bool\n+\n+\tsetCh chan struct{}\n+}\n+\n+// New returns a new synced Viper.\n+func New() *Viper {\n+\treturn &Viper{\n+\t\tdisk:  viper.New(),\n+\t\tlive:  viper.New(),\n+\t\tkeys:  map[string]*sync.RWMutex{},\n+\t\tsetCh: make(chan struct{}, 1),\n+\t}\n+}\n+\n+// Set sets the given key to the given value, in both the disk and live vipers.\n+func (v *Viper) Set(key string, value any) {\n+\tm, ok := v.keys[key]\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\n+\tv.m.Lock()\n+\tdefer v.m.Unlock()\n+\n+\t// We must not update v.disk here; explicit calls to Set will supercede all\n+\t// future config reloads.\n+\tv.live.Set(key, value)\n+\tselect {\n+\tcase v.setCh <- struct{}{}:\n+\tdefault:\n+\t}\n+}\n+\n+// ErrDuplicateWatch is returned when Watch is called on a synced Viper which\n+// has already started a watch.\n+var ErrDuplicateWatch = errors.New(\"duplicate watch\")\n+\n+// Watch starts watching the config used by the passed-in Viper. Before starting\n+// the watch, the synced viper will perform an initial read and load from disk\n+// so that the live config is ready for use without requiring an initial config\n+// change.\n+//\n+// If the given static viper did not load a config file (and is instead relying\n+// purely on defaults, flags, and environment variables), then the settings of\n+// that viper are merged over, and this synced Viper may be used to set up an\n+// actual watch later. Additionally, this starts a background goroutine to\n+// persist changes made in-memory back to disk. It returns a cancel func to stop\n+// the persist loop, which the caller is responsible for calling during\n+// shutdown (see package servenv for an example).\n+//\n+// This does two things — one which is a nice-to-have, and another which is\n+// necessary for correctness.\n+//\n+// 1. Writing in-memory changes (which usually occur through a request to a\n+// /debug/env endpoint) ensures they are persisted across process restarts.\n+// 2. Writing in-memory changes ensures that subsequent modifications to the\n+// config file do not clobber those changes. Because viper loads the entire\n+// config on-change, rather than an incremental (diff) load, if a user were to\n+// edit an unrelated key (keyA) in the file, and we did not persist the\n+// in-memory change (keyB), then future calls to keyB.Get() would return the\n+// older value.\n+//\n+// If this synced viper is already watching a config file, this function returns\n+// an ErrDuplicateWatch. Other errors may be returned via underlying viper code\n+// to ensure the config file can be read in properly.\n+func (v *Viper) Watch(ctx context.Context, static *viper.Viper, minWaitInterval time.Duration) (cancel context.CancelFunc, err error) {\n+\tif v.watchingConfig {\n+\t\treturn nil, fmt.Errorf(\"%w: viper is already watching %s\", ErrDuplicateWatch, v.disk.ConfigFileUsed())",
        "comment_created_at": "2023-05-22T19:50:56+00:00",
        "comment_author": "mattlord",
        "comment_body": "Probably worth using vterrors.New / vterrors.Errorf here so that we at least have a code as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1912286197",
    "pr_number": 17429,
    "pr_file": "go/vt/vtctl/workflow/server.go",
    "created_at": "2025-01-11T23:06:25+00:00",
    "commented_code": "resp := &vtctldatapb.LookupVindexExternalizeResponse{}\n \n \tif vindex.Owner != \"\" {\n-\t\t// If there is an owner, we have to delete the streams. Once we externalize it\n-\t\t// the VTGate will now be responsible for keeping the lookup table up to date\n-\t\t// with the owner table.\n-\t\tif _, derr := s.WorkflowDelete(ctx, &vtctldatapb.WorkflowDeleteRequest{\n-\t\t\tKeyspace:         req.TableKeyspace,\n-\t\t\tWorkflow:         req.Name,\n-\t\t\tKeepData:         true, // Not relevant\n-\t\t\tKeepRoutingRules: true, // Not relevant\n-\t\t}); derr != nil {\n-\t\t\treturn nil, vterrors.Errorf(vtrpcpb.Code_FAILED_PRECONDITION, \"failed to delete workflow %s: %v\", req.Name, derr)\n+\t\t// If there is an owner, we have to stop/delete the streams. Once we\n+\t\t// externalize it the VTGate will now be responsible for keeping the\n+\t\t// lookup table up to date with the owner table.\n+\t\tif req.DeleteWorkflow {\n+\t\t\t// Delete the workflow.\n+\t\t\tif _, derr := s.WorkflowDelete(ctx, &vtctldatapb.WorkflowDeleteRequest{\n+\t\t\t\tKeyspace:         req.TableKeyspace,\n+\t\t\t\tWorkflow:         req.Name,\n+\t\t\t\tKeepData:         true, // Not relevant\n+\t\t\t\tKeepRoutingRules: true, // Not relevant\n+\t\t\t}); derr != nil {\n+\t\t\t\treturn nil, vterrors.Errorf(vtrpcpb.Code_FAILED_PRECONDITION, \"failed to delete workflow %s: %v\", req.Name, derr)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1912286197",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17429,
        "pr_file": "go/vt/vtctl/workflow/server.go",
        "discussion_id": "1912286197",
        "commented_code": "@@ -669,23 +709,98 @@ func (s *Server) LookupVindexExternalize(ctx context.Context, req *vtctldatapb.L\n \tresp := &vtctldatapb.LookupVindexExternalizeResponse{}\n \n \tif vindex.Owner != \"\" {\n-\t\t// If there is an owner, we have to delete the streams. Once we externalize it\n-\t\t// the VTGate will now be responsible for keeping the lookup table up to date\n-\t\t// with the owner table.\n-\t\tif _, derr := s.WorkflowDelete(ctx, &vtctldatapb.WorkflowDeleteRequest{\n-\t\t\tKeyspace:         req.TableKeyspace,\n-\t\t\tWorkflow:         req.Name,\n-\t\t\tKeepData:         true, // Not relevant\n-\t\t\tKeepRoutingRules: true, // Not relevant\n-\t\t}); derr != nil {\n-\t\t\treturn nil, vterrors.Errorf(vtrpcpb.Code_FAILED_PRECONDITION, \"failed to delete workflow %s: %v\", req.Name, derr)\n+\t\t// If there is an owner, we have to stop/delete the streams. Once we\n+\t\t// externalize it the VTGate will now be responsible for keeping the\n+\t\t// lookup table up to date with the owner table.\n+\t\tif req.DeleteWorkflow {\n+\t\t\t// Delete the workflow.\n+\t\t\tif _, derr := s.WorkflowDelete(ctx, &vtctldatapb.WorkflowDeleteRequest{\n+\t\t\t\tKeyspace:         req.TableKeyspace,\n+\t\t\t\tWorkflow:         req.Name,\n+\t\t\t\tKeepData:         true, // Not relevant\n+\t\t\t\tKeepRoutingRules: true, // Not relevant\n+\t\t\t}); derr != nil {\n+\t\t\t\treturn nil, vterrors.Errorf(vtrpcpb.Code_FAILED_PRECONDITION, \"failed to delete workflow %s: %v\", req.Name, derr)",
        "comment_created_at": "2025-01-11T23:06:25+00:00",
        "comment_author": "mattlord",
        "comment_body": "Nit, but I think `vterrors.Wrapf(derr, ...)` would be better here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1914595725",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17429,
        "pr_file": "go/vt/vtctl/workflow/server.go",
        "discussion_id": "1912286197",
        "commented_code": "@@ -669,23 +709,98 @@ func (s *Server) LookupVindexExternalize(ctx context.Context, req *vtctldatapb.L\n \tresp := &vtctldatapb.LookupVindexExternalizeResponse{}\n \n \tif vindex.Owner != \"\" {\n-\t\t// If there is an owner, we have to delete the streams. Once we externalize it\n-\t\t// the VTGate will now be responsible for keeping the lookup table up to date\n-\t\t// with the owner table.\n-\t\tif _, derr := s.WorkflowDelete(ctx, &vtctldatapb.WorkflowDeleteRequest{\n-\t\t\tKeyspace:         req.TableKeyspace,\n-\t\t\tWorkflow:         req.Name,\n-\t\t\tKeepData:         true, // Not relevant\n-\t\t\tKeepRoutingRules: true, // Not relevant\n-\t\t}); derr != nil {\n-\t\t\treturn nil, vterrors.Errorf(vtrpcpb.Code_FAILED_PRECONDITION, \"failed to delete workflow %s: %v\", req.Name, derr)\n+\t\t// If there is an owner, we have to stop/delete the streams. Once we\n+\t\t// externalize it the VTGate will now be responsible for keeping the\n+\t\t// lookup table up to date with the owner table.\n+\t\tif req.DeleteWorkflow {\n+\t\t\t// Delete the workflow.\n+\t\t\tif _, derr := s.WorkflowDelete(ctx, &vtctldatapb.WorkflowDeleteRequest{\n+\t\t\t\tKeyspace:         req.TableKeyspace,\n+\t\t\t\tWorkflow:         req.Name,\n+\t\t\t\tKeepData:         true, // Not relevant\n+\t\t\t\tKeepRoutingRules: true, // Not relevant\n+\t\t\t}); derr != nil {\n+\t\t\t\treturn nil, vterrors.Errorf(vtrpcpb.Code_FAILED_PRECONDITION, \"failed to delete workflow %s: %v\", req.Name, derr)",
        "comment_created_at": "2025-01-14T10:33:41+00:00",
        "comment_author": "beingnoble03",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1923454038",
    "pr_number": 17578,
    "pr_file": "go/viperutil/config.go",
    "created_at": "2025-01-21T10:20:52+00:00",
    "commented_code": "return registry.Dynamic.Watch(context.Background(), registry.Static, configPersistenceMinInterval.Get())\n }\n \n+// isConfigFileNotFoundError checks if the error is caused because the file wasn't found.\n+func isConfigFileNotFoundError(err error) bool {\n+\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n+\t\treturn true",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1923454038",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17578,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1923454038",
        "commented_code": "@@ -186,6 +187,14 @@ func LoadConfig() (context.CancelFunc, error) {\n \treturn registry.Dynamic.Watch(context.Background(), registry.Static, configPersistenceMinInterval.Get())\n }\n \n+// isConfigFileNotFoundError checks if the error is caused because the file wasn't found.\n+func isConfigFileNotFoundError(err error) bool {\n+\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n+\t\treturn true",
        "comment_created_at": "2025-01-21T10:20:52+00:00",
        "comment_author": "dbussink",
        "comment_body": "Should we use `errors.As` here to be more robust if there's future error chaining? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1924018892",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17578,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1923454038",
        "commented_code": "@@ -186,6 +187,14 @@ func LoadConfig() (context.CancelFunc, error) {\n \treturn registry.Dynamic.Watch(context.Background(), registry.Static, configPersistenceMinInterval.Get())\n }\n \n+// isConfigFileNotFoundError checks if the error is caused because the file wasn't found.\n+func isConfigFileNotFoundError(err error) bool {\n+\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n+\t\treturn true",
        "comment_created_at": "2025-01-21T16:19:04+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "I tried it, but that requires instantiating a ConfigFileNotFoundError like `errors.As(err, viper.ConfigFileNotFoundError{})` that's why I opted against it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1924028910",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17578,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1923454038",
        "commented_code": "@@ -186,6 +187,14 @@ func LoadConfig() (context.CancelFunc, error) {\n \treturn registry.Dynamic.Watch(context.Background(), registry.Static, configPersistenceMinInterval.Get())\n }\n \n+// isConfigFileNotFoundError checks if the error is caused because the file wasn't found.\n+func isConfigFileNotFoundError(err error) bool {\n+\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n+\t\treturn true",
        "comment_created_at": "2025-01-21T16:25:13+00:00",
        "comment_author": "dbussink",
        "comment_body": "@GuptaManan100 Yeah, I still think that's worth it then though? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1924063142",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17578,
        "pr_file": "go/viperutil/config.go",
        "discussion_id": "1923454038",
        "commented_code": "@@ -186,6 +187,14 @@ func LoadConfig() (context.CancelFunc, error) {\n \treturn registry.Dynamic.Watch(context.Background(), registry.Static, configPersistenceMinInterval.Get())\n }\n \n+// isConfigFileNotFoundError checks if the error is caused because the file wasn't found.\n+func isConfigFileNotFoundError(err error) bool {\n+\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n+\t\treturn true",
        "comment_created_at": "2025-01-21T16:47:11+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "Okay. I've fixed it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1877579659",
    "pr_number": 17342,
    "pr_file": "go/vt/vtgate/engine/routing.go",
    "created_at": "2024-12-10T08:29:48+00:00",
    "commented_code": "default:\n \t\t\treturn rp.in(ctx, vcursor, bindVars)\n \t\t}\n+\tcase Between:\n+\t\tswitch rp.Vindex.(type) {\n+\t\tcase vindexes.SingleColumn:\n+\t\t\treturn rp.between(ctx, vcursor, bindVars)\n+\t\tdefault:\n+\t\t\t// Only SingleColumn vindex supported.\n+\t\t\treturn nil, nil, vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"opcode: %v not supported\", rp.Opcode)\n+\t\t}",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1877579659",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17342,
        "pr_file": "go/vt/vtgate/engine/routing.go",
        "discussion_id": "1877579659",
        "commented_code": "@@ -157,6 +161,14 @@ func (rp *RoutingParameters) findRoute(ctx context.Context, vcursor VCursor, bin\n \t\tdefault:\n \t\t\treturn rp.in(ctx, vcursor, bindVars)\n \t\t}\n+\tcase Between:\n+\t\tswitch rp.Vindex.(type) {\n+\t\tcase vindexes.SingleColumn:\n+\t\t\treturn rp.between(ctx, vcursor, bindVars)\n+\t\tdefault:\n+\t\t\t// Only SingleColumn vindex supported.\n+\t\t\treturn nil, nil, vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"opcode: %v not supported\", rp.Opcode)\n+\t\t}",
        "comment_created_at": "2024-12-10T08:29:48+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "This should use vterrors.VT13001 i.e. Internal Bug, if we ended up selecting this opcode.",
        "pr_file_module": null
      },
      {
        "comment_id": "1879195695",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17342,
        "pr_file": "go/vt/vtgate/engine/routing.go",
        "discussion_id": "1877579659",
        "commented_code": "@@ -157,6 +161,14 @@ func (rp *RoutingParameters) findRoute(ctx context.Context, vcursor VCursor, bin\n \t\tdefault:\n \t\t\treturn rp.in(ctx, vcursor, bindVars)\n \t\t}\n+\tcase Between:\n+\t\tswitch rp.Vindex.(type) {\n+\t\tcase vindexes.SingleColumn:\n+\t\t\treturn rp.between(ctx, vcursor, bindVars)\n+\t\tdefault:\n+\t\t\t// Only SingleColumn vindex supported.\n+\t\t\treturn nil, nil, vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"opcode: %v not supported\", rp.Opcode)\n+\t\t}",
        "comment_created_at": "2024-12-11T01:44:10+00:00",
        "comment_author": "c-r-dev",
        "comment_body": "thanks , incorporated with 40d041f28f5b371854b4538ccc915b0a32f0b79d",
        "pr_file_module": null
      }
    ]
  }
]