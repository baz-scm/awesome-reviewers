[
  {
    "discussion_id": "1040887248",
    "pr_number": 11456,
    "pr_file": "doc/viper/viper.md",
    "created_at": "2022-12-06T12:04:32+00:00",
    "commented_code": "+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1040887248",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1040887248",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.",
        "comment_created_at": "2022-12-06T12:04:32+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "This impact is only there if there is no local copy of the config and always referring the configuration coming from Viper. right?",
        "pr_file_module": null
      },
      {
        "comment_id": "1041580507",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1040887248",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.",
        "comment_created_at": "2022-12-06T23:30:46+00:00",
        "comment_author": "ajm188",
        "comment_body": "That's correct, and in fact I would not recommend diverging from the viper version for dynamic variables, as extracting your own registry will completely divorce you from the config-watching behavior.\r\n\r\nUnless by \"local copy\" you mean something like \"keep a local version of the last-read value and only check viper at most every N seconds\", in which case, yeah the throughput only is impacted when checking viper.",
        "pr_file_module": null
      },
      {
        "comment_id": "1041736155",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1040887248",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.",
        "comment_created_at": "2022-12-07T04:12:00+00:00",
        "comment_author": "harshit-gangal",
        "comment_body": "Basically on the hot path we can avoid it with periodic checks, if it runs in a separate goroutine for that piece of code, then it might be ok to do.",
        "pr_file_module": null
      },
      {
        "comment_id": "1042505494",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1040887248",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.",
        "comment_created_at": "2022-12-07T17:43:18+00:00",
        "comment_author": "ajm188",
        "comment_body": "yeah, and if you see in [locks.go](https://github.com/vitessio/vitess/pull/11456/files/91689f14db3377f7f77e6e5bbb26f82caf780199#diff-068fe4fbabfd3c7026b62e06ebf3e7c737ce297ed58e9c83796f25532fd2e10bR93) i've put a trivial example of how you could set something like that up (without the \"periodic checks\" bit, tbc)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1041466117",
    "pr_number": 11456,
    "pr_file": "doc/viper/viper.md",
    "created_at": "2022-12-06T21:14:26+00:00",
    "commented_code": "+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1041466117",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2022-12-06T21:14:26+00:00",
        "comment_author": "deepthi",
        "comment_body": "I think this should be `exit`, not `warn`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1041508481",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2022-12-06T22:05:49+00:00",
        "comment_author": "ajm188",
        "comment_body": "this would break anyone moving to this version (because they wouldn't be able to specify a config file before, so they would immediately `exit` rather than use flags + default values, which was the behavior in the previous version)",
        "pr_file_module": null
      },
      {
        "comment_id": "1045278786",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2022-12-11T18:37:53+00:00",
        "comment_author": "deepthi",
        "comment_body": "the way I understood this is that \"IF a config file is specified AND it is not found, what do I do?\". what you are saying is implying that this is simply \"IF a config file is not found, what do I do?\" We should make it mean the other thing. Is that possible?",
        "pr_file_module": null
      },
      {
        "comment_id": "1045926413",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2022-12-12T14:51:11+00:00",
        "comment_author": "ajm188",
        "comment_body": "we _can_ (probably, we'd have to shim a few things and i haven't looked but it'll almost certainly work), but let's back up for a second first.\r\n\r\nyou don't \"specify a config file\" (usually, more on this in a bit); instead you specify enough for viper to _find_ a config file (by specifying any or all of: (1) paths to search; (2) the name of the file, without the extension; and (3) the type of config file, e.g. \"yaml\", or let viper infer it from the file extension) and viper will just find it. so the way we have this hooked up now is, \"for free\" if you run a binary while having a `vtconfig` file (in any supported format, so `.json`, `.yaml`, `.toml`, and so on (see [`SupportedExts`](https://github.com/spf13/viper/blob/v1.14.0/viper.go#L419))) in your working directory, the config gets loaded without you needing to add extra flags on the command line.\r\n\r\nif we wanted the behavior you're describing, we'd have to remove that \"for free\" behavior (which may be fine and what we want, in the end, but that is the necessary tradeoff).\r\n\r\nsecond, viper let's you explicitly specify a full path, including the extension, and it'll skip the searching process described above and just try to load that file. _this_ case i'm much more on board with what you're describing (though it would make the warn/error/exit flag more confusing, because in the _first_ case we probably want the default of \"warn\" but in _this_ case we probably want the default of \"exit\")\r\n\r\nwith all that said (and let me know if anything wasn't clear!!), uhh, for lack of a more eloquent question: thoughts?",
        "pr_file_module": null
      },
      {
        "comment_id": "1054776681",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2022-12-21T19:36:41+00:00",
        "comment_author": "deepthi",
        "comment_body": "If a full path is explicitly specified, and the file is not found, exit.\r\nIf viper is searching various paths and no files are found, Info / Warn is sufficient.",
        "pr_file_module": null
      },
      {
        "comment_id": "1054846969",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2022-12-21T21:21:09+00:00",
        "comment_author": "ajm188",
        "comment_body": "right, but what is the default value for this flag, then? you can't have a default value that's conditional on the final value of some other flag",
        "pr_file_module": null
      },
      {
        "comment_id": "1198288384",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2023-05-18T20:47:22+00:00",
        "comment_author": "deepthi",
        "comment_body": "Hmm yeah that makes sense. In the interest of keeping the behavior uniform, we can leave this as-is.",
        "pr_file_module": null
      },
      {
        "comment_id": "1198806041",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2023-05-19T10:23:27+00:00",
        "comment_author": "ajm188",
        "comment_body": "oh, actually i changed this to Ignore because it was breaking tests that invoked a `vtctlclient` and asserted on the output (since the warning now came first). let me try to actually fix that instead of being lazy, because i would prefer the Warn-as-default",
        "pr_file_module": null
      },
      {
        "comment_id": "1198942628",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1041466117",
        "commented_code": "@@ -0,0 +1,298 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.\n+Dynamic values, conversely, may respond to config changes.\n+\n+In order for dynamic configs to be truly dynamic, `LoadConfig` must have found a config file (as opposed to pulling values entirely from defaults, flags, and environment variables).\n+If this is the case, a second viper shim, which backs the dynamic registry, will start a watch on that file, and any changes to that file will be reflected in the `Get` methods of any values configured with `Dynamic: true`.\n+\n+**An important caveat** is that viper on its own is not threadsafe, meaning that if a config reload is being processed while a value is being accessed, a race condition can occur.\n+To protect against this, the dynamic registry uses a second shim, [`sync.Viper`](../../go/viperutil/internal/sync/sync.go).\n+This works by assigning each dynamic value its own `sync.RWMutex`, and locking it for writes whenever a config change is detected. Value `GetFunc`s are then adapted to wrap the underlying get in a `m.RLock(); defer m.RUnlock()` layer.\n+This means that there's a potential throughput impact of using dynamic values, which module authors should be aware of when deciding to make a given value dynamic.\n+\n+### A brief aside on flags\n+\n+In the name of \"we will catch as many mistakes as possible in tests\" (\"mistakes\" here referring to typos in flag names, deleting a flag in one place but forgetting to clean up another reference, and so on), `Values` will panic at bind-time if they are configured to bind to a flag name that does not exist.\n+Then, **as long as every binary is at least invoked** (including just `mycmd --help`) in an end-to-end test, our CI will fail if we ever misconfigure a value in this way.\n+\n+However, since `Configure` handles the binding of defaults, aliases, and envirnomnent variables, and is usually called in `var` blocks, this binding can actually happen before the module registers its flags via the `servenv.{OnParse,OnParseFor}` hooks.\n+If we were to also bind any named flags at the point of `Configure`, this would cause panics even if the module later registered a flag with that name.\n+Therefore, we introduce a separate function, namely `viperutil.BindFlags`, which binds the flags on one or more values, which modules can call _after_ registering their flags, usually in the same `OnParse` hook function.\n+For example:\n+\n+```go\n+package azblobbackupstorage\n+\n+import (\n+\t\"github.com/spf13/pflag\"\n+\n+\t\"vitess.io/vitess/go/viperutil\"\n+\t\"vitess.io/vitess/go/vt/servenv\"\n+)\n+\n+var (\n+\tconfigKey = viperutil.KeyPrefixFunc(\"backup.storage.azblob\")\n+\n+\taccountName = viperutil.Configure(\n+\t\tconfigKey(\"account.name\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tEnvVars:  []string{\"VT_AZBLOB_ACCOUNT_NAME\"},\n+\t\t\tFlagName: \"azblob_backup_account_name\",\n+\t\t},\n+\t)\n+\n+\taccountKeyFile = viperutil.Configure(\n+\t\tconfigKey(\"account.key_file\"),\n+\t\tviperutil.Options[string]{\n+\t\t\tFlagName: \"azblob_backup_account_key_file\",\n+\t\t},\n+\t)\n+)\n+\n+func registerFlags(fs *pflag.FlagSet) {\n+\tfs.String(\"azblob_backup_account_name\", accountName.Default(), \"Azure Storage Account name for backups; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_NAME will be used.\")\n+\tfs.String(\"azblob_backup_account_key_file\", accountKeyFile.Default(), \"Path to a file containing the Azure Storage account key; if this flag is unset, the environment variable VT_AZBLOB_ACCOUNT_KEY will be used as the key itself (NOT a file path).\")\n+\n+    viperutil.BindFlags(fs, accountName, accountKeyFile)\n+}\n+\n+func init() {\n+\tservenv.OnParseFor(\"vtbackup\", registerFlags)\n+\tservenv.OnParseFor(\"vtctl\", registerFlags)\n+\tservenv.OnParseFor(\"vtctld\", registerFlags)\n+\tservenv.OnParseFor(\"vttablet\", registerFlags)\n+}\n+```\n+\n+## Config Files\n+\n+`viperutil` provides a few flags that allow binaries to read values from config files in addition to defaults, environment variables and flags.\n+They are:\n+\n+- `--config-path`\n+    - Default: `$(pwd)`\n+    - EnvVar: `VT_CONFIG_PATH` (parsed exactly like a `$PATH` style shell variable).\n+    - FlagType: `StringSlice`\n+    - Behavior: Paths for `ReadInConfig` to search.\n+- `--config-type`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_TYPE`\n+    - FlagType: `flagutil.StringEnum`\n+        - Values: everything contained in `viper.SupportedExts`, case-insensitive.\n+    - Behavior: Force viper to use a particular unmarshalling strategy; required if the config file does not have an extension (by default, viper infers the config type from the file extension).\n+- `--config-name`\n+    - Default: `\"vtconfig\"`\n+    - EnvVar: `VT_CONFIG_NAME`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to only look in `ConfigPaths` for files named with this name (with any supported extension, unless `ConfigType` is also set, in which case only with that extension).\n+- `--config-file`\n+    - Default: `\"\"`\n+    - EnvVar: `VT_CONFIG_FILE`\n+    - FlagType: `string`\n+    - Behavior: Instructs `ReadInConfig` to search in `ConfigPaths` for explicitly a file with this name. Takes precedence over `ConfigName`.\n+- `--config-file-not-found-handling`\n+    - Default: `WarnOnConfigFileNotFound`",
        "comment_created_at": "2023-05-19T13:11:32+00:00",
        "comment_author": "ajm188",
        "comment_body": "done \u2705 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1198283965",
    "pr_number": 11456,
    "pr_file": "doc/viper/viper.md",
    "created_at": "2023-05-18T20:41:41+00:00",
    "commented_code": "+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1198283965",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 11456,
        "pr_file": "doc/viper/viper.md",
        "discussion_id": "1198283965",
        "commented_code": "@@ -0,0 +1,322 @@\n+# Vitess Viper Guidelines\n+\n+## What is Viper?\n+\n+[`viper`][viper] is a configuration-management library for Go programs.\n+It acts as a registry for configuration values coming from a variety of sources, including:\n+\n+- Default values.\n+- Configuration files (JSON, YAML, TOML, and other formats supported), including optionally watching and live-reloading.\n+- Environment variables.\n+- Command-line flags, primarily from `pflag.Flag` types.\n+\n+It is used by a wide variety of Go projects, including [hugo][hugo] and [the kubernetes operator][kops].\n+\n+## \"Normal\" Usage\n+\n+Normally, and if you were to follow the examples on the viper documentation, you \"just\" load in a config file, maybe bind some flags, and then load values all across your codebase, like so:\n+\n+```go\n+// cmd/main.go\n+package main\n+\n+import (\n+    \"log\"\n+\n+    \"github.com/spf13/pflag\"\n+    \"github.com/spf13/viper\"\n+\n+    \"example.com/pkg/stuff\"\n+)\n+\n+func main() {\n+    pflag.String(\"name\", \"\", \"name to print\")\n+    pflag.Parse()\n+\n+    viper.AddConfigPath(\".\")\n+    viper.AddConfigPath(\"/var/mypkg\")\n+\n+    if err := viper.ReadInConfig(); err != nil {\n+        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n+            log.Fatal(err)\n+        }\n+    }\n+\n+    viper.BindPFlags(pflag.CommandLine)\n+    viper.BindEnv(\"name\", \"MY_COOL_ENVVAR\")\n+\n+    stuff.Do()\n+}\n+\n+// pkg/stuff/do_stuff.go\n+package stuff\n+\n+import (\n+    \"fmt\"\n+\n+    \"github.com/spf13/viper\"\n+)\n+\n+func Do() {\n+    fmt.Println(viper.GetString(\"name\"))\n+}\n+```\n+\n+While this example is great for getting started with `viper` quickly &mdash; it is very easy, and very fast, to _write_ go from nothing to working code &mdash; it's not likely to scale well for a codebase the size and complexity of Vitess, for several reasons:\n+\n+1. Everything is globally-accessible.\n+\n+    Currently, most of the config values in Vitess modules are un-exported (and we un-exported more of these during the `pflag` migration).\n+    This is a good thing, as it gives each module control over how its configuration values are used, rather than allowing the raw values to leak across package boundaries.\n+\n+1. [Magical][a_theory_of_modern_go] access and lack of compile-time safety.\n+\n+    In the above example, `package stuff` just \"happens to know\" that (1) `package main` binds a value to `viper` with the key `\"name\"` and (2) `\"name\"` is going to be bound to a `string` value specifically.\n+\n+    If `package main` ever changes either of these two facts, `package stuff` is going to break (precisely how it breaks depends on what the changes are), and there's no way to catch this _before_ runtime without writing additional linters. (Note this is strongly-related to point 1 above).\n+\n+1. Hard to document.\n+\n+    `viper` does not provide any sort of automatic documentation-generation code (we'll discuss this more later), so we will need to write our own tooling if we want to update our flag documentation with information like \"this flag is also settable via this config key and these environment variables\".\n+\n+    If anyone anywhere can just magically try to read a value from the global registry without first declaring (1) that a config value with that key _should_ exist; (2) what flags, aliases, environment variables it reads from; and (3) what type it is, then writing that tooling is going to be vastly more complicated, and possibly impossible to do correctly.\n+\n+So, we use an approach that requires a bit more verbosity up-front to mitigate these drawbacks to the simpler approach.\n+\n+## Our Approach\n+\n+Instead of relying on the global `viper.Viper` singleton, we use a shim layer introduced in `package viperutil` to configure values in a standardized way across the entire Vitess codebase.\n+\n+This function, `Configure`, then returns a value object, with a `Get` method that returns the actual value from the viper registry.\n+Packages may then choose to export their config values, or not, as they see fit for their API consumers.\n+\n+### `Configure` Options\n+\n+In order to properly configure a value for use, `Configure` needs to know, broadly speaking, three things:\n+\n+1. The key name being bound.\n+1. What \"things\" it should be bound to (i.e. other keys via aliases, environment variables, and flag names), as well as if it has a default value.\n+1. How to `Get` it out of a viper.\n+\n+`Configure`, therefore, has the following signature:\n+\n+```go\n+func Configure[T any](key string, options Options[T]) Value[T]\n+```\n+\n+The first parameter provides the key name (point 1 of our above list); all other information is provided via various `Options` fields, which looks like:\n+\n+```go\n+type Options[T any] struct {\n+    // what \"things\" to bind to\n+    Aliases []string\n+    FlagName string\n+    EnvVars []string\n+\n+    // default, if any\n+    Default T\n+\n+    // whether it can reload or not (more on this later)\n+    Dynamic bool\n+\n+    // how to \"get\" it from a viper (more on this slightly less later)\n+    GetFunc func(v *viper.Viper) func(key string) T\n+}\n+```\n+\n+### `Get` funcs\n+\n+In most cases, module authors will not need to specify a `GetFunc` option, since, if not provided, `viperutil` will do its best to provide a sensible default for the given type `T`.\n+\n+This requires a fair amount of `reflect`ion code, which we won't go into here, and unfortunately cannot support even all primitive types (notably, array (not slice!!) types).\n+In these cases, the `GetFuncForType` will panic, allowing the module author to catch this during testing of their package.\n+They may then provide their own `GetFunc`.\n+\n+Authors may also want to provide their own `GetFunc` to provide additional logic to load a value even for types supported by `GetFuncForType` (for example, post-processing a string to ensure it is always lowercase).\n+\n+The full suite of types, both supported and panic-inducing, are documented by way of unit tests in [`go/viperutil/get_func_test.go`](../../go/viperutil/get_func_test.go).\n+\n+### Dynamic values\n+\n+Values can be configured to be either static or dynamic.\n+Static values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the processes lifetime.",
        "comment_created_at": "2023-05-18T20:41:41+00:00",
        "comment_author": "deepthi",
        "comment_body": "```suggestion\r\nStatic values are loaded once at startup (more precisely, when `viperutil.LoadConfig` is called), and whatever value is loaded at the point will be the result of calling `Get` on that value for the remainder of the process's lifetime.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]