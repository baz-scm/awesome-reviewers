[
  {
    "discussion_id": "1912291545",
    "pr_number": 17429,
    "pr_file": "go/vt/vtctl/workflow/server.go",
    "created_at": "2025-01-11T23:17:28+00:00",
    "commented_code": "lockTablesCycles = 2\n \t// Time to wait between LOCK TABLES cycles on the sources during SwitchWrites.\n \tlockTablesCycleDelay = time.Duration(100 * time.Millisecond)\n+\n+\tSqlUnfreezeWorkflow = \"update _vt.vreplication set state='Running', message='' where db_name=%s and workflow=%s\"",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1912291545",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17429,
        "pr_file": "go/vt/vtctl/workflow/server.go",
        "discussion_id": "1912291545",
        "commented_code": "@@ -127,6 +127,8 @@ const (\n \tlockTablesCycles = 2\n \t// Time to wait between LOCK TABLES cycles on the sources during SwitchWrites.\n \tlockTablesCycleDelay = time.Duration(100 * time.Millisecond)\n+\n+\tSqlUnfreezeWorkflow = \"update _vt.vreplication set state='Running', message='' where db_name=%s and workflow=%s\"",
        "comment_created_at": "2025-01-11T23:17:28+00:00",
        "comment_author": "mattlord",
        "comment_body": "We should use the parser instead. So instead of `%s` here and fmt.Sprintf later on we'd have `%a` and then when building the query we use the parser and bindvars instead. You can see examples of doing it this way throughout the code base, but e.g. you can see vdiff/schama.go to see the queries with \"%a\" in them and then how those variables are used. For example:\r\n  - Query: https://github.com/vitessio/vitess/blob/54dfd6005bcdd599604d42a6771cdf5a1025d7d9/go/vt/vttablet/tabletmanager/vdiff/schema.go#L30\r\n  - Usage: https://github.com/vitessio/vitess/blob/54dfd6005bcdd599604d42a6771cdf5a1025d7d9/go/vt/vttablet/tabletmanager/vdiff/action.go#L318-L321",
        "pr_file_module": null
      },
      {
        "comment_id": "1912292041",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17429,
        "pr_file": "go/vt/vtctl/workflow/server.go",
        "discussion_id": "1912291545",
        "commented_code": "@@ -127,6 +127,8 @@ const (\n \tlockTablesCycles = 2\n \t// Time to wait between LOCK TABLES cycles on the sources during SwitchWrites.\n \tlockTablesCycleDelay = time.Duration(100 * time.Millisecond)\n+\n+\tSqlUnfreezeWorkflow = \"update _vt.vreplication set state='Running', message='' where db_name=%s and workflow=%s\"",
        "comment_created_at": "2025-01-11T23:18:17+00:00",
        "comment_author": "mattlord",
        "comment_body": "Does this variable really need to be exported from the package? If not, we should make the first letter a lower case s.",
        "pr_file_module": null
      },
      {
        "comment_id": "1914580877",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17429,
        "pr_file": "go/vt/vtctl/workflow/server.go",
        "discussion_id": "1912291545",
        "commented_code": "@@ -127,6 +127,8 @@ const (\n \tlockTablesCycles = 2\n \t// Time to wait between LOCK TABLES cycles on the sources during SwitchWrites.\n \tlockTablesCycleDelay = time.Duration(100 * time.Millisecond)\n+\n+\tSqlUnfreezeWorkflow = \"update _vt.vreplication set state='Running', message='' where db_name=%s and workflow=%s\"",
        "comment_created_at": "2025-01-14T10:23:23+00:00",
        "comment_author": "beingnoble03",
        "comment_body": "Done. And, yes, this was intentionally exported because we need it for some unit tests outside the package.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1622010513",
    "pr_number": 16022,
    "pr_file": "go/vt/mysqlctl/replication.go",
    "created_at": "2024-05-31T08:59:52+00:00",
    "commented_code": "return conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1622010513",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1622010513",
        "commented_code": "@@ -228,6 +228,27 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
        "comment_created_at": "2024-05-31T08:59:52+00:00",
        "comment_author": "rohit-nayak-ps",
        "comment_body": "Don't we need a comma separator here? You can just do a a `strings.Join(statuses, \",\")` instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "1622047328",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1622010513",
        "commented_code": "@@ -228,6 +228,27 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
        "comment_created_at": "2024-05-31T09:23:32+00:00",
        "comment_author": "rohit-nayak-ps",
        "comment_body": "Previous comment is not correct about using `strings.Join` since we need to escape the variable name (though we do need the separator). The escaping can be done using `sqltypes.EncodeStringSQL()`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1622682002",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1622010513",
        "commented_code": "@@ -228,6 +228,27 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
        "comment_created_at": "2024-05-31T16:30:45+00:00",
        "comment_author": "mattlord",
        "comment_body": "I would recommend something like this:\r\n```\r\n        // The format specifier is for any optional predicates.\r\n        query := \"SELECT variable_name, variable_value FROM performance_schema.global_status%s\"\r\n        predicates := strings.Builder{} // optional filters\r\n        if len(names) > 0 {\r\n\t\tpredicates.WriteString(\" WHERE variable_name IN (\")\r\n\t        for i, name := range names {\r\n\t\t        if i > 0 {\r\n\t\t\t        predicates.WriteByte(',')\r\n\t        \t}\r\n                        predicates.WriteString(sqltypes.EncodeStringSQL(name))\r\n                }\r\n\t        predicates.WriteByte(')')\r\n        }\r\n        qr, err := mysqld.FetchSuperQuery(ctx, fmt.Sprintf(query, predicates.String())\r\n```\r\n\r\nSelecting the `variable_name` is necessary in order to return a map, which I think we really have to in order for this to be usable with multiple values.\r\n\r\nI also think that the base query should be a const in the package (~ `getGlobalStatusQuery`).\r\n\r\nLastly, I also think that we should build a parsed query here rather than sending the raw unparsed one on. This will add some input validation to protect against intentional or not, unexpected/unwanted behaviors. For example, someone sending in something like `'); drop table mysql.user;` as a var name. For example:\r\n```\r\n\tparsed := sqlparser.BuildParsedQuery(query, predicates.String())\r\n        query, err := parsed.GenerateQuery(nil, nil)\r\n        if err != nil {\r\n             return nil, err\r\n        }\r\n        qr, err := mysqld.FetchSuperQuery(ctx, query)\r\n```\r\n\r\nRelated to that, we don't have to use Super for this query.",
        "pr_file_module": null
      },
      {
        "comment_id": "1623376146",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1622010513",
        "commented_code": "@@ -228,6 +228,27 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
        "comment_created_at": "2024-06-02T10:26:48+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "If we don't already, we should have a generic utility function that generates a comma separated string clause (as for `IN` clause) rather than implement it specifically in this function.",
        "pr_file_module": null
      },
      {
        "comment_id": "1623468077",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1622010513",
        "commented_code": "@@ -228,6 +228,27 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
        "comment_created_at": "2024-06-02T15:04:22+00:00",
        "comment_author": "mattlord",
        "comment_body": "We do. So if we do end up using the parser, which I think we should as discussed above, we can leverage that to build the IN clause. Here's an example:\r\n\r\n`... in %a ...`:\r\nhttps://github.com/vitessio/vitess/blob/main/go/vt/vttablet/tabletmanager/vdiff/table_plan.go#L39\r\n\r\nBuilding and binding the slice bind var:\r\nhttps://github.com/vitessio/vitess/blob/377e1ddc99b9b1aeeae3eddb5a6ce575d1f5fc79/go/vt/vttablet/tabletmanager/vdiff/table_plan.go#L250-L262",
        "pr_file_module": null
      },
      {
        "comment_id": "1624066003",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1622010513",
        "commented_code": "@@ -228,6 +228,27 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetServerStatus returns the server statuses asked for.\n+func (mysqld *Mysqld) GetServerStatus(ctx context.Context, statuses []string) ([]string, error) {\n+\tquery := `SELECT variable_value FROM performance_schema.global_status WHERE variable_name IN (`\n+\tfor _, status := range statuses {",
        "comment_created_at": "2024-06-03T08:58:33+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1624561695",
    "pr_number": 16022,
    "pr_file": "go/vt/mysqlctl/replication.go",
    "created_at": "2024-06-03T14:28:14+00:00",
    "commented_code": "return conn.Conn.GetServerUUID()\n }\n \n+// GetGlobalStatusVars returns the server's global status variables asked for.\n+// An empty/nil variable name parameter slice means you want all of them.\n+func (mysqld *Mysqld) GetGlobalStatusVars(ctx context.Context, statuses []string) (map[string]string, error) {\n+\tquery := \"SELECT variable_name, variable_value FROM performance_schema.global_status\"\n+\tif len(statuses) != 0 {\n+\t\t// The format specifier is for any optional predicates.\n+\t\tstatusBv, err := sqltypes.BuildBindVariable(statuses)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tquery, err = sqlparser.ParseAndBind(\"SELECT variable_name, variable_value FROM performance_schema.global_status WHERE variable_name IN %a\",\n+\t\t\tstatusBv,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tqr, err := mysqld.FetchSuperQuery(ctx, query)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1624561695",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1624561695",
        "commented_code": "@@ -228,6 +230,38 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetGlobalStatusVars returns the server's global status variables asked for.\n+// An empty/nil variable name parameter slice means you want all of them.\n+func (mysqld *Mysqld) GetGlobalStatusVars(ctx context.Context, statuses []string) (map[string]string, error) {\n+\tquery := \"SELECT variable_name, variable_value FROM performance_schema.global_status\"\n+\tif len(statuses) != 0 {\n+\t\t// The format specifier is for any optional predicates.\n+\t\tstatusBv, err := sqltypes.BuildBindVariable(statuses)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tquery, err = sqlparser.ParseAndBind(\"SELECT variable_name, variable_value FROM performance_schema.global_status WHERE variable_name IN %a\",\n+\t\t\tstatusBv,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tqr, err := mysqld.FetchSuperQuery(ctx, query)",
        "comment_created_at": "2024-06-03T14:28:14+00:00",
        "comment_author": "mattlord",
        "comment_body": "IMO it's worth creating a `mysqld.FetchQuery` helper (doesn't have to be done here) as there should be no need to use the DBA pool for this and various other things. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1625053659",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 16022,
        "pr_file": "go/vt/mysqlctl/replication.go",
        "discussion_id": "1624561695",
        "commented_code": "@@ -228,6 +230,38 @@ func (mysqld *Mysqld) GetServerUUID(ctx context.Context) (string, error) {\n \treturn conn.Conn.GetServerUUID()\n }\n \n+// GetGlobalStatusVars returns the server's global status variables asked for.\n+// An empty/nil variable name parameter slice means you want all of them.\n+func (mysqld *Mysqld) GetGlobalStatusVars(ctx context.Context, statuses []string) (map[string]string, error) {\n+\tquery := \"SELECT variable_name, variable_value FROM performance_schema.global_status\"\n+\tif len(statuses) != 0 {\n+\t\t// The format specifier is for any optional predicates.\n+\t\tstatusBv, err := sqltypes.BuildBindVariable(statuses)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tquery, err = sqlparser.ParseAndBind(\"SELECT variable_name, variable_value FROM performance_schema.global_status WHERE variable_name IN %a\",\n+\t\t\tstatusBv,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tqr, err := mysqld.FetchSuperQuery(ctx, query)",
        "comment_created_at": "2024-06-03T21:08:57+00:00",
        "comment_author": "GuptaManan100",
        "comment_body": "We can do that change as a follow up. Currently rushing to get this into RC",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140267932",
    "pr_number": 18348,
    "pr_file": "go/vt/vttablet/tabletmanager/rpc_vreplication.go",
    "created_at": "2025-06-11T13:59:42+00:00",
    "commented_code": "sqlGetVReplicationCopyStatus = \"select distinct vrepl_id from %s.copy_state where vrepl_id = %d\"\n \t// Validate the minimum set of permissions needed to manage vreplication metadata.\n \t// This is a simple check for a matching user rather than any specific user@host\n-\t// combination.\n+\t// combination. Also checks for wildcards. Note the, seemingly reverse check, `%a LIKE d.db`,\n+\t// which is required since %a replaces the actual sidecar db name and\n+\t// d.db is where a (potential) wildcard match is specified in a privilege grant.\n \tsqlValidateVReplicationPermissions = `\n select count(*)>0 as good from mysql.user as u\n   left join mysql.db as d on (u.user = d.user)\n   left join mysql.tables_priv as t on (u.user = t.user)\n where u.user = %a\n   and (\n     (u.select_priv = 'y' and u.insert_priv = 'y' and u.update_priv = 'y' and u.delete_priv = 'y') /* user has global privs */\n-    or (d.db = %a and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n-    or (t.db = %a and t.table_name = 'vreplication' /* user has table privs */\n+    or (%a LIKE d.db escape '\\\\' and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n+    or (%a LIKE t.db escape '\\\\' and t.table_name = 'vreplication'",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "2140267932",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18348,
        "pr_file": "go/vt/vttablet/tabletmanager/rpc_vreplication.go",
        "discussion_id": "2140267932",
        "commented_code": "@@ -75,23 +75,26 @@ const (\n \tsqlGetVReplicationCopyStatus = \"select distinct vrepl_id from %s.copy_state where vrepl_id = %d\"\n \t// Validate the minimum set of permissions needed to manage vreplication metadata.\n \t// This is a simple check for a matching user rather than any specific user@host\n-\t// combination.\n+\t// combination. Also checks for wildcards. Note the, seemingly reverse check, `%a LIKE d.db`,\n+\t// which is required since %a replaces the actual sidecar db name and\n+\t// d.db is where a (potential) wildcard match is specified in a privilege grant.\n \tsqlValidateVReplicationPermissions = `\n select count(*)>0 as good from mysql.user as u\n   left join mysql.db as d on (u.user = d.user)\n   left join mysql.tables_priv as t on (u.user = t.user)\n where u.user = %a\n   and (\n     (u.select_priv = 'y' and u.insert_priv = 'y' and u.update_priv = 'y' and u.delete_priv = 'y') /* user has global privs */\n-    or (d.db = %a and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n-    or (t.db = %a and t.table_name = 'vreplication' /* user has table privs */\n+    or (%a LIKE d.db escape '\\\\' and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n+    or (%a LIKE t.db escape '\\\\' and t.table_name = 'vreplication'",
        "comment_created_at": "2025-06-11T13:59:42+00:00",
        "comment_author": "deepthi",
        "comment_body": "If we are anyway changing the permissions query, aren't we better off using `SHOW GRANTS` instead of querying the `mysql` database? We have seen cases where the migration user does not have permissions on the `mysql` database on the source.",
        "pr_file_module": null
      },
      {
        "comment_id": "2140329271",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18348,
        "pr_file": "go/vt/vttablet/tabletmanager/rpc_vreplication.go",
        "discussion_id": "2140267932",
        "commented_code": "@@ -75,23 +75,26 @@ const (\n \tsqlGetVReplicationCopyStatus = \"select distinct vrepl_id from %s.copy_state where vrepl_id = %d\"\n \t// Validate the minimum set of permissions needed to manage vreplication metadata.\n \t// This is a simple check for a matching user rather than any specific user@host\n-\t// combination.\n+\t// combination. Also checks for wildcards. Note the, seemingly reverse check, `%a LIKE d.db`,\n+\t// which is required since %a replaces the actual sidecar db name and\n+\t// d.db is where a (potential) wildcard match is specified in a privilege grant.\n \tsqlValidateVReplicationPermissions = `\n select count(*)>0 as good from mysql.user as u\n   left join mysql.db as d on (u.user = d.user)\n   left join mysql.tables_priv as t on (u.user = t.user)\n where u.user = %a\n   and (\n     (u.select_priv = 'y' and u.insert_priv = 'y' and u.update_priv = 'y' and u.delete_priv = 'y') /* user has global privs */\n-    or (d.db = %a and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n-    or (t.db = %a and t.table_name = 'vreplication' /* user has table privs */\n+    or (%a LIKE d.db escape '\\\\' and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n+    or (%a LIKE t.db escape '\\\\' and t.table_name = 'vreplication'",
        "comment_created_at": "2025-06-11T14:20:02+00:00",
        "comment_author": "mattlord-istari",
        "comment_body": "Yeah, parsing the `SHOW GRANTS` output is really the best option. There are valid scenarios not covered by the current query too. If this is a more common issue then it's worth taking that route IMO. When this work was initially done there had only ever been a single report of related issues that I was aware of so I didn't think it was worth going that route at the time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2140707363",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 18348,
        "pr_file": "go/vt/vttablet/tabletmanager/rpc_vreplication.go",
        "discussion_id": "2140267932",
        "commented_code": "@@ -75,23 +75,26 @@ const (\n \tsqlGetVReplicationCopyStatus = \"select distinct vrepl_id from %s.copy_state where vrepl_id = %d\"\n \t// Validate the minimum set of permissions needed to manage vreplication metadata.\n \t// This is a simple check for a matching user rather than any specific user@host\n-\t// combination.\n+\t// combination. Also checks for wildcards. Note the, seemingly reverse check, `%a LIKE d.db`,\n+\t// which is required since %a replaces the actual sidecar db name and\n+\t// d.db is where a (potential) wildcard match is specified in a privilege grant.\n \tsqlValidateVReplicationPermissions = `\n select count(*)>0 as good from mysql.user as u\n   left join mysql.db as d on (u.user = d.user)\n   left join mysql.tables_priv as t on (u.user = t.user)\n where u.user = %a\n   and (\n     (u.select_priv = 'y' and u.insert_priv = 'y' and u.update_priv = 'y' and u.delete_priv = 'y') /* user has global privs */\n-    or (d.db = %a and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n-    or (t.db = %a and t.table_name = 'vreplication' /* user has table privs */\n+    or (%a LIKE d.db escape '\\\\' and d.select_priv = 'y' and d.insert_priv = 'y' and d.update_priv = 'y' and d.delete_priv = 'y') /* user has db privs */\n+    or (%a LIKE t.db escape '\\\\' and t.table_name = 'vreplication'",
        "comment_created_at": "2025-06-11T17:17:35+00:00",
        "comment_author": "rohit-nayak-ps",
        "comment_body": "Let's go with this iterative improvement for now. I am not sure what the `show grants` logic will look like and what edge cases it might have. ",
        "pr_file_module": null
      }
    ]
  }
]