[
  {
    "discussion_id": "1948435504",
    "pr_number": 17720,
    "pr_file": "go/cache/lru_cache_test.go",
    "created_at": "2025-02-10T05:58:34+00:00",
    "commented_code": "cache.Set(key, data)\n \n \tv, ok := cache.Get(key)\n-\tif !ok || v != data {\n-\t\tt.Errorf(\"Cache has incorrect value: %v != %v\", data, v)\n-\t}\n+\tassert.True(t, ok && v == data, \"Cache has incorrect value: expected %v, got %v\", data, v)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1948435504",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/cache/lru_cache_test.go",
        "discussion_id": "1948435504",
        "commented_code": "@@ -44,14 +44,10 @@ func TestSetInsertsValue(t *testing.T) {\n \tcache.Set(key, data)\n \n \tv, ok := cache.Get(key)\n-\tif !ok || v != data {\n-\t\tt.Errorf(\"Cache has incorrect value: %v != %v\", data, v)\n-\t}\n+\tassert.True(t, ok && v == data, \"Cache has incorrect value: expected %v, got %v\", data, v)",
        "comment_created_at": "2025-02-10T05:58:34+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "Let's replace this with two distinct asserts: `assert.True(t, ok, ...)` and `assert.Equal(t, data, v, ...)`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1948439437",
    "pr_number": 17720,
    "pr_file": "go/cache/lru_cache_test.go",
    "created_at": "2025-02-10T06:04:14+00:00",
    "commented_code": "cache.Set(\"key1\", value)\n \tcache.Set(\"key2\", value)\n \tcache.Set(\"key3\", value)\n-\tif sz := cache.UsedCapacity(); sz != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() = %v, expected %v\", sz, size)\n-\t}\n+\tsz := cache.UsedCapacity()\n+\tassert.Equal(t, size, sz, \"cache.UsedCapacity() = %v, expected %v\", sz, size)\n \t// Insert one more; something should be evicted to make room.\n \tcache.Set(\"key4\", value)\n \tsz, evictions := cache.UsedCapacity(), cache.Evictions()\n \tassert.Equal(t, size, sz)\n \tassert.EqualValues(t, 1, evictions)\n \n \t// Check various other stats\n-\tif l := cache.Len(); int64(l) != size {\n-\t\tt.Errorf(\"cache.Len() returned bad length: %v\", l)\n-\t}\n-\tif s := cache.UsedCapacity(); s != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() returned bad size: %v\", s)\n-\t}\n-\tif c := cache.MaxCapacity(); c != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() returned bad length: %v\", c)\n-\t}\n-\tif c := cache.Hits(); c != 0 {\n-\t\tt.Errorf(\"cache.Hits() returned hits when there should be none: %v\", c)\n-\t}\n-\tif c := cache.Misses(); c != 0 {\n-\t\tt.Errorf(\"cache.Misses() returned misses when there should be none: %v\", c)\n-\t}\n+\tl := cache.Len()\n+\tassert.Equal(t, size, int64(l), \"cache.Len() returned bad length: %v\", l)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1948439437",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/cache/lru_cache_test.go",
        "discussion_id": "1948439437",
        "commented_code": "@@ -121,31 +108,29 @@ func TestCapacityIsObeyed(t *testing.T) {\n \tcache.Set(\"key1\", value)\n \tcache.Set(\"key2\", value)\n \tcache.Set(\"key3\", value)\n-\tif sz := cache.UsedCapacity(); sz != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() = %v, expected %v\", sz, size)\n-\t}\n+\tsz := cache.UsedCapacity()\n+\tassert.Equal(t, size, sz, \"cache.UsedCapacity() = %v, expected %v\", sz, size)\n \t// Insert one more; something should be evicted to make room.\n \tcache.Set(\"key4\", value)\n \tsz, evictions := cache.UsedCapacity(), cache.Evictions()\n \tassert.Equal(t, size, sz)\n \tassert.EqualValues(t, 1, evictions)\n \n \t// Check various other stats\n-\tif l := cache.Len(); int64(l) != size {\n-\t\tt.Errorf(\"cache.Len() returned bad length: %v\", l)\n-\t}\n-\tif s := cache.UsedCapacity(); s != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() returned bad size: %v\", s)\n-\t}\n-\tif c := cache.MaxCapacity(); c != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() returned bad length: %v\", c)\n-\t}\n-\tif c := cache.Hits(); c != 0 {\n-\t\tt.Errorf(\"cache.Hits() returned hits when there should be none: %v\", c)\n-\t}\n-\tif c := cache.Misses(); c != 0 {\n-\t\tt.Errorf(\"cache.Misses() returned misses when there should be none: %v\", c)\n-\t}\n+\tl := cache.Len()\n+\tassert.Equal(t, size, int64(l), \"cache.Len() returned bad length: %v\", l)",
        "comment_created_at": "2025-02-10T06:04:14+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "Let's use `EqualValues` which accepts compatible integer types.\r\n\r\n```suggestion\r\n\tEqualValues(t, size, l, \"cache.Len() returned bad length: %v\", l)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1948440814",
    "pr_number": 17720,
    "pr_file": "go/event/event_test.go",
    "created_at": "2025-02-10T06:06:15+00:00",
    "commented_code": "AddListener(func(testEvent1) { triggered2 = true })\n \tDispatch(testEvent1{})\n \n-\tif !triggered1 || !triggered2 {\n-\t\tt.Errorf(\"not all matching listeners triggered\")\n-\t}\n+\tassert.True(t, triggered1 && triggered2, \"not all matching listeners triggered\")",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1948440814",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/event/event_test.go",
        "discussion_id": "1948440814",
        "commented_code": "@@ -98,19 +104,16 @@ func TestMultipleListeners(t *testing.T) {\n \tAddListener(func(testEvent1) { triggered2 = true })\n \tDispatch(testEvent1{})\n \n-\tif !triggered1 || !triggered2 {\n-\t\tt.Errorf(\"not all matching listeners triggered\")\n-\t}\n+\tassert.True(t, triggered1 && triggered2, \"not all matching listeners triggered\")",
        "comment_created_at": "2025-02-10T06:06:15+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "split to two distinct `assert.True` calls",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1948441613",
    "pr_number": 17720,
    "pr_file": "go/event/event_test.go",
    "created_at": "2025-02-10T06:07:24+00:00",
    "commented_code": "defer func() {\n \t\terr := recover()\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"bad listener type (not a func) failed to trigger panic\")\n-\t\t}\n+\t\tassert.NotNil(t, err, \"bad listener type (not a func) failed to trigger panic\")",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1948441613",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/event/event_test.go",
        "discussion_id": "1948441613",
        "commented_code": "@@ -134,19 +135,15 @@ func TestBadListenerWrongType(t *testing.T) {\n \n \tdefer func() {\n \t\terr := recover()\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"bad listener type (not a func) failed to trigger panic\")\n-\t\t}\n+\t\tassert.NotNil(t, err, \"bad listener type (not a func) failed to trigger panic\")",
        "comment_created_at": "2025-02-10T06:07:24+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "prefer `assert.Error(t, err, ...)`",
        "pr_file_module": null
      },
      {
        "comment_id": "1948745978",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/event/event_test.go",
        "discussion_id": "1948441613",
        "commented_code": "@@ -134,19 +135,15 @@ func TestBadListenerWrongType(t *testing.T) {\n \n \tdefer func() {\n \t\terr := recover()\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"bad listener type (not a func) failed to trigger panic\")\n-\t\t}\n+\t\tassert.NotNil(t, err, \"bad listener type (not a func) failed to trigger panic\")",
        "comment_created_at": "2025-02-10T09:54:25+00:00",
        "comment_author": "akagami-harsh",
        "comment_body": "`assert.Error` specifically expects an error type, but the `err` here is an `interface{}`, so using `assert.NotNil` here because  can handle any interface{}",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1949113978",
    "pr_number": 17720,
    "pr_file": "go/cache/lru_cache_test.go",
    "created_at": "2025-02-10T14:02:38+00:00",
    "commented_code": "cache.Set(\"key1\", value)\n \tcache.Set(\"key2\", value)\n \tcache.Set(\"key3\", value)\n-\tif sz := cache.UsedCapacity(); sz != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() = %v, expected %v\", sz, size)\n-\t}\n+\tsz := cache.UsedCapacity()\n+\tassert.Equal(t, size, sz, \"cache.UsedCapacity() = %v, expected %v\", sz, size)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1949113978",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/cache/lru_cache_test.go",
        "discussion_id": "1949113978",
        "commented_code": "@@ -121,31 +114,29 @@ func TestCapacityIsObeyed(t *testing.T) {\n \tcache.Set(\"key1\", value)\n \tcache.Set(\"key2\", value)\n \tcache.Set(\"key3\", value)\n-\tif sz := cache.UsedCapacity(); sz != size {\n-\t\tt.Errorf(\"cache.UsedCapacity() = %v, expected %v\", sz, size)\n-\t}\n+\tsz := cache.UsedCapacity()\n+\tassert.Equal(t, size, sz, \"cache.UsedCapacity() = %v, expected %v\", sz, size)",
        "comment_created_at": "2025-02-10T14:02:38+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "No need to report the expected and found values, since `assert.Equal()` already does so.\r\n```suggestion\r\n\tassert.Equal(t, size, sz)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950424654",
    "pr_number": 17720,
    "pr_file": "go/pools/id_pool_test.go",
    "created_at": "2025-02-11T08:32:54+00:00",
    "commented_code": "id1 := pool.Get()\n \tpool.Get()\n \tpool.Put(id1)\n-\n-\tif got := pool.Get(); got != 1 {\n-\t\tt.Errorf(\"pool.Get() = %v, want 1\", got)\n-\t}\n-\n+\tgot := pool.Get()\n+\tassert.EqualValues(t, uint32(1), got)\n \tpool.want(&IDPool{used: map[uint32]bool{}, maxUsed: 2}, t)\n }\n \n func wantError(want string, t *testing.T) {\n \trec := recover()\n-\tif rec == nil {\n-\t\tt.Errorf(\"expected panic, but there wasn't one\")\n-\t}\n+\trequire.NotNil(t, rec, \"expected panic, but there wasn't one\")\n \terr, ok := rec.(error)\n-\tif !ok || !strings.Contains(err.Error(), want) {\n-\t\tt.Errorf(\"wrong error, got '%v', want '%v'\", err, want)\n-\t}\n+\trequire.True(t, ok && strings.Contains(err.Error(), want), \"wrong error, got '%v', want '%v'\", err, want)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1950424654",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/pools/id_pool_test.go",
        "discussion_id": "1950424654",
        "commented_code": "@@ -84,23 +72,16 @@ func TestIDPoolGetFromUsedSet(t *testing.T) {\n \tid1 := pool.Get()\n \tpool.Get()\n \tpool.Put(id1)\n-\n-\tif got := pool.Get(); got != 1 {\n-\t\tt.Errorf(\"pool.Get() = %v, want 1\", got)\n-\t}\n-\n+\tgot := pool.Get()\n+\tassert.EqualValues(t, uint32(1), got)\n \tpool.want(&IDPool{used: map[uint32]bool{}, maxUsed: 2}, t)\n }\n \n func wantError(want string, t *testing.T) {\n \trec := recover()\n-\tif rec == nil {\n-\t\tt.Errorf(\"expected panic, but there wasn't one\")\n-\t}\n+\trequire.NotNil(t, rec, \"expected panic, but there wasn't one\")\n \terr, ok := rec.(error)\n-\tif !ok || !strings.Contains(err.Error(), want) {\n-\t\tt.Errorf(\"wrong error, got '%v', want '%v'\", err, want)\n-\t}\n+\trequire.True(t, ok && strings.Contains(err.Error(), want), \"wrong error, got '%v', want '%v'\", err, want)",
        "comment_created_at": "2025-02-11T08:32:54+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "Split to two checks. One is `require.True`, the other is `require.Contains`.\r\nAlso, what makes this a `require` rather than `assert`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950426778",
    "pr_number": 17720,
    "pr_file": "go/pools/id_pool_test.go",
    "created_at": "2025-02-11T08:34:42+00:00",
    "commented_code": "package pools\n \n import (\n-\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func (pool *IDPool) want(want *IDPool, t *testing.T) {\n-\tif pool.maxUsed != want.maxUsed {\n-\t\tt.Errorf(\"pool.maxUsed = %#v, want %#v\", pool.maxUsed, want.maxUsed)\n-\t}\n-\n-\tif !reflect.DeepEqual(pool.used, want.used) {\n-\t\tt.Errorf(\"pool.used = %#v, want %#v\", pool.used, want.used)\n-\t}\n+\tassert.EqualValues(t, want.maxUsed, pool.maxUsed)\n+\tassert.EqualValues(t, want.used, pool.used)\n }\n \n func TestIDPoolFirstGet(t *testing.T) {\n \tpool := NewIDPool(0)\n-\n-\tif got := pool.Get(); got != 1 {\n-\t\tt.Errorf(\"pool.Get() = %v, want 1\", got)\n-\t}\n-\n+\tgot := pool.Get()\n+\tassert.EqualValues(t, uint32(1), got)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1950426778",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/pools/id_pool_test.go",
        "discussion_id": "1950426778",
        "commented_code": "@@ -17,39 +17,30 @@ limitations under the License.\n package pools\n \n import (\n-\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func (pool *IDPool) want(want *IDPool, t *testing.T) {\n-\tif pool.maxUsed != want.maxUsed {\n-\t\tt.Errorf(\"pool.maxUsed = %#v, want %#v\", pool.maxUsed, want.maxUsed)\n-\t}\n-\n-\tif !reflect.DeepEqual(pool.used, want.used) {\n-\t\tt.Errorf(\"pool.used = %#v, want %#v\", pool.used, want.used)\n-\t}\n+\tassert.EqualValues(t, want.maxUsed, pool.maxUsed)\n+\tassert.EqualValues(t, want.used, pool.used)\n }\n \n func TestIDPoolFirstGet(t *testing.T) {\n \tpool := NewIDPool(0)\n-\n-\tif got := pool.Get(); got != 1 {\n-\t\tt.Errorf(\"pool.Get() = %v, want 1\", got)\n-\t}\n-\n+\tgot := pool.Get()\n+\tassert.EqualValues(t, uint32(1), got)",
        "comment_created_at": "2025-02-11T08:34:42+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "The whole point with `EqualValues` is that you don't need casting for compatible types.\r\n```suggestion\r\n\tassert.EqualValues(t, 1, got)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950428479",
    "pr_number": 17720,
    "pr_file": "go/pools/id_pool_test.go",
    "created_at": "2025-02-11T08:35:58+00:00",
    "commented_code": "package pools\n \n import (\n-\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func (pool *IDPool) want(want *IDPool, t *testing.T) {\n-\tif pool.maxUsed != want.maxUsed {\n-\t\tt.Errorf(\"pool.maxUsed = %#v, want %#v\", pool.maxUsed, want.maxUsed)\n-\t}\n-\n-\tif !reflect.DeepEqual(pool.used, want.used) {\n-\t\tt.Errorf(\"pool.used = %#v, want %#v\", pool.used, want.used)\n-\t}\n+\tassert.EqualValues(t, want.maxUsed, pool.maxUsed)\n+\tassert.EqualValues(t, want.used, pool.used)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1950428479",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/pools/id_pool_test.go",
        "discussion_id": "1950428479",
        "commented_code": "@@ -17,39 +17,30 @@ limitations under the License.\n package pools\n \n import (\n-\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func (pool *IDPool) want(want *IDPool, t *testing.T) {\n-\tif pool.maxUsed != want.maxUsed {\n-\t\tt.Errorf(\"pool.maxUsed = %#v, want %#v\", pool.maxUsed, want.maxUsed)\n-\t}\n-\n-\tif !reflect.DeepEqual(pool.used, want.used) {\n-\t\tt.Errorf(\"pool.used = %#v, want %#v\", pool.used, want.used)\n-\t}\n+\tassert.EqualValues(t, want.maxUsed, pool.maxUsed)\n+\tassert.EqualValues(t, want.used, pool.used)",
        "comment_created_at": "2025-02-11T08:35:58+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "Here we should use `Equal` as this is a deep-equal comparison of two maps.\r\n```suggestion\r\n\tassert.Equal(t, want.used, pool.used)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950446704",
    "pr_number": 17720,
    "pr_file": "go/mysql/binlog_event_common_test.go",
    "created_at": "2025-02-11T08:49:17+00:00",
    "commented_code": "func TestBinlogEventEmptyBuf(t *testing.T) {\n \tinput := binlogEvent([]byte{})\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventGarbage(t *testing.T) {\n \tinput := binlogEvent(garbageEvent)\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventIsValid(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := true\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventTruncatedHeader(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent[:18])\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventTruncatedData(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent[:len(googleRotateEvent)-1])\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventType(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := byte(0x04)\n-\tif got := input.Type(); got != want {\n-\t\tt.Errorf(\"%#v.Type() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.EqualValues(t, byte(0x04), input.Type())\n }\n \n func TestBinlogEventFlags(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := uint16(0x20)\n-\tif got := input.Flags(); got != want {\n-\t\tt.Errorf(\"%#v.Flags() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.Equal(t, uint16(0x20), input.Flags())\n }\n \n func TestBinlogEventTimestamp(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := uint32(0x53e95252)\n-\tif got := input.Timestamp(); got != want {\n-\t\tt.Errorf(\"%#v.Timestamp() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.EqualValues(t, uint32(0x53e95252), input.Timestamp())\n }\n \n func TestBinlogEventServerID(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := uint32(62344)\n-\tif got := input.ServerID(); got != want {\n-\t\tt.Errorf(\"%#v.ServerID() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.EqualValues(t, uint32(62344), input.ServerID())\n }\n \n func TestBinlogEventIsFormatDescription(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := true\n-\tif got := input.IsFormatDescription(); got != want {\n-\t\tt.Errorf(\"%#v.IsFormatDescription() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsFormatDescription(), \"%#v.IsFormatDescription()\", input)\n }\n \n func TestBinlogEventIsNotFormatDescription(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := false\n-\tif got := input.IsFormatDescription(); got != want {\n-\t\tt.Errorf(\"%#v.IsFormatDescription() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsFormatDescription(), \"%#v.IsFormatDescription()\", input)\n }\n \n func TestBinlogEventIsQuery(t *testing.T) {\n \tinput := binlogEvent(googleQueryEvent)\n-\twant := true\n-\tif got := input.IsQuery(); got != want {\n-\t\tt.Errorf(\"%#v.IsQuery() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsQuery(), \"%#v.IsQuery()\", input)\n }\n \n func TestBinlogEventIsNotQuery(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := false\n-\tif got := input.IsQuery(); got != want {\n-\t\tt.Errorf(\"%#v.IsQuery() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsQuery(), \"%#v.IsQuery()\", input)\n }\n \n func TestBinlogEventIsIntVar(t *testing.T) {\n \tinput := binlogEvent(googleIntVarEvent1)\n-\twant := true\n-\tif got := input.IsIntVar(); got != want {\n-\t\tt.Errorf(\"%#v.IsIntVar() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsIntVar(), \"%#v.IsIntVar()\", input)\n }\n \n func TestBinlogEventIsNotIntVar(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := false\n-\tif got := input.IsIntVar(); got != want {\n-\t\tt.Errorf(\"%#v.IsIntVar() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsIntVar(), \"%#v.IsIntVar()\", input)\n }\n \n func TestBinlogEventIsRotate(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := true\n-\tif got := input.IsRotate(); got != want {\n-\t\tt.Errorf(\"%#v.IsRotate() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsRotate(), \"%#v.IsRotate()\", input)\n }\n \n func TestBinlogEventIsNotRotate(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := false\n-\tif got := input.IsRotate(); got != want {\n-\t\tt.Errorf(\"%#v.IsRotate() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsRotate(), \"%#v.IsRotate()\", input)\n }\n \n func TestBinlogEventIsNotHeartbeat(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\tassert.False(t, input.IsHeartbeat())\n+\tassert.False(t, input.IsHeartbeat(), \"%#v.IsHeartbeat()\", input)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1950446704",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/mysql/binlog_event_common_test.go",
        "discussion_id": "1950446704",
        "commented_code": "@@ -40,159 +40,102 @@ var (\n \n func TestBinlogEventEmptyBuf(t *testing.T) {\n \tinput := binlogEvent([]byte{})\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventGarbage(t *testing.T) {\n \tinput := binlogEvent(garbageEvent)\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventIsValid(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := true\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventTruncatedHeader(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent[:18])\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventTruncatedData(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent[:len(googleRotateEvent)-1])\n-\twant := false\n-\tif got := input.IsValid(); got != want {\n-\t\tt.Errorf(\"%#v.IsValid() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsValid(), \"%#v.IsValid()\", input)\n }\n \n func TestBinlogEventType(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := byte(0x04)\n-\tif got := input.Type(); got != want {\n-\t\tt.Errorf(\"%#v.Type() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.EqualValues(t, byte(0x04), input.Type())\n }\n \n func TestBinlogEventFlags(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := uint16(0x20)\n-\tif got := input.Flags(); got != want {\n-\t\tt.Errorf(\"%#v.Flags() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.Equal(t, uint16(0x20), input.Flags())\n }\n \n func TestBinlogEventTimestamp(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := uint32(0x53e95252)\n-\tif got := input.Timestamp(); got != want {\n-\t\tt.Errorf(\"%#v.Timestamp() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.EqualValues(t, uint32(0x53e95252), input.Timestamp())\n }\n \n func TestBinlogEventServerID(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := uint32(62344)\n-\tif got := input.ServerID(); got != want {\n-\t\tt.Errorf(\"%#v.ServerID() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.EqualValues(t, uint32(62344), input.ServerID())\n }\n \n func TestBinlogEventIsFormatDescription(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := true\n-\tif got := input.IsFormatDescription(); got != want {\n-\t\tt.Errorf(\"%#v.IsFormatDescription() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsFormatDescription(), \"%#v.IsFormatDescription()\", input)\n }\n \n func TestBinlogEventIsNotFormatDescription(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := false\n-\tif got := input.IsFormatDescription(); got != want {\n-\t\tt.Errorf(\"%#v.IsFormatDescription() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsFormatDescription(), \"%#v.IsFormatDescription()\", input)\n }\n \n func TestBinlogEventIsQuery(t *testing.T) {\n \tinput := binlogEvent(googleQueryEvent)\n-\twant := true\n-\tif got := input.IsQuery(); got != want {\n-\t\tt.Errorf(\"%#v.IsQuery() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsQuery(), \"%#v.IsQuery()\", input)\n }\n \n func TestBinlogEventIsNotQuery(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := false\n-\tif got := input.IsQuery(); got != want {\n-\t\tt.Errorf(\"%#v.IsQuery() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsQuery(), \"%#v.IsQuery()\", input)\n }\n \n func TestBinlogEventIsIntVar(t *testing.T) {\n \tinput := binlogEvent(googleIntVarEvent1)\n-\twant := true\n-\tif got := input.IsIntVar(); got != want {\n-\t\tt.Errorf(\"%#v.IsIntVar() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsIntVar(), \"%#v.IsIntVar()\", input)\n }\n \n func TestBinlogEventIsNotIntVar(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := false\n-\tif got := input.IsIntVar(); got != want {\n-\t\tt.Errorf(\"%#v.IsIntVar() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsIntVar(), \"%#v.IsIntVar()\", input)\n }\n \n func TestBinlogEventIsRotate(t *testing.T) {\n \tinput := binlogEvent(googleRotateEvent)\n-\twant := true\n-\tif got := input.IsRotate(); got != want {\n-\t\tt.Errorf(\"%#v.IsRotate() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.True(t, input.IsRotate(), \"%#v.IsRotate()\", input)\n }\n \n func TestBinlogEventIsNotRotate(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\twant := false\n-\tif got := input.IsRotate(); got != want {\n-\t\tt.Errorf(\"%#v.IsRotate() = %v, want %v\", input, got, want)\n-\t}\n+\tassert.False(t, input.IsRotate(), \"%#v.IsRotate()\", input)\n }\n \n func TestBinlogEventIsNotHeartbeat(t *testing.T) {\n \tinput := binlogEvent(googleFormatEvent)\n-\tassert.False(t, input.IsHeartbeat())\n+\tassert.False(t, input.IsHeartbeat(), \"%#v.IsHeartbeat()\", input)",
        "comment_created_at": "2025-02-11T08:49:17+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "if you're going to describe the actual value, then make the description correct. Printing `%#v.IsHeartbeat()` is misleading.\r\n```suggestion\r\n\tassert.False(t, input.IsHeartbeat(), \"%#v\", input)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950451522",
    "pr_number": 17720,
    "pr_file": "go/history/history_test.go",
    "created_at": "2025-02-11T08:53:00+00:00",
    "commented_code": "// Add first value.\n \th.Add(mod10(1))\n-\tif got, want := int(h.Records()[0].(mod10)), 1; got != want {\n-\t\tt.Errorf(\"h.Records()[0] = %v, want %v\", got, want)\n-\t}\n-\tif got, want := int(h.Latest().(mod10)), 1; got != want {\n-\t\tt.Errorf(\"h.Latest() = %v, want %v\", got, want)\n-\t}\n+\tassert.EqualValues(t, 1, int(h.Records()[0].(mod10)))",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1950451522",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/history/history_test.go",
        "discussion_id": "1950451522",
        "commented_code": "@@ -59,32 +53,20 @@ func TestLatest(t *testing.T) {\n \n \t// Add first value.\n \th.Add(mod10(1))\n-\tif got, want := int(h.Records()[0].(mod10)), 1; got != want {\n-\t\tt.Errorf(\"h.Records()[0] = %v, want %v\", got, want)\n-\t}\n-\tif got, want := int(h.Latest().(mod10)), 1; got != want {\n-\t\tt.Errorf(\"h.Latest() = %v, want %v\", got, want)\n-\t}\n+\tassert.EqualValues(t, 1, int(h.Records()[0].(mod10)))",
        "comment_created_at": "2025-02-11T08:53:00+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "The point of `EqualValues` is that you don't need casting for compatible values.\r\n```suggestion\r\n\tassert.EqualValues(t, 1, h.Records()[0].(mod10))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1969018956",
    "pr_number": 17720,
    "pr_file": "go/cache/lru_cache_test.go",
    "created_at": "2025-02-25T06:17:50+00:00",
    "commented_code": "cache.Set(key, data)\n \n \tv, ok := cache.Get(key)\n-\tif !ok || v != data {\n-\t\tt.Errorf(\"Cache has incorrect value: %v != %v\", data, v)\n-\t}\n+\tassert.True(t, ok)\n+\tassert.EqualValues(t, v, data)\n \n \tvalues := cache.Items()\n-\tif len(values) != 1 || values[0].Key != key {\n-\t\tt.Errorf(\"Cache.Values() returned incorrect values: %v\", values)\n-\t}\n+\trequire.NotEmpty(t, values)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1969018956",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17720,
        "pr_file": "go/cache/lru_cache_test.go",
        "discussion_id": "1969018956",
        "commented_code": "@@ -44,14 +45,12 @@ func TestSetInsertsValue(t *testing.T) {\n \tcache.Set(key, data)\n \n \tv, ok := cache.Get(key)\n-\tif !ok || v != data {\n-\t\tt.Errorf(\"Cache has incorrect value: %v != %v\", data, v)\n-\t}\n+\tassert.True(t, ok)\n+\tassert.EqualValues(t, v, data)\n \n \tvalues := cache.Items()\n-\tif len(values) != 1 || values[0].Key != key {\n-\t\tt.Errorf(\"Cache.Values() returned incorrect values: %v\", values)\n-\t}\n+\trequire.NotEmpty(t, values)",
        "comment_created_at": "2025-02-25T06:17:50+00:00",
        "comment_author": "shlomi-noach",
        "comment_body": "This should be `assert` and not `required`. And it should test for exactly one element.\r\n```suggestion\r\n\trequire.Len(t, values, 1)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1912258944",
    "pr_number": 17274,
    "pr_file": "go/vt/tableacl/tableacl_test.go",
    "created_at": "2025-01-11T22:12:11+00:00",
    "commented_code": "}\n }\n \n+func TestInitWithEmptyConfig(t *testing.T) {\n+\ttacl := tableACL{factory: &simpleacl.Factory{}}\n+\tf, err := os.CreateTemp(\"\", \"tableacl\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.Remove(f.Name())\n+\tif err := f.Close(); err != nil {\n+\t\tt.Fatal(err)",
    "repo_full_name": "vitessio/vitess",
    "discussion_comments": [
      {
        "comment_id": "1912258944",
        "repo_full_name": "vitessio/vitess",
        "pr_number": 17274,
        "pr_file": "go/vt/tableacl/tableacl_test.go",
        "discussion_id": "1912258944",
        "commented_code": "@@ -74,6 +74,21 @@ func TestInitWithValidConfig(t *testing.T) {\n \t}\n }\n \n+func TestInitWithEmptyConfig(t *testing.T) {\n+\ttacl := tableACL{factory: &simpleacl.Factory{}}\n+\tf, err := os.CreateTemp(\"\", \"tableacl\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.Remove(f.Name())\n+\tif err := f.Close(); err != nil {\n+\t\tt.Fatal(err)",
        "comment_created_at": "2025-01-11T22:12:11+00:00",
        "comment_author": "mattlord",
        "comment_body": "We should use require/assert in new tests. So e.g. here it would be:\r\n```\r\nerr := f.Close()\r\nrequire.NoError(t, err)\r\n```\r\n\r\nOr even just: `require.NoError(t, f.Close())`",
        "pr_file_module": null
      }
    ]
  }
]