[
  {
    "discussion_id": "1997859514",
    "pr_number": 4068,
    "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
    "created_at": "2025-03-17T02:51:28+00:00",
    "commented_code": "}\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {\n+\t\terr := field.Invalid(fldPath, memberType, \"hyperNode member type must be one of HyperNode or Node\")\n \t\terrs = append(errs, err)\n \t\treturn errs\n \t}\n-\tif selector.RegexMatch != nil && selector.ExactMatch != nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector cannot have both regexMatch and exactMatch\")\n-\t\terrs = append(errs, err)\n-\t\treturn errs\n+\tif memberType == hypernodev1alpha1.MemberTypeHyperNode {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1997859514",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4068,
        "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
        "discussion_id": "1997859514",
        "commented_code": "@@ -84,21 +84,48 @@ func AdmitHyperNode(ar admissionv1.AdmissionReview) *admissionv1.AdmissionRespon\n }\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {\n+\t\terr := field.Invalid(fldPath, memberType, \"hyperNode member type must be one of HyperNode or Node\")\n \t\terrs = append(errs, err)\n \t\treturn errs\n \t}\n-\tif selector.RegexMatch != nil && selector.ExactMatch != nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector cannot have both regexMatch and exactMatch\")\n-\t\terrs = append(errs, err)\n-\t\treturn errs\n+\tif memberType == hypernodev1alpha1.MemberTypeHyperNode {",
        "comment_created_at": "2025-03-17T02:51:28+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "The validation using kubebuilder is not consistent with here. MemberType is also verified here. I think we should keep consistent? @Monokaix ",
        "pr_file_module": null
      },
      {
        "comment_id": "2020324370",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4068,
        "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
        "discussion_id": "1997859514",
        "commented_code": "@@ -84,21 +84,48 @@ func AdmitHyperNode(ar admissionv1.AdmissionReview) *admissionv1.AdmissionRespon\n }\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {\n+\t\terr := field.Invalid(fldPath, memberType, \"hyperNode member type must be one of HyperNode or Node\")\n \t\terrs = append(errs, err)\n \t\treturn errs\n \t}\n-\tif selector.RegexMatch != nil && selector.ExactMatch != nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector cannot have both regexMatch and exactMatch\")\n-\t\terrs = append(errs, err)\n-\t\treturn errs\n+\tif memberType == hypernodev1alpha1.MemberTypeHyperNode {",
        "comment_created_at": "2025-03-31T01:41:23+00:00",
        "comment_author": "ecosysbin",
        "comment_body": "Ok, I have delete it. Just ignore it when the MemberType  is invalid.",
        "pr_file_module": null
      },
      {
        "comment_id": "2030648315",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4068,
        "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
        "discussion_id": "1997859514",
        "commented_code": "@@ -84,21 +84,48 @@ func AdmitHyperNode(ar admissionv1.AdmissionReview) *admissionv1.AdmissionRespon\n }\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {\n+\t\terr := field.Invalid(fldPath, memberType, \"hyperNode member type must be one of HyperNode or Node\")\n \t\terrs = append(errs, err)\n \t\treturn errs\n \t}\n-\tif selector.RegexMatch != nil && selector.ExactMatch != nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector cannot have both regexMatch and exactMatch\")\n-\t\terrs = append(errs, err)\n-\t\treturn errs\n+\tif memberType == hypernodev1alpha1.MemberTypeHyperNode {",
        "comment_created_at": "2025-04-07T07:48:10+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "I mean, do we need to distinguish `MemberTypeHyperNode` from `MemberTypeNode`? Currently, our kubebuilder rules do not distinguish between them. We should keep consistent",
        "pr_file_module": null
      },
      {
        "comment_id": "2030754601",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4068,
        "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
        "discussion_id": "1997859514",
        "commented_code": "@@ -84,21 +84,48 @@ func AdmitHyperNode(ar admissionv1.AdmissionReview) *admissionv1.AdmissionRespon\n }\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {\n+\t\terr := field.Invalid(fldPath, memberType, \"hyperNode member type must be one of HyperNode or Node\")\n \t\terrs = append(errs, err)\n \t\treturn errs\n \t}\n-\tif selector.RegexMatch != nil && selector.ExactMatch != nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector cannot have both regexMatch and exactMatch\")\n-\t\terrs = append(errs, err)\n-\t\treturn errs\n+\tif memberType == hypernodev1alpha1.MemberTypeHyperNode {",
        "comment_created_at": "2025-04-07T08:45:58+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "I looked at the cel validation in kubebuilder and it also supports referencing other fields. Perhaps if type validation is needed here, when memberType is HyperNode, it can only use ExactMatch. You should also update in apis repo to distinguish memberType is HyperNode and Node to keep consistent",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1897217392",
    "pr_number": 3922,
    "pr_file": "pkg/scheduler/cache/cache.go",
    "created_at": "2024-12-25T09:04:44+00:00",
    "commented_code": "nodes sets.Set[string]\n }\n \n+// MemberMatcher represents a matcher for a child node (exact for regex)\n+type MemberMatcher struct {\n+\tExact string // Exact string match\n+\tRegex string // Regex match\n+}\n+\n+// Matches checks if the node name matches the MemberMatcher\n+func (mm *MemberMatcher) Matches(name string) bool {\n+\tif mm.Exact != \"\" {\n+\t\tresult := mm.Exact == name\n+\t\tklog.V(4).Infof(\"Matching node %s with exact %s: %v\", name, mm.Exact, result)\n+\t\treturn result\n+\t}\n+\tif mm.Regex != \"\" {\n+\t\tr, err := regexp.Compile(mm.Regex)\n+\t\tif err != nil {\n+\t\t\tklog.Errorf(\"Failed to compile regex %s: %v\", mm.Regex, err)\n+\t\t\treturn false\n+\t\t}\n+\t\tresult := r.MatchString(name)\n+\t\tklog.V(4).Infof(\"Matching node %s with regex %s: %v\", name, mm.Regex, result)\n+\t\treturn result\n+\t}\n+\treturn false\n+}\n+\n+// NewExactMatcher creates a new MemberMatcher for exact matching\n+func NewExactMatcher(exact string) *MemberMatcher {\n+\treturn &MemberMatcher{Exact: exact}\n+}\n+\n+// NewRegexMatcher creates a new MemberMatcher for regex matching\n+func NewRegexMatcher(regex string) (*MemberMatcher, error) {\n+\t_, err := regexp.Compile(regex)\n+\tif err != nil {\n+\t\tklog.Errorf(\"Failed to compile regex %s: %v\", regex, err)\n+\t\treturn nil, err\n+\t}\n+\treturn &MemberMatcher{Regex: regex}, nil\n+}\n+\n+// HyperNodeTreeNode reprensent a single hypernode in the tree\n+type HyperNodeTreeNode struct {\n+\tName           string\n+\tTier           int\n+\tParent         *HyperNodeTreeNode\n+\tMembers        sets.Set[*HyperNodeTreeNode]\n+\tMemberMatchers sets.Set[*MemberMatcher]\n+\tNodes          sets.Set[*schedulingapi.NodeInfo]\n+\tNodeMatchers   sets.Set[*MemberMatcher]\n+\tHyperNodeRef   *networktopov1alpha1.HyperNode\n+}\n+\n+func NewHyperNodeTreeNode(name string) *HyperNodeTreeNode {\n+\treturn &HyperNodeTreeNode{\n+\t\tName:           name,\n+\t\tTier:           -1, // Initialize to an invalid value\n+\t\tMembers:        sets.New[*HyperNodeTreeNode](),\n+\t\tMemberMatchers: sets.New[*MemberMatcher](),\n+\t\tNodes:          sets.New[*schedulingapi.NodeInfo](),\n+\t\tNodeMatchers:   sets.New[*MemberMatcher](),\n+\t}\n+}\n+\n+type HyperNodeSet sets.Set[*HyperNodeTreeNode]\n+\n+// HyperNodeForestBuilder helps in building the forest of hypernodes\n+type HyperNodeForestBuilder struct {\n+\tnodes map[string]*HyperNodeTreeNode // Map to store nodes temporarily\n+\troots sets.Set[string]              // Set of root node names\n+}\n+\n+// NewHyperNodeForestBuilder initializes and returns a ForestBuilder\n+func NewHyperNodeForestBuilder() *HyperNodeForestBuilder {\n+\treturn &HyperNodeForestBuilder{\n+\t\tnodes: make(map[string]*HyperNodeTreeNode),\n+\t\troots: sets.New[string](),\n+\t}\n+}\n+\n+// insertHyperNodeMember inserts a member into a hypernode and updates the forest\n+func insertHyperNodeMember(hntn *HyperNodeTreeNode, hnfb *HyperNodeForestBuilder, memberName string, memberNode *HyperNodeTreeNode, sc *SchedulerCache) {\n+\thntn.Members.Insert(memberNode)\n+\tmemberNode.Parent = hntn\n+\tif hnfb.roots.Has(memberName) {\n+\t\thnfb.roots.Delete(memberName)\n+\t}\n+\tsc.HyperNodeListByTier[memberNode.Tier].Insert(memberName)\n+\n+\tsc.HyperNodes[hntn.Name].Union(sc.HyperNodes[memberName])\n+}\n+\n+// addHyperNode adds a HyperNodeTreeNode to the forest based on v1apha1.HyperNode\n+// Adding a hypernode can result in updating the entire forest, as it may add new\n+// nodes, or link existing nodes - which could demote nodes from roots to child.\n+// Because of regex matching, this can trigger ripple effects in the forest.\n+func (sc *SchedulerCache) addHyperNode(hn *networktopov1alpha1.HyperNode) {\n+\thnfb := sc.hypernodeForestbuilder\n+\thntn := NewHyperNodeTreeNode(hn.Name)\n+\thntn.HyperNodeRef = hn\n+\thnfb.nodes[hn.Name] = hntn\n+\n+\ttierStr := hn.Spec.Tier\n+\ttier, err := strconv.Atoi(tierStr)",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1897217392",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3922,
        "pr_file": "pkg/scheduler/cache/cache.go",
        "discussion_id": "1897217392",
        "commented_code": "@@ -176,6 +184,236 @@ type imageState struct {\n \tnodes sets.Set[string]\n }\n \n+// MemberMatcher represents a matcher for a child node (exact for regex)\n+type MemberMatcher struct {\n+\tExact string // Exact string match\n+\tRegex string // Regex match\n+}\n+\n+// Matches checks if the node name matches the MemberMatcher\n+func (mm *MemberMatcher) Matches(name string) bool {\n+\tif mm.Exact != \"\" {\n+\t\tresult := mm.Exact == name\n+\t\tklog.V(4).Infof(\"Matching node %s with exact %s: %v\", name, mm.Exact, result)\n+\t\treturn result\n+\t}\n+\tif mm.Regex != \"\" {\n+\t\tr, err := regexp.Compile(mm.Regex)\n+\t\tif err != nil {\n+\t\t\tklog.Errorf(\"Failed to compile regex %s: %v\", mm.Regex, err)\n+\t\t\treturn false\n+\t\t}\n+\t\tresult := r.MatchString(name)\n+\t\tklog.V(4).Infof(\"Matching node %s with regex %s: %v\", name, mm.Regex, result)\n+\t\treturn result\n+\t}\n+\treturn false\n+}\n+\n+// NewExactMatcher creates a new MemberMatcher for exact matching\n+func NewExactMatcher(exact string) *MemberMatcher {\n+\treturn &MemberMatcher{Exact: exact}\n+}\n+\n+// NewRegexMatcher creates a new MemberMatcher for regex matching\n+func NewRegexMatcher(regex string) (*MemberMatcher, error) {\n+\t_, err := regexp.Compile(regex)\n+\tif err != nil {\n+\t\tklog.Errorf(\"Failed to compile regex %s: %v\", regex, err)\n+\t\treturn nil, err\n+\t}\n+\treturn &MemberMatcher{Regex: regex}, nil\n+}\n+\n+// HyperNodeTreeNode reprensent a single hypernode in the tree\n+type HyperNodeTreeNode struct {\n+\tName           string\n+\tTier           int\n+\tParent         *HyperNodeTreeNode\n+\tMembers        sets.Set[*HyperNodeTreeNode]\n+\tMemberMatchers sets.Set[*MemberMatcher]\n+\tNodes          sets.Set[*schedulingapi.NodeInfo]\n+\tNodeMatchers   sets.Set[*MemberMatcher]\n+\tHyperNodeRef   *networktopov1alpha1.HyperNode\n+}\n+\n+func NewHyperNodeTreeNode(name string) *HyperNodeTreeNode {\n+\treturn &HyperNodeTreeNode{\n+\t\tName:           name,\n+\t\tTier:           -1, // Initialize to an invalid value\n+\t\tMembers:        sets.New[*HyperNodeTreeNode](),\n+\t\tMemberMatchers: sets.New[*MemberMatcher](),\n+\t\tNodes:          sets.New[*schedulingapi.NodeInfo](),\n+\t\tNodeMatchers:   sets.New[*MemberMatcher](),\n+\t}\n+}\n+\n+type HyperNodeSet sets.Set[*HyperNodeTreeNode]\n+\n+// HyperNodeForestBuilder helps in building the forest of hypernodes\n+type HyperNodeForestBuilder struct {\n+\tnodes map[string]*HyperNodeTreeNode // Map to store nodes temporarily\n+\troots sets.Set[string]              // Set of root node names\n+}\n+\n+// NewHyperNodeForestBuilder initializes and returns a ForestBuilder\n+func NewHyperNodeForestBuilder() *HyperNodeForestBuilder {\n+\treturn &HyperNodeForestBuilder{\n+\t\tnodes: make(map[string]*HyperNodeTreeNode),\n+\t\troots: sets.New[string](),\n+\t}\n+}\n+\n+// insertHyperNodeMember inserts a member into a hypernode and updates the forest\n+func insertHyperNodeMember(hntn *HyperNodeTreeNode, hnfb *HyperNodeForestBuilder, memberName string, memberNode *HyperNodeTreeNode, sc *SchedulerCache) {\n+\thntn.Members.Insert(memberNode)\n+\tmemberNode.Parent = hntn\n+\tif hnfb.roots.Has(memberName) {\n+\t\thnfb.roots.Delete(memberName)\n+\t}\n+\tsc.HyperNodeListByTier[memberNode.Tier].Insert(memberName)\n+\n+\tsc.HyperNodes[hntn.Name].Union(sc.HyperNodes[memberName])\n+}\n+\n+// addHyperNode adds a HyperNodeTreeNode to the forest based on v1apha1.HyperNode\n+// Adding a hypernode can result in updating the entire forest, as it may add new\n+// nodes, or link existing nodes - which could demote nodes from roots to child.\n+// Because of regex matching, this can trigger ripple effects in the forest.\n+func (sc *SchedulerCache) addHyperNode(hn *networktopov1alpha1.HyperNode) {\n+\thnfb := sc.hypernodeForestbuilder\n+\thntn := NewHyperNodeTreeNode(hn.Name)\n+\thntn.HyperNodeRef = hn\n+\thnfb.nodes[hn.Name] = hntn\n+\n+\ttierStr := hn.Spec.Tier\n+\ttier, err := strconv.Atoi(tierStr)",
        "comment_created_at": "2024-12-25T09:04:44+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "Currently, in api definition, the tier is a type of string, what if the user wants to specify tier name other than numbers? Is there any purpose in defining the type of tier as string before?",
        "pr_file_module": null
      },
      {
        "comment_id": "1897961835",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3922,
        "pr_file": "pkg/scheduler/cache/cache.go",
        "discussion_id": "1897217392",
        "commented_code": "@@ -176,6 +184,236 @@ type imageState struct {\n \tnodes sets.Set[string]\n }\n \n+// MemberMatcher represents a matcher for a child node (exact for regex)\n+type MemberMatcher struct {\n+\tExact string // Exact string match\n+\tRegex string // Regex match\n+}\n+\n+// Matches checks if the node name matches the MemberMatcher\n+func (mm *MemberMatcher) Matches(name string) bool {\n+\tif mm.Exact != \"\" {\n+\t\tresult := mm.Exact == name\n+\t\tklog.V(4).Infof(\"Matching node %s with exact %s: %v\", name, mm.Exact, result)\n+\t\treturn result\n+\t}\n+\tif mm.Regex != \"\" {\n+\t\tr, err := regexp.Compile(mm.Regex)\n+\t\tif err != nil {\n+\t\t\tklog.Errorf(\"Failed to compile regex %s: %v\", mm.Regex, err)\n+\t\t\treturn false\n+\t\t}\n+\t\tresult := r.MatchString(name)\n+\t\tklog.V(4).Infof(\"Matching node %s with regex %s: %v\", name, mm.Regex, result)\n+\t\treturn result\n+\t}\n+\treturn false\n+}\n+\n+// NewExactMatcher creates a new MemberMatcher for exact matching\n+func NewExactMatcher(exact string) *MemberMatcher {\n+\treturn &MemberMatcher{Exact: exact}\n+}\n+\n+// NewRegexMatcher creates a new MemberMatcher for regex matching\n+func NewRegexMatcher(regex string) (*MemberMatcher, error) {\n+\t_, err := regexp.Compile(regex)\n+\tif err != nil {\n+\t\tklog.Errorf(\"Failed to compile regex %s: %v\", regex, err)\n+\t\treturn nil, err\n+\t}\n+\treturn &MemberMatcher{Regex: regex}, nil\n+}\n+\n+// HyperNodeTreeNode reprensent a single hypernode in the tree\n+type HyperNodeTreeNode struct {\n+\tName           string\n+\tTier           int\n+\tParent         *HyperNodeTreeNode\n+\tMembers        sets.Set[*HyperNodeTreeNode]\n+\tMemberMatchers sets.Set[*MemberMatcher]\n+\tNodes          sets.Set[*schedulingapi.NodeInfo]\n+\tNodeMatchers   sets.Set[*MemberMatcher]\n+\tHyperNodeRef   *networktopov1alpha1.HyperNode\n+}\n+\n+func NewHyperNodeTreeNode(name string) *HyperNodeTreeNode {\n+\treturn &HyperNodeTreeNode{\n+\t\tName:           name,\n+\t\tTier:           -1, // Initialize to an invalid value\n+\t\tMembers:        sets.New[*HyperNodeTreeNode](),\n+\t\tMemberMatchers: sets.New[*MemberMatcher](),\n+\t\tNodes:          sets.New[*schedulingapi.NodeInfo](),\n+\t\tNodeMatchers:   sets.New[*MemberMatcher](),\n+\t}\n+}\n+\n+type HyperNodeSet sets.Set[*HyperNodeTreeNode]\n+\n+// HyperNodeForestBuilder helps in building the forest of hypernodes\n+type HyperNodeForestBuilder struct {\n+\tnodes map[string]*HyperNodeTreeNode // Map to store nodes temporarily\n+\troots sets.Set[string]              // Set of root node names\n+}\n+\n+// NewHyperNodeForestBuilder initializes and returns a ForestBuilder\n+func NewHyperNodeForestBuilder() *HyperNodeForestBuilder {\n+\treturn &HyperNodeForestBuilder{\n+\t\tnodes: make(map[string]*HyperNodeTreeNode),\n+\t\troots: sets.New[string](),\n+\t}\n+}\n+\n+// insertHyperNodeMember inserts a member into a hypernode and updates the forest\n+func insertHyperNodeMember(hntn *HyperNodeTreeNode, hnfb *HyperNodeForestBuilder, memberName string, memberNode *HyperNodeTreeNode, sc *SchedulerCache) {\n+\thntn.Members.Insert(memberNode)\n+\tmemberNode.Parent = hntn\n+\tif hnfb.roots.Has(memberName) {\n+\t\thnfb.roots.Delete(memberName)\n+\t}\n+\tsc.HyperNodeListByTier[memberNode.Tier].Insert(memberName)\n+\n+\tsc.HyperNodes[hntn.Name].Union(sc.HyperNodes[memberName])\n+}\n+\n+// addHyperNode adds a HyperNodeTreeNode to the forest based on v1apha1.HyperNode\n+// Adding a hypernode can result in updating the entire forest, as it may add new\n+// nodes, or link existing nodes - which could demote nodes from roots to child.\n+// Because of regex matching, this can trigger ripple effects in the forest.\n+func (sc *SchedulerCache) addHyperNode(hn *networktopov1alpha1.HyperNode) {\n+\thnfb := sc.hypernodeForestbuilder\n+\thntn := NewHyperNodeTreeNode(hn.Name)\n+\thntn.HyperNodeRef = hn\n+\thnfb.nodes[hn.Name] = hntn\n+\n+\ttierStr := hn.Spec.Tier\n+\ttier, err := strconv.Atoi(tierStr)",
        "comment_created_at": "2024-12-26T14:45:15+00:00",
        "comment_author": "penggu",
        "comment_body": "I think Tier should be an int. If a \"tier name\" is needed, then a mapping from a \"tier name\" string to its \"tier number\" int is needed.",
        "pr_file_module": null
      }
    ]
  }
]