[
  {
    "discussion_id": "2275601675",
    "pr_number": 4512,
    "pr_file": "pkg/scheduler/plugins/resource-strategy-fit/resource_strategy_fit.go",
    "created_at": "2025-08-14T06:23:09+00:00",
    "commented_code": "}\n \n \tfor k, v := range resources {\n+\t\tconfigKeyStr := string(k)\n+\n+\t\tif strings.Contains(configKeyStr, \"*\") {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "2275601675",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4512,
        "pr_file": "pkg/scheduler/plugins/resource-strategy-fit/resource_strategy_fit.go",
        "discussion_id": "2275601675",
        "commented_code": "@@ -104,6 +105,19 @@ func calculateWeight(args framework.Arguments) ResourceStrategyFit {\n \t}\n \n \tfor k, v := range resources {\n+\t\tconfigKeyStr := string(k)\n+\n+\t\tif strings.Contains(configKeyStr, \"*\") {",
        "comment_created_at": "2025-08-14T06:23:09+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "Why do we need to add a `strings.Contains` check in the outer layer? Shouldn't this be put in `isValidWildcardPattern`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283864523",
    "pr_number": 4454,
    "pr_file": "pkg/scheduler/plugins/util/util.go",
    "created_at": "2025-08-19T01:51:35+00:00",
    "commented_code": "}\n \treturn inqueue\n }\n+\n+// ShouldAbort determines if the given status indicates that execution should be aborted.\n+// It checks if the status code corresponds to any of the following conditions:\n+// - UnschedulableAndUnresolvable: Indicates the task cannot be scheduled and resolved.\n+// - Error: Represents an error state that prevents further execution.\n+// - Wait: Suggests that the process should pause and not proceed further.\n+// - Skip: Indicates that the operation should be skipped entirely.\n+//\n+// Parameters:\n+// - status (*api.Status): The status object to evaluate.\n+//\n+// Returns:\n+// - bool: True if the status code matches any of the abort conditions; false otherwise.\n+func ShouldAbort(status *api.Status) bool {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "2283864523",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4454,
        "pr_file": "pkg/scheduler/plugins/util/util.go",
        "discussion_id": "2283864523",
        "commented_code": "@@ -137,3 +137,22 @@ func GetInqueueResource(job *api.JobInfo, allocated *api.Resource) *api.Resource\n \t}\n \treturn inqueue\n }\n+\n+// ShouldAbort determines if the given status indicates that execution should be aborted.\n+// It checks if the status code corresponds to any of the following conditions:\n+// - UnschedulableAndUnresolvable: Indicates the task cannot be scheduled and resolved.\n+// - Error: Represents an error state that prevents further execution.\n+// - Wait: Suggests that the process should pause and not proceed further.\n+// - Skip: Indicates that the operation should be skipped entirely.\n+//\n+// Parameters:\n+// - status (*api.Status): The status object to evaluate.\n+//\n+// Returns:\n+// - bool: True if the status code matches any of the abort conditions; false otherwise.\n+func ShouldAbort(status *api.Status) bool {",
        "comment_created_at": "2025-08-19T01:51:35+00:00",
        "comment_author": "Monokaix",
        "comment_body": "There is already a same func in pkg/scheduler/plugins/predicates/predicates.go.",
        "pr_file_module": null
      },
      {
        "comment_id": "2285081606",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4454,
        "pr_file": "pkg/scheduler/plugins/util/util.go",
        "discussion_id": "2283864523",
        "commented_code": "@@ -137,3 +137,22 @@ func GetInqueueResource(job *api.JobInfo, allocated *api.Resource) *api.Resource\n \t}\n \treturn inqueue\n }\n+\n+// ShouldAbort determines if the given status indicates that execution should be aborted.\n+// It checks if the status code corresponds to any of the following conditions:\n+// - UnschedulableAndUnresolvable: Indicates the task cannot be scheduled and resolved.\n+// - Error: Represents an error state that prevents further execution.\n+// - Wait: Suggests that the process should pause and not proceed further.\n+// - Skip: Indicates that the operation should be skipped entirely.\n+//\n+// Parameters:\n+// - status (*api.Status): The status object to evaluate.\n+//\n+// Returns:\n+// - bool: True if the status code matches any of the abort conditions; false otherwise.\n+func ShouldAbort(status *api.Status) bool {",
        "comment_created_at": "2025-08-19T12:20:19+00:00",
        "comment_author": "XbaoWu",
        "comment_body": "Well, I will modify it",
        "pr_file_module": null
      },
      {
        "comment_id": "2288868655",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4454,
        "pr_file": "pkg/scheduler/plugins/util/util.go",
        "discussion_id": "2283864523",
        "commented_code": "@@ -137,3 +137,22 @@ func GetInqueueResource(job *api.JobInfo, allocated *api.Resource) *api.Resource\n \t}\n \treturn inqueue\n }\n+\n+// ShouldAbort determines if the given status indicates that execution should be aborted.\n+// It checks if the status code corresponds to any of the following conditions:\n+// - UnschedulableAndUnresolvable: Indicates the task cannot be scheduled and resolved.\n+// - Error: Represents an error state that prevents further execution.\n+// - Wait: Suggests that the process should pause and not proceed further.\n+// - Skip: Indicates that the operation should be skipped entirely.\n+//\n+// Parameters:\n+// - status (*api.Status): The status object to evaluate.\n+//\n+// Returns:\n+// - bool: True if the status code matches any of the abort conditions; false otherwise.\n+func ShouldAbort(status *api.Status) bool {",
        "comment_created_at": "2025-08-20T17:40:04+00:00",
        "comment_author": "XbaoWu",
        "comment_body": "The `ShouldAbort` func has been moved to `pkg/scheduler/plugins/util/util.go`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2144205443",
    "pr_number": 4373,
    "pr_file": "pkg/scheduler/framework/session.go",
    "created_at": "2025-06-13T04:58:52+00:00",
    "commented_code": "return ssn\n }\n \n+func nodeIsNotReady(obj *v1.Node) bool {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "2144205443",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4373,
        "pr_file": "pkg/scheduler/framework/session.go",
        "discussion_id": "2144205443",
        "commented_code": "@@ -222,6 +229,38 @@ func openSession(cache cache.Cache) *Session {\n \treturn ssn\n }\n \n+func nodeIsNotReady(obj *v1.Node) bool {",
        "comment_created_at": "2025-06-13T04:58:52+00:00",
        "comment_author": "googs1025",
        "comment_body": "can we move to `util.go` ? \ud83d\ude04 \r\nThis method does not seem to be directly related to session.",
        "pr_file_module": null
      },
      {
        "comment_id": "2144266107",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4373,
        "pr_file": "pkg/scheduler/framework/session.go",
        "discussion_id": "2144205443",
        "commented_code": "@@ -222,6 +229,38 @@ func openSession(cache cache.Cache) *Session {\n \treturn ssn\n }\n \n+func nodeIsNotReady(obj *v1.Node) bool {",
        "comment_created_at": "2025-06-13T06:01:06+00:00",
        "comment_author": "LY-today",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086748259",
    "pr_number": 4279,
    "pr_file": "pkg/scheduler/actions/preempt/preempt.go",
    "created_at": "2025-05-13T12:51:40+00:00",
    "commented_code": "return nil\n }\n+\n+func (pmpt *Action) topologyAwarePreempt(\n+\tssn *framework.Session,\n+\tstmt *framework.Statement,\n+\tpreemptor *api.TaskInfo,\n+\tfilter func(*api.TaskInfo) bool,\n+\tpredicateHelper util.PredicateHelper,\n+) (bool, error) {\n+\tif err := ssn.PrePredicateFn(preemptor); err != nil {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "2086748259",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4279,
        "pr_file": "pkg/scheduler/actions/preempt/preempt.go",
        "discussion_id": "2086748259",
        "commented_code": "@@ -342,3 +386,612 @@ func (pmpt *Action) taskEligibleToPreempt(preemptor *api.TaskInfo) error {\n \n \treturn nil\n }\n+\n+func (pmpt *Action) topologyAwarePreempt(\n+\tssn *framework.Session,\n+\tstmt *framework.Statement,\n+\tpreemptor *api.TaskInfo,\n+\tfilter func(*api.TaskInfo) bool,\n+\tpredicateHelper util.PredicateHelper,\n+) (bool, error) {\n+\tif err := ssn.PrePredicateFn(preemptor); err != nil {",
        "comment_created_at": "2025-05-13T12:51:40+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "L397-L410 is the same as in `normalPreempt` L277-L285(Swapping the order of PrePredicate and taskEligibleToPreempt should not affect\uff1f), I think we can extract a public func",
        "pr_file_module": null
      },
      {
        "comment_id": "2108569720",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4279,
        "pr_file": "pkg/scheduler/actions/preempt/preempt.go",
        "discussion_id": "2086748259",
        "commented_code": "@@ -342,3 +386,612 @@ func (pmpt *Action) taskEligibleToPreempt(preemptor *api.TaskInfo) error {\n \n \treturn nil\n }\n+\n+func (pmpt *Action) topologyAwarePreempt(\n+\tssn *framework.Session,\n+\tstmt *framework.Statement,\n+\tpreemptor *api.TaskInfo,\n+\tfilter func(*api.TaskInfo) bool,\n+\tpredicateHelper util.PredicateHelper,\n+) (bool, error) {\n+\tif err := ssn.PrePredicateFn(preemptor); err != nil {",
        "comment_created_at": "2025-05-27T08:27:39+00:00",
        "comment_author": "bibibox",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1997858387",
    "pr_number": 4068,
    "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
    "created_at": "2025-03-17T02:49:15+00:00",
    "commented_code": "}\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1997858387",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4068,
        "pr_file": "pkg/webhooks/admission/hypernodes/validate/admit_hypernode.go",
        "discussion_id": "1997858387",
        "commented_code": "@@ -84,21 +84,48 @@ func AdmitHyperNode(ar admissionv1.AdmissionReview) *admissionv1.AdmissionRespon\n }\n \n // validateHyperNodeMemberSelector is to validate hypernode member selector.\n-func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path) field.ErrorList {\n+func validateHyperNodeMemberSelector(selector hypernodev1alpha1.MemberSelector, fldPath *field.Path, memberType hypernodev1alpha1.MemberType) field.ErrorList {\n \terrs := field.ErrorList{}\n \n-\tif selector.RegexMatch == nil && selector.ExactMatch == nil {\n-\t\terr := field.Invalid(fldPath, selector,\n-\t\t\t\"member selector must have one of regexMatch or exactMatch\")\n+\tif memberType != hypernodev1alpha1.MemberTypeHyperNode && memberType != hypernodev1alpha1.MemberTypeNode {",
        "comment_created_at": "2025-03-17T02:49:15+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "It is best to extract a function that validate memberType separately, otherwise the responsibility of the func validateHyperNodeMemberSelector does not match",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1898291647",
    "pr_number": 3894,
    "pr_file": "pkg/scheduler/util/scheduler_helper.go",
    "created_at": "2024-12-27T06:18:58+00:00",
    "commented_code": "}\n \treturn rl\n }\n+\n+// Find the hyperNode to which the node belongs.\n+func FindHyperNodeOfNode(nodeName string, hyperNodeTree []map[string][]string) string {\n+\tfor hyperNode, nodes := range hyperNodeTree[len(hyperNodeTree)-1] {\n+\t\tfor _, node := range nodes {\n+\t\t\tif node == nodeName {\n+\t\t\t\treturn hyperNode\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func FindJobTaskNumOfHyperNode(hyperNodeName string, job *api.JobInfo, hyperNodeTree []map[string][]string) int {\n+\trevertHyperNodeTree := make([]map[string][]string, len(hyperNodeTree))\n+\tfor i := len(hyperNodeTree) - 1; i >= 0; i-- {\n+\t\trevertHyperNodeTree[len(hyperNodeTree)-1-i] = hyperNodeTree[i]\n+\t}\n+\n+\thyperNodesMap := make(map[string]sets.Set[string])\n+\tfor i := 0; i < len(revertHyperNodeTree); i++ {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1898291647",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3894,
        "pr_file": "pkg/scheduler/util/scheduler_helper.go",
        "discussion_id": "1898291647",
        "commented_code": "@@ -295,3 +290,88 @@ func ConvertRes2ResList(res *api.Resource) v1.ResourceList {\n \t}\n \treturn rl\n }\n+\n+// Find the hyperNode to which the node belongs.\n+func FindHyperNodeOfNode(nodeName string, hyperNodeTree []map[string][]string) string {\n+\tfor hyperNode, nodes := range hyperNodeTree[len(hyperNodeTree)-1] {\n+\t\tfor _, node := range nodes {\n+\t\t\tif node == nodeName {\n+\t\t\t\treturn hyperNode\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func FindJobTaskNumOfHyperNode(hyperNodeName string, job *api.JobInfo, hyperNodeTree []map[string][]string) int {\n+\trevertHyperNodeTree := make([]map[string][]string, len(hyperNodeTree))\n+\tfor i := len(hyperNodeTree) - 1; i >= 0; i-- {\n+\t\trevertHyperNodeTree[len(hyperNodeTree)-1-i] = hyperNodeTree[i]\n+\t}\n+\n+\thyperNodesMap := make(map[string]sets.Set[string])\n+\tfor i := 0; i < len(revertHyperNodeTree); i++ {",
        "comment_created_at": "2024-12-27T06:18:58+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "extract a public function, has the same code in FindLCAHyperNode",
        "pr_file_module": null
      },
      {
        "comment_id": "1898790654",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3894,
        "pr_file": "pkg/scheduler/util/scheduler_helper.go",
        "discussion_id": "1898291647",
        "commented_code": "@@ -295,3 +290,88 @@ func ConvertRes2ResList(res *api.Resource) v1.ResourceList {\n \t}\n \treturn rl\n }\n+\n+// Find the hyperNode to which the node belongs.\n+func FindHyperNodeOfNode(nodeName string, hyperNodeTree []map[string][]string) string {\n+\tfor hyperNode, nodes := range hyperNodeTree[len(hyperNodeTree)-1] {\n+\t\tfor _, node := range nodes {\n+\t\t\tif node == nodeName {\n+\t\t\t\treturn hyperNode\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func FindJobTaskNumOfHyperNode(hyperNodeName string, job *api.JobInfo, hyperNodeTree []map[string][]string) int {\n+\trevertHyperNodeTree := make([]map[string][]string, len(hyperNodeTree))\n+\tfor i := len(hyperNodeTree) - 1; i >= 0; i-- {\n+\t\trevertHyperNodeTree[len(hyperNodeTree)-1-i] = hyperNodeTree[i]\n+\t}\n+\n+\thyperNodesMap := make(map[string]sets.Set[string])\n+\tfor i := 0; i < len(revertHyperNodeTree); i++ {",
        "comment_created_at": "2024-12-28T04:17:03+00:00",
        "comment_author": "ecosysbin",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1399036772",
    "pr_number": 3182,
    "pr_file": "pkg/controllers/podgroup/pg_controller_handler.go",
    "created_at": "2023-11-20T11:08:13+00:00",
    "commented_code": "pg.addReplicaSet(newObj)\n }\n \n+func (pg *pgcontroller) addStatefulSet(obj interface{}) {\n+\tsts, ok := obj.(*appsv1.StatefulSet)\n+\tif !ok {\n+\t\tklog.Errorf(\"Failed to convert %v to appsv1.StatefulSet\", obj)\n+\t\treturn\n+\t}\n+\n+\tif *sts.Spec.Replicas == 0 {\n+\t\tpgName := batchv1alpha1.PodgroupNamePrefix + string(sts.UID)\n+\t\terr := pg.vcClient.SchedulingV1beta1().PodGroups(sts.Namespace).Delete(context.TODO(), pgName, metav1.DeleteOptions{})\n+\t\tif err != nil && !apierrors.IsNotFound(err) {\n+\t\t\tklog.Errorf(\"Failed to delete PodGroup <%s/%s>: %v\", sts.Namespace, pgName, err)\n+\t\t}\n+\t}\n+}\n+\n+func (pg *pgcontroller) updateStatefulSet(oldObj, newObj interface{}) {\n+\tpg.addStatefulSet(newObj)\n+}\n+\n+func (pg *pgcontroller) addJob(obj interface{}) {\n+\tjob, ok := obj.(*batchv1.Job)\n+\tif !ok {\n+\t\tklog.Errorf(\"Failed to convert %v to batchv1.Job\", obj)\n+\t\treturn\n+\t}\n+\t// Delete PodGroup if the job is Complete or Failed or Suspended.\n+\tfor _, condition := range job.Status.Conditions {\n+\t\tif condition.Status == v1.ConditionTrue && (condition.Type == batchv1.JobComplete || condition.Type == batchv1.JobFailed || condition.Type == batchv1.JobSuspended) {",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1399036772",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3182,
        "pr_file": "pkg/controllers/podgroup/pg_controller_handler.go",
        "discussion_id": "1399036772",
        "commented_code": "@@ -83,6 +111,49 @@ func (pg *pgcontroller) updateReplicaSet(oldObj, newObj interface{}) {\n \tpg.addReplicaSet(newObj)\n }\n \n+func (pg *pgcontroller) addStatefulSet(obj interface{}) {\n+\tsts, ok := obj.(*appsv1.StatefulSet)\n+\tif !ok {\n+\t\tklog.Errorf(\"Failed to convert %v to appsv1.StatefulSet\", obj)\n+\t\treturn\n+\t}\n+\n+\tif *sts.Spec.Replicas == 0 {\n+\t\tpgName := batchv1alpha1.PodgroupNamePrefix + string(sts.UID)\n+\t\terr := pg.vcClient.SchedulingV1beta1().PodGroups(sts.Namespace).Delete(context.TODO(), pgName, metav1.DeleteOptions{})\n+\t\tif err != nil && !apierrors.IsNotFound(err) {\n+\t\t\tklog.Errorf(\"Failed to delete PodGroup <%s/%s>: %v\", sts.Namespace, pgName, err)\n+\t\t}\n+\t}\n+}\n+\n+func (pg *pgcontroller) updateStatefulSet(oldObj, newObj interface{}) {\n+\tpg.addStatefulSet(newObj)\n+}\n+\n+func (pg *pgcontroller) addJob(obj interface{}) {\n+\tjob, ok := obj.(*batchv1.Job)\n+\tif !ok {\n+\t\tklog.Errorf(\"Failed to convert %v to batchv1.Job\", obj)\n+\t\treturn\n+\t}\n+\t// Delete PodGroup if the job is Complete or Failed or Suspended.\n+\tfor _, condition := range job.Status.Conditions {\n+\t\tif condition.Status == v1.ConditionTrue && (condition.Type == batchv1.JobComplete || condition.Type == batchv1.JobFailed || condition.Type == batchv1.JobSuspended) {",
        "comment_created_at": "2023-11-20T11:08:13+00:00",
        "comment_author": "Monokaix",
        "comment_body": "Better abstract a function here like jobTerminated to increase code readability, and so does pod.",
        "pr_file_module": null
      },
      {
        "comment_id": "1399071320",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3182,
        "pr_file": "pkg/controllers/podgroup/pg_controller_handler.go",
        "discussion_id": "1399036772",
        "commented_code": "@@ -83,6 +111,49 @@ func (pg *pgcontroller) updateReplicaSet(oldObj, newObj interface{}) {\n \tpg.addReplicaSet(newObj)\n }\n \n+func (pg *pgcontroller) addStatefulSet(obj interface{}) {\n+\tsts, ok := obj.(*appsv1.StatefulSet)\n+\tif !ok {\n+\t\tklog.Errorf(\"Failed to convert %v to appsv1.StatefulSet\", obj)\n+\t\treturn\n+\t}\n+\n+\tif *sts.Spec.Replicas == 0 {\n+\t\tpgName := batchv1alpha1.PodgroupNamePrefix + string(sts.UID)\n+\t\terr := pg.vcClient.SchedulingV1beta1().PodGroups(sts.Namespace).Delete(context.TODO(), pgName, metav1.DeleteOptions{})\n+\t\tif err != nil && !apierrors.IsNotFound(err) {\n+\t\t\tklog.Errorf(\"Failed to delete PodGroup <%s/%s>: %v\", sts.Namespace, pgName, err)\n+\t\t}\n+\t}\n+}\n+\n+func (pg *pgcontroller) updateStatefulSet(oldObj, newObj interface{}) {\n+\tpg.addStatefulSet(newObj)\n+}\n+\n+func (pg *pgcontroller) addJob(obj interface{}) {\n+\tjob, ok := obj.(*batchv1.Job)\n+\tif !ok {\n+\t\tklog.Errorf(\"Failed to convert %v to batchv1.Job\", obj)\n+\t\treturn\n+\t}\n+\t// Delete PodGroup if the job is Complete or Failed or Suspended.\n+\tfor _, condition := range job.Status.Conditions {\n+\t\tif condition.Status == v1.ConditionTrue && (condition.Type == batchv1.JobComplete || condition.Type == batchv1.JobFailed || condition.Type == batchv1.JobSuspended) {",
        "comment_created_at": "2023-11-20T11:38:25+00:00",
        "comment_author": "HDJZX",
        "comment_body": "Ok, the code has been submitted",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967006316",
    "pr_number": 4033,
    "pr_file": "pkg/webhooks/admission/queues/validate/validate_queue.go",
    "created_at": "2025-02-24T03:26:51+00:00",
    "commented_code": "if queue.Spec.Parent == \"\" || queue.Spec.Parent == \"root\" {\n \t\treturn nil\n \t}\n+\n \tparentQueue, err := config.QueueLister.Get(queue.Spec.Parent)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to get parent queue of queue %s: %v\", queue.Name, err)\n \t}\n \n-\tif allocated, ok := parentQueue.Status.Allocated[v1.ResourcePods]; ok && !allocated.IsZero() {\n-\t\treturn fmt.Errorf(\"queue %s cannot be the parent queue of queue %s because it has allocated Pods: %d\",\n-\t\t\tparentQueue.Name, queue.Name, allocated.Value())\n+\tqueueList, err := config.QueueLister.List(labels.Everything())",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1967006316",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4033,
        "pr_file": "pkg/webhooks/admission/queues/validate/validate_queue.go",
        "discussion_id": "1967006316",
        "commented_code": "@@ -251,14 +251,29 @@ func validateHierarchicalQueue(queue *schedulingv1beta1.Queue) error {\n \tif queue.Spec.Parent == \"\" || queue.Spec.Parent == \"root\" {\n \t\treturn nil\n \t}\n+\n \tparentQueue, err := config.QueueLister.Get(queue.Spec.Parent)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to get parent queue of queue %s: %v\", queue.Name, err)\n \t}\n \n-\tif allocated, ok := parentQueue.Status.Allocated[v1.ResourcePods]; ok && !allocated.IsZero() {\n-\t\treturn fmt.Errorf(\"queue %s cannot be the parent queue of queue %s because it has allocated Pods: %d\",\n-\t\t\tparentQueue.Name, queue.Name, allocated.Value())\n+\tqueueList, err := config.QueueLister.List(labels.Everything())",
        "comment_created_at": "2025-02-24T03:26:51+00:00",
        "comment_author": "Monokaix",
        "comment_body": "These are duplicated logic with `validateQueueDeleting`, we can abstract a func.",
        "pr_file_module": null
      },
      {
        "comment_id": "1967082535",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4033,
        "pr_file": "pkg/webhooks/admission/queues/validate/validate_queue.go",
        "discussion_id": "1967006316",
        "commented_code": "@@ -251,14 +251,29 @@ func validateHierarchicalQueue(queue *schedulingv1beta1.Queue) error {\n \tif queue.Spec.Parent == \"\" || queue.Spec.Parent == \"root\" {\n \t\treturn nil\n \t}\n+\n \tparentQueue, err := config.QueueLister.Get(queue.Spec.Parent)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to get parent queue of queue %s: %v\", queue.Name, err)\n \t}\n \n-\tif allocated, ok := parentQueue.Status.Allocated[v1.ResourcePods]; ok && !allocated.IsZero() {\n-\t\treturn fmt.Errorf(\"queue %s cannot be the parent queue of queue %s because it has allocated Pods: %d\",\n-\t\t\tparentQueue.Name, queue.Name, allocated.Value())\n+\tqueueList, err := config.QueueLister.List(labels.Everything())",
        "comment_created_at": "2025-02-24T06:15:46+00:00",
        "comment_author": "zhutong196",
        "comment_body": "Good suggestion, I will abstract a  func of whether there is a child in the repeated judgments of `validateQueueDeleting` and `validateHierarchicalQueue` into a method",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1867136386",
    "pr_number": 3813,
    "pr_file": "pkg/controllers/job/job_controller.go",
    "created_at": "2024-12-03T06:44:27+00:00",
    "commented_code": "klog.V(3).Infof(\"Try to handle request <%v>\", req)\n \n+\t// Handle cancellation logic for delayed actions:\n+\t// 1. When request event is not Pod Pending:\n+\t//   - Cancel corresponding Pod Pending delayed action\n+\t//   - When Pod enters Running state, cancel corresponding Pod Failed and Pod Evicted delayed actions\n+\tif req.Event != busv1alpha1.PodPendingEvent {\n+\t\tcc.delayActionMapLock.Lock()\n+\t\tif taskMap, exists := cc.delayActionMap[key]; exists {\n+\t\t\tfor podName, delayAct := range taskMap {\n+\t\t\t\tshouldCancel := false\n+\n+\t\t\t\tif podName == req.PodName {\n+\t\t\t\t\tif delayAct.event == busv1alpha1.PodPendingEvent {\n+\t\t\t\t\t\tshouldCancel = true\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif req.Event == busv1alpha1.PodRunningEvent &&\n+\t\t\t\t\t\t(delayAct.event == busv1alpha1.PodFailedEvent || delayAct.event == busv1alpha1.PodEvictedEvent) {\n+\t\t\t\t\t\tshouldCancel = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif shouldCancel {\n+\t\t\t\t\tklog.V(3).Infof(\"Cancel delayed action <%v> for pod <%s> of Job <%s>\", delayAct.action, podName, delayAct.jobKey)\n+\t\t\t\t\tdelayAct.cancel()\n+\t\t\t\t\tdelete(taskMap, podName)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcc.delayActionMapLock.Unlock()",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1867136386",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3813,
        "pr_file": "pkg/controllers/job/job_controller.go",
        "discussion_id": "1867136386",
        "commented_code": "@@ -327,6 +359,37 @@ func (cc *jobcontroller) processNextReq(count uint32) bool {\n \n \tklog.V(3).Infof(\"Try to handle request <%v>\", req)\n \n+\t// Handle cancellation logic for delayed actions:\n+\t// 1. When request event is not Pod Pending:\n+\t//   - Cancel corresponding Pod Pending delayed action\n+\t//   - When Pod enters Running state, cancel corresponding Pod Failed and Pod Evicted delayed actions\n+\tif req.Event != busv1alpha1.PodPendingEvent {\n+\t\tcc.delayActionMapLock.Lock()\n+\t\tif taskMap, exists := cc.delayActionMap[key]; exists {\n+\t\t\tfor podName, delayAct := range taskMap {\n+\t\t\t\tshouldCancel := false\n+\n+\t\t\t\tif podName == req.PodName {\n+\t\t\t\t\tif delayAct.event == busv1alpha1.PodPendingEvent {\n+\t\t\t\t\t\tshouldCancel = true\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif req.Event == busv1alpha1.PodRunningEvent &&\n+\t\t\t\t\t\t(delayAct.event == busv1alpha1.PodFailedEvent || delayAct.event == busv1alpha1.PodEvictedEvent) {\n+\t\t\t\t\t\tshouldCancel = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif shouldCancel {\n+\t\t\t\t\tklog.V(3).Infof(\"Cancel delayed action <%v> for pod <%s> of Job <%s>\", delayAct.action, podName, delayAct.jobKey)\n+\t\t\t\t\tdelayAct.cancel()\n+\t\t\t\t\tdelete(taskMap, podName)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcc.delayActionMapLock.Unlock()",
        "comment_created_at": "2024-12-03T06:44:27+00:00",
        "comment_author": "ouyangshengjia",
        "comment_body": "refactor into a function and unlock by `defer`",
        "pr_file_module": null
      },
      {
        "comment_id": "1898385326",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3813,
        "pr_file": "pkg/controllers/job/job_controller.go",
        "discussion_id": "1867136386",
        "commented_code": "@@ -327,6 +359,37 @@ func (cc *jobcontroller) processNextReq(count uint32) bool {\n \n \tklog.V(3).Infof(\"Try to handle request <%v>\", req)\n \n+\t// Handle cancellation logic for delayed actions:\n+\t// 1. When request event is not Pod Pending:\n+\t//   - Cancel corresponding Pod Pending delayed action\n+\t//   - When Pod enters Running state, cancel corresponding Pod Failed and Pod Evicted delayed actions\n+\tif req.Event != busv1alpha1.PodPendingEvent {\n+\t\tcc.delayActionMapLock.Lock()\n+\t\tif taskMap, exists := cc.delayActionMap[key]; exists {\n+\t\t\tfor podName, delayAct := range taskMap {\n+\t\t\t\tshouldCancel := false\n+\n+\t\t\t\tif podName == req.PodName {\n+\t\t\t\t\tif delayAct.event == busv1alpha1.PodPendingEvent {\n+\t\t\t\t\t\tshouldCancel = true\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif req.Event == busv1alpha1.PodRunningEvent &&\n+\t\t\t\t\t\t(delayAct.event == busv1alpha1.PodFailedEvent || delayAct.event == busv1alpha1.PodEvictedEvent) {\n+\t\t\t\t\t\tshouldCancel = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif shouldCancel {\n+\t\t\t\t\tklog.V(3).Infof(\"Cancel delayed action <%v> for pod <%s> of Job <%s>\", delayAct.action, podName, delayAct.jobKey)\n+\t\t\t\t\tdelayAct.cancel()\n+\t\t\t\t\tdelete(taskMap, podName)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcc.delayActionMapLock.Unlock()",
        "comment_created_at": "2024-12-27T09:16:03+00:00",
        "comment_author": "bibibox",
        "comment_body": "updated",
        "pr_file_module": null
      }
    ]
  }
]