[
  {
    "discussion_id": "1963263156",
    "pr_number": 4014,
    "pr_file": "pkg/controllers/hypernode/provider/provider.go",
    "created_at": "2025-02-20T10:07:37+00:00",
    "commented_code": "+/*\n+Copyright 2025 The Volcano Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package provider\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"plugin\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/util/wait\"\n+\t\"k8s.io/client-go/util/retry\"\n+\t\"k8s.io/klog/v2\"\n+\tvcclientset \"volcano.sh/apis/pkg/client/clientset/versioned\"\n+\tvcinformer \"volcano.sh/apis/pkg/client/informers/externalversions\"\n+)\n+\n+// Provider is the interface for the hyperNode provider.\n+type Provider interface {\n+\tProvision(stopCh <-chan struct{})\n+}\n+\n+var backoff = wait.Backoff{\n+\tDuration: time.Second,\n+\tFactor:   1,\n+\tJitter:   0.1,\n+\tSteps:    20,\n+}\n+\n+type provider struct {\n+\teventCh        chan Event\n+\treplyCh        chan Reply\n+\tvcClient       vcclientset.Interface\n+\tfactory        vcinformer.SharedInformerFactory\n+\tpluginBuilders map[string]PluginBuilder\n+\tpluginDir      string\n+}\n+\n+// NewProvider creates a new hyperNode provider.\n+func NewProvider(client vcclientset.Interface, factory vcinformer.SharedInformerFactory, pluginDir string) Provider {\n+\tp := &provider{\n+\t\tvcClient:       client,\n+\t\tfactory:        factory,\n+\t\teventCh:        make(chan Event),\n+\t\treplyCh:        make(chan Reply),\n+\t\tpluginBuilders: make(map[string]PluginBuilder),\n+\t\tpluginDir:      pluginDir,\n+\t}\n+\tif err := p.loadProvider(pluginDir); err != nil {\n+\t\tklog.ErrorS(err, \"Failed to load hyperNode provider\")\n+\t}\n+\treturn p\n+}\n+\n+func (p *provider) loadProvider(dir string) error {\n+\tpluginPaths, _ := filepath.Glob(fmt.Sprintf(\"%s/*.so\", dir))\n+\tfor _, pluginPath := range pluginPaths {\n+\t\tpb, err := loadPlugin(pluginPath)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tplugin := pb()\n+\t\t//pluginName := getPluginName(pluginPath)\n+\t\tp.RegisterPlugin(plugin.Name(), pb)\n+\t\tklog.V(2).Infof(\"hyperNode provider %s loaded\", plugin.Name())\n+\t}\n+\n+\treturn nil\n+}\n+\n+func getPluginName(pluginPath string) string {\n+\treturn strings.TrimSuffix(filepath.Base(pluginPath), filepath.Ext(pluginPath))\n+}\n+\n+func loadPlugin(pluginPath string) (PluginBuilder, error) {\n+\tklog.ErrorS(nil, \"loadPlugin\", \"pathxxx\", pluginPath)",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1963263156",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4014,
        "pr_file": "pkg/controllers/hypernode/provider/provider.go",
        "discussion_id": "1963263156",
        "commented_code": "@@ -0,0 +1,246 @@\n+/*\n+Copyright 2025 The Volcano Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package provider\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"plugin\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/util/wait\"\n+\t\"k8s.io/client-go/util/retry\"\n+\t\"k8s.io/klog/v2\"\n+\tvcclientset \"volcano.sh/apis/pkg/client/clientset/versioned\"\n+\tvcinformer \"volcano.sh/apis/pkg/client/informers/externalversions\"\n+)\n+\n+// Provider is the interface for the hyperNode provider.\n+type Provider interface {\n+\tProvision(stopCh <-chan struct{})\n+}\n+\n+var backoff = wait.Backoff{\n+\tDuration: time.Second,\n+\tFactor:   1,\n+\tJitter:   0.1,\n+\tSteps:    20,\n+}\n+\n+type provider struct {\n+\teventCh        chan Event\n+\treplyCh        chan Reply\n+\tvcClient       vcclientset.Interface\n+\tfactory        vcinformer.SharedInformerFactory\n+\tpluginBuilders map[string]PluginBuilder\n+\tpluginDir      string\n+}\n+\n+// NewProvider creates a new hyperNode provider.\n+func NewProvider(client vcclientset.Interface, factory vcinformer.SharedInformerFactory, pluginDir string) Provider {\n+\tp := &provider{\n+\t\tvcClient:       client,\n+\t\tfactory:        factory,\n+\t\teventCh:        make(chan Event),\n+\t\treplyCh:        make(chan Reply),\n+\t\tpluginBuilders: make(map[string]PluginBuilder),\n+\t\tpluginDir:      pluginDir,\n+\t}\n+\tif err := p.loadProvider(pluginDir); err != nil {\n+\t\tklog.ErrorS(err, \"Failed to load hyperNode provider\")\n+\t}\n+\treturn p\n+}\n+\n+func (p *provider) loadProvider(dir string) error {\n+\tpluginPaths, _ := filepath.Glob(fmt.Sprintf(\"%s/*.so\", dir))\n+\tfor _, pluginPath := range pluginPaths {\n+\t\tpb, err := loadPlugin(pluginPath)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tplugin := pb()\n+\t\t//pluginName := getPluginName(pluginPath)\n+\t\tp.RegisterPlugin(plugin.Name(), pb)\n+\t\tklog.V(2).Infof(\"hyperNode provider %s loaded\", plugin.Name())\n+\t}\n+\n+\treturn nil\n+}\n+\n+func getPluginName(pluginPath string) string {\n+\treturn strings.TrimSuffix(filepath.Base(pluginPath), filepath.Ext(pluginPath))\n+}\n+\n+func loadPlugin(pluginPath string) (PluginBuilder, error) {\n+\tklog.ErrorS(nil, \"loadPlugin\", \"pathxxx\", pluginPath)",
        "comment_created_at": "2025-02-20T10:07:37+00:00",
        "comment_author": "fishingfly",
        "comment_body": "`klog.InfoS` should be used here? Instead of `klog.ErrorS`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1964627397",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4014,
        "pr_file": "pkg/controllers/hypernode/provider/provider.go",
        "discussion_id": "1963263156",
        "commented_code": "@@ -0,0 +1,246 @@\n+/*\n+Copyright 2025 The Volcano Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package provider\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"plugin\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/util/wait\"\n+\t\"k8s.io/client-go/util/retry\"\n+\t\"k8s.io/klog/v2\"\n+\tvcclientset \"volcano.sh/apis/pkg/client/clientset/versioned\"\n+\tvcinformer \"volcano.sh/apis/pkg/client/informers/externalversions\"\n+)\n+\n+// Provider is the interface for the hyperNode provider.\n+type Provider interface {\n+\tProvision(stopCh <-chan struct{})\n+}\n+\n+var backoff = wait.Backoff{\n+\tDuration: time.Second,\n+\tFactor:   1,\n+\tJitter:   0.1,\n+\tSteps:    20,\n+}\n+\n+type provider struct {\n+\teventCh        chan Event\n+\treplyCh        chan Reply\n+\tvcClient       vcclientset.Interface\n+\tfactory        vcinformer.SharedInformerFactory\n+\tpluginBuilders map[string]PluginBuilder\n+\tpluginDir      string\n+}\n+\n+// NewProvider creates a new hyperNode provider.\n+func NewProvider(client vcclientset.Interface, factory vcinformer.SharedInformerFactory, pluginDir string) Provider {\n+\tp := &provider{\n+\t\tvcClient:       client,\n+\t\tfactory:        factory,\n+\t\teventCh:        make(chan Event),\n+\t\treplyCh:        make(chan Reply),\n+\t\tpluginBuilders: make(map[string]PluginBuilder),\n+\t\tpluginDir:      pluginDir,\n+\t}\n+\tif err := p.loadProvider(pluginDir); err != nil {\n+\t\tklog.ErrorS(err, \"Failed to load hyperNode provider\")\n+\t}\n+\treturn p\n+}\n+\n+func (p *provider) loadProvider(dir string) error {\n+\tpluginPaths, _ := filepath.Glob(fmt.Sprintf(\"%s/*.so\", dir))\n+\tfor _, pluginPath := range pluginPaths {\n+\t\tpb, err := loadPlugin(pluginPath)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tplugin := pb()\n+\t\t//pluginName := getPluginName(pluginPath)\n+\t\tp.RegisterPlugin(plugin.Name(), pb)\n+\t\tklog.V(2).Infof(\"hyperNode provider %s loaded\", plugin.Name())\n+\t}\n+\n+\treturn nil\n+}\n+\n+func getPluginName(pluginPath string) string {\n+\treturn strings.TrimSuffix(filepath.Base(pluginPath), filepath.Ext(pluginPath))\n+}\n+\n+func loadPlugin(pluginPath string) (PluginBuilder, error) {\n+\tklog.ErrorS(nil, \"loadPlugin\", \"pathxxx\", pluginPath)",
        "comment_created_at": "2025-02-21T01:47:13+00:00",
        "comment_author": "Monokaix",
        "comment_body": "Yeah you're right, done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149959869",
    "pr_number": 4373,
    "pr_file": "pkg/scheduler/framework/session.go",
    "created_at": "2025-06-16T13:12:50+00:00",
    "commented_code": "ssn.NamespaceInfo = snapshot.NamespaceInfo\n \t// calculate all nodes' resource only once in each schedule cycle, other plugins can clone it when need\n \tfor _, n := range ssn.Nodes {\n+\t\tif !nodeIsNotReady(n.Node) {\n+\t\t\tklog.V(3).Infof(\"node %s is not ready,need continue\", n.Name)",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "2149979322",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4373,
        "pr_file": "pkg/scheduler/framework/session.go",
        "discussion_id": "2149959869",
        "commented_code": "@@ -211,6 +211,11 @@ func openSession(cache cache.Cache) *Session {\n \tssn.NamespaceInfo = snapshot.NamespaceInfo\n \t// calculate all nodes' resource only once in each schedule cycle, other plugins can clone it when need\n \tfor _, n := range ssn.Nodes {\n+\t\tif !nodeIsNotReady(n.Node) {\n+\t\t\tklog.V(3).Infof(\"node %s is not ready,need continue\", n.Name)",
        "comment_created_at": "2025-06-16T13:12:50+00:00",
        "comment_author": "JesseStutler",
        "comment_body": "I think it's better to log as `node %s is not ready/unschedulable, skip considering this node`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1436713710",
    "pr_number": 3210,
    "pr_file": "pkg/scheduler/api/devices/nvidia/vgpu/device_info.go",
    "created_at": "2023-12-27T03:10:38+00:00",
    "commented_code": "func (gs *GPUDevices) FilterNode(pod *v1.Pod) (int, string, error) {\n \tif VGPUEnable {\n \t\tklog.V(5).Infoln(\"4pdvgpu DeviceSharing starts filtering pods\", pod.Name)\n-\t\tfit, _, err := checkNodeGPUSharingPredicate(pod, gs, true)\n+\t\tfit, _, score, err := checkNodeGPUSharingPredicate(pod, gs, true)\n \t\tif err != nil || !fit {\n \t\t\tklog.Errorln(\"deviceSharing err=\", err.Error())\n \t\t\treturn devices.Unschedulable, fmt.Sprintf(\"4pdvgpuDeviceSharing %s\", err.Error()), err\n \t\t}\n+\t\tgs.ScoreMap[pod.Name] = score\n \t\tklog.V(5).Infoln(\"4pdvgpu DeviceSharing successfully filters pods\")\n \t}\n \treturn devices.Success, \"\", nil\n }\n \n+func (gs *GPUDevices) ScoreNode(pod *v1.Pod) float64 {\n+\t/* TODO: we need a base score to be campatable with preemption, it means a node without evicting a task has\n+\ta higher score than those needs to evict a task */\n+\n+\t// Use cached stored in filter state in order to avoid recalculating.\n+\tklog.V(5).Infoln(\"pod=\", pod.Name, \"scoreMap=\", gs.ScoreMap[pod.Name])",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1436713710",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3210,
        "pr_file": "pkg/scheduler/api/devices/nvidia/vgpu/device_info.go",
        "discussion_id": "1436713710",
        "commented_code": "@@ -182,20 +185,30 @@ func (gs *GPUDevices) Release(kubeClient kubernetes.Interface, pod *v1.Pod) erro\n func (gs *GPUDevices) FilterNode(pod *v1.Pod) (int, string, error) {\n \tif VGPUEnable {\n \t\tklog.V(5).Infoln(\"4pdvgpu DeviceSharing starts filtering pods\", pod.Name)\n-\t\tfit, _, err := checkNodeGPUSharingPredicate(pod, gs, true)\n+\t\tfit, _, score, err := checkNodeGPUSharingPredicate(pod, gs, true)\n \t\tif err != nil || !fit {\n \t\t\tklog.Errorln(\"deviceSharing err=\", err.Error())\n \t\t\treturn devices.Unschedulable, fmt.Sprintf(\"4pdvgpuDeviceSharing %s\", err.Error()), err\n \t\t}\n+\t\tgs.ScoreMap[pod.Name] = score\n \t\tklog.V(5).Infoln(\"4pdvgpu DeviceSharing successfully filters pods\")\n \t}\n \treturn devices.Success, \"\", nil\n }\n \n+func (gs *GPUDevices) ScoreNode(pod *v1.Pod) float64 {\n+\t/* TODO: we need a base score to be campatable with preemption, it means a node without evicting a task has\n+\ta higher score than those needs to evict a task */\n+\n+\t// Use cached stored in filter state in order to avoid recalculating.\n+\tklog.V(5).Infoln(\"pod=\", pod.Name, \"scoreMap=\", gs.ScoreMap[pod.Name])",
        "comment_created_at": "2023-12-27T03:10:38+00:00",
        "comment_author": "Monokaix",
        "comment_body": "Please use klog.InfoS and ErrorS format, and then `=` is not needed. And please modify other places too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1436898045",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3210,
        "pr_file": "pkg/scheduler/api/devices/nvidia/vgpu/device_info.go",
        "discussion_id": "1436713710",
        "commented_code": "@@ -182,20 +185,30 @@ func (gs *GPUDevices) Release(kubeClient kubernetes.Interface, pod *v1.Pod) erro\n func (gs *GPUDevices) FilterNode(pod *v1.Pod) (int, string, error) {\n \tif VGPUEnable {\n \t\tklog.V(5).Infoln(\"4pdvgpu DeviceSharing starts filtering pods\", pod.Name)\n-\t\tfit, _, err := checkNodeGPUSharingPredicate(pod, gs, true)\n+\t\tfit, _, score, err := checkNodeGPUSharingPredicate(pod, gs, true)\n \t\tif err != nil || !fit {\n \t\t\tklog.Errorln(\"deviceSharing err=\", err.Error())\n \t\t\treturn devices.Unschedulable, fmt.Sprintf(\"4pdvgpuDeviceSharing %s\", err.Error()), err\n \t\t}\n+\t\tgs.ScoreMap[pod.Name] = score\n \t\tklog.V(5).Infoln(\"4pdvgpu DeviceSharing successfully filters pods\")\n \t}\n \treturn devices.Success, \"\", nil\n }\n \n+func (gs *GPUDevices) ScoreNode(pod *v1.Pod) float64 {\n+\t/* TODO: we need a base score to be campatable with preemption, it means a node without evicting a task has\n+\ta higher score than those needs to evict a task */\n+\n+\t// Use cached stored in filter state in order to avoid recalculating.\n+\tklog.V(5).Infoln(\"pod=\", pod.Name, \"scoreMap=\", gs.ScoreMap[pod.Name])",
        "comment_created_at": "2023-12-27T10:01:52+00:00",
        "comment_author": "archlitchi",
        "comment_body": "ok",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1441539721",
    "pr_number": 3210,
    "pr_file": "pkg/scheduler/api/devices/nvidia/vgpu/utils.go",
    "created_at": "2024-01-04T09:44:51+00:00",
    "commented_code": "gs = gssnap\n \t}\n \tctrdevs := []ContainerDevices{}\n+\n \tfor _, val := range ctrReq {\n \t\tdevs := []ContainerDevice{}\n \t\tif int(val.Nums) > len(gs.Device) {\n-\t\t\treturn false, []ContainerDevices{}, fmt.Errorf(\"no enough gpu cards on node %s\", gs.Name)\n+\t\t\treturn false, []ContainerDevices{}, 0, fmt.Errorf(\"no enough gpu cards on node %s\", gs.Name)\n \t\t}\n \t\tklog.V(3).Infoln(\"Allocating device for container request\", val)",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1441539721",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 3210,
        "pr_file": "pkg/scheduler/api/devices/nvidia/vgpu/utils.go",
        "discussion_id": "1441539721",
        "commented_code": "@@ -342,10 +344,11 @@ func checkNodeGPUSharingPredicate(pod *v1.Pod, gssnap *GPUDevices, replicate boo\n \t\tgs = gssnap\n \t}\n \tctrdevs := []ContainerDevices{}\n+\n \tfor _, val := range ctrReq {\n \t\tdevs := []ContainerDevice{}\n \t\tif int(val.Nums) > len(gs.Device) {\n-\t\t\treturn false, []ContainerDevices{}, fmt.Errorf(\"no enough gpu cards on node %s\", gs.Name)\n+\t\t\treturn false, []ContainerDevices{}, 0, fmt.Errorf(\"no enough gpu cards on node %s\", gs.Name)\n \t\t}\n \t\tklog.V(3).Infoln(\"Allocating device for container request\", val)\n ",
        "comment_created_at": "2024-01-04T09:44:51+00:00",
        "comment_author": "Monokaix",
        "comment_body": "Please use klog.InfoS() nethod.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1965200062",
    "pr_number": 4000,
    "pr_file": "pkg/controllers/podgroup/pg_controller_handler.go",
    "created_at": "2025-02-21T09:58:21+00:00",
    "commented_code": "}\n }\n \n+func (pg *pgcontroller) getMinMemberFromUpperRes(pod *v1.Pod) int32 {\n+\tminMember := int32(1)\n+\n+\tfor _, reference := range pod.OwnerReferences {\n+\t\t// Currently we assume the group-min-member annotation will be specified only once\n+\t\tif reference.Kind != \"\" && reference.Name != \"\" {\n+\t\t\tannotations := pg.getAnnotationsFromUpperRes(reference.Kind, reference.Name, pod.Namespace)\n+\t\t\tif minMemberAnno, ok := annotations[scheduling.VolcanoGroupMinMemberAnnotationKey]; ok {\n+\t\t\t\tminMemberFromAnno, err := strconv.Atoi(minMemberAnno)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tklog.Infof(\"Failed to convert minMemberAnnotation of Pod owners <%s/%s> into number, skipping\",",
    "repo_full_name": "volcano-sh/volcano",
    "discussion_comments": [
      {
        "comment_id": "1965200062",
        "repo_full_name": "volcano-sh/volcano",
        "pr_number": 4000,
        "pr_file": "pkg/controllers/podgroup/pg_controller_handler.go",
        "discussion_id": "1965200062",
        "commented_code": "@@ -177,6 +179,33 @@ func (pg *pgcontroller) getAnnotationsFromUpperRes(kind string, name string, nam\n \t}\n }\n \n+func (pg *pgcontroller) getMinMemberFromUpperRes(pod *v1.Pod) int32 {\n+\tminMember := int32(1)\n+\n+\tfor _, reference := range pod.OwnerReferences {\n+\t\t// Currently we assume the group-min-member annotation will be specified only once\n+\t\tif reference.Kind != \"\" && reference.Name != \"\" {\n+\t\t\tannotations := pg.getAnnotationsFromUpperRes(reference.Kind, reference.Name, pod.Namespace)\n+\t\t\tif minMemberAnno, ok := annotations[scheduling.VolcanoGroupMinMemberAnnotationKey]; ok {\n+\t\t\t\tminMemberFromAnno, err := strconv.Atoi(minMemberAnno)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tklog.Infof(\"Failed to convert minMemberAnnotation of Pod owners <%s/%s> into number, skipping\",",
        "comment_created_at": "2025-02-21T09:58:21+00:00",
        "comment_author": "Monokaix",
        "comment_body": "This klog info is not so clear, we should mention that remain minmember =1, or users will don't  know the value finally set.",
        "pr_file_module": null
      }
    ]
  }
]