[
  {
    "discussion_id": "2223276536",
    "pr_number": 257306,
    "pr_file": "src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/task/taskHelpers.ts",
    "created_at": "2025-07-22T17:13:24+00:00",
    "commented_code": "}\n \n-export function getTaskRepresentation(task: Task): string {\n-\tconst taskDefinition = task.getDefinition(true);\n-\tif (!taskDefinition) {\n-\t\treturn '';\n-\t}\n-\tif ('label' in taskDefinition) {\n-\t\treturn taskDefinition.label;\n-\t} else if ('script' in taskDefinition) {\n-\t\treturn taskDefinition.script;\n-\t} else if ('command' in taskDefinition) {\n-\t\treturn taskDefinition.command;\n+export function getTaskRepresentation(task: { [key: string]: any }): string {\n+\tif ('label' in task) {\n+\t\treturn task.label;\n+\t} else if ('_label' in task) {\n+\t\treturn task._label;\n+\t} else if ('script' in task) {\n+\t\treturn task.script;\n+\t} else if ('command' in task) {\n+\t\treturn task.command;\n \t}\n \treturn '';\n }\n \n-export async function getTaskForTool(id: string, taskDefinition: { taskLabel?: string; taskType?: string }, workspaceFolder: string, taskService: ITaskService): Promise<Task | undefined> {\n+export async function getTaskForTool(id: string, taskDefinition: { taskLabel?: string; taskType?: string }, workspaceFolder: string, configurationService: IConfigurationService, taskService: ITaskService): Promise<Task | undefined> {\n \tlet index = 0;\n-\tlet task;\n-\tconst workspaceTasks: IStringDictionary<ConfiguringTask> | undefined = (await taskService.getWorkspaceTasks())?.get(URI.file(workspaceFolder).toString())?.configurations?.byIdentifier;\n-\tfor (const workspaceTask of Object.values(workspaceTasks ?? {})) {\n-\t\tif ((!workspaceTask.type || workspaceTask.type === taskDefinition?.taskType) &&\n-\t\t\t((workspaceTask._label === taskDefinition?.taskLabel)\n-\t\t\t\t|| (id === workspaceTask._label))) {\n-\t\t\ttask = workspaceTask;\n+\tlet task: IConfiguredTask | undefined = undefined;\n+\tconst configTasks: IConfiguredTask[] = (configurationService.getValue('tasks') as { tasks: IConfiguredTask[] }).tasks ?? [];\n+\tfor (const configTask of configTasks) {\n+\t\tif ((configTask.type && taskDefinition.taskType ? configTask.type === taskDefinition.taskType : true) &&\n+\t\t\t((getTaskRepresentation(configTask) === taskDefinition?.taskLabel) || (id === configTask._label))) {\n+\t\t\ttask = configTask;\n \t\t\tbreak;\n-\t\t} else if (id === `${workspaceTask.type}: ${index}`) {\n-\t\t\ttask = workspaceTask;\n+\t\t} else if (id === `${configTask.type}: ${index}`) {\n+\t\t\ttask = configTask;\n \t\t\tbreak;\n \t\t}\n \t\tindex++;\n \t}\n-\tif (task) {\n-\t\treturn taskService.tryResolveTask(task);\n+\tif (!task) {\n+\t\treturn;\n \t}\n-\treturn undefined;\n+\tconst configuringTasks: IStringDictionary<ConfiguringTask> | undefined = (await taskService.getWorkspaceTasks())?.get(URI.file(workspaceFolder).toString())?.configurations?.byIdentifier;\n+\tconst configuredTask: ConfiguringTask | undefined = Object.values(configuringTasks ?? {}).find(t => {\n+\t\treturn t.type === task.type && (t._label === getTaskRepresentation(task) || t._label === `${task.type}: ${getTaskRepresentation(task)}`);\n+\t});\n+\tlet resolvedTask: Task | undefined = undefined;\n+\tif (configuredTask) {\n+\t\tresolvedTask = await taskService.tryResolveTask(configuredTask);\n+\t}\n+\tif (!resolvedTask) {\n+\t\tconst customTasks: Task[] | undefined = (await taskService.getWorkspaceTasks())?.get(URI.file(workspaceFolder).toString())?.set?.tasks;\n+\t\tresolvedTask = customTasks?.find(t => getTaskRepresentation(t) === getTaskRepresentation(task));\n+\n+\t}\n+\treturn resolvedTask;\n+}\n+",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2223276536",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 257306,
        "pr_file": "src/vs/workbench/contrib/terminalContrib/chatAgentTools/browser/task/taskHelpers.ts",
        "discussion_id": "2223276536",
        "commented_code": "@@ -22,39 +22,55 @@ export function getTaskDefinition(id: string) {\n \n }\n \n-export function getTaskRepresentation(task: Task): string {\n-\tconst taskDefinition = task.getDefinition(true);\n-\tif (!taskDefinition) {\n-\t\treturn '';\n-\t}\n-\tif ('label' in taskDefinition) {\n-\t\treturn taskDefinition.label;\n-\t} else if ('script' in taskDefinition) {\n-\t\treturn taskDefinition.script;\n-\t} else if ('command' in taskDefinition) {\n-\t\treturn taskDefinition.command;\n+export function getTaskRepresentation(task: { [key: string]: any }): string {\n+\tif ('label' in task) {\n+\t\treturn task.label;\n+\t} else if ('_label' in task) {\n+\t\treturn task._label;\n+\t} else if ('script' in task) {\n+\t\treturn task.script;\n+\t} else if ('command' in task) {\n+\t\treturn task.command;\n \t}\n \treturn '';\n }\n \n-export async function getTaskForTool(id: string, taskDefinition: { taskLabel?: string; taskType?: string }, workspaceFolder: string, taskService: ITaskService): Promise<Task | undefined> {\n+export async function getTaskForTool(id: string, taskDefinition: { taskLabel?: string; taskType?: string }, workspaceFolder: string, configurationService: IConfigurationService, taskService: ITaskService): Promise<Task | undefined> {\n \tlet index = 0;\n-\tlet task;\n-\tconst workspaceTasks: IStringDictionary<ConfiguringTask> | undefined = (await taskService.getWorkspaceTasks())?.get(URI.file(workspaceFolder).toString())?.configurations?.byIdentifier;\n-\tfor (const workspaceTask of Object.values(workspaceTasks ?? {})) {\n-\t\tif ((!workspaceTask.type || workspaceTask.type === taskDefinition?.taskType) &&\n-\t\t\t((workspaceTask._label === taskDefinition?.taskLabel)\n-\t\t\t\t|| (id === workspaceTask._label))) {\n-\t\t\ttask = workspaceTask;\n+\tlet task: IConfiguredTask | undefined = undefined;\n+\tconst configTasks: IConfiguredTask[] = (configurationService.getValue('tasks') as { tasks: IConfiguredTask[] }).tasks ?? [];\n+\tfor (const configTask of configTasks) {\n+\t\tif ((configTask.type && taskDefinition.taskType ? configTask.type === taskDefinition.taskType : true) &&\n+\t\t\t((getTaskRepresentation(configTask) === taskDefinition?.taskLabel) || (id === configTask._label))) {\n+\t\t\ttask = configTask;\n \t\t\tbreak;\n-\t\t} else if (id === `${workspaceTask.type}: ${index}`) {\n-\t\t\ttask = workspaceTask;\n+\t\t} else if (id === `${configTask.type}: ${index}`) {\n+\t\t\ttask = configTask;\n \t\t\tbreak;\n \t\t}\n \t\tindex++;\n \t}\n-\tif (task) {\n-\t\treturn taskService.tryResolveTask(task);\n+\tif (!task) {\n+\t\treturn;\n \t}\n-\treturn undefined;\n+\tconst configuringTasks: IStringDictionary<ConfiguringTask> | undefined = (await taskService.getWorkspaceTasks())?.get(URI.file(workspaceFolder).toString())?.configurations?.byIdentifier;\n+\tconst configuredTask: ConfiguringTask | undefined = Object.values(configuringTasks ?? {}).find(t => {\n+\t\treturn t.type === task.type && (t._label === getTaskRepresentation(task) || t._label === `${task.type}: ${getTaskRepresentation(task)}`);\n+\t});\n+\tlet resolvedTask: Task | undefined = undefined;\n+\tif (configuredTask) {\n+\t\tresolvedTask = await taskService.tryResolveTask(configuredTask);\n+\t}\n+\tif (!resolvedTask) {\n+\t\tconst customTasks: Task[] | undefined = (await taskService.getWorkspaceTasks())?.get(URI.file(workspaceFolder).toString())?.set?.tasks;\n+\t\tresolvedTask = customTasks?.find(t => getTaskRepresentation(t) === getTaskRepresentation(task));\n+\n+\t}\n+\treturn resolvedTask;\n+}\n+",
        "comment_created_at": "2025-07-22T17:13:24+00:00",
        "comment_author": "Copilot",
        "comment_body": "The IConfiguredTask interface lacks JSDoc documentation. Add documentation explaining its purpose and the meaning of the optional properties, especially the difference between 'label' and '_label'.\n```suggestion\n\n/**\n * Represents a configured task in the system.\n * \n * This interface is used to define tasks that can be executed within the workspace.\n * It includes optional properties for identifying and describing the task.\n * \n * Properties:\n * - `type`: (optional) The type of the task, which categorizes it (e.g., \"build\", \"test\").\n * - `label`: (optional) A user-facing label for the task, typically used for display purposes.\n * - `_label`: (optional) An internal label for the task, used for unique identification.\n * \n * Note: The `label` property is prioritized for user-facing representations, while `_label`\n * is used internally for task resolution and matching.\n */\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132898772",
    "pr_number": 250880,
    "pr_file": "extensions/terminal-suggest/src/tokens.ts",
    "created_at": "2025-06-06T20:55:39+00:00",
    "commented_code": "const shellTypeResetChars = new Map<TerminalShellType, string[]>([\n \t[TerminalShellType.Bash, ['>', '>>', '<', '2>', '2>>', '&>', '&>>', '|', '|&', '&&', '||', '&', ';', '(', '{', '<<']],\n \t[TerminalShellType.Zsh, ['>', '>>', '<', '2>', '2>>', '&>', '&>>', '<>', '|', '|&', '&&', '||', '&', ';', '(', '{', '<<', '<<<', '<(']],\n-\t[TerminalShellType.PowerShell, ['>', '>>', '<', '2>', '2>>', '*>', '*>>', '|', '-and', '-or', '-not', '!', '&', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '-like', '-notlike', '-match', '-notmatch', '-contains', '-notcontains', '-in', '-notin']]\n+\t[TerminalShellType.PowerShell, ['>', '>>', '<', '2>', '2>>', '*>', '*>>', '|', '-and', '-or', '-not', '!', '&', ';', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '-like', '-notlike', '-match', '-notmatch', '-contains', '-notcontains', '-in', '-notin']]\n+]);\n+\n+// Command separators that start new command contexts (vs logical operators that stay in argument context)\n+const shellTypeCommandSeparators = new Map<TerminalShellType, string[]>([\n+\t[TerminalShellType.Bash, ['|', '|&', '&&', '||', '&', ';', '(', '{']],\n+\t[TerminalShellType.Zsh, ['|', '|&', '&&', '||', '&', ';', '(', '{']],\n+\t[TerminalShellType.PowerShell, ['|', '&', ';']]\n ]);\n \n const defaultShellTypeResetChars = shellTypeResetChars.get(TerminalShellType.Bash)!;\n+const defaultShellTypeCommandSeparators = shellTypeCommandSeparators.get(TerminalShellType.Bash)!;\n+\n+export { shellTypeResetChars, defaultShellTypeResetChars, shellTypeCommandSeparators, defaultShellTypeCommandSeparators };\n \n export function getTokenType(ctx: { commandLine: string; cursorPosition: number }, shellType: TerminalShellType | undefined): TokenType {",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2132898772",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 250880,
        "pr_file": "extensions/terminal-suggest/src/tokens.ts",
        "discussion_id": "2132898772",
        "commented_code": "@@ -14,20 +14,102 @@ export const enum TokenType {\n const shellTypeResetChars = new Map<TerminalShellType, string[]>([\n \t[TerminalShellType.Bash, ['>', '>>', '<', '2>', '2>>', '&>', '&>>', '|', '|&', '&&', '||', '&', ';', '(', '{', '<<']],\n \t[TerminalShellType.Zsh, ['>', '>>', '<', '2>', '2>>', '&>', '&>>', '<>', '|', '|&', '&&', '||', '&', ';', '(', '{', '<<', '<<<', '<(']],\n-\t[TerminalShellType.PowerShell, ['>', '>>', '<', '2>', '2>>', '*>', '*>>', '|', '-and', '-or', '-not', '!', '&', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '-like', '-notlike', '-match', '-notmatch', '-contains', '-notcontains', '-in', '-notin']]\n+\t[TerminalShellType.PowerShell, ['>', '>>', '<', '2>', '2>>', '*>', '*>>', '|', '-and', '-or', '-not', '!', '&', ';', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '-like', '-notlike', '-match', '-notmatch', '-contains', '-notcontains', '-in', '-notin']]\n+]);\n+\n+// Command separators that start new command contexts (vs logical operators that stay in argument context)\n+const shellTypeCommandSeparators = new Map<TerminalShellType, string[]>([\n+\t[TerminalShellType.Bash, ['|', '|&', '&&', '||', '&', ';', '(', '{']],\n+\t[TerminalShellType.Zsh, ['|', '|&', '&&', '||', '&', ';', '(', '{']],\n+\t[TerminalShellType.PowerShell, ['|', '&', ';']]\n ]);\n \n const defaultShellTypeResetChars = shellTypeResetChars.get(TerminalShellType.Bash)!;\n+const defaultShellTypeCommandSeparators = shellTypeCommandSeparators.get(TerminalShellType.Bash)!;\n+\n+export { shellTypeResetChars, defaultShellTypeResetChars, shellTypeCommandSeparators, defaultShellTypeCommandSeparators };\n \n export function getTokenType(ctx: { commandLine: string; cursorPosition: number }, shellType: TerminalShellType | undefined): TokenType {",
        "comment_created_at": "2025-06-06T20:55:39+00:00",
        "comment_author": "meganrogge",
        "comment_body": "@copilot for this function, add examples to comments so it's easier to understand/ read each case",
        "pr_file_module": null
      },
      {
        "comment_id": "2132906129",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 250880,
        "pr_file": "extensions/terminal-suggest/src/tokens.ts",
        "discussion_id": "2132898772",
        "commented_code": "@@ -14,20 +14,102 @@ export const enum TokenType {\n const shellTypeResetChars = new Map<TerminalShellType, string[]>([\n \t[TerminalShellType.Bash, ['>', '>>', '<', '2>', '2>>', '&>', '&>>', '|', '|&', '&&', '||', '&', ';', '(', '{', '<<']],\n \t[TerminalShellType.Zsh, ['>', '>>', '<', '2>', '2>>', '&>', '&>>', '<>', '|', '|&', '&&', '||', '&', ';', '(', '{', '<<', '<<<', '<(']],\n-\t[TerminalShellType.PowerShell, ['>', '>>', '<', '2>', '2>>', '*>', '*>>', '|', '-and', '-or', '-not', '!', '&', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '-like', '-notlike', '-match', '-notmatch', '-contains', '-notcontains', '-in', '-notin']]\n+\t[TerminalShellType.PowerShell, ['>', '>>', '<', '2>', '2>>', '*>', '*>>', '|', '-and', '-or', '-not', '!', '&', ';', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '-like', '-notlike', '-match', '-notmatch', '-contains', '-notcontains', '-in', '-notin']]\n+]);\n+\n+// Command separators that start new command contexts (vs logical operators that stay in argument context)\n+const shellTypeCommandSeparators = new Map<TerminalShellType, string[]>([\n+\t[TerminalShellType.Bash, ['|', '|&', '&&', '||', '&', ';', '(', '{']],\n+\t[TerminalShellType.Zsh, ['|', '|&', '&&', '||', '&', ';', '(', '{']],\n+\t[TerminalShellType.PowerShell, ['|', '&', ';']]\n ]);\n \n const defaultShellTypeResetChars = shellTypeResetChars.get(TerminalShellType.Bash)!;\n+const defaultShellTypeCommandSeparators = shellTypeCommandSeparators.get(TerminalShellType.Bash)!;\n+\n+export { shellTypeResetChars, defaultShellTypeResetChars, shellTypeCommandSeparators, defaultShellTypeCommandSeparators };\n \n export function getTokenType(ctx: { commandLine: string; cursorPosition: number }, shellType: TerminalShellType | undefined): TokenType {",
        "comment_created_at": "2025-06-06T21:03:04+00:00",
        "comment_author": "Copilot",
        "comment_body": "Added comprehensive JSDoc documentation with concrete examples for each case in the getTokenType function. The examples illustrate different scenarios like separator handling, command vs argument detection, and cursor position analysis. This makes the complex logic much easier to understand and maintain. Commit: 0719510",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1799343256",
    "pr_number": 231178,
    "pr_file": "src/vs/workbench/contrib/terminalContrib/clipboard/browser/terminalClipboard.ts",
    "created_at": "2024-10-14T11:47:00+00:00",
    "commented_code": "import { ServicesAccessor } from '../../../../../platform/instantiation/common/instantiation.js';\n import { TerminalSettingId } from '../../../../../platform/terminal/common/terminal.js';\n \n-export async function shouldPasteTerminalText(accessor: ServicesAccessor, text: string, bracketedPasteMode: boolean | undefined): Promise<boolean | { modifiedText: string }> {\n+class SmartPasteUtils {\n+\t/**\n+\t *\n+\t * @param string\n+\t * @returns true if the string is a path\n+\t */",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "1799343256",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 231178,
        "pr_file": "src/vs/workbench/contrib/terminalContrib/clipboard/browser/terminalClipboard.ts",
        "discussion_id": "1799343256",
        "commented_code": "@@ -9,14 +9,84 @@ import { IDialogService } from '../../../../../platform/dialogs/common/dialogs.j\n import { ServicesAccessor } from '../../../../../platform/instantiation/common/instantiation.js';\n import { TerminalSettingId } from '../../../../../platform/terminal/common/terminal.js';\n \n-export async function shouldPasteTerminalText(accessor: ServicesAccessor, text: string, bracketedPasteMode: boolean | undefined): Promise<boolean | { modifiedText: string }> {\n+class SmartPasteUtils {\n+\t/**\n+\t *\n+\t * @param string\n+\t * @returns true if the string is a path\n+\t */",
        "comment_created_at": "2024-10-14T11:47:00+00:00",
        "comment_author": "Tyriar",
        "comment_body": "nit: Prefer a main description over `@returns`, eg. `Whether the provided value looks like a path.`. We also want to either add a description to the parameter or omit it.",
        "pr_file_module": null
      }
    ]
  }
]