[
  {
    "discussion_id": "2200098313",
    "pr_number": 254992,
    "pr_file": "extensions/git/src/git.ts",
    "created_at": "2025-07-11T08:45:39+00:00",
    "commented_code": "return parseGitStashes(result.stdout.trim());\n \t}\n \n+\tasync getWorktrees(): Promise<Worktree[]> {\n+\t\treturn await this.getWorktreesFS();\n+\t}\n+\n+\tprivate async getWorktreesFS(): Promise<Worktree[]> {\n+\t\tconst worktreesPath = path.join(this.repositoryRoot, '.git', 'worktrees');\n+\n+\t\ttry {\n+\t\t\t// List all worktree folder names\n+\t\t\tconst raw = await fs.readdir(worktreesPath);\n+\t\t\tconst result: Worktree[] = [];\n+\n+\t\t\tfor (const name of raw) {\n+\t\t\t\tconst gitdirPath = path.join(worktreesPath, name, 'gitdir');\n+\t\t\t\tconst gitdirContent = (await fs.readFile(gitdirPath, 'utf8')).trim();\n+\t\t\t\t// Remove trailing '/.git'\n+\t\t\t\tconst gitdirTrimmed = gitdirContent.substring(0, gitdirContent.length - '/.git'.length);\n+\t\t\t\tresult.push({ name: name, path: gitdirTrimmed });\n+\t\t\t}\n+\n+\t\t\treturn result;\n+\t\t}\n+\t\tcatch (err) {\n+\t\t\t// There is no worktrees folder, so no worktrees were created",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2200098313",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254992,
        "pr_file": "extensions/git/src/git.ts",
        "discussion_id": "2200098313",
        "commented_code": "@@ -2714,6 +2724,34 @@ export class Repository {\n \t\treturn parseGitStashes(result.stdout.trim());\n \t}\n \n+\tasync getWorktrees(): Promise<Worktree[]> {\n+\t\treturn await this.getWorktreesFS();\n+\t}\n+\n+\tprivate async getWorktreesFS(): Promise<Worktree[]> {\n+\t\tconst worktreesPath = path.join(this.repositoryRoot, '.git', 'worktrees');\n+\n+\t\ttry {\n+\t\t\t// List all worktree folder names\n+\t\t\tconst raw = await fs.readdir(worktreesPath);\n+\t\t\tconst result: Worktree[] = [];\n+\n+\t\t\tfor (const name of raw) {\n+\t\t\t\tconst gitdirPath = path.join(worktreesPath, name, 'gitdir');\n+\t\t\t\tconst gitdirContent = (await fs.readFile(gitdirPath, 'utf8')).trim();\n+\t\t\t\t// Remove trailing '/.git'\n+\t\t\t\tconst gitdirTrimmed = gitdirContent.substring(0, gitdirContent.length - '/.git'.length);\n+\t\t\t\tresult.push({ name: name, path: gitdirTrimmed });\n+\t\t\t}\n+\n+\t\t\treturn result;\n+\t\t}\n+\t\tcatch (err) {\n+\t\t\t// There is no worktrees folder, so no worktrees were created",
        "comment_created_at": "2025-07-11T08:45:39+00:00",
        "comment_author": "lszomoru",
        "comment_body": "We should be more specific here:\n```ts\n\t\t\tif (/ENOENT/.test(err.message)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2194633578",
    "pr_number": 250239,
    "pr_file": "src/vs/workbench/api/common/extHostTreeViews.ts",
    "created_at": "2025-07-09T10:14:32+00:00",
    "commented_code": "}));\n \t}\n \n+\tprivate _loadingPromise: Promise<any> | undefined;\n+\tprivate trackAsLoading<T>(promise: Promise<T>): Promise<T> {\n+\t\tconst chainedPromise = this._loadingPromise ? this._loadingPromise.finally(() => promise) : promise;\n+\t\tconst last = chainedPromise.catch(() => { }).finally(() => {",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2194633578",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 250239,
        "pr_file": "src/vs/workbench/api/common/extHostTreeViews.ts",
        "discussion_id": "2194633578",
        "commented_code": "@@ -416,6 +416,19 @@ class ExtHostTreeView<T> extends Disposable {\n \t\t}));\n \t}\n \n+\tprivate _loadingPromise: Promise<any> | undefined;\n+\tprivate trackAsLoading<T>(promise: Promise<T>): Promise<T> {\n+\t\tconst chainedPromise = this._loadingPromise ? this._loadingPromise.finally(() => promise) : promise;\n+\t\tconst last = chainedPromise.catch(() => { }).finally(() => {",
        "comment_created_at": "2025-07-09T10:14:32+00:00",
        "comment_author": "alexr00",
        "comment_body": "I don't think we want to catch and ignore exception here. Can this be done without the catch?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2185229114",
    "pr_number": 254075,
    "pr_file": "src/vs/platform/extensionManagement/common/unsupportedExtensionsMigration.ts",
    "created_at": "2025-07-04T12:22:26+00:00",
    "commented_code": "logService.error(error);\n \t\t\t}\n \t\t}\n+\n+\t\tif (extensionsControlManifest.autoUpdate) {\n+\t\t\tfor (const [extensionId, version] of Object.entries(extensionsControlManifest.autoUpdate)) {\n+\t\t\t\tconst extensionToAutoUpdate = installed.find(i => areSameExtensions(i.identifier, { id: extensionId }) && semver.lte(i.manifest.version, version));\n+\t\t\t\tif (!extensionToAutoUpdate) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tconst gallery = (await galleryService.getExtensions([{ id: extensionId, preRelease: extensionToAutoUpdate.preRelease }], { targetPlatform: await extensionManagementService.getTargetPlatform(), compatible: true }, CancellationToken.None))[0];",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2185229114",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254075,
        "pr_file": "src/vs/platform/extensionManagement/common/unsupportedExtensionsMigration.ts",
        "discussion_id": "2185229114",
        "commented_code": "@@ -69,6 +70,24 @@ export async function migrateUnsupportedExtensions(extensionManagementService: I\n \t\t\t\tlogService.error(error);\n \t\t\t}\n \t\t}\n+\n+\t\tif (extensionsControlManifest.autoUpdate) {\n+\t\t\tfor (const [extensionId, version] of Object.entries(extensionsControlManifest.autoUpdate)) {\n+\t\t\t\tconst extensionToAutoUpdate = installed.find(i => areSameExtensions(i.identifier, { id: extensionId }) && semver.lte(i.manifest.version, version));\n+\t\t\t\tif (!extensionToAutoUpdate) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tconst gallery = (await galleryService.getExtensions([{ id: extensionId, preRelease: extensionToAutoUpdate.preRelease }], { targetPlatform: await extensionManagementService.getTargetPlatform(), compatible: true }, CancellationToken.None))[0];",
        "comment_created_at": "2025-07-04T12:22:26+00:00",
        "comment_author": "joaomoreno",
        "comment_body": "What happens if there are multiple iterations of this for loop and this call fails? The subsequent ones won't run, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2185236031",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254075,
        "pr_file": "src/vs/platform/extensionManagement/common/unsupportedExtensionsMigration.ts",
        "discussion_id": "2185229114",
        "commented_code": "@@ -69,6 +70,24 @@ export async function migrateUnsupportedExtensions(extensionManagementService: I\n \t\t\t\tlogService.error(error);\n \t\t\t}\n \t\t}\n+\n+\t\tif (extensionsControlManifest.autoUpdate) {\n+\t\t\tfor (const [extensionId, version] of Object.entries(extensionsControlManifest.autoUpdate)) {\n+\t\t\t\tconst extensionToAutoUpdate = installed.find(i => areSameExtensions(i.identifier, { id: extensionId }) && semver.lte(i.manifest.version, version));\n+\t\t\t\tif (!extensionToAutoUpdate) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tconst gallery = (await galleryService.getExtensions([{ id: extensionId, preRelease: extensionToAutoUpdate.preRelease }], { targetPlatform: await extensionManagementService.getTargetPlatform(), compatible: true }, CancellationToken.None))[0];",
        "comment_created_at": "2025-07-04T12:25:48+00:00",
        "comment_author": "sandy081",
        "comment_body": "Yeah! That's right. Since there will be just one extension configured, I ignored it to have minimal change. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2185238410",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254075,
        "pr_file": "src/vs/platform/extensionManagement/common/unsupportedExtensionsMigration.ts",
        "discussion_id": "2185229114",
        "commented_code": "@@ -69,6 +70,24 @@ export async function migrateUnsupportedExtensions(extensionManagementService: I\n \t\t\t\tlogService.error(error);\n \t\t\t}\n \t\t}\n+\n+\t\tif (extensionsControlManifest.autoUpdate) {\n+\t\t\tfor (const [extensionId, version] of Object.entries(extensionsControlManifest.autoUpdate)) {\n+\t\t\t\tconst extensionToAutoUpdate = installed.find(i => areSameExtensions(i.identifier, { id: extensionId }) && semver.lte(i.manifest.version, version));\n+\t\t\t\tif (!extensionToAutoUpdate) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tconst gallery = (await galleryService.getExtensions([{ id: extensionId, preRelease: extensionToAutoUpdate.preRelease }], { targetPlatform: await extensionManagementService.getTargetPlatform(), compatible: true }, CancellationToken.None))[0];",
        "comment_created_at": "2025-07-04T12:26:44+00:00",
        "comment_author": "sandy081",
        "comment_body": "I will add a try/catch block which makes the change correct",
        "pr_file_module": null
      },
      {
        "comment_id": "2185238650",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254075,
        "pr_file": "src/vs/platform/extensionManagement/common/unsupportedExtensionsMigration.ts",
        "discussion_id": "2185229114",
        "commented_code": "@@ -69,6 +70,24 @@ export async function migrateUnsupportedExtensions(extensionManagementService: I\n \t\t\t\tlogService.error(error);\n \t\t\t}\n \t\t}\n+\n+\t\tif (extensionsControlManifest.autoUpdate) {\n+\t\t\tfor (const [extensionId, version] of Object.entries(extensionsControlManifest.autoUpdate)) {\n+\t\t\t\tconst extensionToAutoUpdate = installed.find(i => areSameExtensions(i.identifier, { id: extensionId }) && semver.lte(i.manifest.version, version));\n+\t\t\t\tif (!extensionToAutoUpdate) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tconst gallery = (await galleryService.getExtensions([{ id: extensionId, preRelease: extensionToAutoUpdate.preRelease }], { targetPlatform: await extensionManagementService.getTargetPlatform(), compatible: true }, CancellationToken.None))[0];",
        "comment_created_at": "2025-07-04T12:26:52+00:00",
        "comment_author": "joaomoreno",
        "comment_body": "Please fix it. When you add a second extension to the map you will forget about this.\r\n\r\nIf you just want to have one extension, then turn that `Map` into a `string`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2185247412",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254075,
        "pr_file": "src/vs/platform/extensionManagement/common/unsupportedExtensionsMigration.ts",
        "discussion_id": "2185229114",
        "commented_code": "@@ -69,6 +70,24 @@ export async function migrateUnsupportedExtensions(extensionManagementService: I\n \t\t\t\tlogService.error(error);\n \t\t\t}\n \t\t}\n+\n+\t\tif (extensionsControlManifest.autoUpdate) {\n+\t\t\tfor (const [extensionId, version] of Object.entries(extensionsControlManifest.autoUpdate)) {\n+\t\t\t\tconst extensionToAutoUpdate = installed.find(i => areSameExtensions(i.identifier, { id: extensionId }) && semver.lte(i.manifest.version, version));\n+\t\t\t\tif (!extensionToAutoUpdate) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tconst gallery = (await galleryService.getExtensions([{ id: extensionId, preRelease: extensionToAutoUpdate.preRelease }], { targetPlatform: await extensionManagementService.getTargetPlatform(), compatible: true }, CancellationToken.None))[0];",
        "comment_created_at": "2025-07-04T12:30:54+00:00",
        "comment_author": "sandy081",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2093459720",
    "pr_number": 249056,
    "pr_file": "src/vs/workbench/api/common/extHostMcp.ts",
    "created_at": "2025-05-16T17:46:32+00:00",
    "commented_code": "this._handleSuccessfulStreamableHttp(res);\n \t}\n \n+\tprivate async _populateAuthMetadata(originalResponse: Response): Promise<void> {\n+\t\t// If there is a resource_metadata challenge, use that to get the oauth server. This is done in 2 steps.\n+\t\t// First, extract the resource_metada challenge from the WWW-Authenticate header (if available)\n+\t\tlet resourceMetadataChallenge: string | undefined;\n+\t\tif (originalResponse.headers.has('WWW-Authenticate')) {\n+\t\t\tconst authHeader = originalResponse.headers.get('WWW-Authenticate')!;\n+\t\t\tconst { scheme, params } = parseWWWAuthenticateHeader(authHeader);\n+\t\t\tif (scheme === 'Bearer' && params['resource_metadata']) {\n+\t\t\t\tresourceMetadataChallenge = params['resource_metadata'];\n+\t\t\t}\n+\t\t}\n+\t\t// Second, fetch that url's well-known server metadata\n+\t\tlet serverMetadataUrl: string | undefined;\n+\t\tlet scopesSupported: string[] | undefined;\n+\t\tif (resourceMetadataChallenge) {\n+\t\t\tconst resourceMetadata = await this._getResourceMetadata(resourceMetadataChallenge);",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2093459720",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 249056,
        "pr_file": "src/vs/workbench/api/common/extHostMcp.ts",
        "discussion_id": "2093459720",
        "commented_code": "@@ -278,6 +319,137 @@ class McpHTTPHandle extends Disposable {\n \t\tthis._handleSuccessfulStreamableHttp(res);\n \t}\n \n+\tprivate async _populateAuthMetadata(originalResponse: Response): Promise<void> {\n+\t\t// If there is a resource_metadata challenge, use that to get the oauth server. This is done in 2 steps.\n+\t\t// First, extract the resource_metada challenge from the WWW-Authenticate header (if available)\n+\t\tlet resourceMetadataChallenge: string | undefined;\n+\t\tif (originalResponse.headers.has('WWW-Authenticate')) {\n+\t\t\tconst authHeader = originalResponse.headers.get('WWW-Authenticate')!;\n+\t\t\tconst { scheme, params } = parseWWWAuthenticateHeader(authHeader);\n+\t\t\tif (scheme === 'Bearer' && params['resource_metadata']) {\n+\t\t\t\tresourceMetadataChallenge = params['resource_metadata'];\n+\t\t\t}\n+\t\t}\n+\t\t// Second, fetch that url's well-known server metadata\n+\t\tlet serverMetadataUrl: string | undefined;\n+\t\tlet scopesSupported: string[] | undefined;\n+\t\tif (resourceMetadataChallenge) {\n+\t\t\tconst resourceMetadata = await this._getResourceMetadata(resourceMetadataChallenge);",
        "comment_created_at": "2025-05-16T17:46:32+00:00",
        "comment_author": "connor4312",
        "comment_body": "We should try/catch this and log errors appropriately",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058897031",
    "pr_number": 246643,
    "pr_file": "src/vs/workbench/services/host/electron-sandbox/nativeHostService.ts",
    "created_at": "2025-04-24T17:13:04+00:00",
    "commented_code": "//#region Screenshots\n \n-\tgetScreenshot(): Promise<VSBuffer | undefined> {\n-\t\treturn this.nativeHostService.getScreenshot();\n+\tgetScreenshot(rect?: IRectangle): Promise<VSBuffer | undefined> {\n+\t\treturn this.nativeHostService.getScreenshot(rect);\n+\t}\n+\n+\tgetElementData(offsetX: number, offsetY: number, token?: CancellationToken): Promise<IElementData | undefined> {\n+\t\tif (token) {\n+\t\t\tthis._register(token.onCancellationRequested(() => {",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2058897031",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 246643,
        "pr_file": "src/vs/workbench/services/host/electron-sandbox/nativeHostService.ts",
        "discussion_id": "2058897031",
        "commented_code": "@@ -193,8 +195,18 @@ class WorkbenchHostService extends Disposable implements IHostService {\n \n \t//#region Screenshots\n \n-\tgetScreenshot(): Promise<VSBuffer | undefined> {\n-\t\treturn this.nativeHostService.getScreenshot();\n+\tgetScreenshot(rect?: IRectangle): Promise<VSBuffer | undefined> {\n+\t\treturn this.nativeHostService.getScreenshot(rect);\n+\t}\n+\n+\tgetElementData(offsetX: number, offsetY: number, token?: CancellationToken): Promise<IElementData | undefined> {\n+\t\tif (token) {\n+\t\t\tthis._register(token.onCancellationRequested(() => {",
        "comment_created_at": "2025-04-24T17:13:04+00:00",
        "comment_author": "connor4312",
        "comment_body": "This leaks the disposable if `getElementData` is called repeatedly, individually dispose it after `getElementData` settles.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058920486",
    "pr_number": 246643,
    "pr_file": "src/vs/platform/native/electron-main/nativeHostMainService.ts",
    "created_at": "2025-04-24T17:26:04+00:00",
    "commented_code": "//#region Screenshots\n \n-\tasync getScreenshot(windowId: number | undefined, options?: INativeHostOptions): Promise<VSBuffer | undefined> {\n+\tasync getScreenshot(windowId: number | undefined, rect?: IRectangle, options?: INativeHostOptions): Promise<VSBuffer | undefined> {\n \t\tconst window = this.windowById(options?.targetWindowId, windowId);\n-\t\tconst captured = await window?.win?.webContents.capturePage();\n+\t\tconst captured = await window?.win?.webContents.capturePage(rect);\n \n \t\tconst buf = captured?.toJPEG(95);\n \t\treturn buf && VSBuffer.wrap(buf);\n \t}\n \n+\tasync getElementData(windowId: number | undefined, offsetX: number = 0, offsetY: number = 0, token?: CancellationToken): Promise<IElementData | undefined> {\n+\t\tconst window = this.windowById(windowId, windowId);\n+\t\tif (!window?.win) {\n+\t\t\treturn undefined;\n+\t\t}\n+\n+\t\t// Find the simple browser webview\n+\t\tconst allWebContents = webContents.getAllWebContents();\n+\t\tconst simpleBrowserWebview = allWebContents.find(webContent => webContent.getTitle().includes('Simple Browser'));\n+\n+\t\tif (!simpleBrowserWebview) {\n+\t\t\treturn undefined;\n+\t\t}\n+\n+\t\tconst debuggers = simpleBrowserWebview.debugger;\n+\t\tdebuggers.attach();\n+\n+\t\tconst { targetInfos } = await debuggers.sendCommand('Target.getTargets');\n+\t\tlet resultId: string | undefined = undefined;\n+\t\tlet target: typeof targetInfos[number] | undefined = undefined;\n+\t\tlet targetSessionId: number | undefined = undefined;\n+\t\ttry {\n+\t\t\t// find parent id and extract id\n+\t\t\tconst matchingTarget = targetInfos.find((targetInfo: { url: string }) => {\n+\t\t\t\tconst url = new URL(targetInfo.url);\n+\t\t\t\treturn url.searchParams.get('parentId') === window?.id.toString();\n+\t\t\t});\n+\n+\t\t\tif (matchingTarget) {\n+\t\t\t\tconst url = new URL(matchingTarget.url);\n+\t\t\t\tresultId = url.searchParams.get('id')!;\n+\t\t\t}\n+\n+\t\t\t// use id to grab simple browser target\n+\t\t\tif (resultId) {\n+\t\t\t\ttarget = targetInfos.find((targetInfo: { url: string }) => {\n+\t\t\t\t\tconst url = new URL(targetInfo.url);\n+\t\t\t\t\treturn url.searchParams.get('id') === resultId && url.searchParams.get('vscodeBrowserReqId')!;\n+\t\t\t\t});\n+\t\t\t}\n+\n+\t\t\tconst { sessionId } = await debuggers.sendCommand('Target.attachToTarget', {\n+\t\t\t\ttargetId: target.targetId,\n+\t\t\t\tflatten: true,\n+\t\t\t});\n+\n+\t\t\ttargetSessionId = sessionId;\n+\n+\t\t\tawait debuggers.sendCommand('DOM.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('CSS.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('Overlay.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('Debugger.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('Runtime.enable', {}, sessionId);\n+\n+\t\t\tawait debuggers.sendCommand('Runtime.evaluate', {\n+\t\t\t\texpression: `(function() {\n+\t\t\t\t\tconst style = document.createElement('style');\n+\t\t\t\t\tstyle.id = '__pseudoBlocker__';\n+\t\t\t\t\tstyle.textContent = '*::before, *::after { pointer-events: none !important; }';\n+\t\t\t\t\tdocument.head.appendChild(style);\n+\t\t\t\t})();`,\n+\t\t\t}, sessionId);\n+\n+\t\t\t// slightly changed default CDP debugger inspect colors\n+\t\t\tawait debuggers.sendCommand('Overlay.setInspectMode', {\n+\t\t\t\tmode: 'searchForNode',\n+\t\t\t\thighlightConfig: {\n+\t\t\t\t\tshowInfo: true,\n+\t\t\t\t\tshowRulers: false,\n+\t\t\t\t\tshowStyles: true,\n+\t\t\t\t\tshowAccessibilityInfo: true,\n+\t\t\t\t\tshowExtensionLines: false,\n+\t\t\t\t\tcontrastAlgorithm: 'aa',\n+\t\t\t\t\tcontentColor: { r: 173, g: 216, b: 255, a: 0.8 },\n+\t\t\t\t\tpaddingColor: { r: 150, g: 200, b: 255, a: 0.5 },\n+\t\t\t\t\tborderColor: { r: 120, g: 180, b: 255, a: 0.7 },\n+\t\t\t\t\tmarginColor: { r: 200, g: 220, b: 255, a: 0.4 },\n+\t\t\t\t\teventTargetColor: { r: 130, g: 160, b: 255, a: 0.8 },\n+\t\t\t\t\tshapeColor: { r: 130, g: 160, b: 255, a: 0.8 },\n+\t\t\t\t\tshapeMarginColor: { r: 130, g: 160, b: 255, a: 0.5 },\n+\t\t\t\t\tgridHighlightConfig: {\n+\t\t\t\t\t\trowGapColor: { r: 140, g: 190, b: 255, a: 0.3 },\n+\t\t\t\t\t\trowHatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\tcolumnGapColor: { r: 140, g: 190, b: 255, a: 0.3 },\n+\t\t\t\t\t\tcolumnHatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\trowLineColor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\tcolumnLineColor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\trowLineDash: true,\n+\t\t\t\t\t\tcolumnLineDash: true\n+\t\t\t\t\t},\n+\t\t\t\t\tflexContainerHighlightConfig: {\n+\t\t\t\t\t\tcontainerBorder: {\n+\t\t\t\t\t\t\tcolor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\titemSeparator: {\n+\t\t\t\t\t\t\tcolor: { r: 140, g: 190, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tlineSeparator: {\n+\t\t\t\t\t\t\tcolor: { r: 140, g: 190, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tmainDistributedSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcrossDistributedSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\trowGapSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcolumnGapSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t}\n+\t\t\t\t\t},\n+\t\t\t\t\tflexItemHighlightConfig: {\n+\t\t\t\t\t\tbaseSizeBox: {\n+\t\t\t\t\t\t\thatchColor: { r: 130, g: 170, b: 255, a: 0.6 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tbaseSizeBorder: {\n+\t\t\t\t\t\t\tcolor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tflexibilityArrow: {\n+\t\t\t\t\t\t\tcolor: { r: 130, g: 190, b: 255 }\n+\t\t\t\t\t\t}\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}, sessionId);\n+\t\t} catch (e) {\n+\t\t\tdebuggers.detach();\n+\t\t\tthrow new Error('No target found', e);\n+\t\t}\n+\n+\t\tif (!targetSessionId) {\n+\t\t\tdebuggers.detach();\n+\t\t\tthrow new Error('No target session id found');\n+\t\t}\n+\n+\t\tconst nodeData = await this.getNodeData(targetSessionId, debuggers, window.win);\n+\t\tdebuggers.detach();\n+\n+\t\tconst zoomFactor = simpleBrowserWebview.getZoomFactor();\n+\t\tconst scaledBounds = {\n+\t\t\tx: (nodeData.bounds.x + offsetX) * zoomFactor,\n+\t\t\ty: (nodeData.bounds.y + offsetY) * zoomFactor,\n+\t\t\twidth: nodeData.bounds.width * zoomFactor,\n+\t\t\theight: nodeData.bounds.height * zoomFactor\n+\t\t};\n+\n+\t\treturn { outerHTML: nodeData.outerHTML, computedStyle: nodeData.computedStyle, bounds: scaledBounds };\n+\t}\n+\n+\tasync getNodeData(sessionId: number, debuggers: any, window: BrowserWindow): Promise<NodeDataResponse> {\n+\t\treturn new Promise((resolve) => {\n+\t\t\tconst onMessage = async (event: any, method: string, params: { backendNodeId: number }) => {\n+\t\t\t\tif (method === 'Overlay.inspectNodeRequested') {\n+\n+\t\t\t\t\tawait debuggers.sendCommand('Runtime.evaluate', {\n+\t\t\t\t\t\texpression: `(() => {\n+\t\t\t\t\t\t\t\tconst style = document.getElementById('__pseudoBlocker__');\n+\t\t\t\t\t\t\t\tif (style) style.remove();\n+\t\t\t\t\t\t\t})();`,\n+\t\t\t\t\t}, sessionId);\n+\n+\n+\t\t\t\t\tdebuggers.off('message', onMessage);\n+\t\t\t\t\tconst backendNodeId = params?.backendNodeId;\n+\t\t\t\t\tif (!backendNodeId) {\n+\t\t\t\t\t\tthrow new Error('Missing backendNodeId in inspectNodeRequested event');\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tawait debuggers.sendCommand('DOM.getDocument', {}, sessionId);\n+\t\t\t\t\t\tconst { nodeIds } = await debuggers.sendCommand('DOM.pushNodesByBackendIdsToFrontend', { backendNodeIds: [backendNodeId] }, sessionId);\n+\t\t\t\t\t\tif (!nodeIds || nodeIds.length === 0) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get node IDs.');\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tconst nodeId = nodeIds[0];\n+\n+\t\t\t\t\t\tconst { model } = await debuggers.sendCommand('DOM.getBoxModel', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!model) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get box model.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconst margin = model.margin;\n+\t\t\t\t\t\tconst x = margin[0];\n+\t\t\t\t\t\tconst y = margin[1] + 32.4 + 35; // 32.4 is height of the title bar, 35 is height of the tab bar\n+\t\t\t\t\t\tconst width = margin[2] - margin[0];\n+\t\t\t\t\t\tconst height = margin[5] - margin[1];\n+\n+\t\t\t\t\t\tconst matched = await debuggers.sendCommand('CSS.getMatchedStylesForNode', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!matched) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get matched css.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconst response: ComputedStyleResponse = await debuggers.sendCommand('CSS.getComputedStyleForNode', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!response || !response.computedStyle) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get computed style.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconst formatted = this.formatMatchedStyles(matched, response);\n+\n+\t\t\t\t\t\tconst { outerHTML } = await debuggers.sendCommand('DOM.getOuterHTML', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!outerHTML) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get outerHTML.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tresolve({\n+\t\t\t\t\t\t\touterHTML,\n+\t\t\t\t\t\t\tcomputedStyle: formatted,\n+\t\t\t\t\t\t\tbounds: { x, y, width, height }\n+\t\t\t\t\t\t});\n+\t\t\t\t\t} catch (err) {\n+\t\t\t\t\t\tdebuggers.detach();\n+\t\t\t\t\t\tthrow new Error(`Failed to get node data: ${err}`);",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2058920486",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 246643,
        "pr_file": "src/vs/platform/native/electron-main/nativeHostMainService.ts",
        "discussion_id": "2058920486",
        "commented_code": "@@ -742,14 +757,315 @@ export class NativeHostMainService extends Disposable implements INativeHostMain\n \n \t//#region Screenshots\n \n-\tasync getScreenshot(windowId: number | undefined, options?: INativeHostOptions): Promise<VSBuffer | undefined> {\n+\tasync getScreenshot(windowId: number | undefined, rect?: IRectangle, options?: INativeHostOptions): Promise<VSBuffer | undefined> {\n \t\tconst window = this.windowById(options?.targetWindowId, windowId);\n-\t\tconst captured = await window?.win?.webContents.capturePage();\n+\t\tconst captured = await window?.win?.webContents.capturePage(rect);\n \n \t\tconst buf = captured?.toJPEG(95);\n \t\treturn buf && VSBuffer.wrap(buf);\n \t}\n \n+\tasync getElementData(windowId: number | undefined, offsetX: number = 0, offsetY: number = 0, token?: CancellationToken): Promise<IElementData | undefined> {\n+\t\tconst window = this.windowById(windowId, windowId);\n+\t\tif (!window?.win) {\n+\t\t\treturn undefined;\n+\t\t}\n+\n+\t\t// Find the simple browser webview\n+\t\tconst allWebContents = webContents.getAllWebContents();\n+\t\tconst simpleBrowserWebview = allWebContents.find(webContent => webContent.getTitle().includes('Simple Browser'));\n+\n+\t\tif (!simpleBrowserWebview) {\n+\t\t\treturn undefined;\n+\t\t}\n+\n+\t\tconst debuggers = simpleBrowserWebview.debugger;\n+\t\tdebuggers.attach();\n+\n+\t\tconst { targetInfos } = await debuggers.sendCommand('Target.getTargets');\n+\t\tlet resultId: string | undefined = undefined;\n+\t\tlet target: typeof targetInfos[number] | undefined = undefined;\n+\t\tlet targetSessionId: number | undefined = undefined;\n+\t\ttry {\n+\t\t\t// find parent id and extract id\n+\t\t\tconst matchingTarget = targetInfos.find((targetInfo: { url: string }) => {\n+\t\t\t\tconst url = new URL(targetInfo.url);\n+\t\t\t\treturn url.searchParams.get('parentId') === window?.id.toString();\n+\t\t\t});\n+\n+\t\t\tif (matchingTarget) {\n+\t\t\t\tconst url = new URL(matchingTarget.url);\n+\t\t\t\tresultId = url.searchParams.get('id')!;\n+\t\t\t}\n+\n+\t\t\t// use id to grab simple browser target\n+\t\t\tif (resultId) {\n+\t\t\t\ttarget = targetInfos.find((targetInfo: { url: string }) => {\n+\t\t\t\t\tconst url = new URL(targetInfo.url);\n+\t\t\t\t\treturn url.searchParams.get('id') === resultId && url.searchParams.get('vscodeBrowserReqId')!;\n+\t\t\t\t});\n+\t\t\t}\n+\n+\t\t\tconst { sessionId } = await debuggers.sendCommand('Target.attachToTarget', {\n+\t\t\t\ttargetId: target.targetId,\n+\t\t\t\tflatten: true,\n+\t\t\t});\n+\n+\t\t\ttargetSessionId = sessionId;\n+\n+\t\t\tawait debuggers.sendCommand('DOM.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('CSS.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('Overlay.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('Debugger.enable', {}, sessionId);\n+\t\t\tawait debuggers.sendCommand('Runtime.enable', {}, sessionId);\n+\n+\t\t\tawait debuggers.sendCommand('Runtime.evaluate', {\n+\t\t\t\texpression: `(function() {\n+\t\t\t\t\tconst style = document.createElement('style');\n+\t\t\t\t\tstyle.id = '__pseudoBlocker__';\n+\t\t\t\t\tstyle.textContent = '*::before, *::after { pointer-events: none !important; }';\n+\t\t\t\t\tdocument.head.appendChild(style);\n+\t\t\t\t})();`,\n+\t\t\t}, sessionId);\n+\n+\t\t\t// slightly changed default CDP debugger inspect colors\n+\t\t\tawait debuggers.sendCommand('Overlay.setInspectMode', {\n+\t\t\t\tmode: 'searchForNode',\n+\t\t\t\thighlightConfig: {\n+\t\t\t\t\tshowInfo: true,\n+\t\t\t\t\tshowRulers: false,\n+\t\t\t\t\tshowStyles: true,\n+\t\t\t\t\tshowAccessibilityInfo: true,\n+\t\t\t\t\tshowExtensionLines: false,\n+\t\t\t\t\tcontrastAlgorithm: 'aa',\n+\t\t\t\t\tcontentColor: { r: 173, g: 216, b: 255, a: 0.8 },\n+\t\t\t\t\tpaddingColor: { r: 150, g: 200, b: 255, a: 0.5 },\n+\t\t\t\t\tborderColor: { r: 120, g: 180, b: 255, a: 0.7 },\n+\t\t\t\t\tmarginColor: { r: 200, g: 220, b: 255, a: 0.4 },\n+\t\t\t\t\teventTargetColor: { r: 130, g: 160, b: 255, a: 0.8 },\n+\t\t\t\t\tshapeColor: { r: 130, g: 160, b: 255, a: 0.8 },\n+\t\t\t\t\tshapeMarginColor: { r: 130, g: 160, b: 255, a: 0.5 },\n+\t\t\t\t\tgridHighlightConfig: {\n+\t\t\t\t\t\trowGapColor: { r: 140, g: 190, b: 255, a: 0.3 },\n+\t\t\t\t\t\trowHatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\tcolumnGapColor: { r: 140, g: 190, b: 255, a: 0.3 },\n+\t\t\t\t\t\tcolumnHatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\trowLineColor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\tcolumnLineColor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\trowLineDash: true,\n+\t\t\t\t\t\tcolumnLineDash: true\n+\t\t\t\t\t},\n+\t\t\t\t\tflexContainerHighlightConfig: {\n+\t\t\t\t\t\tcontainerBorder: {\n+\t\t\t\t\t\t\tcolor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\titemSeparator: {\n+\t\t\t\t\t\t\tcolor: { r: 140, g: 190, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tlineSeparator: {\n+\t\t\t\t\t\t\tcolor: { r: 140, g: 190, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tmainDistributedSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcrossDistributedSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\trowGapSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcolumnGapSpace: {\n+\t\t\t\t\t\t\thatchColor: { r: 140, g: 190, b: 255, a: 0.7 },\n+\t\t\t\t\t\t\tfillColor: { r: 140, g: 190, b: 255, a: 0.4 }\n+\t\t\t\t\t\t}\n+\t\t\t\t\t},\n+\t\t\t\t\tflexItemHighlightConfig: {\n+\t\t\t\t\t\tbaseSizeBox: {\n+\t\t\t\t\t\t\thatchColor: { r: 130, g: 170, b: 255, a: 0.6 }\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tbaseSizeBorder: {\n+\t\t\t\t\t\t\tcolor: { r: 120, g: 180, b: 255 },\n+\t\t\t\t\t\t\tpattern: 'solid'\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tflexibilityArrow: {\n+\t\t\t\t\t\t\tcolor: { r: 130, g: 190, b: 255 }\n+\t\t\t\t\t\t}\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}, sessionId);\n+\t\t} catch (e) {\n+\t\t\tdebuggers.detach();\n+\t\t\tthrow new Error('No target found', e);\n+\t\t}\n+\n+\t\tif (!targetSessionId) {\n+\t\t\tdebuggers.detach();\n+\t\t\tthrow new Error('No target session id found');\n+\t\t}\n+\n+\t\tconst nodeData = await this.getNodeData(targetSessionId, debuggers, window.win);\n+\t\tdebuggers.detach();\n+\n+\t\tconst zoomFactor = simpleBrowserWebview.getZoomFactor();\n+\t\tconst scaledBounds = {\n+\t\t\tx: (nodeData.bounds.x + offsetX) * zoomFactor,\n+\t\t\ty: (nodeData.bounds.y + offsetY) * zoomFactor,\n+\t\t\twidth: nodeData.bounds.width * zoomFactor,\n+\t\t\theight: nodeData.bounds.height * zoomFactor\n+\t\t};\n+\n+\t\treturn { outerHTML: nodeData.outerHTML, computedStyle: nodeData.computedStyle, bounds: scaledBounds };\n+\t}\n+\n+\tasync getNodeData(sessionId: number, debuggers: any, window: BrowserWindow): Promise<NodeDataResponse> {\n+\t\treturn new Promise((resolve) => {\n+\t\t\tconst onMessage = async (event: any, method: string, params: { backendNodeId: number }) => {\n+\t\t\t\tif (method === 'Overlay.inspectNodeRequested') {\n+\n+\t\t\t\t\tawait debuggers.sendCommand('Runtime.evaluate', {\n+\t\t\t\t\t\texpression: `(() => {\n+\t\t\t\t\t\t\t\tconst style = document.getElementById('__pseudoBlocker__');\n+\t\t\t\t\t\t\t\tif (style) style.remove();\n+\t\t\t\t\t\t\t})();`,\n+\t\t\t\t\t}, sessionId);\n+\n+\n+\t\t\t\t\tdebuggers.off('message', onMessage);\n+\t\t\t\t\tconst backendNodeId = params?.backendNodeId;\n+\t\t\t\t\tif (!backendNodeId) {\n+\t\t\t\t\t\tthrow new Error('Missing backendNodeId in inspectNodeRequested event');\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tawait debuggers.sendCommand('DOM.getDocument', {}, sessionId);\n+\t\t\t\t\t\tconst { nodeIds } = await debuggers.sendCommand('DOM.pushNodesByBackendIdsToFrontend', { backendNodeIds: [backendNodeId] }, sessionId);\n+\t\t\t\t\t\tif (!nodeIds || nodeIds.length === 0) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get node IDs.');\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tconst nodeId = nodeIds[0];\n+\n+\t\t\t\t\t\tconst { model } = await debuggers.sendCommand('DOM.getBoxModel', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!model) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get box model.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconst margin = model.margin;\n+\t\t\t\t\t\tconst x = margin[0];\n+\t\t\t\t\t\tconst y = margin[1] + 32.4 + 35; // 32.4 is height of the title bar, 35 is height of the tab bar\n+\t\t\t\t\t\tconst width = margin[2] - margin[0];\n+\t\t\t\t\t\tconst height = margin[5] - margin[1];\n+\n+\t\t\t\t\t\tconst matched = await debuggers.sendCommand('CSS.getMatchedStylesForNode', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!matched) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get matched css.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconst response: ComputedStyleResponse = await debuggers.sendCommand('CSS.getComputedStyleForNode', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!response || !response.computedStyle) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get computed style.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconst formatted = this.formatMatchedStyles(matched, response);\n+\n+\t\t\t\t\t\tconst { outerHTML } = await debuggers.sendCommand('DOM.getOuterHTML', { nodeId }, sessionId);\n+\t\t\t\t\t\tif (!outerHTML) {\n+\t\t\t\t\t\t\tthrow new Error('Failed to get outerHTML.');\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tresolve({\n+\t\t\t\t\t\t\touterHTML,\n+\t\t\t\t\t\t\tcomputedStyle: formatted,\n+\t\t\t\t\t\t\tbounds: { x, y, width, height }\n+\t\t\t\t\t\t});\n+\t\t\t\t\t} catch (err) {\n+\t\t\t\t\t\tdebuggers.detach();\n+\t\t\t\t\t\tthrow new Error(`Failed to get node data: ${err}`);",
        "comment_created_at": "2025-04-24T17:26:04+00:00",
        "comment_author": "connor4312",
        "comment_body": "This error will be unhandled, you want to make sure to reject the promise",
        "pr_file_module": null
      }
    ]
  }
]