[
  {
    "discussion_id": "2197142303",
    "pr_number": 254992,
    "pr_file": "extensions/git/src/git.ts",
    "created_at": "2025-07-10T09:37:28+00:00",
    "commented_code": "}\n \t}\n \n+\tasync getWorktrees(): Promise<Worktree[]> {",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2197142303",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 254992,
        "pr_file": "extensions/git/src/git.ts",
        "discussion_id": "2197142303",
        "commented_code": "@@ -2999,6 +3073,11 @@ export class Repository {\n \t\t}\n \t}\n \n+\tasync getWorktrees(): Promise<Worktree[]> {",
        "comment_created_at": "2025-07-10T09:37:28+00:00",
        "comment_author": "lszomoru",
        "comment_body": "This method is being called on a very hot path \ud83d\udd25 so we would like to avoid spawning a child process to run git because of the performance implications. We should try to use file system operations to determine whether there are any worktrees:\n* check whether `.git/worktrees` has any subfolders\n* If there are:\n    * the worktree folder name is the name of the worktree\n    * in the worktree folder look at the contents of the `gitdir` file and that is the path of the worktree",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172897428",
    "pr_number": 252703,
    "pr_file": "src/vs/platform/shell/node/shellEnv.ts",
    "created_at": "2025-06-27T21:31:05+00:00",
    "commented_code": "const systemShell = await getSystemShell(OS, env); // note: windows always resolves a powershell instance\n \tlogService.trace('doResolveShellEnv#shell', systemShell);\n \n-\tlet name = basename(systemShell);\n-\tif (isWindows) {\n-\t\tconst nameExt = extname(name);\n-\t\tif (getWindowPathExtensions().some(e => equalsIgnoreCase(e, nameExt))) {\n-\t\t\tname = name.substring(0, name.length - nameExt.length); // remove any .exe/.cmd/... from the name for matching logic on Windows\n-\t\t}\n-\t}\n-\n+\tconst name = basename(systemShell);\n \tlet command: string, shellArgs: Array<string>;\n \tconst extraArgs = '';\n \tif (/^(?:pwsh|powershell)(?:-preview)?$/.test(name)) {\n-\t\tconst profilePaths = await getPowershellProfilePaths(systemShell);\n+\t\tconst profilePaths = await getPowershellProfilePaths();\n \t\tconst profilePathThatExists = await first(profilePaths.map(profilePath => async () => (await FSPromises.exists(profilePath)) ? profilePath : undefined));",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2172897428",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 252703,
        "pr_file": "src/vs/platform/shell/node/shellEnv.ts",
        "discussion_id": "2172897428",
        "commented_code": "@@ -116,18 +118,11 @@ async function doResolveShellEnv(logService: ILogService, token: CancellationTok\n \tconst systemShell = await getSystemShell(OS, env); // note: windows always resolves a powershell instance\n \tlogService.trace('doResolveShellEnv#shell', systemShell);\n \n-\tlet name = basename(systemShell);\n-\tif (isWindows) {\n-\t\tconst nameExt = extname(name);\n-\t\tif (getWindowPathExtensions().some(e => equalsIgnoreCase(e, nameExt))) {\n-\t\t\tname = name.substring(0, name.length - nameExt.length); // remove any .exe/.cmd/... from the name for matching logic on Windows\n-\t\t}\n-\t}\n-\n+\tconst name = basename(systemShell);\n \tlet command: string, shellArgs: Array<string>;\n \tconst extraArgs = '';\n \tif (/^(?:pwsh|powershell)(?:-preview)?$/.test(name)) {\n-\t\tconst profilePaths = await getPowershellProfilePaths(systemShell);\n+\t\tconst profilePaths = await getPowershellProfilePaths();\n \t\tconst profilePathThatExists = await first(profilePaths.map(profilePath => async () => (await FSPromises.exists(profilePath)) ? profilePath : undefined));",
        "comment_created_at": "2025-06-27T21:31:05+00:00",
        "comment_author": "Tyriar",
        "comment_body": "I don't think we need to be doing this anymore? The less awaits in this code the better.\r\n\r\nPreviously it looked like this:\r\n\r\n```\r\n\t\t\t// Older versions of PowerShell removes double quotes sometimes so we use \"double single quotes\" which is how\r\n\t\t\t// you escape single quotes inside of a single quoted string.\r\n\t\t\tcommand = `& '${process.execPath}' ${extraArgs} -p '''${mark}'' + JSON.stringify(process.env) + ''${mark}'''`;\r\n\t\t\tshellArgs = ['-Login', '-Command'];\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2172912153",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 252703,
        "pr_file": "src/vs/platform/shell/node/shellEnv.ts",
        "discussion_id": "2172897428",
        "commented_code": "@@ -116,18 +118,11 @@ async function doResolveShellEnv(logService: ILogService, token: CancellationTok\n \tconst systemShell = await getSystemShell(OS, env); // note: windows always resolves a powershell instance\n \tlogService.trace('doResolveShellEnv#shell', systemShell);\n \n-\tlet name = basename(systemShell);\n-\tif (isWindows) {\n-\t\tconst nameExt = extname(name);\n-\t\tif (getWindowPathExtensions().some(e => equalsIgnoreCase(e, nameExt))) {\n-\t\t\tname = name.substring(0, name.length - nameExt.length); // remove any .exe/.cmd/... from the name for matching logic on Windows\n-\t\t}\n-\t}\n-\n+\tconst name = basename(systemShell);\n \tlet command: string, shellArgs: Array<string>;\n \tconst extraArgs = '';\n \tif (/^(?:pwsh|powershell)(?:-preview)?$/.test(name)) {\n-\t\tconst profilePaths = await getPowershellProfilePaths(systemShell);\n+\t\tconst profilePaths = await getPowershellProfilePaths();\n \t\tconst profilePathThatExists = await first(profilePaths.map(profilePath => async () => (await FSPromises.exists(profilePath)) ? profilePath : undefined));",
        "comment_created_at": "2025-06-27T21:49:57+00:00",
        "comment_author": "connor4312",
        "comment_body": "This still avoids doing shell resolution if no profile file is configured, which saves boot time. File existence checks are super cheap compared to launching the shell, so avoiding it is good.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1481339840",
    "pr_number": 199021,
    "pr_file": "src/vs/editor/common/viewModel/viewModelLines.ts",
    "created_at": "2024-02-07T11:37:07+00:00",
    "commented_code": "}\n \n \t\tconst linesContent = this.model.getLinesContent();\n-\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n+\t\tconst injectedTextDecorations = this.model.getAllDecorations(this._editorId);",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "1481339840",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 199021,
        "pr_file": "src/vs/editor/common/viewModel/viewModelLines.ts",
        "discussion_id": "1481339840",
        "commented_code": "@@ -124,7 +125,7 @@ export class ViewModelLinesFromProjectedModel implements IViewModelLines {\n \t\t}\n \n \t\tconst linesContent = this.model.getLinesContent();\n-\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n+\t\tconst injectedTextDecorations = this.model.getAllDecorations(this._editorId);",
        "comment_created_at": "2024-02-07T11:37:07+00:00",
        "comment_author": "hediet",
        "comment_body": "We really shouldn't query all decorations here.\nThere could be thousands of them (e.g. bracket pair colorization uses decorations, so this would list all brackets in the entire document).\n`getAllDecorations` should never be used.\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1528649606",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 199021,
        "pr_file": "src/vs/editor/common/viewModel/viewModelLines.ts",
        "discussion_id": "1481339840",
        "commented_code": "@@ -124,7 +125,7 @@ export class ViewModelLinesFromProjectedModel implements IViewModelLines {\n \t\t}\n \n \t\tconst linesContent = this.model.getLinesContent();\n-\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n+\t\tconst injectedTextDecorations = this.model.getAllDecorations(this._editorId);",
        "comment_created_at": "2024-03-18T14:14:42+00:00",
        "comment_author": "remcohaszing",
        "comment_body": "Should we handled this here instead?\r\n\r\nhttps://github.com/microsoft/vscode/blob/19a78385c78f142c0e30ee94cabad145a393a03f/src/vs/editor/common/model/textModel.ts#L2110-L2118\r\n\r\nWe could change `_injectedTextDecorationsTree` to include decorations that have `inlineClassNameAffectsLetterSpacing` enabled. Alternatively we could add a new `IntervalTree` which is used to track all decorations that enable `inlineClassNameAffectsLetterSpacing`. In this case we don\u2019t need to use `getAllDecorations`. `LineInjectedText` could be adjusted to also support decorations with `inlineClassNameAffectsLetterSpacing`. Then there\u2019s no need anymore for `lineBreaksComputer.finalize()` to accept any arguments.",
        "pr_file_module": null
      },
      {
        "comment_id": "2104616555",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 199021,
        "pr_file": "src/vs/editor/common/viewModel/viewModelLines.ts",
        "discussion_id": "1481339840",
        "commented_code": "@@ -124,7 +125,7 @@ export class ViewModelLinesFromProjectedModel implements IViewModelLines {\n \t\t}\n \n \t\tconst linesContent = this.model.getLinesContent();\n-\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n+\t\tconst injectedTextDecorations = this.model.getAllDecorations(this._editorId);",
        "comment_created_at": "2025-05-23T13:37:31+00:00",
        "comment_author": "remcohaszing",
        "comment_body": "`getAllDecorations` was problematic indeed. It\u2019s no longer used.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2032519256",
    "pr_number": 245922,
    "pr_file": "src/vs/workbench/contrib/chat/browser/chatAttachmentResolve.ts",
    "created_at": "2025-04-08T06:59:28+00:00",
    "commented_code": "};\n const SUPPORTED_IMAGE_EXTENSIONS_REGEX = /\\.(png|jpg|jpeg|gif|webp)$/i;\n \n-export async function resolveImageEditorAttachContext(editor: EditorInput | IDraggedResourceEditorInput, fileService: IFileService, dialogService: IDialogService): Promise<IChatRequestVariableEntry | undefined> {\n-\tif (!editor.resource) {\n+export async function resolveImageEditorAttachContext(resource: URI, fileService: IFileService, dialogService: IDialogService, data?: VSBuffer): Promise<IChatRequestVariableEntry | undefined> {\n+\tif (!resource) {\n \t\treturn undefined;\n \t}\n \n-\tconst match = SUPPORTED_IMAGE_EXTENSIONS_REGEX.exec(editor.resource.path);\n+\tconst match = SUPPORTED_IMAGE_EXTENSIONS_REGEX.exec(resource.path);\n \tif (!match) {\n \t\treturn undefined;\n \t}\n \n \tconst mimeType = getMimeTypeFromPath(match);\n-\tconst fileName = basename(editor.resource);\n-\tconst readFile = await fileService.readFile(editor.resource);\n+\tconst fileName = basename(resource);\n+\n+\tlet dataBuffer: VSBuffer | undefined;\n+\tif (data) {\n+\t\tdataBuffer = data;\n+\t} else {\n+\t\tconst readFile = await fileService.readFile(resource);",
    "repo_full_name": "microsoft/vscode",
    "discussion_comments": [
      {
        "comment_id": "2032519256",
        "repo_full_name": "microsoft/vscode",
        "pr_number": 245922,
        "pr_file": "src/vs/workbench/contrib/chat/browser/chatAttachmentResolve.ts",
        "discussion_id": "2032519256",
        "commented_code": "@@ -113,32 +114,40 @@ export type ImageTransferData = {\n };\n const SUPPORTED_IMAGE_EXTENSIONS_REGEX = /\\.(png|jpg|jpeg|gif|webp)$/i;\n \n-export async function resolveImageEditorAttachContext(editor: EditorInput | IDraggedResourceEditorInput, fileService: IFileService, dialogService: IDialogService): Promise<IChatRequestVariableEntry | undefined> {\n-\tif (!editor.resource) {\n+export async function resolveImageEditorAttachContext(resource: URI, fileService: IFileService, dialogService: IDialogService, data?: VSBuffer): Promise<IChatRequestVariableEntry | undefined> {\n+\tif (!resource) {\n \t\treturn undefined;\n \t}\n \n-\tconst match = SUPPORTED_IMAGE_EXTENSIONS_REGEX.exec(editor.resource.path);\n+\tconst match = SUPPORTED_IMAGE_EXTENSIONS_REGEX.exec(resource.path);\n \tif (!match) {\n \t\treturn undefined;\n \t}\n \n \tconst mimeType = getMimeTypeFromPath(match);\n-\tconst fileName = basename(editor.resource);\n-\tconst readFile = await fileService.readFile(editor.resource);\n+\tconst fileName = basename(resource);\n+\n+\tlet dataBuffer: VSBuffer | undefined;\n+\tif (data) {\n+\t\tdataBuffer = data;\n+\t} else {\n+\t\tconst readFile = await fileService.readFile(resource);",
        "comment_created_at": "2025-04-08T06:59:28+00:00",
        "comment_author": "jrieken",
        "comment_body": "Do a `stat`-call to check the size first and only then `readFile`. Otherwise you'll read 10GB images/files just to throw them away again. ",
        "pr_file_module": null
      }
    ]
  }
]