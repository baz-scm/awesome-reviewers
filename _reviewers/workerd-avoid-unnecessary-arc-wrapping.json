[
  {
    "discussion_id": "2129090369",
    "pr_number": 4238,
    "pr_file": "src/rust/container/lib.rs",
    "created_at": "2025-06-05T15:10:18+00:00",
    "commented_code": "+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+use std::task::Context;\n+use std::task::Poll;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::exec::CreateExecOptions;\n+use bollard::exec::StartExecOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::AsyncRead;\n+use futures::AsyncWrite;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Connection error: {0}\")]\n+    ConnectionError(String),\n+    #[error(\"Destroy failed: {0}\")]\n+    DestroyError(String),\n+    #[error(\"Exec error: {0}\")]\n+    ExecError(String),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::ConnectionError(msg) => Self::failed(msg),\n+            ContainerError::DestroyError(msg) => Self::failed(msg),\n+            ContainerError::ExecError(msg) => Self::failed(msg),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService {\n+        r#impl: r#impl.clone(),\n+    });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: Arc<std::sync::atomic::AtomicBool>,",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2129090369",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129090369",
        "commented_code": "@@ -0,0 +1,384 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+use std::task::Context;\n+use std::task::Poll;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::exec::CreateExecOptions;\n+use bollard::exec::StartExecOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::AsyncRead;\n+use futures::AsyncWrite;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Connection error: {0}\")]\n+    ConnectionError(String),\n+    #[error(\"Destroy failed: {0}\")]\n+    DestroyError(String),\n+    #[error(\"Exec error: {0}\")]\n+    ExecError(String),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::ConnectionError(msg) => Self::failed(msg),\n+            ContainerError::DestroyError(msg) => Self::failed(msg),\n+            ContainerError::ExecError(msg) => Self::failed(msg),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService {\n+        r#impl: r#impl.clone(),\n+    });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: Arc<std::sync::atomic::AtomicBool>,",
        "comment_created_at": "2025-06-05T15:10:18+00:00",
        "comment_author": "mikea",
        "comment_body": "this doesn't need to be Arc. Simple AtomicBool would suffice.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2129870390",
    "pr_number": 4238,
    "pr_file": "src/rust/container/lib.rs",
    "created_at": "2025-06-05T18:57:16+00:00",
    "commented_code": "+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2129870390",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129870390",
        "commented_code": "@@ -0,0 +1,347 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(",
        "comment_created_at": "2025-06-05T18:57:16+00:00",
        "comment_author": "mikenomitch",
        "comment_body": "I believe what happens here is that we send a SIGTERM, wait for 5 min for the container to stop, and if it is not stopped then we send a SIGKILL.\r\n\r\nSo I think if this were changed to sending a SIGTERM first, then we waited and checked for status and then called `remove_container` conditionally it'd be the right logic.",
        "pr_file_module": null
      },
      {
        "comment_id": "2129881941",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129870390",
        "commented_code": "@@ -0,0 +1,347 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(",
        "comment_created_at": "2025-06-05T19:00:28+00:00",
        "comment_author": "mikenomitch",
        "comment_body": "I'm not 100% positive that this happens on the `destroy` RPC command though (versus just when we update)... \r\n\r\n@gabivlj - I tracked things to here at least: https://gitlab.cfdata.org/cloudflare/cc/cloudchamber/-/blob/master/go/cmd/cloudchamberd/internal/services/durableobject/binding.go#L362\r\n\r\nDoes the `container.sidecar.Stop` command do the two signals, or will this just immediately SIGKILL in this case?",
        "pr_file_module": null
      },
      {
        "comment_id": "2129926947",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129870390",
        "commented_code": "@@ -0,0 +1,347 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(",
        "comment_created_at": "2025-06-05T19:11:33+00:00",
        "comment_author": "mikenomitch",
        "comment_body": "Oh... maybe stop_container has the behavior we want? (https://docs.rs/bollard/latest/bollard/struct.Docker.html#method.stop_container) and it includes a timeout to wait before it sigkills (https://docs.rs/bollard/latest/bollard/container/struct.StopContainerOptions.html).\r\n\r\nSo I think:\r\n- If `destroy` is meant to immediately destory, then we call kill_container\r\n- If `destory` does in fact do the timeout behavior, we use stop_container and set the timeout",
        "pr_file_module": null
      },
      {
        "comment_id": "2129937628",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129870390",
        "commented_code": "@@ -0,0 +1,347 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(",
        "comment_created_at": "2025-06-05T19:13:51+00:00",
        "comment_author": "gabivlj",
        "comment_body": "When `signal()` is called, we just relay that signal to the runtime. When `destroy()` is called, we send a SIGKILL.",
        "pr_file_module": null
      }
    ]
  }
]