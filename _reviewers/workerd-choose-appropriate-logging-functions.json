[
  {
    "discussion_id": "2267144682",
    "pr_number": 4745,
    "pr_file": "src/workerd/server/actor-id-impl.c++",
    "created_at": "2025-08-11T15:32:46+00:00",
    "commented_code": "JSG_REQUIRE(kj::arrayPtr(id).slice(BASE_LENGTH).startsWith(decoded.asPtr().slice(BASE_LENGTH)),\n       TypeError, \"Durable Object ID is not valid for this namespace.\");\n \n-  return kj::heap<ActorIdImpl>(id, kj::none);\n+  // TODO(jhoward): This has an issue that an actor ID will loose its jurisdiction after being\n+  // converted to a string.\n+  return kj::heap<ActorIdImpl>(id, kj::none, kj::none);\n }\n \n kj::Own<ActorIdFactory> ActorIdFactoryImpl::cloneWithJurisdiction(kj::StringPtr jurisdiction) {\n-  JSG_FAIL_REQUIRE(Error, \"Jurisdiction restrictions are not implemented in workerd.\");\n+  JSG_REQUIRE(maybeJurisdiction == kj::none, TypeError,\n+      \"Cannot create a jurisdictional subnamespace from a subnamespace that already \"\n+      \"has a jurisdiction set\");\n+  // TODO(jhoward): Do these warnings show up in local dev?\n+  KJ_LOG(WARNING, \"jurisdiction restrictions have no affect in workerd\", jurisdiction);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2267144682",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4745,
        "pr_file": "src/workerd/server/actor-id-impl.c++",
        "discussion_id": "2267144682",
        "commented_code": "@@ -87,14 +108,28 @@ kj::Own<ActorIdFactory::ActorId> ActorIdFactoryImpl::idFromString(kj::String str\n   JSG_REQUIRE(kj::arrayPtr(id).slice(BASE_LENGTH).startsWith(decoded.asPtr().slice(BASE_LENGTH)),\n       TypeError, \"Durable Object ID is not valid for this namespace.\");\n \n-  return kj::heap<ActorIdImpl>(id, kj::none);\n+  // TODO(jhoward): This has an issue that an actor ID will loose its jurisdiction after being\n+  // converted to a string.\n+  return kj::heap<ActorIdImpl>(id, kj::none, kj::none);\n }\n \n kj::Own<ActorIdFactory> ActorIdFactoryImpl::cloneWithJurisdiction(kj::StringPtr jurisdiction) {\n-  JSG_FAIL_REQUIRE(Error, \"Jurisdiction restrictions are not implemented in workerd.\");\n+  JSG_REQUIRE(maybeJurisdiction == kj::none, TypeError,\n+      \"Cannot create a jurisdictional subnamespace from a subnamespace that already \"\n+      \"has a jurisdiction set\");\n+  // TODO(jhoward): Do these warnings show up in local dev?\n+  KJ_LOG(WARNING, \"jurisdiction restrictions have no affect in workerd\", jurisdiction);",
        "comment_created_at": "2025-08-11T15:32:46+00:00",
        "comment_author": "jasnell",
        "comment_body": "Might make sense to make this `LOG_ONCE` or `LOG_PERIODICALLY`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180001580",
    "pr_number": 4437,
    "pr_file": "src/workerd/io/worker-entrypoint.c++",
    "created_at": "2025-07-02T12:58:14+00:00",
    "commented_code": "[](IoContext& context, kj::Own<IoContext::IncomingRequest> request) -> kj::Promise<bool> {\n     TRACE_EVENT(\"workerd\", \"WorkerEntrypoint::test() waitForFinished()\");\n     auto result = co_await request->finishScheduled();\n+\n+    if (result == IoContext_IncomingRequest::FinishScheduledResult::ABORTED) {\n+      // If the test handler throws an exception (without aborting - just a regular exception),\n+      // then `outcome` ends up being EventOutcome::EXCEPTION, which causes us to return false.\n+      // But in that case we are separately relying on the exception being logged as an uncaught\n+      // exception, rather than throwing it.\n+      // This is why we don't rethrow the exception but rather log it as an uncaught exception.\n+      try {\n+        co_await context.onAbort();\n+      } catch (...) {\n+        auto e = kj::getCaughtExceptionAsKj();\n+        LOG_EXCEPTION(\"test\", e);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2180001580",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4437,
        "pr_file": "src/workerd/io/worker-entrypoint.c++",
        "discussion_id": "2180001580",
        "commented_code": "@@ -729,6 +729,21 @@ kj::Promise<bool> WorkerEntrypoint::test() {\n       [](IoContext& context, kj::Own<IoContext::IncomingRequest> request) -> kj::Promise<bool> {\n     TRACE_EVENT(\"workerd\", \"WorkerEntrypoint::test() waitForFinished()\");\n     auto result = co_await request->finishScheduled();\n+\n+    if (result == IoContext_IncomingRequest::FinishScheduledResult::ABORTED) {\n+      // If the test handler throws an exception (without aborting - just a regular exception),\n+      // then `outcome` ends up being EventOutcome::EXCEPTION, which causes us to return false.\n+      // But in that case we are separately relying on the exception being logged as an uncaught\n+      // exception, rather than throwing it.\n+      // This is why we don't rethrow the exception but rather log it as an uncaught exception.\n+      try {\n+        co_await context.onAbort();\n+      } catch (...) {\n+        auto e = kj::getCaughtExceptionAsKj();\n+        LOG_EXCEPTION(\"test\", e);",
        "comment_created_at": "2025-07-02T12:58:14+00:00",
        "comment_author": "kentonv",
        "comment_body": "I guess arguably this should be `KJ_LOG(ERROR` -- `LOG_EXCEPTION` specifically logs exceptions formatted for sentry, but this isn't intended for sentry.",
        "pr_file_module": null
      },
      {
        "comment_id": "2180090913",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4437,
        "pr_file": "src/workerd/io/worker-entrypoint.c++",
        "discussion_id": "2180001580",
        "commented_code": "@@ -729,6 +729,21 @@ kj::Promise<bool> WorkerEntrypoint::test() {\n       [](IoContext& context, kj::Own<IoContext::IncomingRequest> request) -> kj::Promise<bool> {\n     TRACE_EVENT(\"workerd\", \"WorkerEntrypoint::test() waitForFinished()\");\n     auto result = co_await request->finishScheduled();\n+\n+    if (result == IoContext_IncomingRequest::FinishScheduledResult::ABORTED) {\n+      // If the test handler throws an exception (without aborting - just a regular exception),\n+      // then `outcome` ends up being EventOutcome::EXCEPTION, which causes us to return false.\n+      // But in that case we are separately relying on the exception being logged as an uncaught\n+      // exception, rather than throwing it.\n+      // This is why we don't rethrow the exception but rather log it as an uncaught exception.\n+      try {\n+        co_await context.onAbort();\n+      } catch (...) {\n+        auto e = kj::getCaughtExceptionAsKj();\n+        LOG_EXCEPTION(\"test\", e);",
        "comment_created_at": "2025-07-02T13:37:10+00:00",
        "comment_author": "anonrig",
        "comment_body": "Thanks! Updated.",
        "pr_file_module": null
      }
    ]
  }
]