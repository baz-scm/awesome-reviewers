[
  {
    "discussion_id": "2261646674",
    "pr_number": 4721,
    "pr_file": "src/node/internal/internal_http_incoming.ts",
    "created_at": "2025-08-07T23:38:24+00:00",
    "commented_code": "): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      const connectingIp = headers.get('cf-connecting-ip');\n+      const isConnectingIpIpv4 = connectingIp ? isIPv4(connectingIp) : true;\n+      const remotePort = Math.floor(Math.random() * (65535 - 32768 + 1));",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2261646674",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261646674",
        "commented_code": "@@ -67,6 +76,50 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      const connectingIp = headers.get('cf-connecting-ip');\n+      const isConnectingIpIpv4 = connectingIp ? isIPv4(connectingIp) : true;\n+      const remotePort = Math.floor(Math.random() * (65535 - 32768 + 1));",
        "comment_created_at": "2025-08-07T23:38:24+00:00",
        "comment_author": "danlapid",
        "comment_body": "```suggestion\r\n      const remotePort = Math.floor(Math.random() * (65535 - 32768 + 1)) + 32768;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2261728221",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261646674",
        "commented_code": "@@ -67,6 +76,50 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      const connectingIp = headers.get('cf-connecting-ip');\n+      const isConnectingIpIpv4 = connectingIp ? isIPv4(connectingIp) : true;\n+      const remotePort = Math.floor(Math.random() * (65535 - 32768 + 1));",
        "comment_created_at": "2025-08-08T01:04:40+00:00",
        "comment_author": "jasnell",
        "comment_body": "If my bitshifting skills aren't too rusty, I *think* you can simplify this even further with: \r\n\r\n```\r\nMath.random() * 0x8000 | 0x8000\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2226871494",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-23T22:37:07+00:00",
    "commented_code": "this.once('listening', callback as (...args: unknown[]) => unknown);\n     }\n \n-    this.port = Number(options.port);\n+    this.port = this.#findSuitablePort(Number(options.port));\n     portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n     queueMicrotask(() => {\n       callback?.();\n     });\n     return this;\n   }\n \n+  #findSuitablePort(port: number): number {\n+    if (port !== 0 && !portMapper.has(port)) {\n+      return port;\n+    }\n+\n+    if (port === 0) {\n+      return this.#findSuitablePort(Math.floor(Math.random() * 65535) + 1);\n+    }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2226871494",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2226871494",
        "commented_code": "@@ -208,14 +208,27 @@ export class Server\n       this.once('listening', callback as (...args: unknown[]) => unknown);\n     }\n \n-    this.port = Number(options.port);\n+    this.port = this.#findSuitablePort(Number(options.port));\n     portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n     queueMicrotask(() => {\n       callback?.();\n     });\n     return this;\n   }\n \n+  #findSuitablePort(port: number): number {\n+    if (port !== 0 && !portMapper.has(port)) {\n+      return port;\n+    }\n+\n+    if (port === 0) {\n+      return this.#findSuitablePort(Math.floor(Math.random() * 65535) + 1);\n+    }",
        "comment_created_at": "2025-07-23T22:37:07+00:00",
        "comment_author": "jasnell",
        "comment_body": "While it is beyond exceedingly unlikely that this will ever recurse more than once it would be nice if we could eliminate the recursion entirely and just use a loop.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2087932501",
    "pr_number": 4141,
    "pr_file": "src/cloudflare/internal/images-api.ts",
    "created_at": "2025-05-14T02:48:17+00:00",
    "commented_code": "return outputStream;\n }\n \n+function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {\n+  const result = new Uint8Array(a.length + b.length);\n+  result.set(a, 0);\n+  result.set(b, a.length);\n+  return result;\n+}\n+\n+class Base64Error extends Error {\n+  public constructor(cause: unknown) {\n+    if (cause instanceof Error) {\n+      super(`base64 error: ${cause.message}`, { cause });\n+    } else {\n+      super('unknown base64 error');\n+    }\n+  }\n+}\n+\n+function createBase64EncoderTransformStream(\n+  maxEncodeChunkSize: number = 32 * 1024 + 1\n+): TransformStream<Uint8Array, Uint8Array> {\n+  if (maxEncodeChunkSize % 3 != 0) {\n+    // Ensures that chunks don't require padding\n+    throw new Error('maxChunkSize must be a multiple of 3');\n+  }\n+\n+  let buffer: Uint8Array | null = null;\n+  const asciiEncoder = new TextEncoder();\n+\n+  const toBase64: (buf: Uint8Array) => Uint8Array = (buf) => {\n+    const binaryString = String.fromCharCode.apply(null, Array.from(buf));\n+\n+    const base64String = btoa(binaryString);\n+    const base64Bytes = asciiEncoder.encode(base64String);\n+\n+    return base64Bytes;\n+  };\n+\n+  return new TransformStream<Uint8Array, Uint8Array>({\n+    transform(chunk, controller): void {\n+      const currentData = buffer ? concatUint8Arrays(buffer, chunk) : chunk;\n+      buffer = null;\n+\n+      let offset = 0;\n+\n+      while (currentData.length - offset >= maxEncodeChunkSize) {\n+        const sliceToEnd = offset + maxEncodeChunkSize;\n+        const processChunk = currentData.slice(offset, sliceToEnd);\n+        offset = sliceToEnd;\n+\n+        try {\n+          controller.enqueue(toBase64(processChunk));\n+        } catch (error) {\n+          controller.error(new Base64Error(error));\n+          buffer = null;\n+          return;\n+        }\n+      }\n+\n+      buffer = offset < currentData.length ? currentData.slice(offset) : null;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2087932501",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4141,
        "pr_file": "src/cloudflare/internal/images-api.ts",
        "discussion_id": "2087932501",
        "commented_code": "@@ -303,6 +327,165 @@ function chainStreams<T>(streams: ReadableStream<T>[]): ReadableStream<T> {\n   return outputStream;\n }\n \n+function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {\n+  const result = new Uint8Array(a.length + b.length);\n+  result.set(a, 0);\n+  result.set(b, a.length);\n+  return result;\n+}\n+\n+class Base64Error extends Error {\n+  public constructor(cause: unknown) {\n+    if (cause instanceof Error) {\n+      super(`base64 error: ${cause.message}`, { cause });\n+    } else {\n+      super('unknown base64 error');\n+    }\n+  }\n+}\n+\n+function createBase64EncoderTransformStream(\n+  maxEncodeChunkSize: number = 32 * 1024 + 1\n+): TransformStream<Uint8Array, Uint8Array> {\n+  if (maxEncodeChunkSize % 3 != 0) {\n+    // Ensures that chunks don't require padding\n+    throw new Error('maxChunkSize must be a multiple of 3');\n+  }\n+\n+  let buffer: Uint8Array | null = null;\n+  const asciiEncoder = new TextEncoder();\n+\n+  const toBase64: (buf: Uint8Array) => Uint8Array = (buf) => {\n+    const binaryString = String.fromCharCode.apply(null, Array.from(buf));\n+\n+    const base64String = btoa(binaryString);\n+    const base64Bytes = asciiEncoder.encode(base64String);\n+\n+    return base64Bytes;\n+  };\n+\n+  return new TransformStream<Uint8Array, Uint8Array>({\n+    transform(chunk, controller): void {\n+      const currentData = buffer ? concatUint8Arrays(buffer, chunk) : chunk;\n+      buffer = null;\n+\n+      let offset = 0;\n+\n+      while (currentData.length - offset >= maxEncodeChunkSize) {\n+        const sliceToEnd = offset + maxEncodeChunkSize;\n+        const processChunk = currentData.slice(offset, sliceToEnd);\n+        offset = sliceToEnd;\n+\n+        try {\n+          controller.enqueue(toBase64(processChunk));\n+        } catch (error) {\n+          controller.error(new Base64Error(error));\n+          buffer = null;\n+          return;\n+        }\n+      }\n+\n+      buffer = offset < currentData.length ? currentData.slice(offset) : null;",
        "comment_created_at": "2025-05-14T02:48:17+00:00",
        "comment_author": "jasnell",
        "comment_body": "Something that most folks miss here is that `slice(...)` on a TypedArray actually creates a copy of the data for the slice. Is that what you're intending here or do you want a view (in which case you want `subarray(...)` not `slice(...)`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2093353053",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4141,
        "pr_file": "src/cloudflare/internal/images-api.ts",
        "discussion_id": "2087932501",
        "commented_code": "@@ -303,6 +327,165 @@ function chainStreams<T>(streams: ReadableStream<T>[]): ReadableStream<T> {\n   return outputStream;\n }\n \n+function concatUint8Arrays(a: Uint8Array, b: Uint8Array): Uint8Array {\n+  const result = new Uint8Array(a.length + b.length);\n+  result.set(a, 0);\n+  result.set(b, a.length);\n+  return result;\n+}\n+\n+class Base64Error extends Error {\n+  public constructor(cause: unknown) {\n+    if (cause instanceof Error) {\n+      super(`base64 error: ${cause.message}`, { cause });\n+    } else {\n+      super('unknown base64 error');\n+    }\n+  }\n+}\n+\n+function createBase64EncoderTransformStream(\n+  maxEncodeChunkSize: number = 32 * 1024 + 1\n+): TransformStream<Uint8Array, Uint8Array> {\n+  if (maxEncodeChunkSize % 3 != 0) {\n+    // Ensures that chunks don't require padding\n+    throw new Error('maxChunkSize must be a multiple of 3');\n+  }\n+\n+  let buffer: Uint8Array | null = null;\n+  const asciiEncoder = new TextEncoder();\n+\n+  const toBase64: (buf: Uint8Array) => Uint8Array = (buf) => {\n+    const binaryString = String.fromCharCode.apply(null, Array.from(buf));\n+\n+    const base64String = btoa(binaryString);\n+    const base64Bytes = asciiEncoder.encode(base64String);\n+\n+    return base64Bytes;\n+  };\n+\n+  return new TransformStream<Uint8Array, Uint8Array>({\n+    transform(chunk, controller): void {\n+      const currentData = buffer ? concatUint8Arrays(buffer, chunk) : chunk;\n+      buffer = null;\n+\n+      let offset = 0;\n+\n+      while (currentData.length - offset >= maxEncodeChunkSize) {\n+        const sliceToEnd = offset + maxEncodeChunkSize;\n+        const processChunk = currentData.slice(offset, sliceToEnd);\n+        offset = sliceToEnd;\n+\n+        try {\n+          controller.enqueue(toBase64(processChunk));\n+        } catch (error) {\n+          controller.error(new Base64Error(error));\n+          buffer = null;\n+          return;\n+        }\n+      }\n+\n+      buffer = offset < currentData.length ? currentData.slice(offset) : null;",
        "comment_created_at": "2025-05-16T16:29:11+00:00",
        "comment_author": "ns476",
        "comment_body": "Switched to `.subarray(...)`",
        "pr_file_module": null
      }
    ]
  }
]