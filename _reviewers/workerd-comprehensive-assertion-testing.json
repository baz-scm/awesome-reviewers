[
  {
    "discussion_id": "2267130179",
    "pr_number": 4745,
    "pr_file": "src/workerd/api/tests/actor-stub-test.js",
    "created_at": "2025-08-11T15:27:14+00:00",
    "commented_code": "checkDurableObject(otherObj);\n     }\n \n+    // TODO(jhoward): This test should run as an ew-test so that behavior is kept consistent between\n+    // workerd and edgeworker.\n+    // Check jurisdictions\n+    const euNs = env.ns.jurisdiction('eu');\n+    // TODO(jhoward): Maybe restrict jurisdictions to those supported in edgeworker?\n+    // assert.throws(() => {\n+    //   env.ns.jurisdiction('foo');\n+    // });\n+    assert.throws(() => {\n+      euNs.jurisdiction('fedramp');\n+    });",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2267130179",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4745,
        "pr_file": "src/workerd/api/tests/actor-stub-test.js",
        "discussion_id": "2267130179",
        "commented_code": "@@ -91,6 +93,66 @@ export default {\n       checkDurableObject(otherObj);\n     }\n \n+    // TODO(jhoward): This test should run as an ew-test so that behavior is kept consistent between\n+    // workerd and edgeworker.\n+    // Check jurisdictions\n+    const euNs = env.ns.jurisdiction('eu');\n+    // TODO(jhoward): Maybe restrict jurisdictions to those supported in edgeworker?\n+    // assert.throws(() => {\n+    //   env.ns.jurisdiction('foo');\n+    // });\n+    assert.throws(() => {\n+      euNs.jurisdiction('fedramp');\n+    });",
        "comment_created_at": "2025-08-11T15:27:14+00:00",
        "comment_author": "jasnell",
        "comment_body": "`assert.throws(...)` really ought to have a second argument to test the error type and message (here and in the other cases below).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2262971411",
    "pr_number": 4721,
    "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
    "created_at": "2025-08-08T13:24:22+00:00",
    "commented_code": "},\n };\n \n+export const testIncomingMessageSocket = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.socket.encrypted, false);\n+      strictEqual(req.socket.localPort, 8080);\n+      strictEqual(req.socket.localAddress, '127.0.0.1');\n+      strictEqual(req.socket.remoteAddress, '127.0.0.1');\n+      strictEqual(typeof req.socket.remotePort, 'number');",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2262971411",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2262971411",
        "commented_code": "@@ -1132,6 +1132,28 @@ export const testConfigurableHighWaterMark = {\n   },\n };\n \n+export const testIncomingMessageSocket = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.socket.encrypted, false);\n+      strictEqual(req.socket.localPort, 8080);\n+      strictEqual(req.socket.localAddress, '127.0.0.1');\n+      strictEqual(req.socket.remoteAddress, '127.0.0.1');\n+      strictEqual(typeof req.socket.remotePort, 'number');",
        "comment_created_at": "2025-08-08T13:24:22+00:00",
        "comment_author": "jasnell",
        "comment_body": "Per the other comments, if `remotePort` is expected to be within a specific range we should likely test for that. Likewise, there are a number of other branches in the relevant code that aren't tested here (such as the values being undefined when the connection is closed). Can be done in a separate PR tho.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076407275",
    "pr_number": 4005,
    "pr_file": "src/workerd/api/tests/http-socket-test.js",
    "created_at": "2025-05-06T21:59:32+00:00",
    "commented_code": "+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2076407275",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2076407275",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection",
        "comment_created_at": "2025-05-06T21:59:32+00:00",
        "comment_author": "jasnell",
        "comment_body": "This test is confusing. Are you expecting this to throw or succeed? If you are expecting a throw, using the `node:assert` `rejects(...)` API would be a better way to construct this block",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223688008",
    "pr_number": 4591,
    "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
    "created_at": "2025-07-22T19:46:50+00:00",
    "commented_code": "+import http from 'node:http';\n+import { strictEqual, ok } from 'node:assert';\n+import { registerFetchEvents } from 'cloudflare:workers';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      // TODO(soon): host should not be joined.\n+      // strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+export default registerFetchEvents({ port: 8080 });\n+\n+// Relevant Node.js tests",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2223688008",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2223688008",
        "commented_code": "@@ -0,0 +1,130 @@\n+import http from 'node:http';\n+import { strictEqual, ok } from 'node:assert';\n+import { registerFetchEvents } from 'cloudflare:workers';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      // TODO(soon): host should not be joined.\n+      // strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+export default registerFetchEvents({ port: 8080 });\n+\n+// Relevant Node.js tests",
        "comment_created_at": "2025-07-22T19:46:50+00:00",
        "comment_author": "jasnell",
        "comment_body": "Need to make sure to include tests that involve passing the `port` option on listen as `0` (auto-assign the port from what's available), invalid port values (like `NaN`, `Infinity`, etc), and port values that are out-of-range.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2236971355",
    "pr_number": 4591,
    "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
    "created_at": "2025-07-28T15:32:16+00:00",
    "commented_code": "+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-de-chunked-trailer.js\n+export const testHttpServerDeChunkedTrailer = {\n+  async test(_ctrl, env) {\n+    const handlerFn = mock.fn((req, res) => {\n+      res.setHeader('Trailer', 'baz');\n+      const trailerInvalidErr = {\n+        code: 'ERR_HTTP_TRAILER_INVALID',\n+        message: 'Trailers are invalid with this transfer encoding',\n+        name: 'Error',\n+      };\n+      throws(\n+        () => res.writeHead(200, { 'Content-Length': '2' }),\n+        trailerInvalidErr\n+      );\n+      res.removeHeader('Trailer');\n+      res.end('ok');\n+    });\n+    const server = http.createServer(handlerFn);\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'ok');\n+    strictEqual(handlerFn.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+// TODO(soon): Fix this\n+// // Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+// export const testHttpServerIncomingMessageDestroy = {\n+//   async test(_ctrl, env) {\n+//     await using server = http.createServer((req, res) => {\n+//       req.destroy(new Error('Destroy test'));\n+//     });\n+\n+//     server.listen(8080);\n+\n+//     await rejects(() => {\n+//       return env.SERVICE.fetch('https://cloudflare.com');\n+//     }, {\n+//       message: '',\n+//     })\n+//   }\n+// }\n+\n+// Test is taken from test/parallel/test-http-server-method.query.js\n+export const testHttpServerMethodQuery = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'QUERY');\n+      res.end('OK');\n+    });\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      method: 'QUERY',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'OK');\n+  },\n+};\n+\n+// Tests is taken from test/parallel/test-http-server-multiheaders.js\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-non-utf8-header.js\n+export const testHttpServerNonUtf8Header = {\n+  async test(_ctrl, env) {\n+    const nonUtf8Header = 'b\u00e5r';\n+    const nonUtf8ToLatin1 = Buffer.from(nonUtf8Header).toString('latin1');\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          Buffer.from(nonUtf8Header).toString('binary'),\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+          method: 'GET',\n+        });\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+\n+      await promise;\n+    }\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      // Test multi-value header\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          [Buffer.from(nonUtf8Header).toString('binary')],\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com');\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+      await promise;\n+    }\n+\n+    // TODO(soon): Investigate this.\n+    // {\n+    //   const { promise, resolve } = Promise.withResolvers();\n+    //   const server = http.createServer((req, res) => {\n+    //     res.writeHead(200, [\n+    //       'Content-Length',\n+    //       '5',\n+    //       'content-disposition',\n+    //       Buffer.from(nonUtf8Header).toString('binary'),\n+    //     ]);\n+    //     res.end('hello');\n+    //   });\n+    //\n+    //   server.listen(8080);\n+    //\n+    //   const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    //   strictEqual(res.status, 200);\n+    //   strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+    //   server.close();\n+    //   resolve();\n+    //\n+    //   await promise;\n+    // }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-incoming-message.js\n+export const testHttpServerOptionsIncomingMessage = {\n+  async test(_ctrl, env) {\n+    class MyIncomingMessage extends http.IncomingMessage {\n+      getUserAgent() {\n+        return this.headers['user-agent'] || 'unknown';\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        IncomingMessage: MyIncomingMessage,\n+      },\n+      (req, res) => {\n+        strictEqual(req.getUserAgent(), 'node-test');\n+        res.statusCode = 200;\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      headers: { 'User-Agent': 'node-test' },\n+    });\n+    strictEqual(res.status, 200);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-server-response.js\n+export const testHttpServerOptionsServerResponse = {\n+  async test(_ctrl, env) {\n+    class MyServerResponse extends http.ServerResponse {\n+      status(code) {\n+        return this.writeHead(code, { 'Content-Type': 'text/plain' });\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        ServerResponse: MyServerResponse,\n+      },\n+      (_req, res) => {\n+        res.status(200);\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(res.headers.get('content-type'), 'text/plain');\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-after-end.js\n+export const testHttpServerWriteAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    await using server = http.createServer(handle);\n+\n+    function handle(_req, res) {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    }\n+\n+    server.listen(8080);\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-end-after-end.js\n+export const testHttpServerWriteEndAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const handle = mock.fn((req, res) => {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.end('world');\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    });\n+    const server = http.createServer(handle);\n+    server.listen(8080);\n+\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+    strictEqual(handle.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+export const testHandleZeroPortNumber = {\n+  async test() {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer();\n+    const listeningFn = mock.fn();\n+    server.on('listening', listeningFn);\n+    server.listen(0, () => {\n+      ok(server.listening);\n+      notStrictEqual(server.port, 0);\n+      notStrictEqual(server.address().port, 0);\n+      strictEqual(listeningFn.mock.callCount(), 1);\n+      server.close();\n+      resolve();\n+    });\n+    await promise;\n+  },\n+};\n+\n+export const testInvalidPorts = {\n+  async test() {\n+    const server = http.createServer();\n+    for (const value of [NaN, Infinity]) {\n+      throws(() => server.listen(value), {\n+        code: 'ERR_SOCKET_BAD_PORT',\n+      });\n+    }\n+    strictEqual(server.listening, false);\n+  },\n+};\n+\n+export const consumeRequestPayloadData = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'POST');\n+      let data = '';\n+      req.setEncoding('utf8');\n+      req.on('data', (d) => (data += d));\n+      req.on('end', () => {\n+        strictEqual(data, 'hello world');\n+        res.setHeaders(new Headers({ hello: 'world' }));\n+        res.end(data + ' x2');\n+      });\n+    });\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      body: 'hello world',\n+      method: 'POST',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'hello world x2');\n+    strictEqual(res.headers.get('hello'), 'world');\n+  },\n+};\n+\n+// Test large streaming responses and various data types\n+export const testStreamingResponses = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      const path = req.url;\n+\n+      if (path === '/large') {\n+        // Test 1: Large payload streaming\n+        const CHUNK_SIZE = 1024 * 64; // 64KB\n+        const NUM_CHUNKS = 10; // 640KB total\n+        res.writeHead(200, { 'X-Test': 'large' });\n+        for (let i = 0; i < NUM_CHUNKS; i++) {\n+          res.write(Buffer.alloc(CHUNK_SIZE, i % 256));\n+        }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2236971355",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2236971355",
        "commented_code": "@@ -0,0 +1,573 @@\n+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-de-chunked-trailer.js\n+export const testHttpServerDeChunkedTrailer = {\n+  async test(_ctrl, env) {\n+    const handlerFn = mock.fn((req, res) => {\n+      res.setHeader('Trailer', 'baz');\n+      const trailerInvalidErr = {\n+        code: 'ERR_HTTP_TRAILER_INVALID',\n+        message: 'Trailers are invalid with this transfer encoding',\n+        name: 'Error',\n+      };\n+      throws(\n+        () => res.writeHead(200, { 'Content-Length': '2' }),\n+        trailerInvalidErr\n+      );\n+      res.removeHeader('Trailer');\n+      res.end('ok');\n+    });\n+    const server = http.createServer(handlerFn);\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'ok');\n+    strictEqual(handlerFn.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+// TODO(soon): Fix this\n+// // Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+// export const testHttpServerIncomingMessageDestroy = {\n+//   async test(_ctrl, env) {\n+//     await using server = http.createServer((req, res) => {\n+//       req.destroy(new Error('Destroy test'));\n+//     });\n+\n+//     server.listen(8080);\n+\n+//     await rejects(() => {\n+//       return env.SERVICE.fetch('https://cloudflare.com');\n+//     }, {\n+//       message: '',\n+//     })\n+//   }\n+// }\n+\n+// Test is taken from test/parallel/test-http-server-method.query.js\n+export const testHttpServerMethodQuery = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'QUERY');\n+      res.end('OK');\n+    });\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      method: 'QUERY',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'OK');\n+  },\n+};\n+\n+// Tests is taken from test/parallel/test-http-server-multiheaders.js\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-non-utf8-header.js\n+export const testHttpServerNonUtf8Header = {\n+  async test(_ctrl, env) {\n+    const nonUtf8Header = 'b\u00e5r';\n+    const nonUtf8ToLatin1 = Buffer.from(nonUtf8Header).toString('latin1');\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          Buffer.from(nonUtf8Header).toString('binary'),\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+          method: 'GET',\n+        });\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+\n+      await promise;\n+    }\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      // Test multi-value header\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          [Buffer.from(nonUtf8Header).toString('binary')],\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com');\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+      await promise;\n+    }\n+\n+    // TODO(soon): Investigate this.\n+    // {\n+    //   const { promise, resolve } = Promise.withResolvers();\n+    //   const server = http.createServer((req, res) => {\n+    //     res.writeHead(200, [\n+    //       'Content-Length',\n+    //       '5',\n+    //       'content-disposition',\n+    //       Buffer.from(nonUtf8Header).toString('binary'),\n+    //     ]);\n+    //     res.end('hello');\n+    //   });\n+    //\n+    //   server.listen(8080);\n+    //\n+    //   const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    //   strictEqual(res.status, 200);\n+    //   strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+    //   server.close();\n+    //   resolve();\n+    //\n+    //   await promise;\n+    // }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-incoming-message.js\n+export const testHttpServerOptionsIncomingMessage = {\n+  async test(_ctrl, env) {\n+    class MyIncomingMessage extends http.IncomingMessage {\n+      getUserAgent() {\n+        return this.headers['user-agent'] || 'unknown';\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        IncomingMessage: MyIncomingMessage,\n+      },\n+      (req, res) => {\n+        strictEqual(req.getUserAgent(), 'node-test');\n+        res.statusCode = 200;\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      headers: { 'User-Agent': 'node-test' },\n+    });\n+    strictEqual(res.status, 200);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-server-response.js\n+export const testHttpServerOptionsServerResponse = {\n+  async test(_ctrl, env) {\n+    class MyServerResponse extends http.ServerResponse {\n+      status(code) {\n+        return this.writeHead(code, { 'Content-Type': 'text/plain' });\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        ServerResponse: MyServerResponse,\n+      },\n+      (_req, res) => {\n+        res.status(200);\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(res.headers.get('content-type'), 'text/plain');\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-after-end.js\n+export const testHttpServerWriteAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    await using server = http.createServer(handle);\n+\n+    function handle(_req, res) {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    }\n+\n+    server.listen(8080);\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-end-after-end.js\n+export const testHttpServerWriteEndAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const handle = mock.fn((req, res) => {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.end('world');\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    });\n+    const server = http.createServer(handle);\n+    server.listen(8080);\n+\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+    strictEqual(handle.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+export const testHandleZeroPortNumber = {\n+  async test() {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer();\n+    const listeningFn = mock.fn();\n+    server.on('listening', listeningFn);\n+    server.listen(0, () => {\n+      ok(server.listening);\n+      notStrictEqual(server.port, 0);\n+      notStrictEqual(server.address().port, 0);\n+      strictEqual(listeningFn.mock.callCount(), 1);\n+      server.close();\n+      resolve();\n+    });\n+    await promise;\n+  },\n+};\n+\n+export const testInvalidPorts = {\n+  async test() {\n+    const server = http.createServer();\n+    for (const value of [NaN, Infinity]) {\n+      throws(() => server.listen(value), {\n+        code: 'ERR_SOCKET_BAD_PORT',\n+      });\n+    }\n+    strictEqual(server.listening, false);\n+  },\n+};\n+\n+export const consumeRequestPayloadData = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'POST');\n+      let data = '';\n+      req.setEncoding('utf8');\n+      req.on('data', (d) => (data += d));\n+      req.on('end', () => {\n+        strictEqual(data, 'hello world');\n+        res.setHeaders(new Headers({ hello: 'world' }));\n+        res.end(data + ' x2');\n+      });\n+    });\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      body: 'hello world',\n+      method: 'POST',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'hello world x2');\n+    strictEqual(res.headers.get('hello'), 'world');\n+  },\n+};\n+\n+// Test large streaming responses and various data types\n+export const testStreamingResponses = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      const path = req.url;\n+\n+      if (path === '/large') {\n+        // Test 1: Large payload streaming\n+        const CHUNK_SIZE = 1024 * 64; // 64KB\n+        const NUM_CHUNKS = 10; // 640KB total\n+        res.writeHead(200, { 'X-Test': 'large' });\n+        for (let i = 0; i < NUM_CHUNKS; i++) {\n+          res.write(Buffer.alloc(CHUNK_SIZE, i % 256));\n+        }",
        "comment_created_at": "2025-07-28T15:32:16+00:00",
        "comment_author": "jasnell",
        "comment_body": "A variation of this test that honors backpressure signaling would be good to have as well. Specifically, it would help to exercise the backpressure signaling as well ensuring the logic around buffering and multiple reads is working correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2237444091",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2236971355",
        "commented_code": "@@ -0,0 +1,573 @@\n+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-de-chunked-trailer.js\n+export const testHttpServerDeChunkedTrailer = {\n+  async test(_ctrl, env) {\n+    const handlerFn = mock.fn((req, res) => {\n+      res.setHeader('Trailer', 'baz');\n+      const trailerInvalidErr = {\n+        code: 'ERR_HTTP_TRAILER_INVALID',\n+        message: 'Trailers are invalid with this transfer encoding',\n+        name: 'Error',\n+      };\n+      throws(\n+        () => res.writeHead(200, { 'Content-Length': '2' }),\n+        trailerInvalidErr\n+      );\n+      res.removeHeader('Trailer');\n+      res.end('ok');\n+    });\n+    const server = http.createServer(handlerFn);\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'ok');\n+    strictEqual(handlerFn.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+// TODO(soon): Fix this\n+// // Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+// export const testHttpServerIncomingMessageDestroy = {\n+//   async test(_ctrl, env) {\n+//     await using server = http.createServer((req, res) => {\n+//       req.destroy(new Error('Destroy test'));\n+//     });\n+\n+//     server.listen(8080);\n+\n+//     await rejects(() => {\n+//       return env.SERVICE.fetch('https://cloudflare.com');\n+//     }, {\n+//       message: '',\n+//     })\n+//   }\n+// }\n+\n+// Test is taken from test/parallel/test-http-server-method.query.js\n+export const testHttpServerMethodQuery = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'QUERY');\n+      res.end('OK');\n+    });\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      method: 'QUERY',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'OK');\n+  },\n+};\n+\n+// Tests is taken from test/parallel/test-http-server-multiheaders.js\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-non-utf8-header.js\n+export const testHttpServerNonUtf8Header = {\n+  async test(_ctrl, env) {\n+    const nonUtf8Header = 'b\u00e5r';\n+    const nonUtf8ToLatin1 = Buffer.from(nonUtf8Header).toString('latin1');\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          Buffer.from(nonUtf8Header).toString('binary'),\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+          method: 'GET',\n+        });\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+\n+      await promise;\n+    }\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      // Test multi-value header\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          [Buffer.from(nonUtf8Header).toString('binary')],\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com');\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+      await promise;\n+    }\n+\n+    // TODO(soon): Investigate this.\n+    // {\n+    //   const { promise, resolve } = Promise.withResolvers();\n+    //   const server = http.createServer((req, res) => {\n+    //     res.writeHead(200, [\n+    //       'Content-Length',\n+    //       '5',\n+    //       'content-disposition',\n+    //       Buffer.from(nonUtf8Header).toString('binary'),\n+    //     ]);\n+    //     res.end('hello');\n+    //   });\n+    //\n+    //   server.listen(8080);\n+    //\n+    //   const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    //   strictEqual(res.status, 200);\n+    //   strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+    //   server.close();\n+    //   resolve();\n+    //\n+    //   await promise;\n+    // }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-incoming-message.js\n+export const testHttpServerOptionsIncomingMessage = {\n+  async test(_ctrl, env) {\n+    class MyIncomingMessage extends http.IncomingMessage {\n+      getUserAgent() {\n+        return this.headers['user-agent'] || 'unknown';\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        IncomingMessage: MyIncomingMessage,\n+      },\n+      (req, res) => {\n+        strictEqual(req.getUserAgent(), 'node-test');\n+        res.statusCode = 200;\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      headers: { 'User-Agent': 'node-test' },\n+    });\n+    strictEqual(res.status, 200);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-server-response.js\n+export const testHttpServerOptionsServerResponse = {\n+  async test(_ctrl, env) {\n+    class MyServerResponse extends http.ServerResponse {\n+      status(code) {\n+        return this.writeHead(code, { 'Content-Type': 'text/plain' });\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        ServerResponse: MyServerResponse,\n+      },\n+      (_req, res) => {\n+        res.status(200);\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(res.headers.get('content-type'), 'text/plain');\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-after-end.js\n+export const testHttpServerWriteAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    await using server = http.createServer(handle);\n+\n+    function handle(_req, res) {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    }\n+\n+    server.listen(8080);\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-end-after-end.js\n+export const testHttpServerWriteEndAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const handle = mock.fn((req, res) => {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.end('world');\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    });\n+    const server = http.createServer(handle);\n+    server.listen(8080);\n+\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+    strictEqual(handle.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+export const testHandleZeroPortNumber = {\n+  async test() {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer();\n+    const listeningFn = mock.fn();\n+    server.on('listening', listeningFn);\n+    server.listen(0, () => {\n+      ok(server.listening);\n+      notStrictEqual(server.port, 0);\n+      notStrictEqual(server.address().port, 0);\n+      strictEqual(listeningFn.mock.callCount(), 1);\n+      server.close();\n+      resolve();\n+    });\n+    await promise;\n+  },\n+};\n+\n+export const testInvalidPorts = {\n+  async test() {\n+    const server = http.createServer();\n+    for (const value of [NaN, Infinity]) {\n+      throws(() => server.listen(value), {\n+        code: 'ERR_SOCKET_BAD_PORT',\n+      });\n+    }\n+    strictEqual(server.listening, false);\n+  },\n+};\n+\n+export const consumeRequestPayloadData = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'POST');\n+      let data = '';\n+      req.setEncoding('utf8');\n+      req.on('data', (d) => (data += d));\n+      req.on('end', () => {\n+        strictEqual(data, 'hello world');\n+        res.setHeaders(new Headers({ hello: 'world' }));\n+        res.end(data + ' x2');\n+      });\n+    });\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      body: 'hello world',\n+      method: 'POST',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'hello world x2');\n+    strictEqual(res.headers.get('hello'), 'world');\n+  },\n+};\n+\n+// Test large streaming responses and various data types\n+export const testStreamingResponses = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      const path = req.url;\n+\n+      if (path === '/large') {\n+        // Test 1: Large payload streaming\n+        const CHUNK_SIZE = 1024 * 64; // 64KB\n+        const NUM_CHUNKS = 10; // 640KB total\n+        res.writeHead(200, { 'X-Test': 'large' });\n+        for (let i = 0; i < NUM_CHUNKS; i++) {\n+          res.write(Buffer.alloc(CHUNK_SIZE, i % 256));\n+        }",
        "comment_created_at": "2025-07-28T17:50:38+00:00",
        "comment_author": "jasnell",
        "comment_body": "It's not clear if there were any changes made in response to this. I see the added tests below. When resolving these, could I ask that you leave a comment indicating the change that was made. There are a number of these resolved without changes and it's difficult to differentiate without digging through the whole change set.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2237526231",
    "pr_number": 4591,
    "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
    "created_at": "2025-07-28T18:30:11+00:00",
    "commented_code": "+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual, rejects } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+const globalServer = http.createServer();\n+globalServer.listen(9090);\n+\n+export const testGlobalHttpServe = {\n+  async test(_ctrl, env) {\n+    strictEqual(globalServer.listening, true);\n+    strictEqual(globalServer.address().port, 9090);\n+    globalServer.close();\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+export const testHttpServerIncomingMessageDestroy = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      req.on('error', (err) => {\n+        res.statusCode = 400;\n+        res.end('Request destroyed: ' + err.message);\n+      });\n+      req.destroy(new Error('Destroy test'));",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2237526231",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2237526231",
        "commented_code": "@@ -0,0 +1,636 @@\n+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual, rejects } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+const globalServer = http.createServer();\n+globalServer.listen(9090);\n+\n+export const testGlobalHttpServe = {\n+  async test(_ctrl, env) {\n+    strictEqual(globalServer.listening, true);\n+    strictEqual(globalServer.address().port, 9090);\n+    globalServer.close();\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+export const testHttpServerIncomingMessageDestroy = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      req.on('error', (err) => {\n+        res.statusCode = 400;\n+        res.end('Request destroyed: ' + err.message);\n+      });\n+      req.destroy(new Error('Destroy test'));",
        "comment_created_at": "2025-07-28T18:30:11+00:00",
        "comment_author": "jasnell",
        "comment_body": "There should also be an example where `req.destroy()` is called without an error as that would mean no `'error'` event is emitted. Also, Is there a test that verifies what happens if `res.destroy()` and `res.destroy(error)` are called?",
        "pr_file_module": null
      },
      {
        "comment_id": "2237555063",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2237526231",
        "commented_code": "@@ -0,0 +1,636 @@\n+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual, rejects } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+const globalServer = http.createServer();\n+globalServer.listen(9090);\n+\n+export const testGlobalHttpServe = {\n+  async test(_ctrl, env) {\n+    strictEqual(globalServer.listening, true);\n+    strictEqual(globalServer.address().port, 9090);\n+    globalServer.close();\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+export const testHttpServerIncomingMessageDestroy = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      req.on('error', (err) => {\n+        res.statusCode = 400;\n+        res.end('Request destroyed: ' + err.message);\n+      });\n+      req.destroy(new Error('Destroy test'));",
        "comment_created_at": "2025-07-28T18:46:11+00:00",
        "comment_author": "anonrig",
        "comment_body": "I've added/updated tests",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224169115",
    "pr_number": 4480,
    "pr_file": "src/workerd/api/node/tests/process-stdio-nodejs-test.js",
    "created_at": "2025-07-23T02:17:42+00:00",
    "commented_code": "+import { ReadStream } from 'node:fs';\n+import { readSync, writeSync } from 'node:fs';\n+import { Buffer } from 'node:buffer';\n+import { Readable, Writable } from 'node:stream';\n+import assert from 'node:assert';\n+\n+export const processStdioPropertiesTest = {\n+  test() {\n+    assert.strictEqual(process.stdin.fd, 0, 'stdin should have fd 0');\n+    assert(\n+      process.stdin instanceof Readable,\n+      'stdin should be instance of Readable'\n+    );\n+    assert(\n+      process.stdin instanceof ReadStream,\n+      'stdin should be instance of ReadStream'\n+    );\n+\n+    assert.strictEqual(process.stdout.fd, 1, 'stdout should have fd 1');\n+    assert.strictEqual(\n+      process.stdout.readable,\n+      false,\n+      'stdout should not be readable'\n+    );\n+    assert.strictEqual(\n+      process.stdout._type,\n+      'fs',\n+      'stdout should have _type \"fs\"'\n+    );\n+    assert.strictEqual(\n+      process.stdout._isStdio,\n+      true,\n+      'stdout should have _isStdio true'\n+    );\n+    assert(\n+      process.stdout instanceof Writable,\n+      'stdout should be instance of Writable'\n+    );\n+\n+    assert.strictEqual(process.stderr.fd, 2, 'stderr should have fd 2');\n+    assert.strictEqual(\n+      process.stderr.readable,\n+      false,\n+      'stderr should not be readable'\n+    );\n+    assert.strictEqual(\n+      process.stderr._type,\n+      'fs',\n+      'stderr should have _type \"fs\"'\n+    );\n+    assert.strictEqual(\n+      process.stderr._isStdio,\n+      true,\n+      'stderr should have _isStdio true'\n+    );\n+    assert(\n+      process.stderr instanceof Writable,\n+      'stderr should be instance of Writable'\n+    );\n+  },\n+};\n+\n+export const processStdioWriteTest = {\n+  async test() {\n+    process.stdout.write('Test string write to stdout\n');\n+    process.stderr.write('Test string write to stderr\n');",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224169115",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/api/node/tests/process-stdio-nodejs-test.js",
        "discussion_id": "2224169115",
        "commented_code": "@@ -0,0 +1,235 @@\n+import { ReadStream } from 'node:fs';\n+import { readSync, writeSync } from 'node:fs';\n+import { Buffer } from 'node:buffer';\n+import { Readable, Writable } from 'node:stream';\n+import assert from 'node:assert';\n+\n+export const processStdioPropertiesTest = {\n+  test() {\n+    assert.strictEqual(process.stdin.fd, 0, 'stdin should have fd 0');\n+    assert(\n+      process.stdin instanceof Readable,\n+      'stdin should be instance of Readable'\n+    );\n+    assert(\n+      process.stdin instanceof ReadStream,\n+      'stdin should be instance of ReadStream'\n+    );\n+\n+    assert.strictEqual(process.stdout.fd, 1, 'stdout should have fd 1');\n+    assert.strictEqual(\n+      process.stdout.readable,\n+      false,\n+      'stdout should not be readable'\n+    );\n+    assert.strictEqual(\n+      process.stdout._type,\n+      'fs',\n+      'stdout should have _type \"fs\"'\n+    );\n+    assert.strictEqual(\n+      process.stdout._isStdio,\n+      true,\n+      'stdout should have _isStdio true'\n+    );\n+    assert(\n+      process.stdout instanceof Writable,\n+      'stdout should be instance of Writable'\n+    );\n+\n+    assert.strictEqual(process.stderr.fd, 2, 'stderr should have fd 2');\n+    assert.strictEqual(\n+      process.stderr.readable,\n+      false,\n+      'stderr should not be readable'\n+    );\n+    assert.strictEqual(\n+      process.stderr._type,\n+      'fs',\n+      'stderr should have _type \"fs\"'\n+    );\n+    assert.strictEqual(\n+      process.stderr._isStdio,\n+      true,\n+      'stderr should have _isStdio true'\n+    );\n+    assert(\n+      process.stderr instanceof Writable,\n+      'stderr should be instance of Writable'\n+    );\n+  },\n+};\n+\n+export const processStdioWriteTest = {\n+  async test() {\n+    process.stdout.write('Test string write to stdout\\n');\n+    process.stderr.write('Test string write to stderr\\n');",
        "comment_created_at": "2025-07-23T02:17:42+00:00",
        "comment_author": "jasnell",
        "comment_body": "Perhaps have a test that includes multiple `\\n` instances in a single write?",
        "pr_file_module": null
      },
      {
        "comment_id": "2226925683",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/api/node/tests/process-stdio-nodejs-test.js",
        "discussion_id": "2224169115",
        "commented_code": "@@ -0,0 +1,235 @@\n+import { ReadStream } from 'node:fs';\n+import { readSync, writeSync } from 'node:fs';\n+import { Buffer } from 'node:buffer';\n+import { Readable, Writable } from 'node:stream';\n+import assert from 'node:assert';\n+\n+export const processStdioPropertiesTest = {\n+  test() {\n+    assert.strictEqual(process.stdin.fd, 0, 'stdin should have fd 0');\n+    assert(\n+      process.stdin instanceof Readable,\n+      'stdin should be instance of Readable'\n+    );\n+    assert(\n+      process.stdin instanceof ReadStream,\n+      'stdin should be instance of ReadStream'\n+    );\n+\n+    assert.strictEqual(process.stdout.fd, 1, 'stdout should have fd 1');\n+    assert.strictEqual(\n+      process.stdout.readable,\n+      false,\n+      'stdout should not be readable'\n+    );\n+    assert.strictEqual(\n+      process.stdout._type,\n+      'fs',\n+      'stdout should have _type \"fs\"'\n+    );\n+    assert.strictEqual(\n+      process.stdout._isStdio,\n+      true,\n+      'stdout should have _isStdio true'\n+    );\n+    assert(\n+      process.stdout instanceof Writable,\n+      'stdout should be instance of Writable'\n+    );\n+\n+    assert.strictEqual(process.stderr.fd, 2, 'stderr should have fd 2');\n+    assert.strictEqual(\n+      process.stderr.readable,\n+      false,\n+      'stderr should not be readable'\n+    );\n+    assert.strictEqual(\n+      process.stderr._type,\n+      'fs',\n+      'stderr should have _type \"fs\"'\n+    );\n+    assert.strictEqual(\n+      process.stderr._isStdio,\n+      true,\n+      'stderr should have _isStdio true'\n+    );\n+    assert(\n+      process.stderr instanceof Writable,\n+      'stderr should be instance of Writable'\n+    );\n+  },\n+};\n+\n+export const processStdioWriteTest = {\n+  async test() {\n+    process.stdout.write('Test string write to stdout\\n');\n+    process.stderr.write('Test string write to stderr\\n');",
        "comment_created_at": "2025-07-23T23:12:07+00:00",
        "comment_author": "guybedford",
        "comment_body": "Thanks, added along with structured logging tests of the same.",
        "pr_file_module": null
      }
    ]
  }
]