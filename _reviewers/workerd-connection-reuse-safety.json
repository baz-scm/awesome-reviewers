[
  {
    "discussion_id": "2070421050",
    "pr_number": 4005,
    "pr_file": "src/workerd/api/tests/http-socket-test.js",
    "created_at": "2025-05-01T15:38:04+00:00",
    "commented_code": "+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2070421050",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-01T15:38:04+00:00",
        "comment_author": "xortive",
        "comment_body": "I don't understand this try/catch -- we want to the fetcher to work for multiple requests",
        "pr_file_module": null
      },
      {
        "comment_id": "2070428748",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-01T15:44:20+00:00",
        "comment_author": "danlapid",
        "comment_body": "The fetcher sadly can't really work on multiple requests as we can't be absolutely sure whether the previous request completed or are we multiplexing request which obviously isn't supported in http1\n\nI don't see why your interface requires it.\n\nYou will be exposing a fetch interface to your clients\n\nYour code for fetch would essentially be\nfetch(request) {\n  Let socket = await apollo.connect()\n  Let fetcher = convertSocketToHttpClient(socket)\n  Return await fetcher.fetch(request)\n}\n\nMeaning each connection is only used for a single request as expected",
        "pr_file_module": null
      },
      {
        "comment_id": "2070487631",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-01T16:34:48+00:00",
        "comment_author": "xortive",
        "comment_body": "> The fetcher sadly can't really work on multiple requests as we can't be absolutely sure whether the previous request completed or are we multiplexing request which obviously isn't supported in http1\r\n\r\nKJ's HTTP implementation should handle managing the state of the connection I would think? Connection keep-alive is a core part of the protocol...\r\n\r\n> I don't see why your interface requires it.\r\n\r\nYour code for fetch would essentially be\r\n```\r\nfetch(request) {\r\n    let socket = await apollo.connect()\r\n    let fetcher = convertSocketToHttpClient(socket)\r\n    return await fetcher.fetch(request)\r\n}\r\n```\r\n\r\nThe worker isn't always going to act as a proxy, it might make multiple requests to a single endpoint, having to re-create the connection every time would be unfortunate.\r\n\r\nI think we might need to expose a \"fetcher capability\" similar to a durable object stub, that can be re-used for multiple requests?",
        "pr_file_module": null
      },
      {
        "comment_id": "2070488678",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-01T16:35:48+00:00",
        "comment_author": "xortive",
        "comment_body": "If this adds a significant amount of implementation complexity, I'm fine merging this as-is, and we can deal with it later, but if KJ handles the difficult part of managing the state of the underlying connection, I don't see why we can't make the fetcher multi-use?",
        "pr_file_module": null
      },
      {
        "comment_id": "2070529337",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-01T17:07:17+00:00",
        "comment_author": "danlapid",
        "comment_body": "The above does enable fetch to be called multiple times though\nIt's just that every fetch would be a new connection",
        "pr_file_module": null
      },
      {
        "comment_id": "2070536069",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-01T17:10:35+00:00",
        "comment_author": "xortive",
        "comment_body": "> The above does enable fetch to be called multiple times though\r\nIt's just that every fetch would be a new connection\r\n\r\nI'd like to take a shot at supporting connection reuse in this PR. If not, we can live with new connection per request for prototyping by having the binding implement support for multiple requests by calling `createHttpClient` every time like you mentioned.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075580685",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-06T14:15:36+00:00",
        "comment_author": "kentonv",
        "comment_body": "I agree with @xortive that we should support connection reuse. It should be no problem to support in this code as KJ HTTP already handles it.\r\n\r\nYes, there is the caveat that responses will be FIFO and if any response stream breaks, all later responses are also broken. We'll need to advise app developers that it's best to send only one request at a time, and if the fetch() or response stream read throws an exception, don't reuse the connection. But IMO connection reuse is too useful to simply disallow for fear of these footguns.",
        "pr_file_module": null
      },
      {
        "comment_id": "2076043525",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-06T18:31:57+00:00",
        "comment_author": "danlapid",
        "comment_body": "@kentonv any way I tried to implement this either allows the user to create deadlocks or to throw KJ exceptions that will end up in sentry.\r\nIf I just try to reuse the connection without kj::mving it then there is a kj exception when the client does 2 concurrent requests\r\ne.g\r\n```js\r\n        const responses = await Promise.all([\r\n          httpClient.fetch('/ping'),\r\n          httpClient.fetch('/json'),\r\n        ]);\r\n```\r\nIf I try to use the stream to create an HttpClient and then create an HttpService out of that and then pass that into the WorkerInterface then the above snippet just deadlocks and never returns.\r\n\r\nBoth of these seem like really bad possibilities.\r\nIf I'm doing something obviously wrong please refer me to the intended way to implement this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2076049800",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-06T18:36:58+00:00",
        "comment_author": "xortive",
        "comment_body": "FWIW, there's more factors at here for optimization than just connection reuse for our usecase. The service we will communicate with using this binding supports FD passing after connection establishment, and for the eventual product release we will likely need to implement support for this in our binding implementation.\r\n\r\nI suspect building a JS API to allow receiving FDs from an `InternalHTTPService` may be more complex than just writing a C++ implementation for our binding when we want to move out of the prototyping phase.\r\n\r\nWith the above context in mind, I'd be perfectly content landing this as-is without connection reuse and marked as experimental, so we can unblock prototyping, considering we may end up moving to a C++ binding implementation later on regardless...",
        "pr_file_module": null
      },
      {
        "comment_id": "2080452057",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-05-08T20:53:58+00:00",
        "comment_author": "kentonv",
        "comment_body": "@danlapid \r\n\r\n> If I just try to reuse the connection without kj::mving it then there is a kj exception when the client does 2 concurrent requests\r\n\r\nWhat is the exception?",
        "pr_file_module": null
      },
      {
        "comment_id": "2196286621",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-10T01:09:03+00:00",
        "comment_author": "tewaro",
        "comment_body": "Exception: \r\n```\r\nworkerd/jsg/util.c++:320: error: e = kj/async-io.c++:925: failed: can't read() again until previous read() completes\r\nstack: src/workerd/server/workerd@9720a34 src/workerd/server/workerd@971e50f src/workerd/server/workerd@9748e9b src/workerd/server/workerd@971284b src/workerd/server/workerd@4f525f0 src/workerd/server/workerd@5015060 src/workerd/server/workerd@5022a62 src/workerd/server/workerd@4fc4460 src/workerd/server/workerd@5006970 src/workerd/server/workerd@2e5d7c0 src/workerd/server/workerd@4380f80 src/workerd/server/workerd@41762a0\r\nkj::(anonymous namespace)::AsyncPipe::BlockedRead::tryRead(void*, unsigned long, unsigned long)\r\nasync-io.c++:0:0\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2196288647",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-10T01:10:28+00:00",
        "comment_author": "tewaro",
        "comment_body": "This is based on the commit titled: `AsyncIoStream reuse attempt 1`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198213815",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-10T16:38:49+00:00",
        "comment_author": "tewaro",
        "comment_body": "@kentonv is this exception acceptable, or should we try to do something else?",
        "pr_file_module": null
      },
      {
        "comment_id": "2212005560",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-17T02:15:58+00:00",
        "comment_author": "kentonv",
        "comment_body": "This exception is pretty bad -- it implies two things are trying to read from the stream at the same time, which could lead to corruption. In fact, overlapping calls to read() on a KJ stream is undefined behavior; this particular implementation is throwing an exception, but only as a courtesy.\r\n\r\nNormally, though, KJ HTTP should automatically enforce queuing of requests and should not allow multiple overlapping reads from the underlying  stream. Something is going wrong in this case. I guess I'd have to study it to understand what.",
        "pr_file_module": null
      },
      {
        "comment_id": "2214148872",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-17T19:41:39+00:00",
        "comment_author": "danlapid",
        "comment_body": "Can we settle on disallowing fetcher reuse to unblock Workers VPC and revisit this if you can figure out what's going wrong?",
        "pr_file_module": null
      },
      {
        "comment_id": "2225800471",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-23T14:32:39+00:00",
        "comment_author": "tewaro",
        "comment_body": "After adding a redirect test as @dom96 mentioned I think this causes a problem if we don't allow multiple fetches, essentially when trying to follow the redirect another fetch is made on the same socket. This definitely limits server behavior but not sure if that matters @xortive do we need redirects?",
        "pr_file_module": null
      },
      {
        "comment_id": "2226163329",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-23T16:54:05+00:00",
        "comment_author": "kentonv",
        "comment_body": "Hmm, it's pretty unclear how automatic redirect following should work at all here. What if the redirect is to a different hostname? Should it really go to the same socket? It sort of depends on the use case.\r\n\r\nMaybe we should require people to set `redirect: \"manual\"` for now. Although that's pretty tedious, as unfortunately \"automatic\" is the default.",
        "pr_file_module": null
      },
      {
        "comment_id": "2240987340",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-07-29T20:48:04+00:00",
        "comment_author": "xortive",
        "comment_body": "After discussing this with @kentonv offline, I think the approach we want to take is to support redirects:\r\n\r\n- Requiring a non-default option like `redirect: \"manual\"` is pretty weird\r\n- If the redirect is to a different path on the same host, it should work fine\r\n- If the redirect is to a different host, the request will likely 404. The solution to this problem is a \"network\" binding where multiple hosts are exposed in a single capability. This won't be needed for the WVPC MVP.",
        "pr_file_module": null
      },
      {
        "comment_id": "2254677880",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2070421050",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {",
        "comment_created_at": "2025-08-05T15:21:01+00:00",
        "comment_author": "tewaro",
        "comment_body": "I plan to address redirection in the next PR, there are a few approaches to enable nonconcurrent requests on the socket.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076412285",
    "pr_number": 4005,
    "pr_file": "src/workerd/api/tests/http-socket-test.js",
    "created_at": "2025-05-06T22:04:00+00:00",
    "commented_code": "+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test multiple concurrent requests on the same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      try {\n+        const responses = await Promise.all([\n+          httpClient.fetch('/ping'),\n+          httpClient.fetch('/json'),\n+        ]);\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test that demonstrates the issue: socket is unusable after creating HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First, successfully use the HTTP client\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+\n+      // Now try to use the socket directly - this should fail because the streams are detached\n+      try {\n+        socket.writable.getWriter();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.writable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This WritableStream is currently locked to a writer.'\n+          ),\n+          'Expected the error message to contain \"This WritableStream is currently locked to a writer.\"'\n+        );\n+      }\n+      try {\n+        let reader = socket.readable.getReader();\n+        await reader.read();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.readable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This ReadableStream is currently locked to a reader.'\n+          ),\n+          'Expected the error message to contain \"This ReadableStream is currently locked to a reader.\"'\n+        );\n+      }\n+    }\n+\n+    // Test that closing the socket does not affect the HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      // Now close the socket\n+      await socket.close();\n+\n+      // Try to send a request with the HTTP client after closing the socket\n+      // This should still work since the HTTP client should have its own stream\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+    }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2076412285",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2076412285",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test multiple concurrent requests on the same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      try {\n+        const responses = await Promise.all([\n+          httpClient.fetch('/ping'),\n+          httpClient.fetch('/json'),\n+        ]);\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test that demonstrates the issue: socket is unusable after creating HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First, successfully use the HTTP client\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+\n+      // Now try to use the socket directly - this should fail because the streams are detached\n+      try {\n+        socket.writable.getWriter();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.writable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This WritableStream is currently locked to a writer.'\n+          ),\n+          'Expected the error message to contain \"This WritableStream is currently locked to a writer.\"'\n+        );\n+      }\n+      try {\n+        let reader = socket.readable.getReader();\n+        await reader.read();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.readable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This ReadableStream is currently locked to a reader.'\n+          ),\n+          'Expected the error message to contain \"This ReadableStream is currently locked to a reader.\"'\n+        );\n+      }\n+    }\n+\n+    // Test that closing the socket does not affect the HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      // Now close the socket\n+      await socket.close();\n+\n+      // Try to send a request with the HTTP client after closing the socket\n+      // This should still work since the HTTP client should have its own stream\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+    }",
        "comment_created_at": "2025-05-06T22:04:00+00:00",
        "comment_author": "jasnell",
        "comment_body": "Additional test cases here should include:\r\n\r\n1. What happens if the socket writable/readable are already locked to a `Writer` or `Reader`\r\n2. What happens if the socket has already been partially consumed / written to\r\n3. What happens if the socket has been errored\r\n4. What happens if the socket is configured to potentially use tls upgrade (internally we use a packet protocol to communicate with the proxy layer when tls upgrade is expected...)\r\n5. What happens if the remote end drops the connection prematurely\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2081849177",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2076412285",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test multiple concurrent requests on the same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      try {\n+        const responses = await Promise.all([\n+          httpClient.fetch('/ping'),\n+          httpClient.fetch('/json'),\n+        ]);\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test that demonstrates the issue: socket is unusable after creating HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First, successfully use the HTTP client\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+\n+      // Now try to use the socket directly - this should fail because the streams are detached\n+      try {\n+        socket.writable.getWriter();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.writable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This WritableStream is currently locked to a writer.'\n+          ),\n+          'Expected the error message to contain \"This WritableStream is currently locked to a writer.\"'\n+        );\n+      }\n+      try {\n+        let reader = socket.readable.getReader();\n+        await reader.read();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.readable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This ReadableStream is currently locked to a reader.'\n+          ),\n+          'Expected the error message to contain \"This ReadableStream is currently locked to a reader.\"'\n+        );\n+      }\n+    }\n+\n+    // Test that closing the socket does not affect the HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      // Now close the socket\n+      await socket.close();\n+\n+      // Try to send a request with the HTTP client after closing the socket\n+      // This should still work since the HTTP client should have its own stream\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+    }",
        "comment_created_at": "2025-05-09T14:49:13+00:00",
        "comment_author": "dom96",
        "comment_body": "Another test that may be worthwhile: what happens when a full URL is specified, it should fail.\r\n\r\nAlso can the Fetcher/kj::HttpClient follow redirects? Might be worth checking what happens when the HTTP server returns a 301.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2081876961",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2076412285",
        "commented_code": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, convertSocketToFetcher } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+\n+export default {\n+  async test(ctrl, env) {\n+    // Basic connectivity and GET test\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, 'pong');\n+    }\n+\n+    // Test JSON response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/json');\n+      assert.equal(response.status, 200);\n+      assert.equal(response.headers.get('content-type'), 'application/json');\n+      const data = await response.json();\n+      assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+    }\n+\n+    // Test POST request with body\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const postData = 'Hello, world!';\n+      const response = await httpClient.fetch('/echo', {\n+        method: 'POST',\n+        body: postData,\n+      });\n+      assert.equal(response.status, 200);\n+      const text = await response.text();\n+      assert.equal(text, postData);\n+    }\n+\n+    // Test request with custom headers\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/headers', {\n+        headers: {\n+          'X-Custom-Header': 'custom-value',\n+          'X-Another-Header': 'another-value',\n+        },\n+      });\n+      assert.equal(response.status, 200);\n+      const headers = await response.json();\n+      assert.equal(headers['x-custom-header'], 'custom-value');\n+      assert.equal(headers['x-another-header'], 'another-value');\n+    }\n+\n+    // Test 404 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/404');\n+      assert.equal(response.status, 404);\n+      const text = await response.text();\n+      assert.equal(text, 'Not Found');\n+    }\n+\n+    // Test 500 response\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      const response = await httpClient.fetch('/status/500');\n+      assert.equal(response.status, 500);\n+      const text = await response.text();\n+      assert.equal(text, 'Internal Server Error');\n+    }\n+\n+    // Test multiple requests on same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First request\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+      const text1 = await response1.text();\n+      assert.equal(text1, 'pong');\n+      try {\n+        // Second request on same connection\n+        const response2 = await httpClient.fetch('/json');\n+        assert.equal(response2.status, 200);\n+        const data = await response2.json();\n+        assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test multiple concurrent requests on the same connection\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      try {\n+        const responses = await Promise.all([\n+          httpClient.fetch('/ping'),\n+          httpClient.fetch('/json'),\n+        ]);\n+      } catch (error) {\n+        assert(error instanceof Error, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'Fetcher created from convertSocketToFetcher can only be used once'\n+          ),\n+          'Expected the error message to contain \"Fetcher created from convertSocketToFetcher can only be used once\"'\n+        );\n+      }\n+    }\n+\n+    // Test that demonstrates the issue: socket is unusable after creating HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+\n+      // First, successfully use the HTTP client\n+      const response = await httpClient.fetch('/ping');\n+      assert.equal(response.status, 200);\n+\n+      // Now try to use the socket directly - this should fail because the streams are detached\n+      try {\n+        socket.writable.getWriter();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.writable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This WritableStream is currently locked to a writer.'\n+          ),\n+          'Expected the error message to contain \"This WritableStream is currently locked to a writer.\"'\n+        );\n+      }\n+      try {\n+        let reader = socket.readable.getReader();\n+        await reader.read();\n+\n+        // This should not be reached\n+        assert.fail(\n+          'Expected socket.readable to throw an error, but it did not'\n+        );\n+      } catch (error) {\n+        // We expect an error because the socket has been detached\n+        // The specific error message might vary, so we'll just check that an error was thrown\n+        assert(error instanceof TypeError, 'Expected an Error to be thrown');\n+        assert(\n+          error.message.includes(\n+            'This ReadableStream is currently locked to a reader.'\n+          ),\n+          'Expected the error message to contain \"This ReadableStream is currently locked to a reader.\"'\n+        );\n+      }\n+    }\n+\n+    // Test that closing the socket does not affect the HTTP client\n+    {\n+      const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+      const httpClient = convertSocketToFetcher(socket);\n+      // Now close the socket\n+      await socket.close();\n+\n+      // Try to send a request with the HTTP client after closing the socket\n+      // This should still work since the HTTP client should have its own stream\n+      const response1 = await httpClient.fetch('/ping');\n+      assert.equal(response1.status, 200);\n+    }",
        "comment_created_at": "2025-05-09T15:04:52+00:00",
        "comment_author": "kentonv",
        "comment_body": "> Another test that may be worthwhile: what happens when a full URL is specified, it should fail.\r\n\r\nWait, what? `fetch()` always requires a full URL. I see as currently implemented this is accepting paths without a hostname or scheme. We should fix that. The hostname should be required and used to populate the `Host` header.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258203844",
    "pr_number": 4005,
    "pr_file": "src/workerd/api/tests/http-socket-test.js",
    "created_at": "2025-08-06T20:20:10+00:00",
    "commented_code": "+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2258203844",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2258203844",
        "commented_code": "@@ -0,0 +1,501 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });",
        "comment_created_at": "2025-08-06T20:20:10+00:00",
        "comment_author": "jasnell",
        "comment_body": "Hmm... yeah, this is a bit weird. Generally it should be possible to use this fetch multiple times but each call to fetch should create it's own one-time-use `kj::HttpClient` under the covers, just reusing the same stream. Then, of course, it should forbid allowing multiple fetches to be in flight at the same time.\r\n\r\nEssentially a pattern like:\r\n\r\n* Calling `internalNewHttpClient` returns a fetcher that takes ownership of the underlying connection stream.. but...\r\n* Instead of creating an http client immediately, each call to fetch:\r\n  * Checks to see if a client currently exists, if so, error\r\n  * If not, create a new client over the stream, perform the fetch, release the stream when done to free it up for a new fetch (unless it errored, at which point the socket is errored)",
        "pr_file_module": null
      },
      {
        "comment_id": "2258469865",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2258203844",
        "commented_code": "@@ -0,0 +1,501 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });",
        "comment_created_at": "2025-08-06T22:49:29+00:00",
        "comment_author": "tewaro",
        "comment_body": "I can try this for redirects...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258210850",
    "pr_number": 4005,
    "pr_file": "src/workerd/api/tests/http-socket-test.js",
    "created_at": "2025-08-06T20:23:18+00:00",
    "commented_code": "+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+     * assert.equal(response2.status, 200);\n+     * const data = await response2.json();\n+     * assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+     */\n+  },\n+};\n+\n+export const multipleConcurrentRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when multiple fetches are enabled make sure this message is changed\n+    await assert.rejects(\n+      Promise.all([\n+        httpClient.fetch('https://example.com/ping'),\n+        httpClient.fetch('https://example.com/json'),\n+      ]),\n+      {\n+        name: 'Error',\n+        message:\n+          'Fetcher created from internalNewHttpClient can only be used once',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that demonstrates socket is unusable after creating HTTP client\n+export const socketFetcherUnusable = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First, successfully use the HTTP client\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+\n+    // Now try to use the socket directly - this should fail because the streams are detached\n+    assert.throws(\n+      () => {\n+        socket.writable.getWriter();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This WritableStream is currently locked to a writer.',\n+      }\n+    );\n+\n+    assert.throws(\n+      () => {\n+        socket.readable.getReader();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This ReadableStream is currently locked to a reader.',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that closing the socket does not affect the HTTP client\n+export const socketCloseThenFetch = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+    // Now close the socket\n+    await socket.close();",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2258210850",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2258210850",
        "commented_code": "@@ -0,0 +1,501 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+     * assert.equal(response2.status, 200);\n+     * const data = await response2.json();\n+     * assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+     */\n+  },\n+};\n+\n+export const multipleConcurrentRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when multiple fetches are enabled make sure this message is changed\n+    await assert.rejects(\n+      Promise.all([\n+        httpClient.fetch('https://example.com/ping'),\n+        httpClient.fetch('https://example.com/json'),\n+      ]),\n+      {\n+        name: 'Error',\n+        message:\n+          'Fetcher created from internalNewHttpClient can only be used once',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that demonstrates socket is unusable after creating HTTP client\n+export const socketFetcherUnusable = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First, successfully use the HTTP client\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+\n+    // Now try to use the socket directly - this should fail because the streams are detached\n+    assert.throws(\n+      () => {\n+        socket.writable.getWriter();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This WritableStream is currently locked to a writer.',\n+      }\n+    );\n+\n+    assert.throws(\n+      () => {\n+        socket.readable.getReader();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This ReadableStream is currently locked to a reader.',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that closing the socket does not affect the HTTP client\n+export const socketCloseThenFetch = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+    // Now close the socket\n+    await socket.close();",
        "comment_created_at": "2025-08-06T20:23:18+00:00",
        "comment_author": "jasnell",
        "comment_body": "Hmm, in this case I would expect the `httpClient` to have complete ownership over the socket such that `socket.close()` should be a non-op. If every other way the socket is unusable so this is a bit strange.",
        "pr_file_module": null
      },
      {
        "comment_id": "2258212960",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2258210850",
        "commented_code": "@@ -0,0 +1,501 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+     * assert.equal(response2.status, 200);\n+     * const data = await response2.json();\n+     * assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+     */\n+  },\n+};\n+\n+export const multipleConcurrentRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when multiple fetches are enabled make sure this message is changed\n+    await assert.rejects(\n+      Promise.all([\n+        httpClient.fetch('https://example.com/ping'),\n+        httpClient.fetch('https://example.com/json'),\n+      ]),\n+      {\n+        name: 'Error',\n+        message:\n+          'Fetcher created from internalNewHttpClient can only be used once',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that demonstrates socket is unusable after creating HTTP client\n+export const socketFetcherUnusable = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First, successfully use the HTTP client\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+\n+    // Now try to use the socket directly - this should fail because the streams are detached\n+    assert.throws(\n+      () => {\n+        socket.writable.getWriter();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This WritableStream is currently locked to a writer.',\n+      }\n+    );\n+\n+    assert.throws(\n+      () => {\n+        socket.readable.getReader();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This ReadableStream is currently locked to a reader.',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that closing the socket does not affect the HTTP client\n+export const socketCloseThenFetch = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+    // Now close the socket\n+    await socket.close();",
        "comment_created_at": "2025-08-06T20:24:21+00:00",
        "comment_author": "jasnell",
        "comment_body": "Oh, wait... it helps if I read the entire test case, lol. The httpclient does take over ownership and the `socket.close()` here is actually a non-op? I'd almost prefer that it errors.",
        "pr_file_module": null
      },
      {
        "comment_id": "2258469331",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/tests/http-socket-test.js",
        "discussion_id": "2258210850",
        "commented_code": "@@ -0,0 +1,501 @@\n+// Copyright (c) 2017-2024 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+import { connect, internalNewHttpClient } from 'cloudflare:sockets';\n+import { strict as assert } from 'node:assert';\n+import { setTimeout as sleep } from 'node:timers/promises';\n+\n+// Basic connectivity and GET test\n+export const oneRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+  },\n+};\n+\n+export const jsonResponse = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/json');\n+    assert.equal(response.status, 200);\n+    assert.equal(response.headers.get('content-type'), 'application/json');\n+    const data = await response.json();\n+    assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+  },\n+};\n+\n+export const postRequest = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const postData = 'Hello, world!';\n+    const response = await httpClient.fetch('https://example.com/echo', {\n+      method: 'POST',\n+      body: postData,\n+    });\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, postData);\n+  },\n+};\n+\n+export const customHeaders = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/headers', {\n+      headers: {\n+        'X-Custom-Header': 'custom-value',\n+        'X-Another-Header': 'another-value',\n+      },\n+    });\n+    assert.equal(response.status, 200);\n+    const headers = await response.json();\n+    assert.equal(headers['x-custom-header'], 'custom-value');\n+    assert.equal(headers['x-another-header'], 'another-value');\n+  },\n+};\n+\n+export const response404 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/404');\n+    assert.equal(response.status, 404);\n+    const text = await response.text();\n+    assert.equal(text, 'Not Found');\n+  },\n+};\n+\n+export const response500 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    const response = await httpClient.fetch('https://example.com/status/500');\n+    assert.equal(response.status, 500);\n+    const text = await response.text();\n+    assert.equal(text, 'Internal Server Error');\n+  },\n+};\n+\n+export const redirect301 = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when enabling multiple fetches we can only then do redirects.\n+    await assert.rejects(httpClient.fetch('https://example.com/redirect'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+    assert.equal(response.status, 200);\n+    const text = await response.text();\n+    assert.equal(text, 'pong');\n+    */\n+  },\n+};\n+\n+export const multipleRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First request\n+    const response1 = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response1.status, 200);\n+    const text1 = await response1.text();\n+    assert.equal(text1, 'pong');\n+\n+    // Second request on same connection\n+    // TODO(cleanup) we want this to fail during this initial implementation but later we should\n+    // support mutiple fetches (perhaps behind a compat flag)\n+    await assert.rejects(httpClient.fetch('https://example.com/json'), {\n+      name: 'Error',\n+      message:\n+        'Fetcher created from internalNewHttpClient can only be used once',\n+    });\n+    /*\n+     * assert.equal(response2.status, 200);\n+     * const data = await response2.json();\n+     * assert.deepEqual(data, { message: 'Hello from HTTP socket server' });\n+     */\n+  },\n+};\n+\n+export const multipleConcurrentRequests = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // TODO(cleanup) when multiple fetches are enabled make sure this message is changed\n+    await assert.rejects(\n+      Promise.all([\n+        httpClient.fetch('https://example.com/ping'),\n+        httpClient.fetch('https://example.com/json'),\n+      ]),\n+      {\n+        name: 'Error',\n+        message:\n+          'Fetcher created from internalNewHttpClient can only be used once',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that demonstrates socket is unusable after creating HTTP client\n+export const socketFetcherUnusable = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+\n+    // First, successfully use the HTTP client\n+    const response = await httpClient.fetch('https://example.com/ping');\n+    assert.equal(response.status, 200);\n+\n+    // Now try to use the socket directly - this should fail because the streams are detached\n+    assert.throws(\n+      () => {\n+        socket.writable.getWriter();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This WritableStream is currently locked to a writer.',\n+      }\n+    );\n+\n+    assert.throws(\n+      () => {\n+        socket.readable.getReader();\n+      },\n+      {\n+        name: 'TypeError',\n+        message: 'This ReadableStream is currently locked to a reader.',\n+      }\n+    );\n+  },\n+};\n+\n+// Test that closing the socket does not affect the HTTP client\n+export const socketCloseThenFetch = {\n+  async test(ctrl, env, ctx) {\n+    const socket = connect(`localhost:${env.HTTP_SOCKET_SERVER_PORT}`);\n+    const httpClient = await internalNewHttpClient(socket);\n+    // Now close the socket\n+    await socket.close();",
        "comment_created_at": "2025-08-06T22:49:00+00:00",
        "comment_author": "tewaro",
        "comment_body": "will discuss before seeing if we need to address this.",
        "pr_file_module": null
      }
    ]
  }
]