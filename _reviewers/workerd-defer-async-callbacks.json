[
  {
    "discussion_id": "2243315836",
    "pr_number": 4636,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-30T16:50:16+00:00",
    "commented_code": "try {\n       this.emit('connection', this, incoming);\n       this.emit('request', incoming, response);\n-      return await getServerResponseFetchResponse(response);\n+      const fetchResponse = await getServerResponseFetchResponse(response);\n+\n+      // Emit 'close' event when the response is complete\n+      response._closed = true;\n+      response.emit('close');",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2243315836",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2243315836",
        "commented_code": "@@ -185,7 +207,13 @@ export class Server\n     try {\n       this.emit('connection', this, incoming);\n       this.emit('request', incoming, response);\n-      return await getServerResponseFetchResponse(response);\n+      const fetchResponse = await getServerResponseFetchResponse(response);\n+\n+      // Emit 'close' event when the response is complete\n+      response._closed = true;\n+      response.emit('close');",
        "comment_created_at": "2025-07-30T16:50:16+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n      queueMicrotask(() => response.emit('close'));\r\n```\r\n?",
        "pr_file_module": null
      },
      {
        "comment_id": "2243316766",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2243315836",
        "commented_code": "@@ -185,7 +207,13 @@ export class Server\n     try {\n       this.emit('connection', this, incoming);\n       this.emit('request', incoming, response);\n-      return await getServerResponseFetchResponse(response);\n+      const fetchResponse = await getServerResponseFetchResponse(response);\n+\n+      // Emit 'close' event when the response is complete\n+      response._closed = true;\n+      response.emit('close');",
        "comment_created_at": "2025-07-30T16:50:40+00:00",
        "comment_author": "jasnell",
        "comment_body": "the queueMicrotask might not be needed here, just want to confirm.",
        "pr_file_module": null
      },
      {
        "comment_id": "2243676177",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2243315836",
        "commented_code": "@@ -185,7 +207,13 @@ export class Server\n     try {\n       this.emit('connection', this, incoming);\n       this.emit('request', incoming, response);\n-      return await getServerResponseFetchResponse(response);\n+      const fetchResponse = await getServerResponseFetchResponse(response);\n+\n+      // Emit 'close' event when the response is complete\n+      response._closed = true;\n+      response.emit('close');",
        "comment_created_at": "2025-07-30T19:29:52+00:00",
        "comment_author": "anonrig",
        "comment_body": "It's not needed since the response completion is already on the next tick.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223634600",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-22T19:25:00+00:00",
    "commented_code": "+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    callback?.();",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2223634600",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2223634600",
        "commented_code": "@@ -0,0 +1,735 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    callback?.();",
        "comment_created_at": "2025-07-22T19:25:00+00:00",
        "comment_author": "jasnell",
        "comment_body": "Does Node.js call this immediately or should this be defered with a `nextTick()`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2223637172",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2223634600",
        "commented_code": "@@ -0,0 +1,735 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    callback?.();",
        "comment_created_at": "2025-07-22T19:26:32+00:00",
        "comment_author": "anonrig",
        "comment_body": "Nice catch, we need to do it in next tick.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2236805102",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_outgoing.ts",
    "created_at": "2025-07-28T14:48:44+00:00",
    "commented_code": "encoding: WrittenDataBufferEntry['encoding'],\n     callback: WrittenDataBufferEntry['callback']\n   ): boolean {\n-    this.#data.push({\n+    const entry: WrittenDataBufferEntry = {\n       data,\n       length: data?.length ?? 0,\n       encoding,\n       callback,\n-      written: false,\n-    });\n-    this._flush();\n+      written: true,\n+    };\n+\n+    if (this.#corked === 0) {\n+      this.#onWrite(this.#index++, entry);\n+      callback?.();",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2236805102",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_outgoing.ts",
        "discussion_id": "2236805102",
        "commented_code": "@@ -111,14 +115,24 @@ class MessageBuffer {\n     encoding: WrittenDataBufferEntry['encoding'],\n     callback: WrittenDataBufferEntry['callback']\n   ): boolean {\n-    this.#data.push({\n+    const entry: WrittenDataBufferEntry = {\n       data,\n       length: data?.length ?? 0,\n       encoding,\n       callback,\n-      written: false,\n-    });\n-    this._flush();\n+      written: true,\n+    };\n+\n+    if (this.#corked === 0) {\n+      this.#onWrite(this.#index++, entry);\n+      callback?.();",
        "comment_created_at": "2025-07-28T14:48:44+00:00",
        "comment_author": "jasnell",
        "comment_body": "Even in this case the callback is expected to be run async.\r\n\r\n```suggestion\r\n      queueMicrotask(() => callback?.());\r\n```\r\n\r\nFor example, in Node.js:\r\n```js\r\nconst { Writable } = require('stream');\r\nconst w = new Writable({ write(d, e, cb) { console.log('.'); cb(); }});\r\nw.write('hello', () => console.log('!'));\r\nconsole.log('written');\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\n.\r\nwritten\r\n!\r\n```",
        "pr_file_module": null
      }
    ]
  }
]