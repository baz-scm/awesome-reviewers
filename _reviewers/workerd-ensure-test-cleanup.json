[
  {
    "discussion_id": "2277040434",
    "pr_number": 4405,
    "pr_file": "src/workerd/io/actor-sqlite-test.c++",
    "created_at": "2025-08-14T15:56:55+00:00",
    "commented_code": "KJ_ASSERT(expectSync(test.getAlarm()) == oneMs);\n }\n \n+KJ_TEST(\"check put multiple wraps operations in a transaction\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\n+    \"check put multiple wraps operations in a transaction with sql-kv-put-multiple-transaction autogate\") {\n+  ActorSqliteTest test;\n+\n+  // This test should reflect the same behavior we saw without the autogate enabled.\n+  util::Autogate::initAutogateNamesForTest({\"sql-kv-put-multiple-transaction\"_kj});\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\"check put multiple wraps operations in a transaction and does not rollbacks on error\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+\n+  // Add some regular key-value pairs that we know are supported\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+\n+  // Now create a key that's too large. Should fail with  string or blob too big: SQLITE_TOOBIG\n+  auto tooLongKey = kj::heapString(2200000);\n+  for (int x = 0; x < 2200000; x++) {\n+    tooLongKey[x] = 'a';\n+  }\n+  // Add it to our KV array\n+  putKVs.add(\n+      ActorCache::KeyValuePair{kj::str(tooLongKey), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    try {\n+      test.putMultiple(putKVs.releaseAsArray());\n+      // We should fail with correct error before reaching here.\n+      KJ_UNREACHABLE;\n+    } catch (kj::Exception e) {\n+      KJ_ASSERT(\n+          e.getDescription() == \"expected false; jsg.Error: string or blob too big: SQLITE_TOOBIG\");\n+    }\n+    // We need this check for the @all-autogates-enabled test variant.",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2277040434",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4405,
        "pr_file": "src/workerd/io/actor-sqlite-test.c++",
        "discussion_id": "2277040434",
        "commented_code": "@@ -168,6 +179,295 @@ KJ_TEST(\"can set and get alarm\") {\n   KJ_ASSERT(expectSync(test.getAlarm()) == oneMs);\n }\n \n+KJ_TEST(\"check put multiple wraps operations in a transaction\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\n+    \"check put multiple wraps operations in a transaction with sql-kv-put-multiple-transaction autogate\") {\n+  ActorSqliteTest test;\n+\n+  // This test should reflect the same behavior we saw without the autogate enabled.\n+  util::Autogate::initAutogateNamesForTest({\"sql-kv-put-multiple-transaction\"_kj});\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\"check put multiple wraps operations in a transaction and does not rollbacks on error\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+\n+  // Add some regular key-value pairs that we know are supported\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+\n+  // Now create a key that's too large. Should fail with  string or blob too big: SQLITE_TOOBIG\n+  auto tooLongKey = kj::heapString(2200000);\n+  for (int x = 0; x < 2200000; x++) {\n+    tooLongKey[x] = 'a';\n+  }\n+  // Add it to our KV array\n+  putKVs.add(\n+      ActorCache::KeyValuePair{kj::str(tooLongKey), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    try {\n+      test.putMultiple(putKVs.releaseAsArray());\n+      // We should fail with correct error before reaching here.\n+      KJ_UNREACHABLE;\n+    } catch (kj::Exception e) {\n+      KJ_ASSERT(\n+          e.getDescription() == \"expected false; jsg.Error: string or blob too big: SQLITE_TOOBIG\");\n+    }\n+    // We need this check for the @all-autogates-enabled test variant.",
        "comment_created_at": "2025-08-14T15:56:55+00:00",
        "comment_author": "justin-mp",
        "comment_body": "Rather than doing this, it might be easier to think about to check for the autogate at the top of the test, and if it's set, emit a log saying you're skipping this test because the autogate is set and then return.",
        "pr_file_module": null
      },
      {
        "comment_id": "2277174186",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4405,
        "pr_file": "src/workerd/io/actor-sqlite-test.c++",
        "discussion_id": "2277040434",
        "commented_code": "@@ -168,6 +179,295 @@ KJ_TEST(\"can set and get alarm\") {\n   KJ_ASSERT(expectSync(test.getAlarm()) == oneMs);\n }\n \n+KJ_TEST(\"check put multiple wraps operations in a transaction\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\n+    \"check put multiple wraps operations in a transaction with sql-kv-put-multiple-transaction autogate\") {\n+  ActorSqliteTest test;\n+\n+  // This test should reflect the same behavior we saw without the autogate enabled.\n+  util::Autogate::initAutogateNamesForTest({\"sql-kv-put-multiple-transaction\"_kj});\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\"check put multiple wraps operations in a transaction and does not rollbacks on error\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+\n+  // Add some regular key-value pairs that we know are supported\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+\n+  // Now create a key that's too large. Should fail with  string or blob too big: SQLITE_TOOBIG\n+  auto tooLongKey = kj::heapString(2200000);\n+  for (int x = 0; x < 2200000; x++) {\n+    tooLongKey[x] = 'a';\n+  }\n+  // Add it to our KV array\n+  putKVs.add(\n+      ActorCache::KeyValuePair{kj::str(tooLongKey), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    try {\n+      test.putMultiple(putKVs.releaseAsArray());\n+      // We should fail with correct error before reaching here.\n+      KJ_UNREACHABLE;\n+    } catch (kj::Exception e) {\n+      KJ_ASSERT(\n+          e.getDescription() == \"expected false; jsg.Error: string or blob too big: SQLITE_TOOBIG\");\n+    }\n+    // We need this check for the @all-autogates-enabled test variant.",
        "comment_created_at": "2025-08-14T16:48:22+00:00",
        "comment_author": "jqmmes",
        "comment_body": "Addressed in latest update",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2252583688",
    "pr_number": 4678,
    "pr_file": "src/workerd/util/perfetto-tracing-test.c++",
    "created_at": "2025-08-04T21:07:41+00:00",
    "commented_code": "+// Copyright (c) 2025 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+#include \"perfetto-tracing.h\"\n+\n+#include <kj/debug.h>\n+#include <kj/test.h>\n+\n+#ifdef WORKERD_USE_PERFETTO\n+#include \"use-perfetto-categories.h\"\n+\n+#include <fcntl.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+\n+#include <chrono>\n+#include <thread>\n+#endif  // WORKERD_USE_PERFETTO\n+\n+#include <cstdlib>\n+\n+namespace workerd {\n+namespace {\n+\n+#ifdef WORKERD_USE_PERFETTO\n+\n+kj::String getTempFileName(const char* prefix) {\n+  const char* tmpDir = getenv(\"TEST_TMPDIR\");\n+  if (tmpDir == nullptr) tmpDir = \"/tmp\";\n+  return kj::str(tmpDir, \"/\", prefix, \"-\", rand(), \".pb\");\n+}\n+\n+bool fileExists(const char* path) {\n+  struct stat buffer;\n+  return (stat(path, &buffer) == 0);\n+}\n+\n+size_t getFileSize(const char* path) {\n+  struct stat buffer;\n+  if (stat(path, &buffer) != 0) return 0;\n+  return buffer.st_size;\n+}\n+\n+void removeFile(const char* path) {\n+  unlink(path);\n+}\n+\n+KJ_TEST(\"PerfettoSession basic functionality\") {\n+  auto traceFile = getTempFileName(\"perfetto-test\");\n+\n+  {\n+    PerfettoSession session(traceFile, \"workerd\");\n+\n+    TRACE_EVENT(\"workerd\", \"test_event\");\n+    TRACE_EVENT(\"workerd\", \"test_event_with_args\", \"test_arg\", 42);\n+\n+    TRACE_EVENT_BEGIN(\"workerd\", \"test_duration_event\");\n+    std::this_thread::sleep_for(std::chrono::microseconds(100));\n+    TRACE_EVENT_END(\"workerd\");\n+\n+    TRACE_EVENT_INSTANT(\"workerd\", \"test_instant_event\");\n+\n+    TRACE_COUNTER(\"workerd\", \"test_counter\", 100);\n+    TRACE_COUNTER(\"workerd\", \"test_counter\", 200);\n+\n+    session.flush();\n+  }\n+\n+  KJ_ASSERT(fileExists(traceFile.cStr()));\n+  KJ_ASSERT(getFileSize(traceFile.cStr()) > 0);\n+\n+  removeFile(traceFile.cStr());",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2252583688",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4678,
        "pr_file": "src/workerd/util/perfetto-tracing-test.c++",
        "discussion_id": "2252583688",
        "commented_code": "@@ -0,0 +1,187 @@\n+// Copyright (c) 2025 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+#include \"perfetto-tracing.h\"\n+\n+#include <kj/debug.h>\n+#include <kj/test.h>\n+\n+#ifdef WORKERD_USE_PERFETTO\n+#include \"use-perfetto-categories.h\"\n+\n+#include <fcntl.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+\n+#include <chrono>\n+#include <thread>\n+#endif  // WORKERD_USE_PERFETTO\n+\n+#include <cstdlib>\n+\n+namespace workerd {\n+namespace {\n+\n+#ifdef WORKERD_USE_PERFETTO\n+\n+kj::String getTempFileName(const char* prefix) {\n+  const char* tmpDir = getenv(\"TEST_TMPDIR\");\n+  if (tmpDir == nullptr) tmpDir = \"/tmp\";\n+  return kj::str(tmpDir, \"/\", prefix, \"-\", rand(), \".pb\");\n+}\n+\n+bool fileExists(const char* path) {\n+  struct stat buffer;\n+  return (stat(path, &buffer) == 0);\n+}\n+\n+size_t getFileSize(const char* path) {\n+  struct stat buffer;\n+  if (stat(path, &buffer) != 0) return 0;\n+  return buffer.st_size;\n+}\n+\n+void removeFile(const char* path) {\n+  unlink(path);\n+}\n+\n+KJ_TEST(\"PerfettoSession basic functionality\") {\n+  auto traceFile = getTempFileName(\"perfetto-test\");\n+\n+  {\n+    PerfettoSession session(traceFile, \"workerd\");\n+\n+    TRACE_EVENT(\"workerd\", \"test_event\");\n+    TRACE_EVENT(\"workerd\", \"test_event_with_args\", \"test_arg\", 42);\n+\n+    TRACE_EVENT_BEGIN(\"workerd\", \"test_duration_event\");\n+    std::this_thread::sleep_for(std::chrono::microseconds(100));\n+    TRACE_EVENT_END(\"workerd\");\n+\n+    TRACE_EVENT_INSTANT(\"workerd\", \"test_instant_event\");\n+\n+    TRACE_COUNTER(\"workerd\", \"test_counter\", 100);\n+    TRACE_COUNTER(\"workerd\", \"test_counter\", 200);\n+\n+    session.flush();\n+  }\n+\n+  KJ_ASSERT(fileExists(traceFile.cStr()));\n+  KJ_ASSERT(getFileSize(traceFile.cStr()) > 0);\n+\n+  removeFile(traceFile.cStr());",
        "comment_created_at": "2025-08-04T21:07:41+00:00",
        "comment_author": "jasnell",
        "comment_body": "If the tests fail these files are going to accumulate. Likely best to structure this so that the files are always removed whether the tests pass or fail?",
        "pr_file_module": null
      }
    ]
  }
]