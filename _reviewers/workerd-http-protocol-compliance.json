[
  {
    "discussion_id": "2261394512",
    "pr_number": 4721,
    "pr_file": "src/node/internal/internal_http_incoming.ts",
    "created_at": "2025-08-07T21:06:11+00:00",
    "commented_code": "): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      incoming.#socket = {\n+        encrypted: headers.get('x-forwarded-proto') === 'https',\n+        get remoteAddress(): string {\n+          // This is defined in production, and will fallback to localhost on local development\n+          // where request headers does not contain cf-connecting-ip.\n+          return headers.get('cf-connecting-ip') ?? '127.0.0.1';\n+        },\n+        get remotePort(): number {\n+          // We return 80 by default.\n+          return 80;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2261394512",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261394512",
        "commented_code": "@@ -67,6 +75,39 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      incoming.#socket = {\n+        encrypted: headers.get('x-forwarded-proto') === 'https',\n+        get remoteAddress(): string {\n+          // This is defined in production, and will fallback to localhost on local development\n+          // where request headers does not contain cf-connecting-ip.\n+          return headers.get('cf-connecting-ip') ?? '127.0.0.1';\n+        },\n+        get remotePort(): number {\n+          // We return 80 by default.\n+          return 80;",
        "comment_created_at": "2025-08-07T21:06:11+00:00",
        "comment_author": "danlapid",
        "comment_body": "80 feels weird.\r\nall modern operating systems only generate ports in the range of 2^15 and 2^16 for the ephemeral source ports on sockets.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2261397726",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261394512",
        "commented_code": "@@ -67,6 +75,39 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      incoming.#socket = {\n+        encrypted: headers.get('x-forwarded-proto') === 'https',\n+        get remoteAddress(): string {\n+          // This is defined in production, and will fallback to localhost on local development\n+          // where request headers does not contain cf-connecting-ip.\n+          return headers.get('cf-connecting-ip') ?? '127.0.0.1';\n+        },\n+        get remotePort(): number {\n+          // We return 80 by default.\n+          return 80;",
        "comment_created_at": "2025-08-07T21:08:35+00:00",
        "comment_author": "anonrig",
        "comment_body": "Referencing node.js doc:\r\n\r\n> The numeric representation of the remote port. For example, 80 or 21. Value may be undefined if the socket is destroyed (for example, if the client disconnected).\r\n\r\nhttps://nodejs.org/api/net.html#socketremoteport",
        "pr_file_module": null
      },
      {
        "comment_id": "2261400066",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261394512",
        "commented_code": "@@ -67,6 +75,39 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      incoming.#socket = {\n+        encrypted: headers.get('x-forwarded-proto') === 'https',\n+        get remoteAddress(): string {\n+          // This is defined in production, and will fallback to localhost on local development\n+          // where request headers does not contain cf-connecting-ip.\n+          return headers.get('cf-connecting-ip') ?? '127.0.0.1';\n+        },\n+        get remotePort(): number {\n+          // We return 80 by default.\n+          return 80;",
        "comment_created_at": "2025-08-07T21:10:12+00:00",
        "comment_author": "danlapid",
        "comment_body": "That quote has nothing to do with my comment though",
        "pr_file_module": null
      },
      {
        "comment_id": "2261405148",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261394512",
        "commented_code": "@@ -67,6 +75,39 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      incoming.#socket = {\n+        encrypted: headers.get('x-forwarded-proto') === 'https',\n+        get remoteAddress(): string {\n+          // This is defined in production, and will fallback to localhost on local development\n+          // where request headers does not contain cf-connecting-ip.\n+          return headers.get('cf-connecting-ip') ?? '127.0.0.1';\n+        },\n+        get remotePort(): number {\n+          // We return 80 by default.\n+          return 80;",
        "comment_created_at": "2025-08-07T21:13:47+00:00",
        "comment_author": "npaun",
        "comment_body": "e.g. just grab `32768` for a realistic _source_ port number",
        "pr_file_module": null
      },
      {
        "comment_id": "2261409932",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4721,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2261394512",
        "commented_code": "@@ -67,6 +75,39 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     ): void => {\n       incoming.#setFetchResponse(response);\n     };\n+\n+    // This method sets the socket property of the IncomingMessage object.\n+    // Please rest assured that this method implements a subset of Socket since\n+    // in Node.js it's net.Socket which isn't possible to implement within our own\n+    // implementation since our implementation is based on Request and Response objects.\n+    setIncomingMessageSocket = (\n+      incoming: IncomingMessage,\n+      { headers, localPort }: { headers: Headers; localPort: number }\n+    ): void => {\n+      incoming.#socket = {\n+        encrypted: headers.get('x-forwarded-proto') === 'https',\n+        get remoteAddress(): string {\n+          // This is defined in production, and will fallback to localhost on local development\n+          // where request headers does not contain cf-connecting-ip.\n+          return headers.get('cf-connecting-ip') ?? '127.0.0.1';\n+        },\n+        get remotePort(): number {\n+          // We return 80 by default.\n+          return 80;",
        "comment_created_at": "2025-08-07T21:17:08+00:00",
        "comment_author": "anonrig",
        "comment_body": "Ah, now I see. But I'm not sure if we should return a random value or a fixed value in here. What do you think? @jasnell ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2240544593",
    "pr_number": 4636,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-29T17:47:08+00:00",
    "commented_code": "const headers = [];\n     for (const [key, value] of request.headers) {\n-      if (key === 'host') {\n-        // By default fetch implementation will join \"host\" header values with a comma.\n+      if (multipleForbiddenHeaders.includes(key)) {\n+        // By default fetch implementation will join the following header values with a comma.\n         // But in order to be node.js compatible, we need to select the first if possible.\n         headers.push(key, value.split(', ', 1).at(0) as string);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2240544593",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2240544593",
        "commented_code": "@@ -202,8 +223,8 @@ export class Server\n \n     const headers = [];\n     for (const [key, value] of request.headers) {\n-      if (key === 'host') {\n-        // By default fetch implementation will join \"host\" header values with a comma.\n+      if (multipleForbiddenHeaders.includes(key)) {\n+        // By default fetch implementation will join the following header values with a comma.\n         // But in order to be node.js compatible, we need to select the first if possible.\n         headers.push(key, value.split(', ', 1).at(0) as string);",
        "comment_created_at": "2025-07-29T17:47:08+00:00",
        "comment_author": "jasnell",
        "comment_body": "the `value.split(', ')` here will not work correctly with some of these. `content-type` in particular allows parameters to be `quoted-string` which can contain commas. The split algorithm needs to ignore any commas that are contained within quoted-string constructions. The `authorization` and `proxy-authorization` fields also allow for quoted-string parameters. The `value.split(', ')` worked for `host` since valid values for host don't include `quoted-string`",
        "pr_file_module": null
      },
      {
        "comment_id": "2240548840",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2240544593",
        "commented_code": "@@ -202,8 +223,8 @@ export class Server\n \n     const headers = [];\n     for (const [key, value] of request.headers) {\n-      if (key === 'host') {\n-        // By default fetch implementation will join \"host\" header values with a comma.\n+      if (multipleForbiddenHeaders.includes(key)) {\n+        // By default fetch implementation will join the following header values with a comma.\n         // But in order to be node.js compatible, we need to select the first if possible.\n         headers.push(key, value.split(', ', 1).at(0) as string);",
        "comment_created_at": "2025-07-29T17:49:15+00:00",
        "comment_author": "jasnell",
        "comment_body": "example for test case: `content-type: text/plain; f=\"a, b, c\", text/foo; a=\"1, 2, 3\"`",
        "pr_file_module": null
      },
      {
        "comment_id": "2240554892",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2240544593",
        "commented_code": "@@ -202,8 +223,8 @@ export class Server\n \n     const headers = [];\n     for (const [key, value] of request.headers) {\n-      if (key === 'host') {\n-        // By default fetch implementation will join \"host\" header values with a comma.\n+      if (multipleForbiddenHeaders.includes(key)) {\n+        // By default fetch implementation will join the following header values with a comma.\n         // But in order to be node.js compatible, we need to select the first if possible.\n         headers.push(key, value.split(', ', 1).at(0) as string);",
        "comment_created_at": "2025-07-29T17:52:05+00:00",
        "comment_author": "jasnell",
        "comment_body": "Also, I'm not sure if the space after the comma is actually required. It's defined as `OWS` which is \"optional white space\", which is to say that this is not going to be correct with headers that omit the OWS... oh! and it's worth pointing out that `OWS` also includes horizontal-tab, `OWS = *( SP / HTAB )` so the split here needs to take spaces and tabs around both sides of the splitting comma into consideration.",
        "pr_file_module": null
      },
      {
        "comment_id": "2240627605",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2240544593",
        "commented_code": "@@ -202,8 +223,8 @@ export class Server\n \n     const headers = [];\n     for (const [key, value] of request.headers) {\n-      if (key === 'host') {\n-        // By default fetch implementation will join \"host\" header values with a comma.\n+      if (multipleForbiddenHeaders.includes(key)) {\n+        // By default fetch implementation will join the following header values with a comma.\n         // But in order to be node.js compatible, we need to select the first if possible.\n         headers.push(key, value.split(', ', 1).at(0) as string);",
        "comment_created_at": "2025-07-29T18:23:58+00:00",
        "comment_author": "jasnell",
        "comment_body": "See https://www.rfc-editor.org/rfc/rfc7230.html#appendix-B for complete details on the header syntax.",
        "pr_file_module": null
      },
      {
        "comment_id": "2240630246",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4636,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2240544593",
        "commented_code": "@@ -202,8 +223,8 @@ export class Server\n \n     const headers = [];\n     for (const [key, value] of request.headers) {\n-      if (key === 'host') {\n-        // By default fetch implementation will join \"host\" header values with a comma.\n+      if (multipleForbiddenHeaders.includes(key)) {\n+        // By default fetch implementation will join the following header values with a comma.\n         // But in order to be node.js compatible, we need to select the first if possible.\n         headers.push(key, value.split(', ', 1).at(0) as string);",
        "comment_created_at": "2025-07-29T18:25:04+00:00",
        "comment_author": "anonrig",
        "comment_body": "Thanks. Thats definitely helpful! Sounds like a task for the good old AI buddy. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223633190",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-22T19:24:11+00:00",
    "commented_code": "+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2223633190",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2223633190",
        "commented_code": "@@ -0,0 +1,735 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {",
        "comment_created_at": "2025-07-22T19:24:11+00:00",
        "comment_author": "jasnell",
        "comment_body": "In Node.js, if `port` is passed as a `0`, then it is automatically assigned a random available port number. We should support that here. Likely the easiest approach would be to have the `portMapper` be able to assign the port for us.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224125642",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-23T01:28:56+00:00",
    "commented_code": "+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      if (key === 'host') {\n+        // By default fetch implementation will join \"host\" header values with a comma.\n+        // But in order to be node.js compatible, we need to select the first if possible.\n+        headers.push(key, value.split(', ').at(0) as string);\n+      } else {\n+        headers.push(key, value);\n+      }\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    queueMicrotask(() => {\n+      callback?.();\n+    });",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224125642",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2224125642",
        "commented_code": "@@ -0,0 +1,708 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      if (key === 'host') {\n+        // By default fetch implementation will join \"host\" header values with a comma.\n+        // But in order to be node.js compatible, we need to select the first if possible.\n+        headers.push(key, value.split(', ').at(0) as string);\n+      } else {\n+        headers.push(key, value);\n+      }\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    queueMicrotask(() => {\n+      callback?.();\n+    });",
        "comment_created_at": "2025-07-23T01:28:56+00:00",
        "comment_author": "jasnell",
        "comment_body": "Actually, thinking about this further, this is actually supposed to be registered as a handler for the `listening` event emitted by the server and we should probably do the same. It's not super common but there is code in the wild that does `server.on('listening', ...); server.listen()` and that should work here also. So instead of calling the `callback` directly in the queueMicrotask, this should register the event handler and `emit('listening')` in the queueMicrotask.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224126311",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2224125642",
        "commented_code": "@@ -0,0 +1,708 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      if (key === 'host') {\n+        // By default fetch implementation will join \"host\" header values with a comma.\n+        // But in order to be node.js compatible, we need to select the first if possible.\n+        headers.push(key, value.split(', ').at(0) as string);\n+      } else {\n+        headers.push(key, value);\n+      }\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    queueMicrotask(() => {\n+      callback?.();\n+    });",
        "comment_created_at": "2025-07-23T01:29:44+00:00",
        "comment_author": "jasnell",
        "comment_body": "Oh, wait, you're already adding the `'listening'` event handler above... so yeah, you're already halfway there.",
        "pr_file_module": null
      }
    ]
  }
]