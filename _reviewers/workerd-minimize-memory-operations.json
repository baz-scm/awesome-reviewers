[
  {
    "discussion_id": "2299138669",
    "pr_number": 4879,
    "pr_file": "src/workerd/util/checked-queue.h",
    "created_at": "2025-08-25T21:06:59+00:00",
    "commented_code": "+#pragma once\n+\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+\n+#include <concepts>\n+#include <list>\n+\n+namespace workerd::util {\n+\n+template <typename T>\n+concept Movable = std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;\n+\n+// A simple wrapper around std::list that provides a checked queue interface,\n+// ensuring that items can only be moved out of the queue if they exist.\n+// Members are not copyable, only movable. The intention here is to provide\n+// a safe-to-use queue that avoids the pitfalls of using std::list directly\n+// (such as accidentally dangling references when the list is empty but someone\n+// calls front(), etc).\n+template <Movable T>\n+class Queue final {\n+ public:\n+  Queue() = default;\n+  Queue(Queue<T>&&) = default;\n+  Queue<T>& operator=(Queue<T>&&) = default;\n+  KJ_DISALLOW_COPY(Queue);\n+\n+  inline void push(T&& value) {\n+    inner.push_back(kj::mv(value));\n+  }\n+\n+  template <typename... Args>\n+  T& emplace(Args&&... args) KJ_LIFETIMEBOUND {\n+    return inner.emplace_back(std::forward<Args>(args)...);\n+  }\n+\n+  // Pops the front element from the queue, moving it out.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T> pop() {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    T value = kj::mv(inner.front());\n+    inner.pop_front();\n+    return kj::mv(value);\n+  }\n+\n+  // Returns a reference to the front element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T&> peek() KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.front();\n+  }\n+\n+  // Returns a reference to the front element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<const T&> peek() const KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.front();\n+  }\n+\n+  // Returns a reference to the last element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T&> peekBack() KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.back();\n+  }\n+\n+  // Returns a reference to the last element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<const T&> peekBack() const KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.back();\n+  }\n+\n+  // Drains the queue, moving each element to the callback one at a time.\n+  // Returns the number of elements moved.\n+  inline size_t drainTo(auto callback) {\n+    size_t count = 0;\n+    while (!inner.empty()) {\n+      callback(KJ_ASSERT_NONNULL(pop()));\n+      count++;\n+    }\n+    return count;\n+  }\n+\n+  // Removes elements from the queue that satisfy the given condition.\n+  // Returns the number of elements removed.\n+  inline size_t deleteIf(auto callback) {\n+    size_t count = 0;\n+    auto it = inner.begin();\n+    while (it != inner.end()) {\n+      if (callback(*it)) {\n+        it = inner.erase(it);\n+        count++;\n+      } else {\n+        ++it;\n+      }\n+    }\n+    return count;\n+  }\n+\n+  // Takes the first element in the queue that satisfies the given condition, if any.\n+  inline kj::Maybe<T> takeIf(auto callback) {\n+    for (auto it = inner.begin(); it != inner.end(); ++it) {\n+      if (callback(*it)) {\n+        T value = kj::mv(*it);\n+        inner.erase(it);\n+        return kj::mv(value);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2299138669",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4879,
        "pr_file": "src/workerd/util/checked-queue.h",
        "discussion_id": "2299138669",
        "commented_code": "@@ -0,0 +1,167 @@\n+#pragma once\n+\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+\n+#include <concepts>\n+#include <list>\n+\n+namespace workerd::util {\n+\n+template <typename T>\n+concept Movable = std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;\n+\n+// A simple wrapper around std::list that provides a checked queue interface,\n+// ensuring that items can only be moved out of the queue if they exist.\n+// Members are not copyable, only movable. The intention here is to provide\n+// a safe-to-use queue that avoids the pitfalls of using std::list directly\n+// (such as accidentally dangling references when the list is empty but someone\n+// calls front(), etc).\n+template <Movable T>\n+class Queue final {\n+ public:\n+  Queue() = default;\n+  Queue(Queue<T>&&) = default;\n+  Queue<T>& operator=(Queue<T>&&) = default;\n+  KJ_DISALLOW_COPY(Queue);\n+\n+  inline void push(T&& value) {\n+    inner.push_back(kj::mv(value));\n+  }\n+\n+  template <typename... Args>\n+  T& emplace(Args&&... args) KJ_LIFETIMEBOUND {\n+    return inner.emplace_back(std::forward<Args>(args)...);\n+  }\n+\n+  // Pops the front element from the queue, moving it out.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T> pop() {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    T value = kj::mv(inner.front());\n+    inner.pop_front();\n+    return kj::mv(value);\n+  }\n+\n+  // Returns a reference to the front element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T&> peek() KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.front();\n+  }\n+\n+  // Returns a reference to the front element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<const T&> peek() const KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.front();\n+  }\n+\n+  // Returns a reference to the last element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T&> peekBack() KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.back();\n+  }\n+\n+  // Returns a reference to the last element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<const T&> peekBack() const KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.back();\n+  }\n+\n+  // Drains the queue, moving each element to the callback one at a time.\n+  // Returns the number of elements moved.\n+  inline size_t drainTo(auto callback) {\n+    size_t count = 0;\n+    while (!inner.empty()) {\n+      callback(KJ_ASSERT_NONNULL(pop()));\n+      count++;\n+    }\n+    return count;\n+  }\n+\n+  // Removes elements from the queue that satisfy the given condition.\n+  // Returns the number of elements removed.\n+  inline size_t deleteIf(auto callback) {\n+    size_t count = 0;\n+    auto it = inner.begin();\n+    while (it != inner.end()) {\n+      if (callback(*it)) {\n+        it = inner.erase(it);\n+        count++;\n+      } else {\n+        ++it;\n+      }\n+    }\n+    return count;\n+  }\n+\n+  // Takes the first element in the queue that satisfies the given condition, if any.\n+  inline kj::Maybe<T> takeIf(auto callback) {\n+    for (auto it = inner.begin(); it != inner.end(); ++it) {\n+      if (callback(*it)) {\n+        T value = kj::mv(*it);\n+        inner.erase(it);\n+        return kj::mv(value);",
        "comment_created_at": "2025-08-25T21:06:59+00:00",
        "comment_author": "npaun",
        "comment_body": "Generally, you shouldn't need to write `return kj::mv(value);` because it's redundant and it interferes with NRVO (named return value optimization). \n\nBut if there is a reason for it, it might be worth adding a comment to stop people like me from refactoring it in the future.",
        "pr_file_module": null
      },
      {
        "comment_id": "2299199845",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4879,
        "pr_file": "src/workerd/util/checked-queue.h",
        "discussion_id": "2299138669",
        "commented_code": "@@ -0,0 +1,167 @@\n+#pragma once\n+\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+\n+#include <concepts>\n+#include <list>\n+\n+namespace workerd::util {\n+\n+template <typename T>\n+concept Movable = std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;\n+\n+// A simple wrapper around std::list that provides a checked queue interface,\n+// ensuring that items can only be moved out of the queue if they exist.\n+// Members are not copyable, only movable. The intention here is to provide\n+// a safe-to-use queue that avoids the pitfalls of using std::list directly\n+// (such as accidentally dangling references when the list is empty but someone\n+// calls front(), etc).\n+template <Movable T>\n+class Queue final {\n+ public:\n+  Queue() = default;\n+  Queue(Queue<T>&&) = default;\n+  Queue<T>& operator=(Queue<T>&&) = default;\n+  KJ_DISALLOW_COPY(Queue);\n+\n+  inline void push(T&& value) {\n+    inner.push_back(kj::mv(value));\n+  }\n+\n+  template <typename... Args>\n+  T& emplace(Args&&... args) KJ_LIFETIMEBOUND {\n+    return inner.emplace_back(std::forward<Args>(args)...);\n+  }\n+\n+  // Pops the front element from the queue, moving it out.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T> pop() {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    T value = kj::mv(inner.front());\n+    inner.pop_front();\n+    return kj::mv(value);\n+  }\n+\n+  // Returns a reference to the front element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T&> peek() KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.front();\n+  }\n+\n+  // Returns a reference to the front element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<const T&> peek() const KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.front();\n+  }\n+\n+  // Returns a reference to the last element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<T&> peekBack() KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.back();\n+  }\n+\n+  // Returns a reference to the last element without removing it.\n+  // Returns kj::none if the queue is empty.\n+  inline kj::Maybe<const T&> peekBack() const KJ_LIFETIMEBOUND {\n+    if (inner.empty()) {\n+      return kj::none;\n+    }\n+    return inner.back();\n+  }\n+\n+  // Drains the queue, moving each element to the callback one at a time.\n+  // Returns the number of elements moved.\n+  inline size_t drainTo(auto callback) {\n+    size_t count = 0;\n+    while (!inner.empty()) {\n+      callback(KJ_ASSERT_NONNULL(pop()));\n+      count++;\n+    }\n+    return count;\n+  }\n+\n+  // Removes elements from the queue that satisfy the given condition.\n+  // Returns the number of elements removed.\n+  inline size_t deleteIf(auto callback) {\n+    size_t count = 0;\n+    auto it = inner.begin();\n+    while (it != inner.end()) {\n+      if (callback(*it)) {\n+        it = inner.erase(it);\n+        count++;\n+      } else {\n+        ++it;\n+      }\n+    }\n+    return count;\n+  }\n+\n+  // Takes the first element in the queue that satisfies the given condition, if any.\n+  inline kj::Maybe<T> takeIf(auto callback) {\n+    for (auto it = inner.begin(); it != inner.end(); ++it) {\n+      if (callback(*it)) {\n+        T value = kj::mv(*it);\n+        inner.erase(it);\n+        return kj::mv(value);",
        "comment_created_at": "2025-08-25T21:39:59+00:00",
        "comment_author": "jasnell",
        "comment_body": "I've added a comment. Specifically, it's not strictly necessary but I wanted it to be clear that the value is being moved and not copied. If it's bothersome then it's perfectly fine to remove it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283444725",
    "pr_number": 4819,
    "pr_file": "src/workerd/api/http.c++",
    "created_at": "2025-08-18T20:54:07+00:00",
    "commented_code": "if (isRedirectStatusCode(response.statusCode) &&\n       jsRequest->getRedirectEnum() == Request::Redirect::FOLLOW) {\n     KJ_IF_SOME(l, response.headers->get(kj::HttpHeaderId::LOCATION)) {\n-      return handleHttpRedirectResponse(\n-          js, kj::mv(fetcher), kj::mv(jsRequest), kj::mv(urlList), response.statusCode, l);\n+      // Read and discard the entire response body before following the redirect.\n+      // This ensures we fully consume the response to avoid connection issues.\n+      auto& ioContext = IoContext::current();\n+      return ioContext.awaitIo(js, \n+          response.body->readAllBytes().ignoreResult().attach(kj::mv(response.body)),",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2283444725",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4819,
        "pr_file": "src/workerd/api/http.c++",
        "discussion_id": "2283444725",
        "commented_code": "@@ -1524,8 +1524,16 @@ jsg::Promise<jsg::Ref<Response>> handleHttpResponse(jsg::Lock& js,\n   if (isRedirectStatusCode(response.statusCode) &&\n       jsRequest->getRedirectEnum() == Request::Redirect::FOLLOW) {\n     KJ_IF_SOME(l, response.headers->get(kj::HttpHeaderId::LOCATION)) {\n-      return handleHttpRedirectResponse(\n-          js, kj::mv(fetcher), kj::mv(jsRequest), kj::mv(urlList), response.statusCode, l);\n+      // Read and discard the entire response body before following the redirect.\n+      // This ensures we fully consume the response to avoid connection issues.\n+      auto& ioContext = IoContext::current();\n+      return ioContext.awaitIo(js, \n+          response.body->readAllBytes().ignoreResult().attach(kj::mv(response.body)),",
        "comment_created_at": "2025-08-18T20:54:07+00:00",
        "comment_author": "kentonv",
        "comment_body": "It'd be somewhat more efficient to pump the bytes to a null stream or something. `readAllBytes()` will buffer them in memory just to be discarded later.\n\nRedirect response bodies are probably always tiny -- unless the server is malicious and trying to eat our memory. Note that this memory won't be accounted to the isolate.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283664817",
    "pr_number": 4819,
    "pr_file": "src/workerd/util/stream-utils.c++",
    "created_at": "2025-08-18T22:53:38+00:00",
    "commented_code": "return kj::heap<NullIoStream>();\n }\n \n+kj::AsyncOutputStream& getGlobalNullOutputStream() {\n+  static auto globalNullStream = kj::heap<NullIoStream>();\n+  return *globalNullStream;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2283664817",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4819,
        "pr_file": "src/workerd/util/stream-utils.c++",
        "discussion_id": "2283664817",
        "commented_code": "@@ -189,6 +189,11 @@ kj::Own<kj::AsyncOutputStream> newNullOutputStream() {\n   return kj::heap<NullIoStream>();\n }\n \n+kj::AsyncOutputStream& getGlobalNullOutputStream() {\n+  static auto globalNullStream = kj::heap<NullIoStream>();\n+  return *globalNullStream;",
        "comment_created_at": "2025-08-18T22:53:38+00:00",
        "comment_author": "kentonv",
        "comment_body": "You don't need the heap allocation here.\n\n```suggestion\n  static NullIoStream globalNullStream;\n  return globalNullStream;\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193537688",
    "pr_number": 4472,
    "pr_file": "src/workerd/api/http.c++",
    "created_at": "2025-07-08T22:26:32+00:00",
    "commented_code": "}\n \n Headers::Headers(jsg::Lock& js, const kj::HttpHeaders& other, Guard guard): guard(Guard::NONE) {\n-  other.forEach([this](kj::StringPtr name, kj::StringPtr value) {\n-    // The variation of toLower we use here creates a copy.\n-    auto key = jsg::ByteString(toLower(name));\n-    KJ_IF_SOME(header, headers.find(key)) {\n-      header.values.add(jsg::ByteString(kj::str(value)));\n+  other.forEachHeader([this](kj::HttpHeaders::Header header) {\n+    auto key = jsg::ByteString(kj::str(header.lowcaseName));",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2193537688",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4472,
        "pr_file": "src/workerd/api/http.c++",
        "discussion_id": "2193537688",
        "commented_code": "@@ -161,14 +161,14 @@ Headers::Headers(jsg::Lock& js, const Headers& other): guard(Guard::NONE) {\n }\n \n Headers::Headers(jsg::Lock& js, const kj::HttpHeaders& other, Guard guard): guard(Guard::NONE) {\n-  other.forEach([this](kj::StringPtr name, kj::StringPtr value) {\n-    // The variation of toLower we use here creates a copy.\n-    auto key = jsg::ByteString(toLower(name));\n-    KJ_IF_SOME(header, headers.find(key)) {\n-      header.values.add(jsg::ByteString(kj::str(value)));\n+  other.forEachHeader([this](kj::HttpHeaders::Header header) {\n+    auto key = jsg::ByteString(kj::str(header.lowcaseName));",
        "comment_created_at": "2025-07-08T22:26:32+00:00",
        "comment_author": "jasnell",
        "comment_body": "It would be ideal if we could avoid the additional allocation (`kj::str(...)`) and wrapping it in `jsg::ByteString` here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2193545345",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4472,
        "pr_file": "src/workerd/api/http.c++",
        "discussion_id": "2193537688",
        "commented_code": "@@ -161,14 +161,14 @@ Headers::Headers(jsg::Lock& js, const Headers& other): guard(Guard::NONE) {\n }\n \n Headers::Headers(jsg::Lock& js, const kj::HttpHeaders& other, Guard guard): guard(Guard::NONE) {\n-  other.forEach([this](kj::StringPtr name, kj::StringPtr value) {\n-    // The variation of toLower we use here creates a copy.\n-    auto key = jsg::ByteString(toLower(name));\n-    KJ_IF_SOME(header, headers.find(key)) {\n-      header.values.add(jsg::ByteString(kj::str(value)));\n+  other.forEachHeader([this](kj::HttpHeaders::Header header) {\n+    auto key = jsg::ByteString(kj::str(header.lowcaseName));",
        "comment_created_at": "2025-07-08T22:34:43+00:00",
        "comment_author": "anonrig",
        "comment_body": "Byte string is a kj::string, and kj::string constructor just moves the value. So technically there is no unnecessary allocation here. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2193553614",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4472,
        "pr_file": "src/workerd/api/http.c++",
        "discussion_id": "2193537688",
        "commented_code": "@@ -161,14 +161,14 @@ Headers::Headers(jsg::Lock& js, const Headers& other): guard(Guard::NONE) {\n }\n \n Headers::Headers(jsg::Lock& js, const kj::HttpHeaders& other, Guard guard): guard(Guard::NONE) {\n-  other.forEach([this](kj::StringPtr name, kj::StringPtr value) {\n-    // The variation of toLower we use here creates a copy.\n-    auto key = jsg::ByteString(toLower(name));\n-    KJ_IF_SOME(header, headers.find(key)) {\n-      header.values.add(jsg::ByteString(kj::str(value)));\n+  other.forEachHeader([this](kj::HttpHeaders::Header header) {\n+    auto key = jsg::ByteString(kj::str(header.lowcaseName));",
        "comment_created_at": "2025-07-08T22:42:29+00:00",
        "comment_author": "jasnell",
        "comment_body": "I was referring to the additional allocation caused by the `kj::str(...)` call, which copies the `kj::StringPtr`. It would be awesome if we could eliminate that allocation unless we end up in the else block.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2222992031",
    "pr_number": 4548,
    "pr_file": "src/workerd/api/pyodide/pyodide.c++",
    "created_at": "2025-07-22T15:41:11+00:00",
    "commented_code": "co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2222992031",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4548,
        "pr_file": "src/workerd/api/pyodide/pyodide.c++",
        "discussion_id": "2222992031",
        "commented_code": "@@ -801,41 +806,107 @@ kj::Promise<void> loadPyodidePackage(const PythonConfig& pyConfig,\n   co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;",
        "comment_created_at": "2025-07-22T15:41:11+00:00",
        "comment_author": "jasnell",
        "comment_body": "Nit... we know how many `filenames` there are, we could reserve the space in advance here on the vector.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1869799832",
    "pr_number": 3209,
    "pr_file": "src/workerd/io/trace.h",
    "created_at": "2024-12-04T15:33:42+00:00",
    "commented_code": "void addLog(kj::Date timestamp, LogLevel logLevel, kj::String message) override;\n   void addSpan(CompleteSpan&& span) override;\n+  void setTraceId(tracing::TraceId traceId);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "1869799832",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 3209,
        "pr_file": "src/workerd/io/trace.h",
        "discussion_id": "1869799832",
        "commented_code": "@@ -609,6 +616,7 @@ class WorkerTracer final: public kj::Refcounted, public BaseTracer {\n \n   void addLog(kj::Date timestamp, LogLevel logLevel, kj::String message) override;\n   void addSpan(CompleteSpan&& span) override;\n+  void setTraceId(tracing::TraceId traceId);",
        "comment_created_at": "2024-12-04T15:33:42+00:00",
        "comment_author": "jasnell",
        "comment_body": "Nit: `const tracing::TraceId&` to prevent the extra copy? I know it's a small class but still. Could also get by with having the `trace->traceId = traceId` in the impl be a `trace->traceId = kj::mv(traceId)`",
        "pr_file_module": null
      }
    ]
  }
]