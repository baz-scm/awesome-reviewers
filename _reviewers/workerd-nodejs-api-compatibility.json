[
  {
    "discussion_id": "2306596033",
    "pr_number": 4922,
    "pr_file": "src/node/crypto.ts",
    "created_at": "2025-08-28T08:10:43+00:00",
    "commented_code": "export let Cipher: (() => void) | undefined = undefined;\n export let Decipher: (() => void) | undefined = undefined;\n \n-if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol) {\n+if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol_v22) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2306596033",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4922,
        "pr_file": "src/node/crypto.ts",
        "discussion_id": "2306596033",
        "commented_code": "@@ -543,7 +543,7 @@ export let createDecipher: (() => void) | undefined = undefined;\n export let Cipher: (() => void) | undefined = undefined;\n export let Decipher: (() => void) | undefined = undefined;\n \n-if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol) {\n+if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol_v22) {",
        "comment_created_at": "2025-08-28T08:10:43+00:00",
        "comment_author": "vicb",
        "comment_body": "Those API does not seem to be in Node 22?\n\n```\n-> % node\nWelcome to Node.js v22.16.0.\nType \".help\" for more information.\n> c = require('crypto')\n> c.createCipher \nundefined\n> c.createDecipher \nundefined\n> c.Cipher\nundefined\n> c.Decipher\nundefined\n```\n\n```suggestion\nif (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol_v20) {\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2307164476",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4922,
        "pr_file": "src/node/crypto.ts",
        "discussion_id": "2306596033",
        "commented_code": "@@ -543,7 +543,7 @@ export let createDecipher: (() => void) | undefined = undefined;\n export let Cipher: (() => void) | undefined = undefined;\n export let Decipher: (() => void) | undefined = undefined;\n \n-if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol) {\n+if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol_v22) {",
        "comment_created_at": "2025-08-28T11:49:37+00:00",
        "comment_author": "jasnell",
        "comment_body": "Yes, they were and they weren't. They were eol'd in 22 but the exports were never actually removed. They were actually exported *as* undefined.",
        "pr_file_module": null
      },
      {
        "comment_id": "2307917367",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4922,
        "pr_file": "src/node/crypto.ts",
        "discussion_id": "2306596033",
        "commented_code": "@@ -543,7 +543,7 @@ export let createDecipher: (() => void) | undefined = undefined;\n export let Cipher: (() => void) | undefined = undefined;\n export let Decipher: (() => void) | undefined = undefined;\n \n-if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol) {\n+if (!Cloudflare.compatibilityFlags.remove_nodejs_compat_eol_v22) {",
        "comment_created_at": "2025-08-28T16:19:51+00:00",
        "comment_author": "vicb",
        "comment_body": "> Yes, they were and they weren't. They were eol'd in 22 but the exports were never actually removed. They were actually exported _as_ undefined.\n\nWhich is exactly what the change I propose would do, no?\ni.e they would be throwing functions in v20 and undefined in v22.\n\nBy keeping v22 here they are still throwing function in v22 which is not consistent with Node.\n\nProbably not a big deal?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2291940169",
    "pr_number": 4857,
    "pr_file": "src/node/module.ts",
    "created_at": "2025-08-21T19:23:41+00:00",
    "commented_code": "];\n Object.freeze(builtinModules);\n \n+export function register(): void {\n+  // TODO(soon): We might support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.register');\n+}\n+\n+export function runMain(): void {\n+  // We don't plan to support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.runMain');\n+}\n+\n+export function syncBuiltinESMExports(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.syncBuiltinESMExports');\n+}\n+\n+export function wrap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.wrap');\n+}\n+\n+export const globalPaths: string[] = [];\n+\n+export const constants = {\n+  compileCacheStatus: {\n+    __proto__: null,\n+    FAILED: 0,\n+    ENABLED: 1,\n+    ALREADY_ENABLED: 2,\n+    DISABLED: 3,\n+  },\n+};\n+\n+export const _cache = { __proto__: null };\n+export const _pathCache = { __proto__: null };\n+\n+export function _debug(): void {\n+  // This is deprecated and will be removed in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._debug');\n+}\n+\n+export function _findPath(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._findPath');\n+}\n+\n+export function _initPaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._initPaths');\n+}\n+\n+export function _load(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._load');\n+}\n+\n+export function _preloadModules(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._preloadModules');\n+}\n+\n+export function _resolveFilename(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveFilename');\n+}\n+\n+export function _resolveLookupPaths(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveLookupPaths');\n+}\n+\n+export function _nodeModulePaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._nodeModulePaths');\n+}\n+\n+export function findSourceMap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findSourceMap');\n+}\n+\n+export function findPackageJSON(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findPackageJSON');\n+}\n+\n+export function flushCompileCache(): void {\n+  // We don't implement compile cache.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.flushCompileCache');\n+}\n+\n+export function getSourceMapsSupport(): Record<string, boolean | null> {\n+  return Object.freeze({\n+    __proto__: null,\n+    enabled: false,\n+    nodeModules: false,\n+    generatedCode: false,\n+  });\n+}\n+\n+export function setSourceMapsSupport(): void {\n+  // We don't implement source maps support.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.setSourceMapsSupport');\n+}\n+\n+export function stripTypeScriptTypes(): void {\n+  // We don't implement stripping TypeScript types.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.stripTypeScriptTypes');\n+}\n+\n+export function SourceMap(): void {\n+  // We don't support source maps.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.SourceMap');\n+}\n+\n+export function Module(): void {\n+  // TODO(soon): Investigate implementing Module class fully.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.Module');\n+}\n+\n+Module.register = register;\n+Module.constants = constants;\n+Module.enableCompileCache = enableCompileCache;\n+Module.findPackageJSON = findPackageJSON;\n+Module.flushCompileCache = flushCompileCache;\n+Module.getCompileCacheDir = getCompileCacheDir;\n+Module.stripTypeScriptTypes = stripTypeScriptTypes;\n+\n+// SourceMap APIs\n+Module.findSourceMap = findSourceMap;\n+Module.SourceMap = SourceMap;\n+Module.getSourceMapsSupport = getSourceMapsSupport;\n+Module.setSourceMapsSupport = setSourceMapsSupport;\n+\n export default {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2291940169",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4857,
        "pr_file": "src/node/module.ts",
        "discussion_id": "2291940169",
        "commented_code": "@@ -110,8 +156,168 @@ export const builtinModules = [\n ];\n Object.freeze(builtinModules);\n \n+export function register(): void {\n+  // TODO(soon): We might support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.register');\n+}\n+\n+export function runMain(): void {\n+  // We don't plan to support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.runMain');\n+}\n+\n+export function syncBuiltinESMExports(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.syncBuiltinESMExports');\n+}\n+\n+export function wrap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.wrap');\n+}\n+\n+export const globalPaths: string[] = [];\n+\n+export const constants = {\n+  compileCacheStatus: {\n+    __proto__: null,\n+    FAILED: 0,\n+    ENABLED: 1,\n+    ALREADY_ENABLED: 2,\n+    DISABLED: 3,\n+  },\n+};\n+\n+export const _cache = { __proto__: null };\n+export const _pathCache = { __proto__: null };\n+\n+export function _debug(): void {\n+  // This is deprecated and will be removed in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._debug');\n+}\n+\n+export function _findPath(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._findPath');\n+}\n+\n+export function _initPaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._initPaths');\n+}\n+\n+export function _load(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._load');\n+}\n+\n+export function _preloadModules(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._preloadModules');\n+}\n+\n+export function _resolveFilename(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveFilename');\n+}\n+\n+export function _resolveLookupPaths(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveLookupPaths');\n+}\n+\n+export function _nodeModulePaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._nodeModulePaths');\n+}\n+\n+export function findSourceMap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findSourceMap');\n+}\n+\n+export function findPackageJSON(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findPackageJSON');\n+}\n+\n+export function flushCompileCache(): void {\n+  // We don't implement compile cache.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.flushCompileCache');\n+}\n+\n+export function getSourceMapsSupport(): Record<string, boolean | null> {\n+  return Object.freeze({\n+    __proto__: null,\n+    enabled: false,\n+    nodeModules: false,\n+    generatedCode: false,\n+  });\n+}\n+\n+export function setSourceMapsSupport(): void {\n+  // We don't implement source maps support.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.setSourceMapsSupport');\n+}\n+\n+export function stripTypeScriptTypes(): void {\n+  // We don't implement stripping TypeScript types.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.stripTypeScriptTypes');\n+}\n+\n+export function SourceMap(): void {\n+  // We don't support source maps.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.SourceMap');\n+}\n+\n+export function Module(): void {\n+  // TODO(soon): Investigate implementing Module class fully.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.Module');\n+}\n+\n+Module.register = register;\n+Module.constants = constants;\n+Module.enableCompileCache = enableCompileCache;\n+Module.findPackageJSON = findPackageJSON;\n+Module.flushCompileCache = flushCompileCache;\n+Module.getCompileCacheDir = getCompileCacheDir;\n+Module.stripTypeScriptTypes = stripTypeScriptTypes;\n+\n+// SourceMap APIs\n+Module.findSourceMap = findSourceMap;\n+Module.SourceMap = SourceMap;\n+Module.getSourceMapsSupport = getSourceMapsSupport;\n+Module.setSourceMapsSupport = setSourceMapsSupport;\n+\n export default {",
        "comment_created_at": "2025-08-21T19:23:41+00:00",
        "comment_author": "jasnell",
        "comment_body": "In Node.js the default export of `node:module` is `Module`. If we are adding `Module`, even if as a non-op, we should match Node.js' expectation here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2291970339",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4857,
        "pr_file": "src/node/module.ts",
        "discussion_id": "2291940169",
        "commented_code": "@@ -110,8 +156,168 @@ export const builtinModules = [\n ];\n Object.freeze(builtinModules);\n \n+export function register(): void {\n+  // TODO(soon): We might support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.register');\n+}\n+\n+export function runMain(): void {\n+  // We don't plan to support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.runMain');\n+}\n+\n+export function syncBuiltinESMExports(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.syncBuiltinESMExports');\n+}\n+\n+export function wrap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.wrap');\n+}\n+\n+export const globalPaths: string[] = [];\n+\n+export const constants = {\n+  compileCacheStatus: {\n+    __proto__: null,\n+    FAILED: 0,\n+    ENABLED: 1,\n+    ALREADY_ENABLED: 2,\n+    DISABLED: 3,\n+  },\n+};\n+\n+export const _cache = { __proto__: null };\n+export const _pathCache = { __proto__: null };\n+\n+export function _debug(): void {\n+  // This is deprecated and will be removed in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._debug');\n+}\n+\n+export function _findPath(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._findPath');\n+}\n+\n+export function _initPaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._initPaths');\n+}\n+\n+export function _load(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._load');\n+}\n+\n+export function _preloadModules(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._preloadModules');\n+}\n+\n+export function _resolveFilename(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveFilename');\n+}\n+\n+export function _resolveLookupPaths(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveLookupPaths');\n+}\n+\n+export function _nodeModulePaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._nodeModulePaths');\n+}\n+\n+export function findSourceMap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findSourceMap');\n+}\n+\n+export function findPackageJSON(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findPackageJSON');\n+}\n+\n+export function flushCompileCache(): void {\n+  // We don't implement compile cache.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.flushCompileCache');\n+}\n+\n+export function getSourceMapsSupport(): Record<string, boolean | null> {\n+  return Object.freeze({\n+    __proto__: null,\n+    enabled: false,\n+    nodeModules: false,\n+    generatedCode: false,\n+  });\n+}\n+\n+export function setSourceMapsSupport(): void {\n+  // We don't implement source maps support.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.setSourceMapsSupport');\n+}\n+\n+export function stripTypeScriptTypes(): void {\n+  // We don't implement stripping TypeScript types.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.stripTypeScriptTypes');\n+}\n+\n+export function SourceMap(): void {\n+  // We don't support source maps.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.SourceMap');\n+}\n+\n+export function Module(): void {\n+  // TODO(soon): Investigate implementing Module class fully.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.Module');\n+}\n+\n+Module.register = register;\n+Module.constants = constants;\n+Module.enableCompileCache = enableCompileCache;\n+Module.findPackageJSON = findPackageJSON;\n+Module.flushCompileCache = flushCompileCache;\n+Module.getCompileCacheDir = getCompileCacheDir;\n+Module.stripTypeScriptTypes = stripTypeScriptTypes;\n+\n+// SourceMap APIs\n+Module.findSourceMap = findSourceMap;\n+Module.SourceMap = SourceMap;\n+Module.getSourceMapsSupport = getSourceMapsSupport;\n+Module.setSourceMapsSupport = setSourceMapsSupport;\n+\n export default {",
        "comment_created_at": "2025-08-21T19:40:58+00:00",
        "comment_author": "anonrig",
        "comment_body": "Agreed. I'll update this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2294118609",
    "pr_number": 4857,
    "pr_file": "src/node/module.ts",
    "created_at": "2025-08-22T16:00:43+00:00",
    "commented_code": "];\n Object.freeze(builtinModules);\n \n-export default {\n-  createRequire,\n-  isBuiltin,\n-  builtinModules,\n-};\n+export function register(): void {\n+  // TODO(soon): We might support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.register');\n+}\n+\n+export function runMain(): void {\n+  // We don't plan to support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.runMain');\n+}\n+\n+export function syncBuiltinESMExports(): void {\n+  // We are unlikely to ever support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.syncBuiltinESMExports');\n+}\n+\n+export function wrap(): void {\n+  // TODO(soon): Implement this feature.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.wrap');\n+}\n+\n+export const globalPaths: string[] = [];\n+\n+const compileCacheStatus = Object.freeze({\n+  __proto__: null,\n+  FAILED: 0,\n+  ENABLED: 1,\n+  ALREADY_ENABLED: 2,\n+  DISABLED: 3,\n+});\n+\n+export const constants = Object.freeze({\n+  __proto__: null,\n+  compileCacheStatus,\n+});\n+\n+export const _cache = { __proto__: null };\n+export const _pathCache = { __proto__: null };\n+\n+export function _debug(): void {\n+  // This is deprecated and will be removed in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._debug');\n+}\n+\n+export function _findPath(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._findPath');\n+}\n+\n+export function _initPaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._initPaths');\n+}\n+\n+export function _load(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._load');\n+}\n+\n+export function _preloadModules(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._preloadModules');\n+}\n+\n+export function _resolveFilename(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveFilename');\n+}\n+\n+export function _resolveLookupPaths(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveLookupPaths');\n+}\n+\n+export function _nodeModulePaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._nodeModulePaths');\n+}\n+\n+export function findSourceMap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findSourceMap');\n+}\n+\n+export function findPackageJSON(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findPackageJSON');\n+}\n+\n+export function flushCompileCache(): void {\n+  // We don't implement compile cache. This acts as a no-op.\n+}\n+\n+export function getSourceMapsSupport(): Record<string, boolean | null> {\n+  return Object.freeze({\n+    __proto__: null,\n+    enabled: false,\n+    nodeModules: false,\n+    generatedCode: false,\n+  });\n+}\n+\n+export function setSourceMapsSupport(): void {\n+  // We don't implement source maps support.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.setSourceMapsSupport');\n+}\n+\n+export function stripTypeScriptTypes(): void {\n+  // We don't implement stripping TypeScript types.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.stripTypeScriptTypes');\n+}\n+\n+export function registerHooks(): void {\n+  // We don't implement hooks registration.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.registerHooks');\n+}\n+\n+export function SourceMap(): void {\n+  // We don't support source maps.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.SourceMap');\n+}\n+\n+export function Module(): void {\n+  // TODO(soon): Investigate implementing Module class fully.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.Module');\n+}",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2294118609",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4857,
        "pr_file": "src/node/module.ts",
        "discussion_id": "2294118609",
        "commented_code": "@@ -110,8 +172,288 @@ export const builtinModules = [\n ];\n Object.freeze(builtinModules);\n \n-export default {\n-  createRequire,\n-  isBuiltin,\n-  builtinModules,\n-};\n+export function register(): void {\n+  // TODO(soon): We might support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.register');\n+}\n+\n+export function runMain(): void {\n+  // We don't plan to support this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.runMain');\n+}\n+\n+export function syncBuiltinESMExports(): void {\n+  // We are unlikely to ever support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.syncBuiltinESMExports');\n+}\n+\n+export function wrap(): void {\n+  // TODO(soon): Implement this feature.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.wrap');\n+}\n+\n+export const globalPaths: string[] = [];\n+\n+const compileCacheStatus = Object.freeze({\n+  __proto__: null,\n+  FAILED: 0,\n+  ENABLED: 1,\n+  ALREADY_ENABLED: 2,\n+  DISABLED: 3,\n+});\n+\n+export const constants = Object.freeze({\n+  __proto__: null,\n+  compileCacheStatus,\n+});\n+\n+export const _cache = { __proto__: null };\n+export const _pathCache = { __proto__: null };\n+\n+export function _debug(): void {\n+  // This is deprecated and will be removed in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._debug');\n+}\n+\n+export function _findPath(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._findPath');\n+}\n+\n+export function _initPaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._initPaths');\n+}\n+\n+export function _load(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._load');\n+}\n+\n+export function _preloadModules(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._preloadModules');\n+}\n+\n+export function _resolveFilename(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveFilename');\n+}\n+\n+export function _resolveLookupPaths(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._resolveLookupPaths');\n+}\n+\n+export function _nodeModulePaths(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module._nodeModulePaths');\n+}\n+\n+export function findSourceMap(): void {\n+  // TODO(soon): Investigate the possibility of supporting this in the future.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findSourceMap');\n+}\n+\n+export function findPackageJSON(): void {\n+  // It doesn't make sense to support this.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.findPackageJSON');\n+}\n+\n+export function flushCompileCache(): void {\n+  // We don't implement compile cache. This acts as a no-op.\n+}\n+\n+export function getSourceMapsSupport(): Record<string, boolean | null> {\n+  return Object.freeze({\n+    __proto__: null,\n+    enabled: false,\n+    nodeModules: false,\n+    generatedCode: false,\n+  });\n+}\n+\n+export function setSourceMapsSupport(): void {\n+  // We don't implement source maps support.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.setSourceMapsSupport');\n+}\n+\n+export function stripTypeScriptTypes(): void {\n+  // We don't implement stripping TypeScript types.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.stripTypeScriptTypes');\n+}\n+\n+export function registerHooks(): void {\n+  // We don't implement hooks registration.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.registerHooks');\n+}\n+\n+export function SourceMap(): void {\n+  // We don't support source maps.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.SourceMap');\n+}\n+\n+export function Module(): void {\n+  // TODO(soon): Investigate implementing Module class fully.\n+  throw new ERR_METHOD_NOT_IMPLEMENTED('module.Module');\n+}",
        "comment_created_at": "2025-08-22T16:00:43+00:00",
        "comment_author": "jasnell",
        "comment_body": "Should we at least stub out the `Module` prototype with non-ops?\r\n\r\n```js\r\n> require('module').Module.prototype\r\n{\r\n  load: [Function (anonymous)],\r\n  require: [Function (anonymous)],\r\n  _compile: [Function (anonymous)]\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223617434",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_incoming.ts",
    "created_at": "2025-07-22T19:16:06+00:00",
    "commented_code": "});\n   }\n \n-  get headers(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  // Add the given (field, value) pair to the message\n+  //\n+  // Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n+  // same header with a ', ' if the header in question supports specification of\n+  // multiple values this way. The one exception to this is the Cookie header,\n+  // which has multiple values joined with a '; ' instead. If a header's values\n+  // cannot be joined in either of these ways, we declare the first instance the\n+  // winner and drop the second. Extended header fields (those beginning with\n+  // 'x-') are always joined.\n+  _addHeaderLine(\n+    field: string,\n+    value: string,\n+    dest: IncomingHttpHeaders\n+  ): void {\n+    field = matchKnownFields(field);\n+    const flag = field.charCodeAt(0);\n+    if (flag === 0 || flag === 2) {\n+      field = field.slice(1);\n+      // Make a delimited list\n+      if (typeof dest[field] === 'string') {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += (flag === 0 ? ', ' : '; ') + value;\n+      } else {\n+        dest[field] = value;\n+      }\n+    } else if (flag === 1) {\n+      // Array header -- only Set-Cookie at the moment\n+      if (dest['set-cookie'] !== undefined) {\n+        dest['set-cookie'].push(value);\n+      } else {\n+        dest['set-cookie'] = [value];\n+      }\n+    } else if (this.joinDuplicateHeaders) {\n+      // RFC 9110 https://www.rfc-editor.org/rfc/rfc9110#section-5.2\n+      // https://github.com/nodejs/node/issues/45699\n+      // allow authorization multiple fields\n+      // Make a delimited list\n+      if (dest[field] === undefined) {\n+        dest[field] = value;\n+      } else {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += ', ' + value;\n+      }\n+    } else if (dest[field] === undefined) {\n+      // Drop duplicates\n+      dest[field] = value;\n+    }\n+  }\n+\n+  _addHeaderLines(headers: string[] | null, n: number): void {\n+    if (Array.isArray(headers)) {\n+      let dest;\n+      if (this.complete) {\n+        this.rawTrailers = headers;\n+        this[kTrailersCount] = n;\n+        dest = this[kTrailers];\n+      } else {\n+        this.rawHeaders = headers;\n+        this[kHeadersCount] = n;\n+        dest = this[kHeaders];\n+      }\n+\n+      if (dest) {\n+        for (let i = 0; i < n; i += 2) {\n+          this._addHeaderLine(\n+            headers[i] as string,\n+            headers[i + 1] as string,\n+            dest\n+          );\n+        }\n+      }\n+    }\n+  }\n+\n+  get headers(): Record<string, string | string[] | undefined> {\n+    if (!this[kHeaders]) {\n+      this[kHeaders] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeaders];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLine(src[n] as string, src[n + 1] as string, dst);\n+      }\n+    }\n+    return this[kHeaders];\n+  }\n+\n+  set headers(val: IncomingHttpHeaders) {\n+    this[kHeaders] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get headersDistinct(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  get headersDistinct(): Record<string, string[]> {\n+    if (!this[kHeadersDistinct]) {\n+      this[kHeadersDistinct] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeadersDistinct];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLineDistinct(\n+          src[n] as string,\n+          src[n + 1] as string,\n+          dst\n+        );\n+      }\n+    }\n+    return this[kHeadersDistinct];\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailers(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  set headersDistinct(val: Record<string, string[]>) {\n+    this[kHeadersDistinct] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailersDistinct(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  get trailers(): Record<string, string | undefined> {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2223617434",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2223617434",
        "commented_code": "@@ -113,27 +163,183 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     });\n   }\n \n-  get headers(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  // Add the given (field, value) pair to the message\n+  //\n+  // Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n+  // same header with a ', ' if the header in question supports specification of\n+  // multiple values this way. The one exception to this is the Cookie header,\n+  // which has multiple values joined with a '; ' instead. If a header's values\n+  // cannot be joined in either of these ways, we declare the first instance the\n+  // winner and drop the second. Extended header fields (those beginning with\n+  // 'x-') are always joined.\n+  _addHeaderLine(\n+    field: string,\n+    value: string,\n+    dest: IncomingHttpHeaders\n+  ): void {\n+    field = matchKnownFields(field);\n+    const flag = field.charCodeAt(0);\n+    if (flag === 0 || flag === 2) {\n+      field = field.slice(1);\n+      // Make a delimited list\n+      if (typeof dest[field] === 'string') {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += (flag === 0 ? ', ' : '; ') + value;\n+      } else {\n+        dest[field] = value;\n+      }\n+    } else if (flag === 1) {\n+      // Array header -- only Set-Cookie at the moment\n+      if (dest['set-cookie'] !== undefined) {\n+        dest['set-cookie'].push(value);\n+      } else {\n+        dest['set-cookie'] = [value];\n+      }\n+    } else if (this.joinDuplicateHeaders) {\n+      // RFC 9110 https://www.rfc-editor.org/rfc/rfc9110#section-5.2\n+      // https://github.com/nodejs/node/issues/45699\n+      // allow authorization multiple fields\n+      // Make a delimited list\n+      if (dest[field] === undefined) {\n+        dest[field] = value;\n+      } else {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += ', ' + value;\n+      }\n+    } else if (dest[field] === undefined) {\n+      // Drop duplicates\n+      dest[field] = value;\n+    }\n+  }\n+\n+  _addHeaderLines(headers: string[] | null, n: number): void {\n+    if (Array.isArray(headers)) {\n+      let dest;\n+      if (this.complete) {\n+        this.rawTrailers = headers;\n+        this[kTrailersCount] = n;\n+        dest = this[kTrailers];\n+      } else {\n+        this.rawHeaders = headers;\n+        this[kHeadersCount] = n;\n+        dest = this[kHeaders];\n+      }\n+\n+      if (dest) {\n+        for (let i = 0; i < n; i += 2) {\n+          this._addHeaderLine(\n+            headers[i] as string,\n+            headers[i + 1] as string,\n+            dest\n+          );\n+        }\n+      }\n+    }\n+  }\n+\n+  get headers(): Record<string, string | string[] | undefined> {\n+    if (!this[kHeaders]) {\n+      this[kHeaders] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeaders];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLine(src[n] as string, src[n + 1] as string, dst);\n+      }\n+    }\n+    return this[kHeaders];\n+  }\n+\n+  set headers(val: IncomingHttpHeaders) {\n+    this[kHeaders] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get headersDistinct(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  get headersDistinct(): Record<string, string[]> {\n+    if (!this[kHeadersDistinct]) {\n+      this[kHeadersDistinct] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeadersDistinct];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLineDistinct(\n+          src[n] as string,\n+          src[n + 1] as string,\n+          dst\n+        );\n+      }\n+    }\n+    return this[kHeadersDistinct];\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailers(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  set headersDistinct(val: Record<string, string[]>) {\n+    this[kHeadersDistinct] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailersDistinct(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  get trailers(): Record<string, string | undefined> {",
        "comment_created_at": "2025-07-22T19:16:06+00:00",
        "comment_author": "jasnell",
        "comment_body": "Not blocking but We know that we don't support trailers so I'm not sure there's much value in implementing this at all.",
        "pr_file_module": null
      },
      {
        "comment_id": "2223620900",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2223617434",
        "commented_code": "@@ -113,27 +163,183 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     });\n   }\n \n-  get headers(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  // Add the given (field, value) pair to the message\n+  //\n+  // Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n+  // same header with a ', ' if the header in question supports specification of\n+  // multiple values this way. The one exception to this is the Cookie header,\n+  // which has multiple values joined with a '; ' instead. If a header's values\n+  // cannot be joined in either of these ways, we declare the first instance the\n+  // winner and drop the second. Extended header fields (those beginning with\n+  // 'x-') are always joined.\n+  _addHeaderLine(\n+    field: string,\n+    value: string,\n+    dest: IncomingHttpHeaders\n+  ): void {\n+    field = matchKnownFields(field);\n+    const flag = field.charCodeAt(0);\n+    if (flag === 0 || flag === 2) {\n+      field = field.slice(1);\n+      // Make a delimited list\n+      if (typeof dest[field] === 'string') {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += (flag === 0 ? ', ' : '; ') + value;\n+      } else {\n+        dest[field] = value;\n+      }\n+    } else if (flag === 1) {\n+      // Array header -- only Set-Cookie at the moment\n+      if (dest['set-cookie'] !== undefined) {\n+        dest['set-cookie'].push(value);\n+      } else {\n+        dest['set-cookie'] = [value];\n+      }\n+    } else if (this.joinDuplicateHeaders) {\n+      // RFC 9110 https://www.rfc-editor.org/rfc/rfc9110#section-5.2\n+      // https://github.com/nodejs/node/issues/45699\n+      // allow authorization multiple fields\n+      // Make a delimited list\n+      if (dest[field] === undefined) {\n+        dest[field] = value;\n+      } else {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += ', ' + value;\n+      }\n+    } else if (dest[field] === undefined) {\n+      // Drop duplicates\n+      dest[field] = value;\n+    }\n+  }\n+\n+  _addHeaderLines(headers: string[] | null, n: number): void {\n+    if (Array.isArray(headers)) {\n+      let dest;\n+      if (this.complete) {\n+        this.rawTrailers = headers;\n+        this[kTrailersCount] = n;\n+        dest = this[kTrailers];\n+      } else {\n+        this.rawHeaders = headers;\n+        this[kHeadersCount] = n;\n+        dest = this[kHeaders];\n+      }\n+\n+      if (dest) {\n+        for (let i = 0; i < n; i += 2) {\n+          this._addHeaderLine(\n+            headers[i] as string,\n+            headers[i + 1] as string,\n+            dest\n+          );\n+        }\n+      }\n+    }\n+  }\n+\n+  get headers(): Record<string, string | string[] | undefined> {\n+    if (!this[kHeaders]) {\n+      this[kHeaders] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeaders];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLine(src[n] as string, src[n + 1] as string, dst);\n+      }\n+    }\n+    return this[kHeaders];\n+  }\n+\n+  set headers(val: IncomingHttpHeaders) {\n+    this[kHeaders] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get headersDistinct(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  get headersDistinct(): Record<string, string[]> {\n+    if (!this[kHeadersDistinct]) {\n+      this[kHeadersDistinct] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeadersDistinct];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLineDistinct(\n+          src[n] as string,\n+          src[n + 1] as string,\n+          dst\n+        );\n+      }\n+    }\n+    return this[kHeadersDistinct];\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailers(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  set headersDistinct(val: Record<string, string[]>) {\n+    this[kHeadersDistinct] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailersDistinct(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  get trailers(): Record<string, string | undefined> {",
        "comment_created_at": "2025-07-22T19:17:56+00:00",
        "comment_author": "anonrig",
        "comment_body": "We can omit the getter (which will throw a typescript error, since we have \"implements _IncomingMessage\"), or have this getter throw an error of ERR_METHOD_UNIMPLEMENTED (which will fail if we do console.log(incoming).\r\n\r\nI think there is no harm in having this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2223704744",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2223617434",
        "commented_code": "@@ -113,27 +163,183 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     });\n   }\n \n-  get headers(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  // Add the given (field, value) pair to the message\n+  //\n+  // Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n+  // same header with a ', ' if the header in question supports specification of\n+  // multiple values this way. The one exception to this is the Cookie header,\n+  // which has multiple values joined with a '; ' instead. If a header's values\n+  // cannot be joined in either of these ways, we declare the first instance the\n+  // winner and drop the second. Extended header fields (those beginning with\n+  // 'x-') are always joined.\n+  _addHeaderLine(\n+    field: string,\n+    value: string,\n+    dest: IncomingHttpHeaders\n+  ): void {\n+    field = matchKnownFields(field);\n+    const flag = field.charCodeAt(0);\n+    if (flag === 0 || flag === 2) {\n+      field = field.slice(1);\n+      // Make a delimited list\n+      if (typeof dest[field] === 'string') {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += (flag === 0 ? ', ' : '; ') + value;\n+      } else {\n+        dest[field] = value;\n+      }\n+    } else if (flag === 1) {\n+      // Array header -- only Set-Cookie at the moment\n+      if (dest['set-cookie'] !== undefined) {\n+        dest['set-cookie'].push(value);\n+      } else {\n+        dest['set-cookie'] = [value];\n+      }\n+    } else if (this.joinDuplicateHeaders) {\n+      // RFC 9110 https://www.rfc-editor.org/rfc/rfc9110#section-5.2\n+      // https://github.com/nodejs/node/issues/45699\n+      // allow authorization multiple fields\n+      // Make a delimited list\n+      if (dest[field] === undefined) {\n+        dest[field] = value;\n+      } else {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += ', ' + value;\n+      }\n+    } else if (dest[field] === undefined) {\n+      // Drop duplicates\n+      dest[field] = value;\n+    }\n+  }\n+\n+  _addHeaderLines(headers: string[] | null, n: number): void {\n+    if (Array.isArray(headers)) {\n+      let dest;\n+      if (this.complete) {\n+        this.rawTrailers = headers;\n+        this[kTrailersCount] = n;\n+        dest = this[kTrailers];\n+      } else {\n+        this.rawHeaders = headers;\n+        this[kHeadersCount] = n;\n+        dest = this[kHeaders];\n+      }\n+\n+      if (dest) {\n+        for (let i = 0; i < n; i += 2) {\n+          this._addHeaderLine(\n+            headers[i] as string,\n+            headers[i + 1] as string,\n+            dest\n+          );\n+        }\n+      }\n+    }\n+  }\n+\n+  get headers(): Record<string, string | string[] | undefined> {\n+    if (!this[kHeaders]) {\n+      this[kHeaders] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeaders];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLine(src[n] as string, src[n + 1] as string, dst);\n+      }\n+    }\n+    return this[kHeaders];\n+  }\n+\n+  set headers(val: IncomingHttpHeaders) {\n+    this[kHeaders] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get headersDistinct(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  get headersDistinct(): Record<string, string[]> {\n+    if (!this[kHeadersDistinct]) {\n+      this[kHeadersDistinct] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeadersDistinct];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLineDistinct(\n+          src[n] as string,\n+          src[n + 1] as string,\n+          dst\n+        );\n+      }\n+    }\n+    return this[kHeadersDistinct];\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailers(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  set headersDistinct(val: Record<string, string[]>) {\n+    this[kHeadersDistinct] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailersDistinct(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  get trailers(): Record<string, string | undefined> {",
        "comment_created_at": "2025-07-22T19:54:48+00:00",
        "comment_author": "anonrig",
        "comment_body": "I'm closing this for now, but LMK if this is a deal-breaker for you (by unresolving)",
        "pr_file_module": null
      },
      {
        "comment_id": "2224142144",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2223617434",
        "commented_code": "@@ -113,27 +163,183 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     });\n   }\n \n-  get headers(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  // Add the given (field, value) pair to the message\n+  //\n+  // Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n+  // same header with a ', ' if the header in question supports specification of\n+  // multiple values this way. The one exception to this is the Cookie header,\n+  // which has multiple values joined with a '; ' instead. If a header's values\n+  // cannot be joined in either of these ways, we declare the first instance the\n+  // winner and drop the second. Extended header fields (those beginning with\n+  // 'x-') are always joined.\n+  _addHeaderLine(\n+    field: string,\n+    value: string,\n+    dest: IncomingHttpHeaders\n+  ): void {\n+    field = matchKnownFields(field);\n+    const flag = field.charCodeAt(0);\n+    if (flag === 0 || flag === 2) {\n+      field = field.slice(1);\n+      // Make a delimited list\n+      if (typeof dest[field] === 'string') {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += (flag === 0 ? ', ' : '; ') + value;\n+      } else {\n+        dest[field] = value;\n+      }\n+    } else if (flag === 1) {\n+      // Array header -- only Set-Cookie at the moment\n+      if (dest['set-cookie'] !== undefined) {\n+        dest['set-cookie'].push(value);\n+      } else {\n+        dest['set-cookie'] = [value];\n+      }\n+    } else if (this.joinDuplicateHeaders) {\n+      // RFC 9110 https://www.rfc-editor.org/rfc/rfc9110#section-5.2\n+      // https://github.com/nodejs/node/issues/45699\n+      // allow authorization multiple fields\n+      // Make a delimited list\n+      if (dest[field] === undefined) {\n+        dest[field] = value;\n+      } else {\n+        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n+        dest[field] += ', ' + value;\n+      }\n+    } else if (dest[field] === undefined) {\n+      // Drop duplicates\n+      dest[field] = value;\n+    }\n+  }\n+\n+  _addHeaderLines(headers: string[] | null, n: number): void {\n+    if (Array.isArray(headers)) {\n+      let dest;\n+      if (this.complete) {\n+        this.rawTrailers = headers;\n+        this[kTrailersCount] = n;\n+        dest = this[kTrailers];\n+      } else {\n+        this.rawHeaders = headers;\n+        this[kHeadersCount] = n;\n+        dest = this[kHeaders];\n+      }\n+\n+      if (dest) {\n+        for (let i = 0; i < n; i += 2) {\n+          this._addHeaderLine(\n+            headers[i] as string,\n+            headers[i + 1] as string,\n+            dest\n+          );\n+        }\n+      }\n+    }\n+  }\n+\n+  get headers(): Record<string, string | string[] | undefined> {\n+    if (!this[kHeaders]) {\n+      this[kHeaders] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeaders];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLine(src[n] as string, src[n + 1] as string, dst);\n+      }\n+    }\n+    return this[kHeaders];\n+  }\n+\n+  set headers(val: IncomingHttpHeaders) {\n+    this[kHeaders] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get headersDistinct(): Record<string, string> {\n-    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-explicit-any\n-    return Object.fromEntries(this.#response.headers as any);\n+  get headersDistinct(): Record<string, string[]> {\n+    if (!this[kHeadersDistinct]) {\n+      this[kHeadersDistinct] = {};\n+\n+      const src = this.rawHeaders;\n+      const dst = this[kHeadersDistinct];\n+\n+      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n+        this._addHeaderLineDistinct(\n+          src[n] as string,\n+          src[n + 1] as string,\n+          dst\n+        );\n+      }\n+    }\n+    return this[kHeadersDistinct];\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailers(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  set headersDistinct(val: Record<string, string[]>) {\n+    this[kHeadersDistinct] = val;\n   }\n \n-  // @ts-expect-error TS2416 Type inconsistency\n-  get trailersDistinct(): Record<string, unknown> {\n-    // Not supported.\n-    return {};\n+  get trailers(): Record<string, string | undefined> {",
        "comment_created_at": "2025-07-23T01:47:54+00:00",
        "comment_author": "jasnell",
        "comment_body": "the concern is that this is a fair amount of code that just isn't going to be exercised at all. I think it's better to remove the implementation and just replace with non-ops to simplify things overall.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223663442",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-22T19:35:04+00:00",
    "commented_code": "+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    callback?.();\n+    return this;\n+  }\n+\n+  getConnections(_cb?: (err: Error | null, count: number) => void): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+\n+  ref(): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+\n+  unref(): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+}\n+\n+// We use this handler to not expose this.#fetchResponse to outside world.\n+let getServerResponseFetchResponse: (\n+  response: ServerResponse\n+) => Promise<Response>;\n+\n+export class ServerResponse<Req extends IncomingMessage = IncomingMessage>\n+  extends OutgoingMessage\n+  implements _ServerResponse\n+{\n+  _sent100 = false;\n+  _expect_continue = false;\n+  override [kOutHeaders]: Record<string, [string, string | string[]]> | null =\n+    null;\n+\n+  statusCode = 200;\n+  statusMessage = 'unknown';\n+\n+  #fetchResponse: Promise<Response>;\n+  #encoder = new TextEncoder();\n+\n+  static {\n+    getServerResponseFetchResponse = (\n+      response: ServerResponse\n+    ): Promise<Response> => {\n+      return response.#fetchResponse;\n+    };\n+  }\n+\n+  constructor(req: Req, options: ServerOptions = {}) {\n+    super(req, options);\n+\n+    if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n+      this.useChunkedEncodingByDefault = chunkExpression.test(\n+        (req.headers.te as string | undefined) ?? ''\n+      );\n+      this.shouldKeepAlive = false;\n+    }\n+\n+    const { promise, resolve } = Promise.withResolvers<Response>();\n+\n+    let finished = false;\n+    this.once('finish', () => (finished = true));\n+    const chunks: (Buffer | Uint8Array)[] = [];\n+    const handler = (event: DataWrittenEvent): void => {\n+      if (finished) return;\n+      chunks[event.index] = this.#dataFromDataWrittenEvent(event);\n+    };\n+    this.on('_dataWritten', handler);\n+    this.on(\n+      '_headersSent',\n+      ({ statusCode, statusMessage, headers }: HeadersSentEvent) => {\n+        this.off('_dataWritten', handler);\n+        resolve(\n+          this.#toFetchResponse({\n+            statusCode,\n+            statusText: statusMessage,\n+            sentHeaders: headers,\n+            chunks,\n+            finished,\n+          })\n+        );\n+      }\n+    );\n+    this.#fetchResponse = promise;\n+  }\n+\n+  #toFetchResponse({\n+    statusCode,\n+    statusText,\n+    sentHeaders,\n+    chunks,\n+    finished,\n+  }: {\n+    statusCode: number;\n+    statusText: string;\n+    sentHeaders: [header: string, value: string][];\n+    chunks: (Buffer | Uint8Array)[];\n+    finished: boolean;\n+  }): Response {\n+    const headers = new Headers();\n+    for (const [header, value] of sentHeaders) {\n+      headers.append(header, value);\n+    }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2223663442",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2223663442",
        "commented_code": "@@ -0,0 +1,735 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    callback?.();\n+    return this;\n+  }\n+\n+  getConnections(_cb?: (err: Error | null, count: number) => void): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+\n+  ref(): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+\n+  unref(): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+}\n+\n+// We use this handler to not expose this.#fetchResponse to outside world.\n+let getServerResponseFetchResponse: (\n+  response: ServerResponse\n+) => Promise<Response>;\n+\n+export class ServerResponse<Req extends IncomingMessage = IncomingMessage>\n+  extends OutgoingMessage\n+  implements _ServerResponse\n+{\n+  _sent100 = false;\n+  _expect_continue = false;\n+  override [kOutHeaders]: Record<string, [string, string | string[]]> | null =\n+    null;\n+\n+  statusCode = 200;\n+  statusMessage = 'unknown';\n+\n+  #fetchResponse: Promise<Response>;\n+  #encoder = new TextEncoder();\n+\n+  static {\n+    getServerResponseFetchResponse = (\n+      response: ServerResponse\n+    ): Promise<Response> => {\n+      return response.#fetchResponse;\n+    };\n+  }\n+\n+  constructor(req: Req, options: ServerOptions = {}) {\n+    super(req, options);\n+\n+    if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n+      this.useChunkedEncodingByDefault = chunkExpression.test(\n+        (req.headers.te as string | undefined) ?? ''\n+      );\n+      this.shouldKeepAlive = false;\n+    }\n+\n+    const { promise, resolve } = Promise.withResolvers<Response>();\n+\n+    let finished = false;\n+    this.once('finish', () => (finished = true));\n+    const chunks: (Buffer | Uint8Array)[] = [];\n+    const handler = (event: DataWrittenEvent): void => {\n+      if (finished) return;\n+      chunks[event.index] = this.#dataFromDataWrittenEvent(event);\n+    };\n+    this.on('_dataWritten', handler);\n+    this.on(\n+      '_headersSent',\n+      ({ statusCode, statusMessage, headers }: HeadersSentEvent) => {\n+        this.off('_dataWritten', handler);\n+        resolve(\n+          this.#toFetchResponse({\n+            statusCode,\n+            statusText: statusMessage,\n+            sentHeaders: headers,\n+            chunks,\n+            finished,\n+          })\n+        );\n+      }\n+    );\n+    this.#fetchResponse = promise;\n+  }\n+\n+  #toFetchResponse({\n+    statusCode,\n+    statusText,\n+    sentHeaders,\n+    chunks,\n+    finished,\n+  }: {\n+    statusCode: number;\n+    statusText: string;\n+    sentHeaders: [header: string, value: string][];\n+    chunks: (Buffer | Uint8Array)[];\n+    finished: boolean;\n+  }): Response {\n+    const headers = new Headers();\n+    for (const [header, value] of sentHeaders) {\n+      headers.append(header, value);\n+    }",
        "comment_created_at": "2025-07-22T19:35:04+00:00",
        "comment_author": "jasnell",
        "comment_body": "If the `sentHeaders` is already an iterable of [header, value] type pairs, I believe you might be able to do this more efficiently by passing the `sentHeaders` directly to the constructor? Would need to verify... `new Headers(sentHeaders)`",
        "pr_file_module": null
      },
      {
        "comment_id": "2226431333",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2223663442",
        "commented_code": "@@ -0,0 +1,735 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validateLinkHeaderValue,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket } from 'node:net';\n+\n+export const kServerResponse = Symbol('ServerResponse');\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+export const STATUS_CODES = {\n+  100: 'Continue', // RFC 7231 6.2.1\n+  101: 'Switching Protocols', // RFC 7231 6.2.2\n+  102: 'Processing', // RFC 2518 10.1 (obsoleted by RFC 4918)\n+  103: 'Early Hints', // RFC 8297 2\n+  200: 'OK', // RFC 7231 6.3.1\n+  201: 'Created', // RFC 7231 6.3.2\n+  202: 'Accepted', // RFC 7231 6.3.3\n+  203: 'Non-Authoritative Information', // RFC 7231 6.3.4\n+  204: 'No Content', // RFC 7231 6.3.5\n+  205: 'Reset Content', // RFC 7231 6.3.6\n+  206: 'Partial Content', // RFC 7233 4.1\n+  207: 'Multi-Status', // RFC 4918 11.1\n+  208: 'Already Reported', // RFC 5842 7.1\n+  226: 'IM Used', // RFC 3229 10.4.1\n+  300: 'Multiple Choices', // RFC 7231 6.4.1\n+  301: 'Moved Permanently', // RFC 7231 6.4.2\n+  302: 'Found', // RFC 7231 6.4.3\n+  303: 'See Other', // RFC 7231 6.4.4\n+  304: 'Not Modified', // RFC 7232 4.1\n+  305: 'Use Proxy', // RFC 7231 6.4.5\n+  307: 'Temporary Redirect', // RFC 7231 6.4.7\n+  308: 'Permanent Redirect', // RFC 7238 3\n+  400: 'Bad Request', // RFC 7231 6.5.1\n+  401: 'Unauthorized', // RFC 7235 3.1\n+  402: 'Payment Required', // RFC 7231 6.5.2\n+  403: 'Forbidden', // RFC 7231 6.5.3\n+  404: 'Not Found', // RFC 7231 6.5.4\n+  405: 'Method Not Allowed', // RFC 7231 6.5.5\n+  406: 'Not Acceptable', // RFC 7231 6.5.6\n+  407: 'Proxy Authentication Required', // RFC 7235 3.2\n+  408: 'Request Timeout', // RFC 7231 6.5.7\n+  409: 'Conflict', // RFC 7231 6.5.8\n+  410: 'Gone', // RFC 7231 6.5.9\n+  411: 'Length Required', // RFC 7231 6.5.10\n+  412: 'Precondition Failed', // RFC 7232 4.2\n+  413: 'Payload Too Large', // RFC 7231 6.5.11\n+  414: 'URI Too Long', // RFC 7231 6.5.12\n+  415: 'Unsupported Media Type', // RFC 7231 6.5.13\n+  416: 'Range Not Satisfiable', // RFC 7233 4.4\n+  417: 'Expectation Failed', // RFC 7231 6.5.14\n+  418: \"I'm a Teapot\", // RFC 7168 2.3.3\n+  421: 'Misdirected Request', // RFC 7540 9.1.2\n+  422: 'Unprocessable Entity', // RFC 4918 11.2\n+  423: 'Locked', // RFC 4918 11.3\n+  424: 'Failed Dependency', // RFC 4918 11.4\n+  425: 'Too Early', // RFC 8470 5.2\n+  426: 'Upgrade Required', // RFC 2817 and RFC 7231 6.5.15\n+  428: 'Precondition Required', // RFC 6585 3\n+  429: 'Too Many Requests', // RFC 6585 4\n+  431: 'Request Header Fields Too Large', // RFC 6585 5\n+  451: 'Unavailable For Legal Reasons', // RFC 7725 3\n+  500: 'Internal Server Error', // RFC 7231 6.6.1\n+  501: 'Not Implemented', // RFC 7231 6.6.2\n+  502: 'Bad Gateway', // RFC 7231 6.6.3\n+  503: 'Service Unavailable', // RFC 7231 6.6.4\n+  504: 'Gateway Timeout', // RFC 7231 6.6.5\n+  505: 'HTTP Version Not Supported', // RFC 7231 6.6.6\n+  506: 'Variant Also Negotiates', // RFC 2295 8.1\n+  507: 'Insufficient Storage', // RFC 4918 11.5\n+  508: 'Loop Detected', // RFC 5842 7.2\n+  509: 'Bandwidth Limit Exceeded',\n+  510: 'Not Extended', // RFC 2774 7\n+  511: 'Network Authentication Required', // RFC 6585 6\n+};\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+// @ts-expect-error TS2720 net.Server inconsistencies.\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port?: number;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    super();\n+\n+    if (options != null) {\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this.on('listening', setupConnectionsTracking);\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(): this {\n+    httpServerPreClose(this);\n+    if (this.port) {\n+      portMapper.delete(this.port);\n+    }\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(\n+    request: Request,\n+    _env: unknown,\n+    _ctx: unknown\n+  ): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);\n+  }\n+\n+  #toReqRes(request: Request): {\n+    incoming: IncomingMessage;\n+    response: ServerResponse;\n+  } {\n+    const incoming = new IncomingMessage();\n+    const reqUrl = new URL(request.url);\n+    incoming.url = reqUrl.pathname + reqUrl.search;\n+\n+    const headers = [];\n+    for (const [key, value] of request.headers) {\n+      headers.push(key, value);\n+    }\n+    incoming._addHeaderLines(headers, headers.length);\n+\n+    incoming.method = request.method;\n+    incoming._stream = request.body;\n+\n+    const response = new ServerResponse(incoming);\n+    return { incoming, response };\n+  }\n+\n+  listen(...args: unknown[]): this {\n+    const [options, callback] = _normalizeArgs(args);\n+    if (typeof options.port === 'number' || typeof options.port === 'string') {\n+      validatePort(options.port, 'options.port');\n+    }\n+\n+    if (!('port' in options)) {\n+      throw new ERR_INVALID_ARG_VALUE(\n+        'options',\n+        options,\n+        'must have the property \"port\"'\n+      );\n+    }\n+\n+    if (this.port != null) {\n+      throw new ERR_SERVER_ALREADY_LISTEN();\n+    }\n+\n+    if (portMapper.has(Number(options.port))) {\n+      throw new Error(`Port ${options.port} is already in use`);\n+    }\n+\n+    if (callback !== null) {\n+      this.once('listening', callback as (...args: unknown[]) => unknown);\n+    }\n+\n+    this.port = Number(options.port);\n+    portMapper.set(this.port, { fetch: this.#onRequest.bind(this) });\n+    callback?.();\n+    return this;\n+  }\n+\n+  getConnections(_cb?: (err: Error | null, count: number) => void): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+\n+  ref(): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+\n+  unref(): this {\n+    // This method is originally implemented in net.Server.\n+    // Since we don't implement net.Server yet, we provide this stub implementation for now.\n+    // TODO(soon): Revisit this once we implement net.Server\n+    return this;\n+  }\n+}\n+\n+// We use this handler to not expose this.#fetchResponse to outside world.\n+let getServerResponseFetchResponse: (\n+  response: ServerResponse\n+) => Promise<Response>;\n+\n+export class ServerResponse<Req extends IncomingMessage = IncomingMessage>\n+  extends OutgoingMessage\n+  implements _ServerResponse\n+{\n+  _sent100 = false;\n+  _expect_continue = false;\n+  override [kOutHeaders]: Record<string, [string, string | string[]]> | null =\n+    null;\n+\n+  statusCode = 200;\n+  statusMessage = 'unknown';\n+\n+  #fetchResponse: Promise<Response>;\n+  #encoder = new TextEncoder();\n+\n+  static {\n+    getServerResponseFetchResponse = (\n+      response: ServerResponse\n+    ): Promise<Response> => {\n+      return response.#fetchResponse;\n+    };\n+  }\n+\n+  constructor(req: Req, options: ServerOptions = {}) {\n+    super(req, options);\n+\n+    if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n+      this.useChunkedEncodingByDefault = chunkExpression.test(\n+        (req.headers.te as string | undefined) ?? ''\n+      );\n+      this.shouldKeepAlive = false;\n+    }\n+\n+    const { promise, resolve } = Promise.withResolvers<Response>();\n+\n+    let finished = false;\n+    this.once('finish', () => (finished = true));\n+    const chunks: (Buffer | Uint8Array)[] = [];\n+    const handler = (event: DataWrittenEvent): void => {\n+      if (finished) return;\n+      chunks[event.index] = this.#dataFromDataWrittenEvent(event);\n+    };\n+    this.on('_dataWritten', handler);\n+    this.on(\n+      '_headersSent',\n+      ({ statusCode, statusMessage, headers }: HeadersSentEvent) => {\n+        this.off('_dataWritten', handler);\n+        resolve(\n+          this.#toFetchResponse({\n+            statusCode,\n+            statusText: statusMessage,\n+            sentHeaders: headers,\n+            chunks,\n+            finished,\n+          })\n+        );\n+      }\n+    );\n+    this.#fetchResponse = promise;\n+  }\n+\n+  #toFetchResponse({\n+    statusCode,\n+    statusText,\n+    sentHeaders,\n+    chunks,\n+    finished,\n+  }: {\n+    statusCode: number;\n+    statusText: string;\n+    sentHeaders: [header: string, value: string][];\n+    chunks: (Buffer | Uint8Array)[];\n+    finished: boolean;\n+  }): Response {\n+    const headers = new Headers();\n+    for (const [header, value] of sentHeaders) {\n+      headers.append(header, value);\n+    }",
        "comment_created_at": "2025-07-23T19:14:07+00:00",
        "comment_author": "anonrig",
        "comment_body": "Nice. `const headers = new Headers(sentHeaders);` works.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224962031",
    "pr_number": 4591,
    "pr_file": "src/cloudflare/workers.ts",
    "created_at": "2025-07-23T09:27:27+00:00",
    "commented_code": ");\n \n export const waitUntil = entrypoints.waitUntil.bind(entrypoints);\n+\n+export function registerFetchEvents({ port }: { port?: number } = {}): unknown {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224962031",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/cloudflare/workers.ts",
        "discussion_id": "2224962031",
        "commented_code": "@@ -91,3 +92,25 @@ export const env = new Proxy(\n );\n \n export const waitUntil = entrypoints.waitUntil.bind(entrypoints);\n+\n+export function registerFetchEvents({ port }: { port?: number } = {}): unknown {",
        "comment_created_at": "2025-07-23T09:27:27+00:00",
        "comment_author": "vicb",
        "comment_body": "I agree with James here.\n\nWhile I understand where `registerFetchEvents`, I think it might be confusing for users - similar to how `waitUntil` confuses a lot of people.\n\nAdding a choice to the poll: `registerServer`.\n\nWe could also do a few more things to make things clearer:\n- add JSDoc\n- refine the return type from `unknown` to `ExportedHandler` (not sure if available here).\n\nIIUC the user worker would look like the following:\n\n```ts\nInitServer(\n  // listen(<PORT>);\n);\n\nregisterFetchEvents({ port: <PORT> });\n```\n\nIt would make it hard to add email, queues, scheduled handlers.\n\nIt could be solved by changing the API or documentation...",
        "pr_file_module": null
      },
      {
        "comment_id": "2231746794",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/cloudflare/workers.ts",
        "discussion_id": "2224962031",
        "commented_code": "@@ -91,3 +92,25 @@ export const env = new Proxy(\n );\n \n export const waitUntil = entrypoints.waitUntil.bind(entrypoints);\n+\n+export function registerFetchEvents({ port }: { port?: number } = {}): unknown {",
        "comment_created_at": "2025-07-25T18:13:25+00:00",
        "comment_author": "anonrig",
        "comment_body": "ExportedHandler is not available here, but I've changed the name of the function.",
        "pr_file_module": null
      }
    ]
  }
]