[
  {
    "discussion_id": "2224176991",
    "pr_number": 4480,
    "pr_file": "src/workerd/io/worker-fs.c++",
    "created_at": "2025-07-23T02:24:14+00:00",
    "commented_code": "mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\n') endPos--;\n+  auto context = js.v8Context();\n+  auto console =\n+      jsg::check(context->Global()->Get(context, jsg::v8StrIntern(js.v8Isolate, \"console\")));\n+  KJ_ASSERT(console->IsObject());\n+  auto consoleObj = console.As<v8::Object>();\n+\n+  // Choose the appropriate console method based on stdio type\n+  const char* methodName = (type == VirtualFileSystem::Stdio::OUT) ? \"log\" : \"error\";\n+  auto method = jsg::check(consoleObj->Get(context, jsg::v8StrIntern(js.v8Isolate, methodName)));\n+  KJ_ASSERT(method->IsFunction());\n+  auto methodFunc = method.As<v8::Function>();\n+\n+  v8::Local<v8::Value> args[] = {jsg::v8StrIntern(js.v8Isolate, kj::str(chars.slice(0, endPos)))};",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224176991",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/io/worker-fs.c++",
        "discussion_id": "2224176991",
        "commented_code": "@@ -1632,12 +1632,42 @@ class DevRandomFile final: public File, public kj::EnableAddRefToThis<DevRandomF\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\\n') endPos--;\n+  auto context = js.v8Context();\n+  auto console =\n+      jsg::check(context->Global()->Get(context, jsg::v8StrIntern(js.v8Isolate, \"console\")));\n+  KJ_ASSERT(console->IsObject());\n+  auto consoleObj = console.As<v8::Object>();\n+\n+  // Choose the appropriate console method based on stdio type\n+  const char* methodName = (type == VirtualFileSystem::Stdio::OUT) ? \"log\" : \"error\";\n+  auto method = jsg::check(consoleObj->Get(context, jsg::v8StrIntern(js.v8Isolate, methodName)));\n+  KJ_ASSERT(method->IsFunction());\n+  auto methodFunc = method.As<v8::Function>();\n+\n+  v8::Local<v8::Value> args[] = {jsg::v8StrIntern(js.v8Isolate, kj::str(chars.slice(0, endPos)))};",
        "comment_created_at": "2025-07-23T02:24:14+00:00",
        "comment_author": "jasnell",
        "comment_body": "Does `chars.first(endPos)` work here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2224177713",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/io/worker-fs.c++",
        "discussion_id": "2224176991",
        "commented_code": "@@ -1632,12 +1632,42 @@ class DevRandomFile final: public File, public kj::EnableAddRefToThis<DevRandomF\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\\n') endPos--;\n+  auto context = js.v8Context();\n+  auto console =\n+      jsg::check(context->Global()->Get(context, jsg::v8StrIntern(js.v8Isolate, \"console\")));\n+  KJ_ASSERT(console->IsObject());\n+  auto consoleObj = console.As<v8::Object>();\n+\n+  // Choose the appropriate console method based on stdio type\n+  const char* methodName = (type == VirtualFileSystem::Stdio::OUT) ? \"log\" : \"error\";\n+  auto method = jsg::check(consoleObj->Get(context, jsg::v8StrIntern(js.v8Isolate, methodName)));\n+  KJ_ASSERT(method->IsFunction());\n+  auto methodFunc = method.As<v8::Function>();\n+\n+  v8::Local<v8::Value> args[] = {jsg::v8StrIntern(js.v8Isolate, kj::str(chars.slice(0, endPos)))};",
        "comment_created_at": "2025-07-23T02:25:01+00:00",
        "comment_author": "jasnell",
        "comment_body": "Also, you should be able to do `js.str(chars.slice(0, endPos))` I believe, and avoid the extra allocation (`kj::str` heap allocates)",
        "pr_file_module": null
      },
      {
        "comment_id": "2226727351",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/io/worker-fs.c++",
        "discussion_id": "2224176991",
        "commented_code": "@@ -1632,12 +1632,42 @@ class DevRandomFile final: public File, public kj::EnableAddRefToThis<DevRandomF\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\\n') endPos--;\n+  auto context = js.v8Context();\n+  auto console =\n+      jsg::check(context->Global()->Get(context, jsg::v8StrIntern(js.v8Isolate, \"console\")));\n+  KJ_ASSERT(console->IsObject());\n+  auto consoleObj = console.As<v8::Object>();\n+\n+  // Choose the appropriate console method based on stdio type\n+  const char* methodName = (type == VirtualFileSystem::Stdio::OUT) ? \"log\" : \"error\";\n+  auto method = jsg::check(consoleObj->Get(context, jsg::v8StrIntern(js.v8Isolate, methodName)));\n+  KJ_ASSERT(method->IsFunction());\n+  auto methodFunc = method.As<v8::Function>();\n+\n+  v8::Local<v8::Value> args[] = {jsg::v8StrIntern(js.v8Isolate, kj::str(chars.slice(0, endPos)))};",
        "comment_created_at": "2025-07-23T21:29:59+00:00",
        "comment_author": "guybedford",
        "comment_body": "Added, thanks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2183788993",
    "pr_number": 4452,
    "pr_file": "src/workerd/jsg/util.c++",
    "created_at": "2025-07-03T21:39:38+00:00",
    "commented_code": "}\n \n void recursivelyFreeze(v8::Local<v8::Context> context, v8::Local<v8::Value> value) {\n-  if (value->IsArray()) {\n-    // Optimize array freezing (Array is a subclass of Object, but we can iterate it faster).\n-    v8::HandleScope scope(v8::Isolate::GetCurrent());\n-    auto arr = value.As<v8::Array>();\n-\n-    for (auto i: kj::zeroTo(arr->Length())) {\n-      recursivelyFreeze(context, check(arr->Get(context, i)));\n-    }\n+  auto isolate = v8::Isolate::GetCurrent();\n+  v8::HandleScope outerScope(isolate);\n+  kj::Vector<v8::Local<v8::Value>> queue;\n+  queue.reserve(128);\n+  queue.add(value);\n+\n+  while (!queue.empty()) {\n+    auto item = queue.back();\n+    queue.removeLast();\n+\n+    if (item->IsArray()) {\n+      auto arr = item.As<v8::Array>();\n+      uint32_t length = arr->Length();\n+\n+      // Process array elements in batches to reduce V8 API call overhead\n+      constexpr uint32_t BATCH_SIZE = 32;\n+      for (uint32_t i = 0; i < length;) {\n+        uint32_t batchEnd = kj::min(i + BATCH_SIZE, length);\n+        queue.reserve(queue.size() + (batchEnd - i));\n+\n+        for (; i < batchEnd; ++i) {\n+          auto element = check(arr->Get(context, i));\n+          if (!element->IsNullOrUndefined()) {\n+            queue.add(element);\n+          }\n+        }\n+      }\n \n-    check(arr->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen));\n-  } else if (value->IsObject()) {\n-    v8::HandleScope scope(v8::Isolate::GetCurrent());\n-    auto obj = value.As<v8::Object>();\n-    auto names = check(obj->GetPropertyNames(context, v8::KeyCollectionMode::kOwnOnly,\n-        v8::ALL_PROPERTIES, v8::IndexFilter::kIncludeIndices));\n+      check(arr->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen));\n+    } else if (item->IsObject()) {\n+      auto obj = item.As<v8::Object>();\n+      auto names = check(obj->GetPropertyNames(context, v8::KeyCollectionMode::kOwnOnly,\n+          v8::ALL_PROPERTIES, v8::IndexFilter::kIncludeIndices));\n+      if (!names.IsEmpty()) {\n+        uint32_t length = names->Length();\n+\n+        constexpr uint32_t BATCH_SIZE = 16;\n+        for (uint32_t i = 0; i < length;) {\n+          uint32_t batchEnd = std::min(i + BATCH_SIZE, length);\n+          queue.reserve(queue.size() + (batchEnd - i));\n+\n+          for (; i < batchEnd; ++i) {\n+            auto propValue = check(obj->Get(context, check(names->Get(context, i))));\n+            if (!propValue->IsNullOrUndefined()) {\n+              queue.add(propValue);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2183788993",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4452,
        "pr_file": "src/workerd/jsg/util.c++",
        "discussion_id": "2183788993",
        "commented_code": "@@ -570,29 +571,60 @@ kj::Array<kj::byte> asBytes(v8::Local<v8::ArrayBufferView> arrayBufferView) {\n }\n \n void recursivelyFreeze(v8::Local<v8::Context> context, v8::Local<v8::Value> value) {\n-  if (value->IsArray()) {\n-    // Optimize array freezing (Array is a subclass of Object, but we can iterate it faster).\n-    v8::HandleScope scope(v8::Isolate::GetCurrent());\n-    auto arr = value.As<v8::Array>();\n-\n-    for (auto i: kj::zeroTo(arr->Length())) {\n-      recursivelyFreeze(context, check(arr->Get(context, i)));\n-    }\n+  auto isolate = v8::Isolate::GetCurrent();\n+  v8::HandleScope outerScope(isolate);\n+  kj::Vector<v8::Local<v8::Value>> queue;\n+  queue.reserve(128);\n+  queue.add(value);\n+\n+  while (!queue.empty()) {\n+    auto item = queue.back();\n+    queue.removeLast();\n+\n+    if (item->IsArray()) {\n+      auto arr = item.As<v8::Array>();\n+      uint32_t length = arr->Length();\n+\n+      // Process array elements in batches to reduce V8 API call overhead\n+      constexpr uint32_t BATCH_SIZE = 32;\n+      for (uint32_t i = 0; i < length;) {\n+        uint32_t batchEnd = kj::min(i + BATCH_SIZE, length);\n+        queue.reserve(queue.size() + (batchEnd - i));\n+\n+        for (; i < batchEnd; ++i) {\n+          auto element = check(arr->Get(context, i));\n+          if (!element->IsNullOrUndefined()) {\n+            queue.add(element);\n+          }\n+        }\n+      }\n \n-    check(arr->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen));\n-  } else if (value->IsObject()) {\n-    v8::HandleScope scope(v8::Isolate::GetCurrent());\n-    auto obj = value.As<v8::Object>();\n-    auto names = check(obj->GetPropertyNames(context, v8::KeyCollectionMode::kOwnOnly,\n-        v8::ALL_PROPERTIES, v8::IndexFilter::kIncludeIndices));\n+      check(arr->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen));\n+    } else if (item->IsObject()) {\n+      auto obj = item.As<v8::Object>();\n+      auto names = check(obj->GetPropertyNames(context, v8::KeyCollectionMode::kOwnOnly,\n+          v8::ALL_PROPERTIES, v8::IndexFilter::kIncludeIndices));\n+      if (!names.IsEmpty()) {\n+        uint32_t length = names->Length();\n+\n+        constexpr uint32_t BATCH_SIZE = 16;\n+        for (uint32_t i = 0; i < length;) {\n+          uint32_t batchEnd = std::min(i + BATCH_SIZE, length);\n+          queue.reserve(queue.size() + (batchEnd - i));\n+\n+          for (; i < batchEnd; ++i) {\n+            auto propValue = check(obj->Get(context, check(names->Get(context, i))));\n+            if (!propValue->IsNullOrUndefined()) {\n+              queue.add(propValue);",
        "comment_created_at": "2025-07-03T21:39:38+00:00",
        "comment_author": "jasnell",
        "comment_body": "Since we only actually care about `Array` and `Object`, it would likely be more efficient to filter out non-Array, and non-Object values when adding to the queue, that way we can avoid unnecessary additional allocations via the queue reservations.",
        "pr_file_module": null
      }
    ]
  }
]