[
  {
    "discussion_id": "2282586623",
    "pr_number": 4800,
    "pr_file": "src/workerd/api/worker-rpc.c++",
    "created_at": "2025-08-18T14:30:13+00:00",
    "commented_code": "jsg::JsValue value,\n     RpcSerializerExternalHandler& externalHandler,\n     Func makeBuilder) {\n+  bool treatErrorsAsHostObjects = workerd::util::Autogate::isEnabled(\n+      workerd::util::AutogateKey::ENHANCED_TUNNELED_EXCEPTION_SERIALIZATION);\n   jsg::Serializer serializer(js,\n       jsg::Serializer::Options{\n         .version = 15,\n         .omitHeader = false,\n         .treatClassInstancesAsPlainObjects = false,\n+        .treatErrorsAsHostObjects = treatErrorsAsHostObjects,",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2282586623",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4800,
        "pr_file": "src/workerd/api/worker-rpc.c++",
        "discussion_id": "2282586623",
        "commented_code": "@@ -162,11 +163,14 @@ void serializeJsValue(jsg::Lock& js,\n     jsg::JsValue value,\n     RpcSerializerExternalHandler& externalHandler,\n     Func makeBuilder) {\n+  bool treatErrorsAsHostObjects = workerd::util::Autogate::isEnabled(\n+      workerd::util::AutogateKey::ENHANCED_TUNNELED_EXCEPTION_SERIALIZATION);\n   jsg::Serializer serializer(js,\n       jsg::Serializer::Options{\n         .version = 15,\n         .omitHeader = false,\n         .treatClassInstancesAsPlainObjects = false,\n+        .treatErrorsAsHostObjects = treatErrorsAsHostObjects,",
        "comment_created_at": "2025-08-18T14:30:13+00:00",
        "comment_author": "kentonv",
        "comment_body": "Is there any reason why we'd actually want different behavior at different call sites of jsg::Serializer? I can't really think of one.\n\nIf not, can we just have jsg::Serializer read the autogate or compat flag directly, rather than make this an option?",
        "pr_file_module": null
      },
      {
        "comment_id": "2291741321",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4800,
        "pr_file": "src/workerd/api/worker-rpc.c++",
        "discussion_id": "2282586623",
        "commented_code": "@@ -162,11 +163,14 @@ void serializeJsValue(jsg::Lock& js,\n     jsg::JsValue value,\n     RpcSerializerExternalHandler& externalHandler,\n     Func makeBuilder) {\n+  bool treatErrorsAsHostObjects = workerd::util::Autogate::isEnabled(\n+      workerd::util::AutogateKey::ENHANCED_TUNNELED_EXCEPTION_SERIALIZATION);\n   jsg::Serializer serializer(js,\n       jsg::Serializer::Options{\n         .version = 15,\n         .omitHeader = false,\n         .treatClassInstancesAsPlainObjects = false,\n+        .treatErrorsAsHostObjects = treatErrorsAsHostObjects,",
        "comment_created_at": "2025-08-21T17:39:41+00:00",
        "comment_author": "jasnell",
        "comment_body": "Well, we need to think through whether this makes sense for every case we use `jsg::Serializer` for, including storage... since it does change the actual produced serialization format for errors without changing the format version.\r\n\r\n~~That said tho, since `Serializer` is in jsg it does not have direct access to the compat flags and routing a compat flag through just to eliminate the option here just feels like, overkill?~~ Actually, I think we'll need this anyway if we use a compat flag to control it. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254598820",
    "pr_number": 4684,
    "pr_file": "src/workerd/api/worker-rpc.c++",
    "created_at": "2025-08-05T14:51:09+00:00",
    "commented_code": "IoContext::current().addWaitUntil(kj::mv(promise));\n }\n \n+// Static member definitions for RPC class registry\n+kj::Vector<kj::String> EntrypointsModule::registeredRpcClasses;\n+std::mutex EntrypointsModule::registryMutex;\n+\n+void EntrypointsModule::registerRpcTargetClass(jsg::Lock& js, jsg::JsValue constructor) {\n+  v8::Local<v8::Value> handle = constructor;\n+  if (!handle->IsFunction()) {\n+    JSG_FAIL_REQUIRE(TypeError, \"registerRpcTargetClass() requires a constructor function\");\n+  }\n+\n+  auto func = handle.As<v8::Function>();\n+  v8::String::Utf8Value name(js.v8Isolate, func->GetName());",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2254598820",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4684,
        "pr_file": "src/workerd/api/worker-rpc.c++",
        "discussion_id": "2254598820",
        "commented_code": "@@ -26,6 +28,58 @@ void EntrypointsModule::waitUntil(kj::Promise<void> promise) {\n   IoContext::current().addWaitUntil(kj::mv(promise));\n }\n \n+// Static member definitions for RPC class registry\n+kj::Vector<kj::String> EntrypointsModule::registeredRpcClasses;\n+std::mutex EntrypointsModule::registryMutex;\n+\n+void EntrypointsModule::registerRpcTargetClass(jsg::Lock& js, jsg::JsValue constructor) {\n+  v8::Local<v8::Value> handle = constructor;\n+  if (!handle->IsFunction()) {\n+    JSG_FAIL_REQUIRE(TypeError, \"registerRpcTargetClass() requires a constructor function\");\n+  }\n+\n+  auto func = handle.As<v8::Function>();\n+  v8::String::Utf8Value name(js.v8Isolate, func->GetName());",
        "comment_created_at": "2025-08-05T14:51:09+00:00",
        "comment_author": "jasnell",
        "comment_body": "If you keep `constructor` as a `JsValue`, you can just do `auto name = constructor.get(js, \"name\"_kj);`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254605695",
    "pr_number": 4684,
    "pr_file": "src/workerd/api/worker-rpc.c++",
    "created_at": "2025-08-05T14:53:37+00:00",
    "commented_code": "IoContext::current().addWaitUntil(kj::mv(promise));\n }\n \n+// Static member definitions for RPC class registry\n+kj::Vector<kj::String> EntrypointsModule::registeredRpcClasses;\n+std::mutex EntrypointsModule::registryMutex;\n+\n+void EntrypointsModule::registerRpcTargetClass(jsg::Lock& js, jsg::JsValue constructor) {\n+  v8::Local<v8::Value> handle = constructor;\n+  if (!handle->IsFunction()) {\n+    JSG_FAIL_REQUIRE(TypeError, \"registerRpcTargetClass() requires a constructor function\");\n+  }\n+\n+  auto func = handle.As<v8::Function>();\n+  v8::String::Utf8Value name(js.v8Isolate, func->GetName());\n+\n+  // Store the constructor name instead of V8 reference to avoid cross-isolate issues\n+  kj::String constructorName = kj::str(*name ? *name : \"<anonymous>\");\n+\n+  std::lock_guard<std::mutex> lock(registryMutex);\n+  // Avoid duplicate registrations\n+  for (const auto& registered: registeredRpcClasses) {\n+    if (registered == constructorName) {\n+      return;  // Already registered\n+    }\n+  }\n+  registeredRpcClasses.add(kj::mv(constructorName));\n+}\n+\n+bool EntrypointsModule::isRegisteredRpcTargetClass(jsg::Lock& js, jsg::JsObject obj) {\n+  std::lock_guard<std::mutex> lock(registryMutex);\n+\n+  auto context = js.v8Context();\n+  v8::Local<v8::Object> objHandle = obj;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2254605695",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4684,
        "pr_file": "src/workerd/api/worker-rpc.c++",
        "discussion_id": "2254605695",
        "commented_code": "@@ -26,6 +28,58 @@ void EntrypointsModule::waitUntil(kj::Promise<void> promise) {\n   IoContext::current().addWaitUntil(kj::mv(promise));\n }\n \n+// Static member definitions for RPC class registry\n+kj::Vector<kj::String> EntrypointsModule::registeredRpcClasses;\n+std::mutex EntrypointsModule::registryMutex;\n+\n+void EntrypointsModule::registerRpcTargetClass(jsg::Lock& js, jsg::JsValue constructor) {\n+  v8::Local<v8::Value> handle = constructor;\n+  if (!handle->IsFunction()) {\n+    JSG_FAIL_REQUIRE(TypeError, \"registerRpcTargetClass() requires a constructor function\");\n+  }\n+\n+  auto func = handle.As<v8::Function>();\n+  v8::String::Utf8Value name(js.v8Isolate, func->GetName());\n+\n+  // Store the constructor name instead of V8 reference to avoid cross-isolate issues\n+  kj::String constructorName = kj::str(*name ? *name : \"<anonymous>\");\n+\n+  std::lock_guard<std::mutex> lock(registryMutex);\n+  // Avoid duplicate registrations\n+  for (const auto& registered: registeredRpcClasses) {\n+    if (registered == constructorName) {\n+      return;  // Already registered\n+    }\n+  }\n+  registeredRpcClasses.add(kj::mv(constructorName));\n+}\n+\n+bool EntrypointsModule::isRegisteredRpcTargetClass(jsg::Lock& js, jsg::JsObject obj) {\n+  std::lock_guard<std::mutex> lock(registryMutex);\n+\n+  auto context = js.v8Context();\n+  v8::Local<v8::Object> objHandle = obj;",
        "comment_created_at": "2025-08-05T14:53:37+00:00",
        "comment_author": "jasnell",
        "comment_body": "It's better to leave this as a `JsObject` and to use the APIs there for getting the proto and the constructor name for doing these checks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224186122",
    "pr_number": 4480,
    "pr_file": "src/workerd/io/worker-fs.c++",
    "created_at": "2025-07-23T02:33:30+00:00",
    "commented_code": "mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\n') endPos--;\n+  auto context = js.v8Context();",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224186122",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/io/worker-fs.c++",
        "discussion_id": "2224186122",
        "commented_code": "@@ -1632,12 +1632,42 @@ class DevRandomFile final: public File, public kj::EnableAddRefToThis<DevRandomF\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\\n') endPos--;\n+  auto context = js.v8Context();",
        "comment_created_at": "2025-07-23T02:33:30+00:00",
        "comment_author": "jasnell",
        "comment_body": "You can use `js.global()` here to get the `Global` as a `jsg::JsObject` that'll be a bit nicer to use in here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2208083811",
    "pr_number": 4530,
    "pr_file": "src/workerd/io/trace-stream.c++",
    "created_at": "2025-07-15T17:10:46+00:00",
    "commented_code": "auto obj = js.obj();\n   obj.set(js, TYPE_STR, cache.get(js, LOG_STR));\n   obj.set(js, LEVEL_STR, ToJs(js, log.logLevel, cache));\n-  obj.set(js, MESSAGE_STR, js.str(log.message));\n+  obj.set(js, MESSAGE_STR, jsg::JsValue(js.parseJson(log.message).getHandle(js)));",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2208083811",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4530,
        "pr_file": "src/workerd/io/trace-stream.c++",
        "discussion_id": "2208083811",
        "commented_code": "@@ -517,7 +519,7 @@ jsg::JsValue ToJs(jsg::Lock& js, const tracing::Log& log, StringCache& cache) {\n   auto obj = js.obj();\n   obj.set(js, TYPE_STR, cache.get(js, LOG_STR));\n   obj.set(js, LEVEL_STR, ToJs(js, log.logLevel, cache));\n-  obj.set(js, MESSAGE_STR, js.str(log.message));\n+  obj.set(js, MESSAGE_STR, jsg::JsValue(js.parseJson(log.message).getHandle(js)));",
        "comment_created_at": "2025-07-15T17:10:46+00:00",
        "comment_author": "jasnell",
        "comment_body": "Nit.. for later... we should probably have a version of `js.parseJson` that just returns a `jsg::JsValue`",
        "pr_file_module": null
      },
      {
        "comment_id": "2208303660",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4530,
        "pr_file": "src/workerd/io/trace-stream.c++",
        "discussion_id": "2208083811",
        "commented_code": "@@ -517,7 +519,7 @@ jsg::JsValue ToJs(jsg::Lock& js, const tracing::Log& log, StringCache& cache) {\n   auto obj = js.obj();\n   obj.set(js, TYPE_STR, cache.get(js, LOG_STR));\n   obj.set(js, LEVEL_STR, ToJs(js, log.logLevel, cache));\n-  obj.set(js, MESSAGE_STR, js.str(log.message));\n+  obj.set(js, MESSAGE_STR, jsg::JsValue(js.parseJson(log.message).getHandle(js)));",
        "comment_created_at": "2025-07-15T18:24:56+00:00",
        "comment_author": "fhanau",
        "comment_body": "Yup, figuring out how to do this took a while since in the equivalent code for LTW we don't need to convert to JsValue",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2211331235",
    "pr_number": 4547,
    "pr_file": "src/workerd/api/node/process.c++",
    "created_at": "2025-07-16T19:09:35+00:00",
    "commented_code": "js.logWarning(kj::str(err.get(js, \"stack\"_kj)));\n }\n \n+kj::String ProcessModule::getCwd(jsg::Lock& js) {\n+  auto cwd = getCurrentWorkingDirectory();\n+  if (cwd == nullptr) {\n+    return kj::str(\"/\");\n+  }\n+  return kj::str(\"/\", cwd.toString());\n+}\n+\n+void ProcessModule::setCwd(jsg::Lock& js, kj::String path) {\n+  static constexpr size_t MAX_PATH_LENGTH = 4096;\n+  if (path.size() > MAX_PATH_LENGTH) {\n+    throwUVException(js, UV_ENAMETOOLONG, \"chdir\"_kj);\n+  }\n+\n+  if (path.size() == 0) {\n+    throwUVException(js, UV_ENOENT, \"chdir\"_kj);\n+  }\n+\n+  auto& vfs = VirtualFileSystem::current(js);\n+  auto url = KJ_REQUIRE_NONNULL(jsg::Url::tryParse(path, \"file:///\"_kj));\n+\n+  // Resolve the path against current working directory if it's relative\n+  kj::Path resolvedPath = [&]() {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2211331235",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4547,
        "pr_file": "src/workerd/api/node/process.c++",
        "discussion_id": "2211331235",
        "commented_code": "@@ -137,4 +139,56 @@ void ProcessModule::exitImpl(jsg::Lock& js, int code) {\n   js.logWarning(kj::str(err.get(js, \"stack\"_kj)));\n }\n \n+kj::String ProcessModule::getCwd(jsg::Lock& js) {\n+  auto cwd = getCurrentWorkingDirectory();\n+  if (cwd == nullptr) {\n+    return kj::str(\"/\");\n+  }\n+  return kj::str(\"/\", cwd.toString());\n+}\n+\n+void ProcessModule::setCwd(jsg::Lock& js, kj::String path) {\n+  static constexpr size_t MAX_PATH_LENGTH = 4096;\n+  if (path.size() > MAX_PATH_LENGTH) {\n+    throwUVException(js, UV_ENAMETOOLONG, \"chdir\"_kj);\n+  }\n+\n+  if (path.size() == 0) {\n+    throwUVException(js, UV_ENOENT, \"chdir\"_kj);\n+  }\n+\n+  auto& vfs = VirtualFileSystem::current(js);\n+  auto url = KJ_REQUIRE_NONNULL(jsg::Url::tryParse(path, \"file:///\"_kj));\n+\n+  // Resolve the path against current working directory if it's relative\n+  kj::Path resolvedPath = [&]() {",
        "comment_created_at": "2025-07-16T19:09:35+00:00",
        "comment_author": "jasnell",
        "comment_body": "You're parsing the path above into a url, then again as a path here. The below here should probably work off the url's `pathname` instead for consistency with the rest of the fs apis.",
        "pr_file_module": null
      },
      {
        "comment_id": "2211607301",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4547,
        "pr_file": "src/workerd/api/node/process.c++",
        "discussion_id": "2211331235",
        "commented_code": "@@ -137,4 +139,56 @@ void ProcessModule::exitImpl(jsg::Lock& js, int code) {\n   js.logWarning(kj::str(err.get(js, \"stack\"_kj)));\n }\n \n+kj::String ProcessModule::getCwd(jsg::Lock& js) {\n+  auto cwd = getCurrentWorkingDirectory();\n+  if (cwd == nullptr) {\n+    return kj::str(\"/\");\n+  }\n+  return kj::str(\"/\", cwd.toString());\n+}\n+\n+void ProcessModule::setCwd(jsg::Lock& js, kj::String path) {\n+  static constexpr size_t MAX_PATH_LENGTH = 4096;\n+  if (path.size() > MAX_PATH_LENGTH) {\n+    throwUVException(js, UV_ENAMETOOLONG, \"chdir\"_kj);\n+  }\n+\n+  if (path.size() == 0) {\n+    throwUVException(js, UV_ENOENT, \"chdir\"_kj);\n+  }\n+\n+  auto& vfs = VirtualFileSystem::current(js);\n+  auto url = KJ_REQUIRE_NONNULL(jsg::Url::tryParse(path, \"file:///\"_kj));\n+\n+  // Resolve the path against current working directory if it's relative\n+  kj::Path resolvedPath = [&]() {",
        "comment_created_at": "2025-07-16T21:03:25+00:00",
        "comment_author": "guybedford",
        "comment_body": "Thanks, that was from a previous iteration where I was doing the URL approach, this line just got left behind.",
        "pr_file_module": null
      }
    ]
  }
]