[
  {
    "discussion_id": "2303522687",
    "pr_number": 4834,
    "pr_file": "src/workerd/server/server.c++",
    "created_at": "2025-08-27T10:27:26+00:00",
    "commented_code": "return kj::refcounted<EntrypointService>(*this, name, kj::mv(props), *handlers);\n   }\n \n+  // Like getEntrypoint() but used specifically to get the entrypoint for use in ctx.exports,\n+  // where it can be used raw (props are empty), or can be specialized with props.\n+  kj::Own<Service> getLoopbackEntrypoint(kj::Maybe<kj::StringPtr> name) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2303522687",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4834,
        "pr_file": "src/workerd/server/server.c++",
        "discussion_id": "2303522687",
        "commented_code": "@@ -1933,6 +1939,27 @@ class Server::WorkerService final: public Service,\n     return kj::refcounted<EntrypointService>(*this, name, kj::mv(props), *handlers);\n   }\n \n+  // Like getEntrypoint() but used specifically to get the entrypoint for use in ctx.exports,\n+  // where it can be used raw (props are empty), or can be specialized with props.\n+  kj::Own<Service> getLoopbackEntrypoint(kj::Maybe<kj::StringPtr> name) {",
        "comment_created_at": "2025-08-27T10:27:26+00:00",
        "comment_author": "harrishancock",
        "comment_body": "Nit: With the uninitialized pointer and `name` parameter overwriting, this function reads a bit hacky. I think returning directly from the happy-path branches and declaring the end of the function unreachable would be a bit more readable for future maintainers.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2291332486",
    "pr_number": 4848,
    "pr_file": "src/workerd/jsg/jsg.c++",
    "created_at": "2025-08-21T14:56:04+00:00",
    "commented_code": "auto spec = kj::Path::parse(specifier);\n   auto& info = JSG_REQUIRE_NONNULL(\n       moduleRegistry->resolve(*this, spec), Error, kj::str(\"No such module: \", specifier));\n+  if (!!requireEsm) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2291332486",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4848,
        "pr_file": "src/workerd/jsg/jsg.c++",
        "discussion_id": "2291332486",
        "commented_code": "@@ -327,6 +327,9 @@ kj::Maybe<JsObject> Lock::resolveModule(kj::StringPtr specifier) {\n   auto spec = kj::Path::parse(specifier);\n   auto& info = JSG_REQUIRE_NONNULL(\n       moduleRegistry->resolve(*this, spec), Error, kj::str(\"No such module: \", specifier));\n+  if (!!requireEsm) {",
        "comment_created_at": "2025-08-21T14:56:04+00:00",
        "comment_author": "anonrig",
        "comment_body": "Why do we need !!? If requireEsm has bool operator if (requireEsm) would be sufficient I believe?",
        "pr_file_module": null
      },
      {
        "comment_id": "2291481305",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4848,
        "pr_file": "src/workerd/jsg/jsg.c++",
        "discussion_id": "2291332486",
        "commented_code": "@@ -327,6 +327,9 @@ kj::Maybe<JsObject> Lock::resolveModule(kj::StringPtr specifier) {\n   auto spec = kj::Path::parse(specifier);\n   auto& info = JSG_REQUIRE_NONNULL(\n       moduleRegistry->resolve(*this, spec), Error, kj::str(\"No such module: \", specifier));\n+  if (!!requireEsm) {",
        "comment_created_at": "2025-08-21T15:51:32+00:00",
        "comment_author": "jasnell",
        "comment_body": "The `!!` is harmless here but I'll remove it in the follow up PR I'm working on that builds on this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2294895022",
    "pr_number": 4848,
    "pr_file": "src/workerd/jsg/resource.h",
    "created_at": "2025-08-22T22:48:22+00:00",
    "commented_code": "// Expose the type of the global scope in the global scope itself.\n     exposeGlobalScopeType(isolate, context);\n \n-    kj::Maybe<kj::Own<void>> maybeNewModuleRegistry;\n-    KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n-      JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n-        // The context must be current for attachToIsolate to succeed.\n-        maybeNewModuleRegistry = newModuleRegistry.attachToIsolate(js, compilationObserver);\n-      });\n-    } else {\n-      ptr->setModuleRegistry(\n-          ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver));\n-    }\n+    ptr->setModuleRegistry(([&]() -> kj::Own<void> {\n+      KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n+        return JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n+          // The context must be current for attachToIsolate to succeed.\n+          return newModuleRegistry.attachToIsolate(js, compilationObserver);\n+        });\n+      }\n+      return ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver);\n+    })());",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2294895022",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4848,
        "pr_file": "src/workerd/jsg/resource.h",
        "discussion_id": "2294895022",
        "commented_code": "@@ -1730,20 +1730,19 @@ class ResourceWrapper {\n     // Expose the type of the global scope in the global scope itself.\n     exposeGlobalScopeType(isolate, context);\n \n-    kj::Maybe<kj::Own<void>> maybeNewModuleRegistry;\n-    KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n-      JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n-        // The context must be current for attachToIsolate to succeed.\n-        maybeNewModuleRegistry = newModuleRegistry.attachToIsolate(js, compilationObserver);\n-      });\n-    } else {\n-      ptr->setModuleRegistry(\n-          ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver));\n-    }\n+    ptr->setModuleRegistry(([&]() -> kj::Own<void> {\n+      KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n+        return JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n+          // The context must be current for attachToIsolate to succeed.\n+          return newModuleRegistry.attachToIsolate(js, compilationObserver);\n+        });\n+      }\n+      return ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver);\n+    })());",
        "comment_created_at": "2025-08-22T22:48:22+00:00",
        "comment_author": "jasnell",
        "comment_body": "Reviewer Note: The first block installs the new module registry on the v8::Context. The second installs the original module registry. Regardless of which one is used, the `kj::Own` holding the instance is stored in the `ContextGlobal`. Previously these were being stored in two separate places which didn't make sense.",
        "pr_file_module": null
      },
      {
        "comment_id": "2302226765",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4848,
        "pr_file": "src/workerd/jsg/resource.h",
        "discussion_id": "2294895022",
        "commented_code": "@@ -1730,20 +1730,19 @@ class ResourceWrapper {\n     // Expose the type of the global scope in the global scope itself.\n     exposeGlobalScopeType(isolate, context);\n \n-    kj::Maybe<kj::Own<void>> maybeNewModuleRegistry;\n-    KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n-      JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n-        // The context must be current for attachToIsolate to succeed.\n-        maybeNewModuleRegistry = newModuleRegistry.attachToIsolate(js, compilationObserver);\n-      });\n-    } else {\n-      ptr->setModuleRegistry(\n-          ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver));\n-    }\n+    ptr->setModuleRegistry(([&]() -> kj::Own<void> {\n+      KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n+        return JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n+          // The context must be current for attachToIsolate to succeed.\n+          return newModuleRegistry.attachToIsolate(js, compilationObserver);\n+        });\n+      }\n+      return ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver);\n+    })());",
        "comment_created_at": "2025-08-26T21:55:09+00:00",
        "comment_author": "danlapid",
        "comment_body": "Nit: I'd restore the else for readability.\r\ne.g.\r\n```\r\n    ptr->setModuleRegistry(([&]() -> kj::Own<void> {\r\n      KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\r\n        return JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\r\n          // The context must be current for attachToIsolate to succeed.\r\n          return newModuleRegistry.attachToIsolate(js, compilationObserver);\r\n        });\r\n      } else {\r\n        return ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver);\r\n      }\r\n    })());\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2302233028",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4848,
        "pr_file": "src/workerd/jsg/resource.h",
        "discussion_id": "2294895022",
        "commented_code": "@@ -1730,20 +1730,19 @@ class ResourceWrapper {\n     // Expose the type of the global scope in the global scope itself.\n     exposeGlobalScopeType(isolate, context);\n \n-    kj::Maybe<kj::Own<void>> maybeNewModuleRegistry;\n-    KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n-      JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n-        // The context must be current for attachToIsolate to succeed.\n-        maybeNewModuleRegistry = newModuleRegistry.attachToIsolate(js, compilationObserver);\n-      });\n-    } else {\n-      ptr->setModuleRegistry(\n-          ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver));\n-    }\n+    ptr->setModuleRegistry(([&]() -> kj::Own<void> {\n+      KJ_IF_SOME(newModuleRegistry, options.newModuleRegistry) {\n+        return JSG_WITHIN_CONTEXT_SCOPE(js, context, [&](jsg::Lock& js) {\n+          // The context must be current for attachToIsolate to succeed.\n+          return newModuleRegistry.attachToIsolate(js, compilationObserver);\n+        });\n+      }\n+      return ModuleRegistryImpl<TypeWrapper>::install(isolate, context, compilationObserver);\n+    })());",
        "comment_created_at": "2025-08-26T21:59:43+00:00",
        "comment_author": "jasnell",
        "comment_body": "I think I'm the only person in the world who finds that less readable \ud83d\ude06 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2191222568",
    "pr_number": 4477,
    "pr_file": "src/workerd/io/worker.c++",
    "created_at": "2025-07-08T00:05:00+00:00",
    "commented_code": "KJ_ASSERT(formatLogVal->IsFunction());\n     auto formatLog = formatLogVal.As<v8::Function>();\n \n+    const char* levelStr = logLevelToString(level);\n     args[length] = v8::Boolean::New(js.v8Isolate, colors);\n+    args[length + 1] = v8::Boolean::New(js.v8Isolate, structuredLogging);\n+    args[length + 2] = jsg::v8StrIntern(js.v8Isolate, levelStr);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2191222568",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4477,
        "pr_file": "src/workerd/io/worker.c++",
        "discussion_id": "2191222568",
        "commented_code": "@@ -1928,9 +1952,12 @@ void Worker::handleLog(jsg::Lock& js,\n     KJ_ASSERT(formatLogVal->IsFunction());\n     auto formatLog = formatLogVal.As<v8::Function>();\n \n+    const char* levelStr = logLevelToString(level);\n     args[length] = v8::Boolean::New(js.v8Isolate, colors);\n+    args[length + 1] = v8::Boolean::New(js.v8Isolate, structuredLogging);\n+    args[length + 2] = jsg::v8StrIntern(js.v8Isolate, levelStr);",
        "comment_created_at": "2025-07-08T00:05:00+00:00",
        "comment_author": "jasnell",
        "comment_body": "You could likely get away with just passing `levelStr` conditionally. If the value is passed as `undefined`, then assume `structuredLogging` is false, otherwise we assume `structuredLogging` is true.",
        "pr_file_module": null
      },
      {
        "comment_id": "2191223758",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4477,
        "pr_file": "src/workerd/io/worker.c++",
        "discussion_id": "2191222568",
        "commented_code": "@@ -1928,9 +1952,12 @@ void Worker::handleLog(jsg::Lock& js,\n     KJ_ASSERT(formatLogVal->IsFunction());\n     auto formatLog = formatLogVal.As<v8::Function>();\n \n+    const char* levelStr = logLevelToString(level);\n     args[length] = v8::Boolean::New(js.v8Isolate, colors);\n+    args[length + 1] = v8::Boolean::New(js.v8Isolate, structuredLogging);\n+    args[length + 2] = jsg::v8StrIntern(js.v8Isolate, levelStr);",
        "comment_created_at": "2025-07-08T00:06:40+00:00",
        "comment_author": "danlapid",
        "comment_body": "Yeah I could but that sounds ugly and odd doesn't it? why not convey intent directly?",
        "pr_file_module": null
      },
      {
        "comment_id": "2191230258",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4477,
        "pr_file": "src/workerd/io/worker.c++",
        "discussion_id": "2191222568",
        "commented_code": "@@ -1928,9 +1952,12 @@ void Worker::handleLog(jsg::Lock& js,\n     KJ_ASSERT(formatLogVal->IsFunction());\n     auto formatLog = formatLogVal.As<v8::Function>();\n \n+    const char* levelStr = logLevelToString(level);\n     args[length] = v8::Boolean::New(js.v8Isolate, colors);\n+    args[length + 1] = v8::Boolean::New(js.v8Isolate, structuredLogging);\n+    args[length + 2] = jsg::v8StrIntern(js.v8Isolate, levelStr);",
        "comment_created_at": "2025-07-08T00:12:47+00:00",
        "comment_author": "jasnell",
        "comment_body": "Why odd? It's fairly idiomatic in JavaScript.\r\n\r\n```c++\r\nargs[length + 1] = js.undefined();\r\nif (structuredLogging) {\r\n  args[length + 1] = js.strIntern(levelStr);\r\n}\r\n```\r\n\r\nThen in JS\r\n\r\n```js\r\nif (level !== undefined) {\r\n  // structured logging enabled\r\n} else {\r\n  // structured logging disabled\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2191243527",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4477,
        "pr_file": "src/workerd/io/worker.c++",
        "discussion_id": "2191222568",
        "commented_code": "@@ -1928,9 +1952,12 @@ void Worker::handleLog(jsg::Lock& js,\n     KJ_ASSERT(formatLogVal->IsFunction());\n     auto formatLog = formatLogVal.As<v8::Function>();\n \n+    const char* levelStr = logLevelToString(level);\n     args[length] = v8::Boolean::New(js.v8Isolate, colors);\n+    args[length + 1] = v8::Boolean::New(js.v8Isolate, structuredLogging);\n+    args[length + 2] = jsg::v8StrIntern(js.v8Isolate, levelStr);",
        "comment_created_at": "2025-07-08T00:29:37+00:00",
        "comment_author": "danlapid",
        "comment_body": "I just meant that it's kinda odd to use whether or not level is defined to convey whether or not to do structured logging.\r\n\r\nSeems besides the point and confusing to a random reader.\r\n\r\nWhy work so hard to optimize away the additional argument? It's not like this is performance critical code that's running in production. Seems more right to prefer readability over a slight of performance.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2276992750",
    "pr_number": 4405,
    "pr_file": "src/workerd/io/actor-sqlite-test.c++",
    "created_at": "2025-08-14T15:38:07+00:00",
    "commented_code": "KJ_ASSERT(expectSync(test.getAlarm()) == oneMs);\n }\n \n+KJ_TEST(\"check put multiple wraps operations in a transaction\") {\n+  ActorSqliteTest test;\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\n+    \"check put multiple wraps operations in a transaction with sql-kv-put-multiple-transaction autogate\") {\n+  ActorSqliteTest test;\n+\n+  // This test should reflect the same behavior we saw without the autogate enabled.\n+  util::Autogate::initAutogateNamesForTest({\"sql-kv-put-multiple-transaction\"_kj});\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\"check put multiple wraps operations in a transaction and does not rollbacks on error\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+\n+  // Add some regular key-value pairs that we know are supported\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+\n+  // Now create a key that's too large. Should fail with  string or blob too big: SQLITE_TOOBIG\n+  auto tooLongKey = kj::heapString(2200000);\n+  for (int x = 0; x < 2200000; x++) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2276992750",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4405,
        "pr_file": "src/workerd/io/actor-sqlite-test.c++",
        "discussion_id": "2276992750",
        "commented_code": "@@ -168,6 +179,284 @@ KJ_TEST(\"can set and get alarm\") {\n   KJ_ASSERT(expectSync(test.getAlarm()) == oneMs);\n }\n \n+KJ_TEST(\"check put multiple wraps operations in a transaction\") {\n+  ActorSqliteTest test;\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\n+    \"check put multiple wraps operations in a transaction with sql-kv-put-multiple-transaction autogate\") {\n+  ActorSqliteTest test;\n+\n+  // This test should reflect the same behavior we saw without the autogate enabled.\n+  util::Autogate::initAutogateNamesForTest({\"sql-kv-put-multiple-transaction\"_kj});\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\"check put multiple wraps operations in a transaction and does not rollbacks on error\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+\n+  // Add some regular key-value pairs that we know are supported\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+\n+  // Now create a key that's too large. Should fail with  string or blob too big: SQLITE_TOOBIG\n+  auto tooLongKey = kj::heapString(2200000);\n+  for (int x = 0; x < 2200000; x++) {",
        "comment_created_at": "2025-08-14T15:38:07+00:00",
        "comment_author": "justin-mp",
        "comment_body": "You can do `tooLongKey.asArray().fill('a');` which seems slightly cleaner because you don't have to repeat the constant.",
        "pr_file_module": null
      },
      {
        "comment_id": "2277174961",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4405,
        "pr_file": "src/workerd/io/actor-sqlite-test.c++",
        "discussion_id": "2276992750",
        "commented_code": "@@ -168,6 +179,284 @@ KJ_TEST(\"can set and get alarm\") {\n   KJ_ASSERT(expectSync(test.getAlarm()) == oneMs);\n }\n \n+KJ_TEST(\"check put multiple wraps operations in a transaction\") {\n+  ActorSqliteTest test;\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\n+    \"check put multiple wraps operations in a transaction with sql-kv-put-multiple-transaction autogate\") {\n+  ActorSqliteTest test;\n+\n+  // This test should reflect the same behavior we saw without the autogate enabled.\n+  util::Autogate::initAutogateNamesForTest({\"sql-kv-put-multiple-transaction\"_kj});\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+\n+  // NoTxn test\n+  {\n+    // Check that we're in a NoTxn\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+    // During write, all NoTxn operations are wrapped in an ImplicitTxn.\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo\"))) == kj::str(\"bar\").asBytes());\n+  }\n+\n+  // ExplicitTxn test\n+  {\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    // Similar to the previous putMultiple, but wrapped in a transactionSync (ExplicitTxn)\n+    test.putMultipleExplicitTxn(putKVs.releaseAsArray());\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    commitFulfiller->fulfill();\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo2\"))) == kj::str(\"bar2\").asBytes());\n+  }\n+\n+  // ImplicitTxn test\n+  {\n+    // Setting an alarm followed by a single put will create an ImplicitTxn that we can use to wrap\n+    // our putMultiple into.\n+    test.setAlarm(oneMs);\n+    test.pollAndExpectCalls({\"scheduleRun(1ms)\"})[0]->fulfill();\n+    test.pollAndExpectCalls({\"commit\"})[0]->fulfill();\n+    test.pollAndExpectCalls({});\n+\n+    putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+    KJ_ASSERT(!test.actor.isCommitScheduled());\n+    test.put(\"baz\", \"bat\");\n+    // By now, we should check there's a commit scheduled in a ImplicitTxn.\n+    KJ_ASSERT(test.actor.isCommitScheduled());\n+    test.putMultiple(putKVs.releaseAsArray());\n+\n+    auto commitFulfiller = kj::mv(test.pollAndExpectCalls({\"commit\"})[0]);\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"baz\"))) == kj::str(\"bat\").asBytes());\n+    KJ_ASSERT(KJ_ASSERT_NONNULL(expectSync(test.get(\"foo3\"))) == kj::str(\"bar3\").asBytes());\n+    commitFulfiller->fulfill();\n+  }\n+}\n+\n+KJ_TEST(\"check put multiple wraps operations in a transaction and does not rollbacks on error\") {\n+  ActorSqliteTest test;\n+\n+  // Let's deinit the autogate. This will enforce the old behavior where putMultiple would commit\n+  // some puts, until a single put failed.\n+  util::Autogate::deinitAutogate();\n+\n+  kj::Vector<ActorCache::KeyValuePair> putKVs;\n+\n+  // Add some regular key-value pairs that we know are supported\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo\"), kj::heapArray(kj::str(\"bar\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo2\"), kj::heapArray(kj::str(\"bar2\").asBytes())});\n+  putKVs.add(ActorCache::KeyValuePair{kj::str(\"foo3\"), kj::heapArray(kj::str(\"bar3\").asBytes())});\n+\n+  // Now create a key that's too large. Should fail with  string or blob too big: SQLITE_TOOBIG\n+  auto tooLongKey = kj::heapString(2200000);\n+  for (int x = 0; x < 2200000; x++) {",
        "comment_created_at": "2025-08-14T16:48:39+00:00",
        "comment_author": "jqmmes",
        "comment_body": "That's helpful! Applied in the latest update",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224165130",
    "pr_number": 4480,
    "pr_file": "src/workerd/io/worker-fs.c++",
    "created_at": "2025-07-23T02:14:06+00:00",
    "commented_code": "private:\n   VirtualFileSystem::Stdio type;\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n+\n+  static constexpr size_t MAX_LINE_BUFFER_SIZE = 4096;\n+  static constexpr size_t MAX_WRITE_SIZE = 16 * 1024;\n+  mutable kj::Vector<kj::byte> stdoutLineBuffer;\n+  mutable kj::Vector<kj::byte> stderrLineBuffer;\n+  mutable bool microtaskScheduled = false;\n+\n+  kj::Rc<WeakRef<StdioFile>> weakThis;\n+\n+  kj::Vector<kj::byte>& getLineBuffer() const {\n+    return (type == VirtualFileSystem::Stdio::OUT) ? stdoutLineBuffer : stderrLineBuffer;\n+  }\n+\n+  void scheduleFlushMicrotask(jsg::Lock& js) {\n+    if (microtaskScheduled) return;\n+    microtaskScheduled = true;\n+\n+    // Create ephemeral callback with weak reference for safety\n+    auto callback = js.wrapSimpleFunction(js.v8Context(),\n+        [weakThis = weakThis->addRef()](jsg::Lock& js, const v8::FunctionCallbackInfo<v8::Value>&) {\n+      weakThis->runIfAlive([&](StdioFile& self) {\n+        self.microtaskScheduled = false;\n+\n+        if (self.stdoutLineBuffer.size() > 0) {\n+          if (IoContext::hasCurrent()) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224165130",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/io/worker-fs.c++",
        "discussion_id": "2224165130",
        "commented_code": "@@ -1738,6 +1796,46 @@ class StdioFile final: public File, public kj::EnableAddRefToThis<StdioFile> {\n  private:\n   VirtualFileSystem::Stdio type;\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n+\n+  static constexpr size_t MAX_LINE_BUFFER_SIZE = 4096;\n+  static constexpr size_t MAX_WRITE_SIZE = 16 * 1024;\n+  mutable kj::Vector<kj::byte> stdoutLineBuffer;\n+  mutable kj::Vector<kj::byte> stderrLineBuffer;\n+  mutable bool microtaskScheduled = false;\n+\n+  kj::Rc<WeakRef<StdioFile>> weakThis;\n+\n+  kj::Vector<kj::byte>& getLineBuffer() const {\n+    return (type == VirtualFileSystem::Stdio::OUT) ? stdoutLineBuffer : stderrLineBuffer;\n+  }\n+\n+  void scheduleFlushMicrotask(jsg::Lock& js) {\n+    if (microtaskScheduled) return;\n+    microtaskScheduled = true;\n+\n+    // Create ephemeral callback with weak reference for safety\n+    auto callback = js.wrapSimpleFunction(js.v8Context(),\n+        [weakThis = weakThis->addRef()](jsg::Lock& js, const v8::FunctionCallbackInfo<v8::Value>&) {\n+      weakThis->runIfAlive([&](StdioFile& self) {\n+        self.microtaskScheduled = false;\n+\n+        if (self.stdoutLineBuffer.size() > 0) {\n+          if (IoContext::hasCurrent()) {",
        "comment_created_at": "2025-07-23T02:14:06+00:00",
        "comment_author": "jasnell",
        "comment_body": "Just to simplify things slightly, we can probably get by with just a single `IoContext::hasCurrent()` check and do both writes within it/",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214426008",
    "pr_number": 4559,
    "pr_file": "src/workerd/api/basics.h",
    "created_at": "2025-07-17T22:31:53+00:00",
    "commented_code": "JSG_READONLY_PROTOTYPE_PROPERTY(cancelable, getCancelable);\n       JSG_READONLY_PROTOTYPE_PROPERTY(defaultPrevented, getDefaultPrevented);\n       JSG_READONLY_PROTOTYPE_PROPERTY(returnValue, getReturnValue);\n-      JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      if (flags.getPedanticWpt()) {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      } else {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getTarget);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2214426008",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4559,
        "pr_file": "src/workerd/api/basics.h",
        "discussion_id": "2214426008",
        "commented_code": "@@ -155,11 +155,19 @@ class Event: public jsg::Object {\n       JSG_READONLY_PROTOTYPE_PROPERTY(cancelable, getCancelable);\n       JSG_READONLY_PROTOTYPE_PROPERTY(defaultPrevented, getDefaultPrevented);\n       JSG_READONLY_PROTOTYPE_PROPERTY(returnValue, getReturnValue);\n-      JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      if (flags.getPedanticWpt()) {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      } else {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getTarget);",
        "comment_created_at": "2025-07-17T22:31:53+00:00",
        "comment_author": "jasnell",
        "comment_body": "Review note: the original implementation had `getTarget` simply deferring to `getCurrentTarget`, the new impl moves the original impl into `getTarget` here so having `currentTarget` point to `getTarget` preserves the original behavior.",
        "pr_file_module": null
      },
      {
        "comment_id": "2214437516",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4559,
        "pr_file": "src/workerd/api/basics.h",
        "discussion_id": "2214426008",
        "commented_code": "@@ -155,11 +155,19 @@ class Event: public jsg::Object {\n       JSG_READONLY_PROTOTYPE_PROPERTY(cancelable, getCancelable);\n       JSG_READONLY_PROTOTYPE_PROPERTY(defaultPrevented, getDefaultPrevented);\n       JSG_READONLY_PROTOTYPE_PROPERTY(returnValue, getReturnValue);\n-      JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      if (flags.getPedanticWpt()) {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      } else {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getTarget);",
        "comment_created_at": "2025-07-17T22:41:42+00:00",
        "comment_author": "npaun",
        "comment_body": "I'd paste in this comment in the code. Would definitely save a headscratcher  later on.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214439007",
    "pr_number": 4559,
    "pr_file": "src/workerd/api/basics.h",
    "created_at": "2025-07-17T22:43:05+00:00",
    "commented_code": "JSG_READONLY_PROTOTYPE_PROPERTY(cancelable, getCancelable);\n       JSG_READONLY_PROTOTYPE_PROPERTY(defaultPrevented, getDefaultPrevented);\n       JSG_READONLY_PROTOTYPE_PROPERTY(returnValue, getReturnValue);\n-      JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      if (flags.getPedanticWpt()) {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      } else {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2214439007",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4559,
        "pr_file": "src/workerd/api/basics.h",
        "discussion_id": "2214439007",
        "commented_code": "@@ -155,11 +155,19 @@ class Event: public jsg::Object {\n       JSG_READONLY_PROTOTYPE_PROPERTY(cancelable, getCancelable);\n       JSG_READONLY_PROTOTYPE_PROPERTY(defaultPrevented, getDefaultPrevented);\n       JSG_READONLY_PROTOTYPE_PROPERTY(returnValue, getReturnValue);\n-      JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      if (flags.getPedanticWpt()) {\n+        JSG_READONLY_PROTOTYPE_PROPERTY(currentTarget, getCurrentTarget);\n+      } else {",
        "comment_created_at": "2025-07-17T22:43:05+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n      } else {\r\n        // The original implementation had getTarget simply deferring to\r\n        // getCurrentTarget, the new impl moves the original impl into\r\n        // getTarget here so having currentTarget point to getTarget\r\n        // preserves the original behavior.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195201880",
    "pr_number": 4371,
    "pr_file": "src/workerd/api/container.c++",
    "created_at": "2025-07-09T14:36:50+00:00",
    "commented_code": "}\n \n   IoContext::current().addTask(req.sendIgnoringResult());\n-\n   running = true;\n+  monitorOnBackgroundIfNeeded();\n }\n \n-jsg::Promise<void> Container::monitor(jsg::Lock& js) {\n+void Container::monitorOnBackgroundIfNeeded() {\n+  if (monitoring || !running) {\n+    return;\n+  }\n+  monitoring = true;\n+\n+  if (monitorKjPromise == kj::none) {\n+    // Store the exit code before forking since Response is not copyable\n+    monitorKjPromise = rpcClient->monitorRequest(capnp::MessageSize{4, 0})\n+                           .send()\n+                           .then([](auto&& results) -> uint8_t {\n+      return results.getExitCode();\n+    }).fork();\n+  }\n+\n+  auto req = KJ_ASSERT_NONNULL(monitorKjPromise)\n+                 .addBranch()\n+                 .then([this, self = JSG_THIS](uint8_t exitCode) {\n+    running = false;\n+    monitoring = false;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2195201880",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4371,
        "pr_file": "src/workerd/api/container.c++",
        "discussion_id": "2195201880",
        "commented_code": "@@ -48,18 +48,74 @@ void Container::start(jsg::Lock& js, jsg::Optional<StartupOptions> maybeOptions)\n   }\n \n   IoContext::current().addTask(req.sendIgnoringResult());\n-\n   running = true;\n+  monitorOnBackgroundIfNeeded();\n }\n \n-jsg::Promise<void> Container::monitor(jsg::Lock& js) {\n+void Container::monitorOnBackgroundIfNeeded() {\n+  if (monitoring || !running) {\n+    return;\n+  }\n+  monitoring = true;\n+\n+  if (monitorKjPromise == kj::none) {\n+    // Store the exit code before forking since Response is not copyable\n+    monitorKjPromise = rpcClient->monitorRequest(capnp::MessageSize{4, 0})\n+                           .send()\n+                           .then([](auto&& results) -> uint8_t {\n+      return results.getExitCode();\n+    }).fork();\n+  }\n+\n+  auto req = KJ_ASSERT_NONNULL(monitorKjPromise)\n+                 .addBranch()\n+                 .then([this, self = JSG_THIS](uint8_t exitCode) {\n+    running = false;\n+    monitoring = false;",
        "comment_created_at": "2025-07-09T14:36:50+00:00",
        "comment_author": "jasnell",
        "comment_body": "You can likely get away with using an `.attach(kj::defer([this, self = JSG_THIS]() { running = false; monitoring = false; }))` to the promise rather than explicitly handling it in both the then and error handler to eliminate the duplication here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2195229240",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4371,
        "pr_file": "src/workerd/api/container.c++",
        "discussion_id": "2195201880",
        "commented_code": "@@ -48,18 +48,74 @@ void Container::start(jsg::Lock& js, jsg::Optional<StartupOptions> maybeOptions)\n   }\n \n   IoContext::current().addTask(req.sendIgnoringResult());\n-\n   running = true;\n+  monitorOnBackgroundIfNeeded();\n }\n \n-jsg::Promise<void> Container::monitor(jsg::Lock& js) {\n+void Container::monitorOnBackgroundIfNeeded() {\n+  if (monitoring || !running) {\n+    return;\n+  }\n+  monitoring = true;\n+\n+  if (monitorKjPromise == kj::none) {\n+    // Store the exit code before forking since Response is not copyable\n+    monitorKjPromise = rpcClient->monitorRequest(capnp::MessageSize{4, 0})\n+                           .send()\n+                           .then([](auto&& results) -> uint8_t {\n+      return results.getExitCode();\n+    }).fork();\n+  }\n+\n+  auto req = KJ_ASSERT_NONNULL(monitorKjPromise)\n+                 .addBranch()\n+                 .then([this, self = JSG_THIS](uint8_t exitCode) {\n+    running = false;\n+    monitoring = false;",
        "comment_created_at": "2025-07-09T14:48:14+00:00",
        "comment_author": "anonrig",
        "comment_body": "Nice. Thanks for the recommendation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178069822",
    "pr_number": 4438,
    "pr_file": "src/workerd/api/streams/standard.c++",
    "created_at": "2025-07-01T16:43:39+00:00",
    "commented_code": "}\n \n template <typename Controller>\n-void ReadableLockImpl<Controller>::PipeLocked::visitForGc(jsg::GcVisitor& visitor) {\n-  visitor.visit(writableStreamRef);\n-}\n+void ReadableLockImpl<Controller>::PipeLocked::visitForGc(jsg::GcVisitor& visitor) {}",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2178069822",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4438,
        "pr_file": "src/workerd/api/streams/standard.c++",
        "discussion_id": "2178069822",
        "commented_code": "@@ -359,9 +354,7 @@ jsg::Promise<ReadResult> ReadableLockImpl<Controller>::PipeLocked::read(jsg::Loc\n }\n \n template <typename Controller>\n-void ReadableLockImpl<Controller>::PipeLocked::visitForGc(jsg::GcVisitor& visitor) {\n-  visitor.visit(writableStreamRef);\n-}\n+void ReadableLockImpl<Controller>::PipeLocked::visitForGc(jsg::GcVisitor& visitor) {}",
        "comment_created_at": "2025-07-01T16:43:39+00:00",
        "comment_author": "danlapid",
        "comment_body": "If it's empty wouldn't it be simpler to just not implement this function?",
        "pr_file_module": null
      }
    ]
  }
]