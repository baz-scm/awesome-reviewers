[
  {
    "discussion_id": "2286671175",
    "pr_number": 4834,
    "pr_file": "src/workerd/api/actor-state.c++",
    "created_at": "2025-08-20T00:14:56+00:00",
    "commented_code": "id = ioCtx.getActorOrThrow().cloneId();\n       }\n \n-      auto actorClass = options.$class->getChannel(ioCtx);\n+      DurableObjectClass& actorClass = [&]() -> DurableObjectClass& {\n+        KJ_SWITCH_ONEOF(options.$class) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2286671175",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4834,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2286671175",
        "commented_code": "@@ -886,10 +887,23 @@ jsg::Ref<Fetcher> DurableObjectFacets::get(jsg::Lock& js,\n         id = ioCtx.getActorOrThrow().cloneId();\n       }\n \n-      auto actorClass = options.$class->getChannel(ioCtx);\n+      DurableObjectClass& actorClass = [&]() -> DurableObjectClass& {\n+        KJ_SWITCH_ONEOF(options.$class) {",
        "comment_created_at": "2025-08-20T00:14:56+00:00",
        "comment_author": "jasnell",
        "comment_body": "Nit: The use of `$class` here is obscure enough that a comment here would likely be helpful for future folks looking into this code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293657348",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4834,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2286671175",
        "commented_code": "@@ -886,10 +887,23 @@ jsg::Ref<Fetcher> DurableObjectFacets::get(jsg::Lock& js,\n         id = ioCtx.getActorOrThrow().cloneId();\n       }\n \n-      auto actorClass = options.$class->getChannel(ioCtx);\n+      DurableObjectClass& actorClass = [&]() -> DurableObjectClass& {\n+        KJ_SWITCH_ONEOF(options.$class) {",
        "comment_created_at": "2025-08-22T12:54:03+00:00",
        "comment_author": "kentonv",
        "comment_body": "OK I added doc comments to `DurableObjectFacets::StartupOptions`.\r\n\r\nFWIW `$class` is just an identifier. The $ is needed so that it's not interpreted as a keyword. JSG removes the $ from the JS API.",
        "pr_file_module": null
      },
      {
        "comment_id": "2294127501",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4834,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2286671175",
        "commented_code": "@@ -886,10 +887,23 @@ jsg::Ref<Fetcher> DurableObjectFacets::get(jsg::Lock& js,\n         id = ioCtx.getActorOrThrow().cloneId();\n       }\n \n-      auto actorClass = options.$class->getChannel(ioCtx);\n+      DurableObjectClass& actorClass = [&]() -> DurableObjectClass& {\n+        KJ_SWITCH_ONEOF(options.$class) {",
        "comment_created_at": "2025-08-22T16:05:35+00:00",
        "comment_author": "jasnell",
        "comment_body": "Yep :-) ... *I* know that but it's one of those odd looking ones that I'm sure trips newcomers up when they happen to stumble across it. :-)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2274481556",
    "pr_number": 4773,
    "pr_file": "src/workerd/io/compatibility-date.capnp",
    "created_at": "2025-08-13T19:52:04+00:00",
    "commented_code": "$compatDisableFlag(\"disable_nodejs_http2_module\")\n     $impliedByAfterDate(name = \"nodeJsCompat\", date = \"2025-09-01\");\n   # Enables the Node.js http2 module stubs.\n+\n+  experimentalAllowEvalAlways @113 :Bool",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2274481556",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4773,
        "pr_file": "src/workerd/io/compatibility-date.capnp",
        "discussion_id": "2274481556",
        "commented_code": "@@ -975,4 +975,11 @@ struct CompatibilityFlags @0x8f8c1b68151b6cef {\n     $compatDisableFlag(\"disable_nodejs_http2_module\")\n     $impliedByAfterDate(name = \"nodeJsCompat\", date = \"2025-09-01\");\n   # Enables the Node.js http2 module stubs.\n+\n+  experimentalAllowEvalAlways @113 :Bool",
        "comment_created_at": "2025-08-13T19:52:04+00:00",
        "comment_author": "danlapid",
        "comment_body": "We could just give it a good name and reuse this same flag in the future when we are actually ready to allow eval.\r\nI'd rather not have two flags for the same thing",
        "pr_file_module": null
      },
      {
        "comment_id": "2274522659",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4773,
        "pr_file": "src/workerd/io/compatibility-date.capnp",
        "discussion_id": "2274481556",
        "commented_code": "@@ -975,4 +975,11 @@ struct CompatibilityFlags @0x8f8c1b68151b6cef {\n     $compatDisableFlag(\"disable_nodejs_http2_module\")\n     $impliedByAfterDate(name = \"nodeJsCompat\", date = \"2025-09-01\");\n   # Enables the Node.js http2 module stubs.\n+\n+  experimentalAllowEvalAlways @113 :Bool",
        "comment_created_at": "2025-08-13T20:12:15+00:00",
        "comment_author": "jasnell",
        "comment_body": "How about just `allow_eval`? The `experimentalAllowEvalAlways` name here, of course, is only used internally so we can rename that any time. It's the actual enable flag name that matters here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2274706424",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4773,
        "pr_file": "src/workerd/io/compatibility-date.capnp",
        "discussion_id": "2274481556",
        "commented_code": "@@ -975,4 +975,11 @@ struct CompatibilityFlags @0x8f8c1b68151b6cef {\n     $compatDisableFlag(\"disable_nodejs_http2_module\")\n     $impliedByAfterDate(name = \"nodeJsCompat\", date = \"2025-09-01\");\n   # Enables the Node.js http2 module stubs.\n+\n+  experimentalAllowEvalAlways @113 :Bool",
        "comment_created_at": "2025-08-13T21:41:02+00:00",
        "comment_author": "jasnell",
        "comment_body": "Chatted with @kentonv a bit on the naming here... he asked for a scarier sounding name... I agreed. updated! PTAL",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2268195051",
    "pr_number": 4749,
    "pr_file": "src/workerd/io/compatibility-date.capnp",
    "created_at": "2025-08-11T23:09:29+00:00",
    "commented_code": "# This flag is intended to be a roll-up flag. That is, as additional APIs\n   # reach EOL, new compat flags will be added for those that will have\n   # `impliedByAfterDate(name = \"removeNodeJsCompatEOL\", ...` annotations.\n+\n+  transpileTypescript @109 :Bool\n+    $compatEnableFlag(\"transpile_typescript\")\n+    $compatDisableFlag(\"no_transpile_typescript\")\n+    $experimental;\n+  # Transpile all loaded files to remove Typescript types.",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2268195051",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4749,
        "pr_file": "src/workerd/io/compatibility-date.capnp",
        "discussion_id": "2268195051",
        "commented_code": "@@ -947,4 +947,10 @@ struct CompatibilityFlags @0x8f8c1b68151b6cef {\n   # This flag is intended to be a roll-up flag. That is, as additional APIs\n   # reach EOL, new compat flags will be added for those that will have\n   # `impliedByAfterDate(name = \"removeNodeJsCompatEOL\", ...` annotations.\n+\n+  transpileTypescript @109 :Bool\n+    $compatEnableFlag(\"transpile_typescript\")\n+    $compatDisableFlag(\"no_transpile_typescript\")\n+    $experimental;\n+  # Transpile all loaded files to remove Typescript types.",
        "comment_created_at": "2025-08-11T23:09:29+00:00",
        "comment_author": "jasnell",
        "comment_body": "I would call this `typescriptErasableSyntax`, which is the more common, familiar name to folks who use this.\r\n\r\n```suggestion\r\n  typescriptErasableSyntax @109 :Bool\r\n    $compatEnableFlag(\"typescript_erasable_syntax\")\r\n    $experimental;\r\n  # Support typescript erasable syntax support.\r\n  # This flag is expected to always be opt-in and never have\r\n  # a default on date.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2273896327",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4749,
        "pr_file": "src/workerd/io/compatibility-date.capnp",
        "discussion_id": "2268195051",
        "commented_code": "@@ -947,4 +947,10 @@ struct CompatibilityFlags @0x8f8c1b68151b6cef {\n   # This flag is intended to be a roll-up flag. That is, as additional APIs\n   # reach EOL, new compat flags will be added for those that will have\n   # `impliedByAfterDate(name = \"removeNodeJsCompatEOL\", ...` annotations.\n+\n+  transpileTypescript @109 :Bool\n+    $compatEnableFlag(\"transpile_typescript\")\n+    $compatDisableFlag(\"no_transpile_typescript\")\n+    $experimental;\n+  # Transpile all loaded files to remove Typescript types.",
        "comment_created_at": "2025-08-13T15:54:35+00:00",
        "comment_author": "mikea",
        "comment_body": "it is now called `typescript_strip_types` which is even more to the point, wdyt?",
        "pr_file_module": null
      },
      {
        "comment_id": "2273992779",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4749,
        "pr_file": "src/workerd/io/compatibility-date.capnp",
        "discussion_id": "2268195051",
        "commented_code": "@@ -947,4 +947,10 @@ struct CompatibilityFlags @0x8f8c1b68151b6cef {\n   # This flag is intended to be a roll-up flag. That is, as additional APIs\n   # reach EOL, new compat flags will be added for those that will have\n   # `impliedByAfterDate(name = \"removeNodeJsCompatEOL\", ...` annotations.\n+\n+  transpileTypescript @109 :Bool\n+    $compatEnableFlag(\"transpile_typescript\")\n+    $compatDisableFlag(\"no_transpile_typescript\")\n+    $experimental;\n+  # Transpile all loaded files to remove Typescript types.",
        "comment_created_at": "2025-08-13T16:34:26+00:00",
        "comment_author": "jasnell",
        "comment_body": "That's fine. Get's the point across :-)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258424418",
    "pr_number": 4698,
    "pr_file": "src/workerd/jsg/util.h",
    "created_at": "2025-08-06T22:11:14+00:00",
    "commented_code": "kj::String fullyQualifiedTypeName(const std::type_info& type);\n kj::String typeName(const std::type_info& type);\n \n+struct MakeInternalErrorOptions {\n+  // When trusted is true and the kj::Exception has a serialized exception detail, the\n+  // stack will be included in the deserialized error if it is available. When false,\n+  // the stack will be omitted.\n+  bool trusted = false;\n+\n+  // When ignoreDetail is true, tells makeInternalError() to ignore any serialized\n+  // exception detail in the kj::Exception.\n+  bool ignoreDetail = false;\n+\n+  // If the deserialized exception detail is not an object, then it will be ignored\n+  // and we will fall back to constructing a new error object. The default is true\n+  // to preserve existing behavior, but setting this to false may be useful in some\n+  // cases. When false, the makeInternalError() might return a non-object value.\n+  bool ignoreNonObjects = true;\n+\n+  // When doNotLog is true, the error will not be logged.",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2258424418",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4698,
        "pr_file": "src/workerd/jsg/util.h",
        "discussion_id": "2258424418",
        "commented_code": "@@ -53,6 +53,26 @@ bool getShouldSetToStringTag(v8::Isolate* isolate);\n kj::String fullyQualifiedTypeName(const std::type_info& type);\n kj::String typeName(const std::type_info& type);\n \n+struct MakeInternalErrorOptions {\n+  // When trusted is true and the kj::Exception has a serialized exception detail, the\n+  // stack will be included in the deserialized error if it is available. When false,\n+  // the stack will be omitted.\n+  bool trusted = false;\n+\n+  // When ignoreDetail is true, tells makeInternalError() to ignore any serialized\n+  // exception detail in the kj::Exception.\n+  bool ignoreDetail = false;\n+\n+  // If the deserialized exception detail is not an object, then it will be ignored\n+  // and we will fall back to constructing a new error object. The default is true\n+  // to preserve existing behavior, but setting this to false may be useful in some\n+  // cases. When false, the makeInternalError() might return a non-object value.\n+  bool ignoreNonObjects = true;\n+\n+  // When doNotLog is true, the error will not be logged.",
        "comment_created_at": "2025-08-06T22:11:14+00:00",
        "comment_author": "kentonv",
        "comment_body": "Maybe clarify this applies only to actually-internal errors; tunneled errors won't ever be logged.\r\n\r\n... on a related note, maybe we should rename the function from `makeInternalError()` to `kjExceptionToJs()` or something.",
        "pr_file_module": null
      },
      {
        "comment_id": "2258492421",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4698,
        "pr_file": "src/workerd/jsg/util.h",
        "discussion_id": "2258424418",
        "commented_code": "@@ -53,6 +53,26 @@ bool getShouldSetToStringTag(v8::Isolate* isolate);\n kj::String fullyQualifiedTypeName(const std::type_info& type);\n kj::String typeName(const std::type_info& type);\n \n+struct MakeInternalErrorOptions {\n+  // When trusted is true and the kj::Exception has a serialized exception detail, the\n+  // stack will be included in the deserialized error if it is available. When false,\n+  // the stack will be omitted.\n+  bool trusted = false;\n+\n+  // When ignoreDetail is true, tells makeInternalError() to ignore any serialized\n+  // exception detail in the kj::Exception.\n+  bool ignoreDetail = false;\n+\n+  // If the deserialized exception detail is not an object, then it will be ignored\n+  // and we will fall back to constructing a new error object. The default is true\n+  // to preserve existing behavior, but setting this to false may be useful in some\n+  // cases. When false, the makeInternalError() might return a non-object value.\n+  bool ignoreNonObjects = true;\n+\n+  // When doNotLog is true, the error will not be logged.",
        "comment_created_at": "2025-08-06T23:08:02+00:00",
        "comment_author": "jasnell",
        "comment_body": "Yeah, renaming makes sense.. additional commit shortly",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258425917",
    "pr_number": 4698,
    "pr_file": "src/workerd/jsg/util.h",
    "created_at": "2025-08-06T22:12:30+00:00",
    "commented_code": "kj::String fullyQualifiedTypeName(const std::type_info& type);\n kj::String typeName(const std::type_info& type);\n \n+struct MakeInternalErrorOptions {\n+  // When trusted is true and the kj::Exception has a serialized exception detail, the\n+  // stack will be included in the deserialized error if it is available. When false,\n+  // the stack will be omitted.\n+  bool trusted = false;\n+\n+  // When ignoreDetail is true, tells makeInternalError() to ignore any serialized\n+  // exception detail in the kj::Exception.\n+  bool ignoreDetail = false;\n+\n+  // If the deserialized exception detail is not an object, then it will be ignored\n+  // and we will fall back to constructing a new error object. The default is true\n+  // to preserve existing behavior, but setting this to false may be useful in some\n+  // cases. When false, the makeInternalError() might return a non-object value.\n+  bool ignoreNonObjects = true;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2258425917",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4698,
        "pr_file": "src/workerd/jsg/util.h",
        "discussion_id": "2258425917",
        "commented_code": "@@ -53,6 +53,26 @@ bool getShouldSetToStringTag(v8::Isolate* isolate);\n kj::String fullyQualifiedTypeName(const std::type_info& type);\n kj::String typeName(const std::type_info& type);\n \n+struct MakeInternalErrorOptions {\n+  // When trusted is true and the kj::Exception has a serialized exception detail, the\n+  // stack will be included in the deserialized error if it is available. When false,\n+  // the stack will be omitted.\n+  bool trusted = false;\n+\n+  // When ignoreDetail is true, tells makeInternalError() to ignore any serialized\n+  // exception detail in the kj::Exception.\n+  bool ignoreDetail = false;\n+\n+  // If the deserialized exception detail is not an object, then it will be ignored\n+  // and we will fall back to constructing a new error object. The default is true\n+  // to preserve existing behavior, but setting this to false may be useful in some\n+  // cases. When false, the makeInternalError() might return a non-object value.\n+  bool ignoreNonObjects = true;",
        "comment_created_at": "2025-08-06T22:12:30+00:00",
        "comment_author": "kentonv",
        "comment_body": "Nitpick: Maybe reverse this to `allowNonObjects` so that the default can be false? I've found it's sort of confusing when booleans default to true, and also `ignoreNonObjects = false` ends up being a double-negative.",
        "pr_file_module": null
      },
      {
        "comment_id": "2258473617",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4698,
        "pr_file": "src/workerd/jsg/util.h",
        "discussion_id": "2258425917",
        "commented_code": "@@ -53,6 +53,26 @@ bool getShouldSetToStringTag(v8::Isolate* isolate);\n kj::String fullyQualifiedTypeName(const std::type_info& type);\n kj::String typeName(const std::type_info& type);\n \n+struct MakeInternalErrorOptions {\n+  // When trusted is true and the kj::Exception has a serialized exception detail, the\n+  // stack will be included in the deserialized error if it is available. When false,\n+  // the stack will be omitted.\n+  bool trusted = false;\n+\n+  // When ignoreDetail is true, tells makeInternalError() to ignore any serialized\n+  // exception detail in the kj::Exception.\n+  bool ignoreDetail = false;\n+\n+  // If the deserialized exception detail is not an object, then it will be ignored\n+  // and we will fall back to constructing a new error object. The default is true\n+  // to preserve existing behavior, but setting this to false may be useful in some\n+  // cases. When false, the makeInternalError() might return a non-object value.\n+  bool ignoreNonObjects = true;",
        "comment_created_at": "2025-08-06T22:53:11+00:00",
        "comment_author": "jasnell",
        "comment_body": "Fair.. will change in the fixup commit soon",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2245846233",
    "pr_number": 4650,
    "pr_file": "src/workerd/api/node/exceptions.c++",
    "created_at": "2025-07-31T16:24:23+00:00",
    "commented_code": "+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::Error: {\n+      KJ_FALLTHROUGH;\n+    }\n+    default: {\n+      return KJ_ASSERT_NONNULL(js.error(message).tryCast<jsg::JsObject>());\n+    }\n+  }\n+  KJ_UNREACHABLE;\n+}\n+\n+constexpr kj::StringPtr getMessage(NodeExceptionCode code, kj::StringPtr message) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2245846233",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4650,
        "pr_file": "src/workerd/api/node/exceptions.c++",
        "discussion_id": "2245846233",
        "commented_code": "@@ -0,0 +1,113 @@\n+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::Error: {\n+      KJ_FALLTHROUGH;\n+    }\n+    default: {\n+      return KJ_ASSERT_NONNULL(js.error(message).tryCast<jsg::JsObject>());\n+    }\n+  }\n+  KJ_UNREACHABLE;\n+}\n+\n+constexpr kj::StringPtr getMessage(NodeExceptionCode code, kj::StringPtr message) {",
        "comment_created_at": "2025-07-31T16:24:23+00:00",
        "comment_author": "anonrig",
        "comment_body": "We are already in node namespace, can we remove the extra Node prefix?\n\n```suggestion\nconstexpr kj::StringPtr getMessage(ExceptionCode code, kj::StringPtr message) {\n```\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2245869229",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4650,
        "pr_file": "src/workerd/api/node/exceptions.c++",
        "discussion_id": "2245846233",
        "commented_code": "@@ -0,0 +1,113 @@\n+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::Error: {\n+      KJ_FALLTHROUGH;\n+    }\n+    default: {\n+      return KJ_ASSERT_NONNULL(js.error(message).tryCast<jsg::JsObject>());\n+    }\n+  }\n+  KJ_UNREACHABLE;\n+}\n+\n+constexpr kj::StringPtr getMessage(NodeExceptionCode code, kj::StringPtr message) {",
        "comment_created_at": "2025-07-31T16:35:03+00:00",
        "comment_author": "jasnell",
        "comment_body": "I prefer the `Node` prefix on this as it is more descriptive.",
        "pr_file_module": null
      },
      {
        "comment_id": "2245885445",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4650,
        "pr_file": "src/workerd/api/node/exceptions.c++",
        "discussion_id": "2245846233",
        "commented_code": "@@ -0,0 +1,113 @@\n+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::Error: {\n+      KJ_FALLTHROUGH;\n+    }\n+    default: {\n+      return KJ_ASSERT_NONNULL(js.error(message).tryCast<jsg::JsObject>());\n+    }\n+  }\n+  KJ_UNREACHABLE;\n+}\n+\n+constexpr kj::StringPtr getMessage(NodeExceptionCode code, kj::StringPtr message) {",
        "comment_created_at": "2025-07-31T16:42:24+00:00",
        "comment_author": "anonrig",
        "comment_body": "You can achieve the same thing with node::ExceptionType",
        "pr_file_module": null
      },
      {
        "comment_id": "2245955325",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4650,
        "pr_file": "src/workerd/api/node/exceptions.c++",
        "discussion_id": "2245846233",
        "commented_code": "@@ -0,0 +1,113 @@\n+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::Error: {\n+      KJ_FALLTHROUGH;\n+    }\n+    default: {\n+      return KJ_ASSERT_NONNULL(js.error(message).tryCast<jsg::JsObject>());\n+    }\n+  }\n+  KJ_UNREACHABLE;\n+}\n+\n+constexpr kj::StringPtr getMessage(NodeExceptionCode code, kj::StringPtr message) {",
        "comment_created_at": "2025-07-31T17:13:41+00:00",
        "comment_author": "jasnell",
        "comment_body": "I still prefer the descriptiveness of `NodeExceptionCode` here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2243171500",
    "pr_number": 4632,
    "pr_file": "src/workerd/api/worker-loader.c++",
    "created_at": "2025-07-30T16:01:08+00:00",
    "commented_code": "auto modules = KJ_MAP(entry, code.modules.fields) -> Worker::Script::Module {\n     KJ_SWITCH_ONEOF(entry.value) {\n       KJ_CASE_ONEOF(text, kj::String) {\n-        return {\n-          .name = entry.name,\n-          .content = Worker::Script::EsModule{.body = text},\n-        };\n+        if (entry.name.endsWith(\".py\"_kj)) {\n+          return {\n+            .name = entry.name,\n+            .content = Worker::Script::PythonModule{.body = text},\n+          };\n+        }\n+\n+        if (entry.name.endsWith(\".js\"_kj)) {\n+          return {\n+            .name = entry.name,\n+            .content = Worker::Script::EsModule{.body = text},\n+          };\n+        }\n+\n+        JSG_FAIL_REQUIRE(TypeError, \"Module name must end with '.js' or '.py'. Got: \", entry.name);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2243171500",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4632,
        "pr_file": "src/workerd/api/worker-loader.c++",
        "discussion_id": "2243171500",
        "commented_code": "@@ -135,16 +135,28 @@ Worker::Script::Source WorkerLoader::extractSource(jsg::Lock& js, WorkerCode& co\n   auto modules = KJ_MAP(entry, code.modules.fields) -> Worker::Script::Module {\n     KJ_SWITCH_ONEOF(entry.value) {\n       KJ_CASE_ONEOF(text, kj::String) {\n-        return {\n-          .name = entry.name,\n-          .content = Worker::Script::EsModule{.body = text},\n-        };\n+        if (entry.name.endsWith(\".py\"_kj)) {\n+          return {\n+            .name = entry.name,\n+            .content = Worker::Script::PythonModule{.body = text},\n+          };\n+        }\n+\n+        if (entry.name.endsWith(\".js\"_kj)) {\n+          return {\n+            .name = entry.name,\n+            .content = Worker::Script::EsModule{.body = text},\n+          };\n+        }\n+\n+        JSG_FAIL_REQUIRE(TypeError, \"Module name must end with '.js' or '.py'. Got: \", entry.name);",
        "comment_created_at": "2025-07-30T16:01:08+00:00",
        "comment_author": "kentonv",
        "comment_body": "```suggestion\r\n        JSG_FAIL_REQUIRE(TypeError, \"Module name must end with '.js' or '.py' (or the content must be an object indicating the type explicitly). Got: \", entry.name);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1869792899",
    "pr_number": 3209,
    "pr_file": "src/workerd/io/trace.h",
    "created_at": "2024-12-04T15:30:24+00:00",
    "commented_code": "// Replicates W3C Serialization\n   kj::String toW3C() const;\n \n+  // Return network order hex representation\n+  kj::String toNEHex() const;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "1869792899",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 3209,
        "pr_file": "src/workerd/io/trace.h",
        "discussion_id": "1869792899",
        "commented_code": "@@ -92,6 +92,9 @@ class TraceId final {\n   // Replicates W3C Serialization\n   kj::String toW3C() const;\n \n+  // Return network order hex representation\n+  kj::String toNEHex() const;",
        "comment_created_at": "2024-12-04T15:30:24+00:00",
        "comment_author": "jasnell",
        "comment_body": "Nit: While it's more verbose, I prefer avoiding the abbreviation here. `s/toNEHex/toNetworkOrderHex`",
        "pr_file_module": null
      }
    ]
  }
]