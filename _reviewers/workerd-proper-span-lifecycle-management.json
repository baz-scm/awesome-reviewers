[
  {
    "discussion_id": "2283120508",
    "pr_number": 4816,
    "pr_file": "src/workerd/api/actor-state.c++",
    "created_at": "2025-08-18T18:16:27+00:00",
    "commented_code": "jsg::Promise<jsg::JsRef<jsg::JsValue>> DurableObjectStorageOperations::get(jsg::Lock& js,\n     kj::OneOf<kj::String, kj::Array<kj::String>> keys,\n     jsg::Optional<GetOptions> maybeOptions) {\n+  auto& context = IoContext::current();\n+  auto userSpan = context.makeUserTraceSpan(\"do_storage_get\"_kjc);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2283120508",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4816,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2283120508",
        "commented_code": "@@ -256,6 +256,8 @@ DurableObjectStorage::DurableObjectStorage(jsg::Lock& js,\n jsg::Promise<jsg::JsRef<jsg::JsValue>> DurableObjectStorageOperations::get(jsg::Lock& js,\n     kj::OneOf<kj::String, kj::Array<kj::String>> keys,\n     jsg::Optional<GetOptions> maybeOptions) {\n+  auto& context = IoContext::current();\n+  auto userSpan = context.makeUserTraceSpan(\"do_storage_get\"_kjc);",
        "comment_created_at": "2025-08-18T18:16:27+00:00",
        "comment_author": "jmorrell-cloudflare",
        "comment_body": "IIUC, because we don't pass the context through here, the span will immediately fall out of scope and close, which is not what we want. This is also the issue with the KV spans I added, and why they show up with a 0 duration currently.",
        "pr_file_module": null
      },
      {
        "comment_id": "2284828332",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4816,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2283120508",
        "commented_code": "@@ -256,6 +256,8 @@ DurableObjectStorage::DurableObjectStorage(jsg::Lock& js,\n jsg::Promise<jsg::JsRef<jsg::JsValue>> DurableObjectStorageOperations::get(jsg::Lock& js,\n     kj::OneOf<kj::String, kj::Array<kj::String>> keys,\n     jsg::Optional<GetOptions> maybeOptions) {\n+  auto& context = IoContext::current();\n+  auto userSpan = context.makeUserTraceSpan(\"do_storage_get\"_kjc);",
        "comment_created_at": "2025-08-19T10:29:50+00:00",
        "comment_author": "danlapid",
        "comment_body": "Yep, for every JSG method that returns a promise we'll need to attach the span, see internal chat I tagged you on to see how to do it right.",
        "pr_file_module": null
      },
      {
        "comment_id": "2290801262",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4816,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2283120508",
        "commented_code": "@@ -256,6 +256,8 @@ DurableObjectStorage::DurableObjectStorage(jsg::Lock& js,\n jsg::Promise<jsg::JsRef<jsg::JsValue>> DurableObjectStorageOperations::get(jsg::Lock& js,\n     kj::OneOf<kj::String, kj::Array<kj::String>> keys,\n     jsg::Optional<GetOptions> maybeOptions) {\n+  auto& context = IoContext::current();\n+  auto userSpan = context.makeUserTraceSpan(\"do_storage_get\"_kjc);",
        "comment_created_at": "2025-08-21T11:49:08+00:00",
        "comment_author": "m-makuch",
        "comment_body": "I've added `userSpan.end()` in lambda after the promise returns. Could you please verify if it's the correct approach?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2300547040",
    "pr_number": 4816,
    "pr_file": "src/workerd/api/actor-state.c++",
    "created_at": "2025-08-26T10:29:21+00:00",
    "commented_code": "jsg::Promise<jsg::JsRef<jsg::JsValue>> DurableObjectStorageOperations::get(jsg::Lock& js,\n     kj::OneOf<kj::String, kj::Array<kj::String>> keys,\n     jsg::Optional<GetOptions> maybeOptions) {\n+  auto& context = IoContext::current();\n+  auto userSpan = context.makeUserTraceSpan(\"durable_object_storage.get\"_kjc);\n   auto options = configureOptions(kj::mv(maybeOptions).orDefault(GetOptions{}));\n   KJ_SWITCH_ONEOF(keys) {\n     KJ_CASE_ONEOF(s, kj::String) {\n-      return getOne(js, kj::mv(s), options);\n+      // resolve the promise and end the span\n+      auto prom = getOne(js, kj::mv(s), options);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2300547040",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4816,
        "pr_file": "src/workerd/api/actor-state.c++",
        "discussion_id": "2300547040",
        "commented_code": "@@ -256,13 +256,20 @@ DurableObjectStorage::DurableObjectStorage(jsg::Lock& js,\n jsg::Promise<jsg::JsRef<jsg::JsValue>> DurableObjectStorageOperations::get(jsg::Lock& js,\n     kj::OneOf<kj::String, kj::Array<kj::String>> keys,\n     jsg::Optional<GetOptions> maybeOptions) {\n+  auto& context = IoContext::current();\n+  auto userSpan = context.makeUserTraceSpan(\"durable_object_storage.get\"_kjc);\n   auto options = configureOptions(kj::mv(maybeOptions).orDefault(GetOptions{}));\n   KJ_SWITCH_ONEOF(keys) {\n     KJ_CASE_ONEOF(s, kj::String) {\n-      return getOne(js, kj::mv(s), options);\n+      // resolve the promise and end the span\n+      auto prom = getOne(js, kj::mv(s), options);",
        "comment_created_at": "2025-08-26T10:29:21+00:00",
        "comment_author": "danlapid",
        "comment_body": "```suggestion\r\n      return context.attachSpans(js, getOne(js, kj::mv(s), options), kj::mv(userSpan));\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2271771356",
    "pr_number": 4767,
    "pr_file": "src/workerd/io/tracer.c++",
    "created_at": "2025-08-13T00:37:17+00:00",
    "commented_code": "KJ_IF_SOME(writer, maybeTailStreamWriter) {\n     auto& spanContext = KJ_UNWRAP_OR_RETURN(topLevelInvocationSpanContext);\n-    writer->report(\n-        spanContext, tracing::Return({KJ_ASSERT_NONNULL(trace->fetchResponseInfo).clone()}));\n+    // TODO: completeTime may not yet be available at this time",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2271771356",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4767,
        "pr_file": "src/workerd/io/tracer.c++",
        "discussion_id": "2271771356",
        "commented_code": "@@ -381,8 +405,9 @@ void WorkerTracer::setFetchResponseInfo(tracing::FetchResponseInfo&& info) {\n \n   KJ_IF_SOME(writer, maybeTailStreamWriter) {\n     auto& spanContext = KJ_UNWRAP_OR_RETURN(topLevelInvocationSpanContext);\n-    writer->report(\n-        spanContext, tracing::Return({KJ_ASSERT_NONNULL(trace->fetchResponseInfo).clone()}));\n+    // TODO: completeTime may not yet be available at this time",
        "comment_created_at": "2025-08-13T00:37:17+00:00",
        "comment_author": "fhanau",
        "comment_body": "This may be addressed by moving fetch response reporting to the destructor (as with outcome), would have to update a couple of tests as this causes fetch response to be reported before the \"worker\" span. Lmk if you can see a more elegant approach.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301744937",
    "pr_number": 4767,
    "pr_file": "src/workerd/io/io-context.c++",
    "created_at": "2025-08-26T18:07:11+00:00",
    "commented_code": "return;\n   }\n \n+  // Hack: We need to report an accurate time stamps for the STW outcome event, but the timer may\n+  // not be available when the outcome event gets reported. Define the outcome event time as the\n+  // time when the incoming request shuts down.\n+  KJ_IF_SOME(w, workerTracer) {\n+    w->recordTimestamp(ioChannelFactory->getTimer().now());",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2301744937",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4767,
        "pr_file": "src/workerd/io/io-context.c++",
        "discussion_id": "2301744937",
        "commented_code": "@@ -250,6 +250,14 @@ IoContext::IncomingRequest::~IoContext_IncomingRequest() noexcept(false) {\n     return;\n   }\n \n+  // Hack: We need to report an accurate time stamps for the STW outcome event, but the timer may\n+  // not be available when the outcome event gets reported. Define the outcome event time as the\n+  // time when the incoming request shuts down.\n+  KJ_IF_SOME(w, workerTracer) {\n+    w->recordTimestamp(ioChannelFactory->getTimer().now());",
        "comment_created_at": "2025-08-26T18:07:11+00:00",
        "comment_author": "danlapid",
        "comment_body": "Let's refactor this into IoContext_IncomingRequest::now() and use that from IoContext::now()",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301783262",
    "pr_number": 4767,
    "pr_file": "src/workerd/io/tracer.c++",
    "created_at": "2025-08-26T18:22:18+00:00",
    "commented_code": "// invocation to submit the onset event before any other tail events.\n   KJ_IF_SOME(writer, maybeTailStreamWriter) {\n     auto& spanContext = KJ_UNWRAP_OR_RETURN(topLevelInvocationSpanContext);\n+\n+    KJ_IF_SOME(fetchResponseInfo, trace->fetchResponseInfo) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2301783262",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4767,
        "pr_file": "src/workerd/io/tracer.c++",
        "discussion_id": "2301783262",
        "commented_code": "@@ -137,12 +137,18 @@ WorkerTracer::~WorkerTracer() noexcept(false) {\n   // invocation to submit the onset event before any other tail events.\n   KJ_IF_SOME(writer, maybeTailStreamWriter) {\n     auto& spanContext = KJ_UNWRAP_OR_RETURN(topLevelInvocationSpanContext);\n+\n+    KJ_IF_SOME(fetchResponseInfo, trace->fetchResponseInfo) {",
        "comment_created_at": "2025-08-26T18:22:18+00:00",
        "comment_author": "danlapid",
        "comment_body": "`tracing::Return` really should not be reported this late.\r\nIt should be reported way way earlier in Request+Response observers and the general WorkerInterface wrappers we have such as `RequestObserverWithTracer` externally and `MetricsCollector::Request` internally",
        "pr_file_module": null
      },
      {
        "comment_id": "2301785297",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4767,
        "pr_file": "src/workerd/io/tracer.c++",
        "discussion_id": "2301783262",
        "commented_code": "@@ -137,12 +137,18 @@ WorkerTracer::~WorkerTracer() noexcept(false) {\n   // invocation to submit the onset event before any other tail events.\n   KJ_IF_SOME(writer, maybeTailStreamWriter) {\n     auto& spanContext = KJ_UNWRAP_OR_RETURN(topLevelInvocationSpanContext);\n+\n+    KJ_IF_SOME(fetchResponseInfo, trace->fetchResponseInfo) {",
        "comment_created_at": "2025-08-26T18:23:20+00:00",
        "comment_author": "danlapid",
        "comment_body": "Probably should not block this PR but this needs to be fixed ASAP",
        "pr_file_module": null
      },
      {
        "comment_id": "2302145316",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4767,
        "pr_file": "src/workerd/io/tracer.c++",
        "discussion_id": "2301783262",
        "commented_code": "@@ -137,12 +137,18 @@ WorkerTracer::~WorkerTracer() noexcept(false) {\n   // invocation to submit the onset event before any other tail events.\n   KJ_IF_SOME(writer, maybeTailStreamWriter) {\n     auto& spanContext = KJ_UNWRAP_OR_RETURN(topLevelInvocationSpanContext);\n+\n+    KJ_IF_SOME(fetchResponseInfo, trace->fetchResponseInfo) {",
        "comment_created_at": "2025-08-26T21:06:10+00:00",
        "comment_author": "fhanau",
        "comment_body": "Merged this, opened #4909 as a follow-up",
        "pr_file_module": null
      }
    ]
  }
]