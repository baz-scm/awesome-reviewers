[
  {
    "discussion_id": "2279886251",
    "pr_number": 4800,
    "pr_file": "src/workerd/api/tests/js-rpc-test.js",
    "created_at": "2025-08-15T21:03:06+00:00",
    "commented_code": "try {\n       await env.MyService.throwingMethod();\n     } catch (e) {\n-      // verify stack trace was produced\n+      // check that the custom property made it through\n+      assert.strictEqual(e.abc, 123);\n+      // verify a local stack trace was produced\n       assert.strictEqual(e.stack.includes('at async Object.test'), true);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2279886251",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4800,
        "pr_file": "src/workerd/api/tests/js-rpc-test.js",
        "discussion_id": "2279886251",
        "commented_code": "@@ -1695,7 +1697,9 @@ export let testAsyncStackTrace = {\n     try {\n       await env.MyService.throwingMethod();\n     } catch (e) {\n-      // verify stack trace was produced\n+      // check that the custom property made it through\n+      assert.strictEqual(e.abc, 123);\n+      // verify a local stack trace was produced\n       assert.strictEqual(e.stack.includes('at async Object.test'), true);",
        "comment_created_at": "2025-08-15T21:03:06+00:00",
        "comment_author": "jasnell",
        "comment_body": "Adding the abc 123 bit here demonstrates that the enhanced handling is working, and the unmodified stack check demonstrates that we're seeing local stacks, not the remote stack.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2236957911",
    "pr_number": 4591,
    "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
    "created_at": "2025-07-28T15:29:06+00:00",
    "commented_code": "+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-de-chunked-trailer.js\n+export const testHttpServerDeChunkedTrailer = {\n+  async test(_ctrl, env) {\n+    const handlerFn = mock.fn((req, res) => {\n+      res.setHeader('Trailer', 'baz');\n+      const trailerInvalidErr = {\n+        code: 'ERR_HTTP_TRAILER_INVALID',\n+        message: 'Trailers are invalid with this transfer encoding',\n+        name: 'Error',\n+      };\n+      throws(\n+        () => res.writeHead(200, { 'Content-Length': '2' }),\n+        trailerInvalidErr\n+      );\n+      res.removeHeader('Trailer');\n+      res.end('ok');\n+    });\n+    const server = http.createServer(handlerFn);\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'ok');\n+    strictEqual(handlerFn.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+// TODO(soon): Fix this\n+// // Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+// export const testHttpServerIncomingMessageDestroy = {\n+//   async test(_ctrl, env) {\n+//     await using server = http.createServer((req, res) => {\n+//       req.destroy(new Error('Destroy test'));\n+//     });\n+\n+//     server.listen(8080);\n+\n+//     await rejects(() => {\n+//       return env.SERVICE.fetch('https://cloudflare.com');\n+//     }, {\n+//       message: '',\n+//     })\n+//   }\n+// }\n+\n+// Test is taken from test/parallel/test-http-server-method.query.js\n+export const testHttpServerMethodQuery = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'QUERY');\n+      res.end('OK');\n+    });\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      method: 'QUERY',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'OK');\n+  },\n+};\n+\n+// Tests is taken from test/parallel/test-http-server-multiheaders.js\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-non-utf8-header.js\n+export const testHttpServerNonUtf8Header = {\n+  async test(_ctrl, env) {\n+    const nonUtf8Header = 'b\u00e5r';\n+    const nonUtf8ToLatin1 = Buffer.from(nonUtf8Header).toString('latin1');\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          Buffer.from(nonUtf8Header).toString('binary'),\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+          method: 'GET',\n+        });\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+\n+      await promise;\n+    }\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      // Test multi-value header\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          [Buffer.from(nonUtf8Header).toString('binary')],\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com');\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+      await promise;\n+    }\n+\n+    // TODO(soon): Investigate this.\n+    // {\n+    //   const { promise, resolve } = Promise.withResolvers();\n+    //   const server = http.createServer((req, res) => {\n+    //     res.writeHead(200, [\n+    //       'Content-Length',\n+    //       '5',\n+    //       'content-disposition',\n+    //       Buffer.from(nonUtf8Header).toString('binary'),\n+    //     ]);\n+    //     res.end('hello');\n+    //   });\n+    //\n+    //   server.listen(8080);\n+    //\n+    //   const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    //   strictEqual(res.status, 200);\n+    //   strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+    //   server.close();\n+    //   resolve();\n+    //\n+    //   await promise;\n+    // }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-incoming-message.js\n+export const testHttpServerOptionsIncomingMessage = {\n+  async test(_ctrl, env) {\n+    class MyIncomingMessage extends http.IncomingMessage {\n+      getUserAgent() {\n+        return this.headers['user-agent'] || 'unknown';\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        IncomingMessage: MyIncomingMessage,\n+      },\n+      (req, res) => {\n+        strictEqual(req.getUserAgent(), 'node-test');\n+        res.statusCode = 200;\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      headers: { 'User-Agent': 'node-test' },\n+    });\n+    strictEqual(res.status, 200);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-server-response.js\n+export const testHttpServerOptionsServerResponse = {\n+  async test(_ctrl, env) {\n+    class MyServerResponse extends http.ServerResponse {\n+      status(code) {\n+        return this.writeHead(code, { 'Content-Type': 'text/plain' });\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        ServerResponse: MyServerResponse,\n+      },\n+      (_req, res) => {\n+        res.status(200);\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(res.headers.get('content-type'), 'text/plain');\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-after-end.js\n+export const testHttpServerWriteAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    await using server = http.createServer(handle);\n+\n+    function handle(_req, res) {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    }\n+\n+    server.listen(8080);\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-end-after-end.js\n+export const testHttpServerWriteEndAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const handle = mock.fn((req, res) => {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.end('world');\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    });\n+    const server = http.createServer(handle);\n+    server.listen(8080);\n+\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+    strictEqual(handle.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+export const testHandleZeroPortNumber = {\n+  async test() {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer();\n+    const listeningFn = mock.fn();\n+    server.on('listening', listeningFn);\n+    server.listen(0, () => {\n+      ok(server.listening);\n+      notStrictEqual(server.port, 0);\n+      notStrictEqual(server.address().port, 0);\n+      strictEqual(listeningFn.mock.callCount(), 1);\n+      server.close();\n+      resolve();\n+    });\n+    await promise;\n+  },\n+};\n+\n+export const testInvalidPorts = {\n+  async test() {\n+    const server = http.createServer();\n+    for (const value of [NaN, Infinity]) {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2236957911",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/workerd/api/node/tests/http-server-nodejs-test.js",
        "discussion_id": "2236957911",
        "commented_code": "@@ -0,0 +1,573 @@\n+import http from 'node:http';\n+import { strictEqual, ok, throws, notStrictEqual } from 'node:assert';\n+import { nodeCompatHttpServerHandler } from 'cloudflare:workers';\n+import { mock } from 'node:test';\n+\n+export const checkPortsSetCorrectly = {\n+  test(_ctrl, env) {\n+    const keys = ['PONG_SERVER_PORT'];\n+    for (const key of keys) {\n+      strictEqual(typeof env[key], 'string');\n+      ok(env[key].length > 0);\n+    }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-async-dispose.js\n+export const testHttpServerAsyncDispose = {\n+  async test() {\n+    const server = http.createServer();\n+\n+    server.listen(8080);\n+    ok(server.listening);\n+    const closeFn = mock.fn();\n+    server.on('close', closeFn);\n+    await server[Symbol.asyncDispose]();\n+    ok(!server.listening);\n+    strictEqual(closeFn.mock.callCount(), 1);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-de-chunked-trailer.js\n+export const testHttpServerDeChunkedTrailer = {\n+  async test(_ctrl, env) {\n+    const handlerFn = mock.fn((req, res) => {\n+      res.setHeader('Trailer', 'baz');\n+      const trailerInvalidErr = {\n+        code: 'ERR_HTTP_TRAILER_INVALID',\n+        message: 'Trailers are invalid with this transfer encoding',\n+        name: 'Error',\n+      };\n+      throws(\n+        () => res.writeHead(200, { 'Content-Length': '2' }),\n+        trailerInvalidErr\n+      );\n+      res.removeHeader('Trailer');\n+      res.end('ok');\n+    });\n+    const server = http.createServer(handlerFn);\n+\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'ok');\n+    strictEqual(handlerFn.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+// TODO(soon): Fix this\n+// // Test is taken from test/parallel/test-http-server-incomingmessage-destroy.js\n+// export const testHttpServerIncomingMessageDestroy = {\n+//   async test(_ctrl, env) {\n+//     await using server = http.createServer((req, res) => {\n+//       req.destroy(new Error('Destroy test'));\n+//     });\n+\n+//     server.listen(8080);\n+\n+//     await rejects(() => {\n+//       return env.SERVICE.fetch('https://cloudflare.com');\n+//     }, {\n+//       message: '',\n+//     })\n+//   }\n+// }\n+\n+// Test is taken from test/parallel/test-http-server-method.query.js\n+export const testHttpServerMethodQuery = {\n+  async test(_ctrl, env) {\n+    await using server = http.createServer((req, res) => {\n+      strictEqual(req.method, 'QUERY');\n+      res.end('OK');\n+    });\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      method: 'QUERY',\n+    });\n+    strictEqual(res.status, 200);\n+    strictEqual(await res.text(), 'OK');\n+  },\n+};\n+\n+// Tests is taken from test/parallel/test-http-server-multiheaders.js\n+export const testHttpServerMultiHeaders = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer(function (req, res) {\n+      strictEqual(req.headers.accept, 'abc, def, ghijklmnopqrst');\n+      strictEqual(req.headers.host, 'foo');\n+      strictEqual(req.headers['www-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['proxy-authenticate'], 'foo, bar, baz');\n+      strictEqual(req.headers['x-foo'], 'bingo');\n+      strictEqual(req.headers['x-bar'], 'banjo, bango');\n+      strictEqual(req.headers['sec-websocket-protocol'], 'chat, share');\n+      strictEqual(\n+        req.headers['sec-websocket-extensions'],\n+        'foo; 1, bar; 2, baz'\n+      );\n+      strictEqual(req.headers.constructor, 'foo, bar, baz');\n+\n+      res.writeHead(200, { 'Content-Type': 'text/plain' });\n+      res.end('EOF');\n+\n+      server.close();\n+    });\n+\n+    server.listen(8080, async function () {\n+      const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+        headers: [\n+          ['accept', 'abc'],\n+          ['accept', 'def'],\n+          ['Accept', 'ghijklmnopqrst'],\n+          ['host', 'foo'],\n+          ['Host', 'bar'],\n+          ['hOst', 'baz'],\n+          ['www-authenticate', 'foo'],\n+          ['WWW-Authenticate', 'bar'],\n+          ['WWW-AUTHENTICATE', 'baz'],\n+          ['proxy-authenticate', 'foo'],\n+          ['Proxy-Authenticate', 'bar'],\n+          ['PROXY-AUTHENTICATE', 'baz'],\n+          ['x-foo', 'bingo'],\n+          ['x-bar', 'banjo'],\n+          ['x-bar', 'bango'],\n+          ['sec-websocket-protocol', 'chat'],\n+          ['sec-websocket-protocol', 'share'],\n+          ['sec-websocket-extensions', 'foo; 1'],\n+          ['sec-websocket-extensions', 'bar; 2'],\n+          ['sec-websocket-extensions', 'baz'],\n+          ['constructor', 'foo'],\n+          ['constructor', 'bar'],\n+          ['constructor', 'baz'],\n+        ],\n+      });\n+\n+      strictEqual(res.status, 200);\n+      strictEqual(res.headers.get('content-type'), 'text/plain');\n+      strictEqual(await res.text(), 'EOF');\n+\n+      resolve();\n+    });\n+\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-non-utf8-header.js\n+export const testHttpServerNonUtf8Header = {\n+  async test(_ctrl, env) {\n+    const nonUtf8Header = 'b\u00e5r';\n+    const nonUtf8ToLatin1 = Buffer.from(nonUtf8Header).toString('latin1');\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          Buffer.from(nonUtf8Header).toString('binary'),\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+          method: 'GET',\n+        });\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+\n+      await promise;\n+    }\n+\n+    {\n+      const { promise, resolve } = Promise.withResolvers();\n+      // Test multi-value header\n+      const server = http.createServer((req, res) => {\n+        res.writeHead(200, [\n+          'content-disposition',\n+          [Buffer.from(nonUtf8Header).toString('binary')],\n+        ]);\n+        res.end('hello');\n+      });\n+\n+      server.listen(8080, async () => {\n+        const res = await env.SERVICE.fetch('https://cloudflare.com');\n+        strictEqual(res.status, 200);\n+        strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+        server.close();\n+        resolve();\n+      });\n+      await promise;\n+    }\n+\n+    // TODO(soon): Investigate this.\n+    // {\n+    //   const { promise, resolve } = Promise.withResolvers();\n+    //   const server = http.createServer((req, res) => {\n+    //     res.writeHead(200, [\n+    //       'Content-Length',\n+    //       '5',\n+    //       'content-disposition',\n+    //       Buffer.from(nonUtf8Header).toString('binary'),\n+    //     ]);\n+    //     res.end('hello');\n+    //   });\n+    //\n+    //   server.listen(8080);\n+    //\n+    //   const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    //   strictEqual(res.status, 200);\n+    //   strictEqual(res.headers.get('content-disposition'), nonUtf8ToLatin1);\n+    //   server.close();\n+    //   resolve();\n+    //\n+    //   await promise;\n+    // }\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-incoming-message.js\n+export const testHttpServerOptionsIncomingMessage = {\n+  async test(_ctrl, env) {\n+    class MyIncomingMessage extends http.IncomingMessage {\n+      getUserAgent() {\n+        return this.headers['user-agent'] || 'unknown';\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        IncomingMessage: MyIncomingMessage,\n+      },\n+      (req, res) => {\n+        strictEqual(req.getUserAgent(), 'node-test');\n+        res.statusCode = 200;\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com', {\n+      headers: { 'User-Agent': 'node-test' },\n+    });\n+    strictEqual(res.status, 200);\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-options-server-response.js\n+export const testHttpServerOptionsServerResponse = {\n+  async test(_ctrl, env) {\n+    class MyServerResponse extends http.ServerResponse {\n+      status(code) {\n+        return this.writeHead(code, { 'Content-Type': 'text/plain' });\n+      }\n+    }\n+\n+    await using server = http.createServer(\n+      {\n+        ServerResponse: MyServerResponse,\n+      },\n+      (_req, res) => {\n+        res.status(200);\n+        res.end();\n+      }\n+    );\n+    server.listen(8080);\n+\n+    const res = await env.SERVICE.fetch('https://cloudflare.com');\n+    strictEqual(res.status, 200);\n+    strictEqual(res.headers.get('content-type'), 'text/plain');\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-after-end.js\n+export const testHttpServerWriteAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    await using server = http.createServer(handle);\n+\n+    function handle(_req, res) {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    }\n+\n+    server.listen(8080);\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+  },\n+};\n+\n+// Test is taken from test/parallel/test-http-server-write-end-after-end.js\n+export const testHttpServerWriteEndAfterEnd = {\n+  async test(_ctrl, env) {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const handle = mock.fn((req, res) => {\n+      res.write('hello');\n+      res.end();\n+\n+      queueMicrotask(() => {\n+        res.end('world');\n+        res.write('world', (err) => {\n+          strictEqual(err.code, 'ERR_STREAM_WRITE_AFTER_END');\n+          resolve();\n+        });\n+      });\n+    });\n+    const server = http.createServer(handle);\n+    server.listen(8080);\n+\n+    await env.SERVICE.fetch('https://cloudflare.com');\n+    await promise;\n+    strictEqual(handle.mock.callCount(), 1);\n+    server.close();\n+  },\n+};\n+\n+export const testHandleZeroPortNumber = {\n+  async test() {\n+    const { promise, resolve } = Promise.withResolvers();\n+    const server = http.createServer();\n+    const listeningFn = mock.fn();\n+    server.on('listening', listeningFn);\n+    server.listen(0, () => {\n+      ok(server.listening);\n+      notStrictEqual(server.port, 0);\n+      notStrictEqual(server.address().port, 0);\n+      strictEqual(listeningFn.mock.callCount(), 1);\n+      server.close();\n+      resolve();\n+    });\n+    await promise;\n+  },\n+};\n+\n+export const testInvalidPorts = {\n+  async test() {\n+    const server = http.createServer();\n+    for (const value of [NaN, Infinity]) {",
        "comment_created_at": "2025-07-28T15:29:06+00:00",
        "comment_author": "jasnell",
        "comment_body": "How about -1, -Infinity, 1.1 (non-integer values), 9999999 (out of range values)",
        "pr_file_module": null
      }
    ]
  }
]