[
  {
    "discussion_id": "2125784415",
    "pr_number": 4238,
    "pr_file": "src/rust/container/lib.rs",
    "created_at": "2025-06-04T06:46:27+00:00",
    "commented_code": "+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::exec::CreateExecOptions;\n+use bollard::exec::StartExecOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Connection error: {0}\")]\n+    ConnectionError(String),\n+    #[error(\"Container error: {0}\")]\n+    DestroyError(String),\n+    #[error(\"Container error: {0}\")]\n+    ExecError(String),\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        pub async fn start(\n+            container_name: &str,\n+            entrypoint: Vec<&str>,\n+            env: Vec<&str>,\n+        ) -> Result<String>;\n+        pub async fn destroy(container_name: &str) -> Result<()>;\n+        pub async fn signal(container_name: &str, signal: &str) -> Result<()>;\n+    }\n+}\n+\n+// TODO:\n+// [ ] - kj::Promise<void> status(StatusContext context) override;\n+// [x] - kj::Promise<void> start(StartContext context) override;\n+// [ ] - kj::Promise<void> monitor(MonitorContext context) override;\n+// [x] - kj::Promise<void> destroy(DestroyContext context) override;\n+// [x] - kj::Promise<void> signal(SignalContext context) override;\n+// [ ] - kj::Promise<void> getTcpPort(GetTcpPortContext context) override;\n+// [ ] - kj::Promise<void> listenTcp(ListenTcpContext context) override;\n+\n+pub fn connect() -> Result<Docker, ContainerError> {\n+    let addr = \"/var/run/docker.sock\";\n+    let socket = Docker::connect_with_unix(addr, 30, API_DEFAULT_VERSION)\n+        .map_err(|e| ContainerError::ConnectionError(e.to_string()))?;\n+    Ok(socket)\n+}\n+\n+pub async fn start(\n+    container_name: &str,\n+    entrypoint: Vec<&str>,\n+    env: Vec<&str>,\n+) -> Result<String, ContainerError> {\n+    // TODO(soon): Persist connection.\n+    let socket = connect()?;",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2125784415",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2125784415",
        "commented_code": "@@ -0,0 +1,88 @@\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::exec::CreateExecOptions;\n+use bollard::exec::StartExecOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Connection error: {0}\")]\n+    ConnectionError(String),\n+    #[error(\"Container error: {0}\")]\n+    DestroyError(String),\n+    #[error(\"Container error: {0}\")]\n+    ExecError(String),\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        pub async fn start(\n+            container_name: &str,\n+            entrypoint: Vec<&str>,\n+            env: Vec<&str>,\n+        ) -> Result<String>;\n+        pub async fn destroy(container_name: &str) -> Result<()>;\n+        pub async fn signal(container_name: &str, signal: &str) -> Result<()>;\n+    }\n+}\n+\n+// TODO:\n+// [ ] - kj::Promise<void> status(StatusContext context) override;\n+// [x] - kj::Promise<void> start(StartContext context) override;\n+// [ ] - kj::Promise<void> monitor(MonitorContext context) override;\n+// [x] - kj::Promise<void> destroy(DestroyContext context) override;\n+// [x] - kj::Promise<void> signal(SignalContext context) override;\n+// [ ] - kj::Promise<void> getTcpPort(GetTcpPortContext context) override;\n+// [ ] - kj::Promise<void> listenTcp(ListenTcpContext context) override;\n+\n+pub fn connect() -> Result<Docker, ContainerError> {\n+    let addr = \"/var/run/docker.sock\";\n+    let socket = Docker::connect_with_unix(addr, 30, API_DEFAULT_VERSION)\n+        .map_err(|e| ContainerError::ConnectionError(e.to_string()))?;\n+    Ok(socket)\n+}\n+\n+pub async fn start(\n+    container_name: &str,\n+    entrypoint: Vec<&str>,\n+    env: Vec<&str>,\n+) -> Result<String, ContainerError> {\n+    // TODO(soon): Persist connection.\n+    let socket = connect()?;",
        "comment_created_at": "2025-06-04T06:46:27+00:00",
        "comment_author": "vicb",
        "comment_body": "It looks like the lib provides a higher level API [start_container](https://docs.rs/bollard/latest/bollard/struct.Docker.html#method.start_container) ([examples](https://docs.rs/bollard/latest/bollard/#examples))\r\n\r\nCould it be used instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2126568013",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2125784415",
        "commented_code": "@@ -0,0 +1,88 @@\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::exec::CreateExecOptions;\n+use bollard::exec::StartExecOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Connection error: {0}\")]\n+    ConnectionError(String),\n+    #[error(\"Container error: {0}\")]\n+    DestroyError(String),\n+    #[error(\"Container error: {0}\")]\n+    ExecError(String),\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        pub async fn start(\n+            container_name: &str,\n+            entrypoint: Vec<&str>,\n+            env: Vec<&str>,\n+        ) -> Result<String>;\n+        pub async fn destroy(container_name: &str) -> Result<()>;\n+        pub async fn signal(container_name: &str, signal: &str) -> Result<()>;\n+    }\n+}\n+\n+// TODO:\n+// [ ] - kj::Promise<void> status(StatusContext context) override;\n+// [x] - kj::Promise<void> start(StartContext context) override;\n+// [ ] - kj::Promise<void> monitor(MonitorContext context) override;\n+// [x] - kj::Promise<void> destroy(DestroyContext context) override;\n+// [x] - kj::Promise<void> signal(SignalContext context) override;\n+// [ ] - kj::Promise<void> getTcpPort(GetTcpPortContext context) override;\n+// [ ] - kj::Promise<void> listenTcp(ListenTcpContext context) override;\n+\n+pub fn connect() -> Result<Docker, ContainerError> {\n+    let addr = \"/var/run/docker.sock\";\n+    let socket = Docker::connect_with_unix(addr, 30, API_DEFAULT_VERSION)\n+        .map_err(|e| ContainerError::ConnectionError(e.to_string()))?;\n+    Ok(socket)\n+}\n+\n+pub async fn start(\n+    container_name: &str,\n+    entrypoint: Vec<&str>,\n+    env: Vec<&str>,\n+) -> Result<String, ContainerError> {\n+    // TODO(soon): Persist connection.\n+    let socket = connect()?;",
        "comment_created_at": "2025-06-04T13:12:30+00:00",
        "comment_author": "anonrig",
        "comment_body": "I looked at it once again, and start_exec() isn't the correct command.\r\n\r\nStart container requires building an image. How are we going to build an image? cc @mikenomitch ",
        "pr_file_module": null
      },
      {
        "comment_id": "2129059619",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2125784415",
        "commented_code": "@@ -0,0 +1,88 @@\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::exec::CreateExecOptions;\n+use bollard::exec::StartExecOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Connection error: {0}\")]\n+    ConnectionError(String),\n+    #[error(\"Container error: {0}\")]\n+    DestroyError(String),\n+    #[error(\"Container error: {0}\")]\n+    ExecError(String),\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        pub async fn start(\n+            container_name: &str,\n+            entrypoint: Vec<&str>,\n+            env: Vec<&str>,\n+        ) -> Result<String>;\n+        pub async fn destroy(container_name: &str) -> Result<()>;\n+        pub async fn signal(container_name: &str, signal: &str) -> Result<()>;\n+    }\n+}\n+\n+// TODO:\n+// [ ] - kj::Promise<void> status(StatusContext context) override;\n+// [x] - kj::Promise<void> start(StartContext context) override;\n+// [ ] - kj::Promise<void> monitor(MonitorContext context) override;\n+// [x] - kj::Promise<void> destroy(DestroyContext context) override;\n+// [x] - kj::Promise<void> signal(SignalContext context) override;\n+// [ ] - kj::Promise<void> getTcpPort(GetTcpPortContext context) override;\n+// [ ] - kj::Promise<void> listenTcp(ListenTcpContext context) override;\n+\n+pub fn connect() -> Result<Docker, ContainerError> {\n+    let addr = \"/var/run/docker.sock\";\n+    let socket = Docker::connect_with_unix(addr, 30, API_DEFAULT_VERSION)\n+        .map_err(|e| ContainerError::ConnectionError(e.to_string()))?;\n+    Ok(socket)\n+}\n+\n+pub async fn start(\n+    container_name: &str,\n+    entrypoint: Vec<&str>,\n+    env: Vec<&str>,\n+) -> Result<String, ContainerError> {\n+    // TODO(soon): Persist connection.\n+    let socket = connect()?;",
        "comment_created_at": "2025-06-05T14:55:36+00:00",
        "comment_author": "emily-shen",
        "comment_body": "just checking we're all on the same page so i can miniflare set up properly:\r\n\r\nso miniflare will build the image and pass workerd the image tag.\r\n\r\nthen you use that with create_container and start_container\r\nhttps://docs.rs/bollard/latest/bollard/struct.Docker.html#method.create_container\r\nhttps://docs.rs/bollard/latest/bollard/struct.Docker.html#method.start_container\r\n\r\nlooking at those docs, it looks like the options will be generated as sometiing like `bollard::models::ContainerCreateBody` etc. from the openapi spec here:\r\nhttps://docs.docker.com/reference/api/engine/version/v1.49/#tag/Container/operation/ContainerCreate etc.\r\nso even if its not actually using http the functions here will have the same options I guess? so you can set entrypoint, env vars and port mapping with that.\r\n\r\nthe container name can be anything, but i guess for readability purposes, can it be whatever gets passed into `DO. idFromString()` or something that makes sense to the end user? \r\n\r\nis that what you were thinking of? thanks for all the work btw \ud83e\udde1 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2129855427",
    "pr_number": 4238,
    "pr_file": "src/rust/container/lib.rs",
    "created_at": "2025-06-05T18:53:58+00:00",
    "commented_code": "+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(\n+        &mut self,\n+        _: container::DestroyParams,\n+        _: container::DestroyResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let options = StopContainerOptionsBuilder::default().signal(\"SIGINT\");\n+            docker\n+                .stop_container(&container_name, Some(options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+\n+            let remove_options = RemoveContainerOptionsBuilder::default().force(true);\n+            docker\n+                .remove_container(&container_name, Some(remove_options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+            Ok(())\n+        })\n+    }\n+\n+    fn signal(\n+        &mut self,\n+        params: container::SignalParams,\n+        _: container::SignalResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let signal =\n+                signo_as_string(params.get()?.get_signo()).unwrap_or_else(|| \"SIGINT\".to_owned());\n+\n+            let options = KillContainerOptionsBuilder::default().signal(&signal);\n+            docker\n+                .kill_container(&container_name, Some(options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+            Ok(())\n+        })\n+    }\n+\n+    /// Starts a container.\n+    /// This method doesn't handle enableInternet attribute since\n+    /// it doesn't make sense for the local usage, and will be hard to\n+    /// manage while still having port mapping to the host.\n+    fn start(\n+        &mut self,\n+        raw_params: container::StartParams,\n+        _: container::StartResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let params = raw_params.get()?;\n+            let entrypoint = params\n+                .get_entrypoint()?\n+                .iter()\n+                .map(|s| s.unwrap().to_string().unwrap())\n+                .collect::<Vec<String>>();\n+            let env = params\n+                .get_environment_variables()?\n+                .iter()\n+                .map(|s| s.unwrap().to_string().unwrap())\n+                .collect::<Vec<String>>();\n+\n+            let config = ContainerCreateBody {\n+                image: Some(container_name.clone()),\n+                cmd: Some(entrypoint),\n+                env: Some(env),\n+                ..Default::default()\n+            };\n+\n+            let options = CreateContainerOptionsBuilder::default()\n+                .name(&container_name)\n+                .build();\n+\n+            docker\n+                .create_container(Some(options), config)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            docker\n+                .start_container(&container_name, None::<StartContainerOptions>)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            Ok(())\n+        })\n+    }\n+\n+    fn status(\n+        &mut self,\n+        _: container::StatusParams,\n+        mut results: container::StatusResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let inspect = docker\n+                .inspect_container(&container_name, None::<InspectContainerOptions>)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            let mut builder = results.get();\n+            if let Some(state) = inspect.state {\n+                builder.set_running(state.running.unwrap_or(false));\n+            }\n+            Ok(())\n+        })\n+    }\n+\n+    fn monitor(\n+        &mut self,\n+        _: container::MonitorParams,\n+        _: container::MonitorResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let options = WaitContainerOptionsBuilder::default()\n+                .condition(\"not-running\")\n+                .build();\n+\n+            let mut stream = docker.wait_container(&container_name, Some(options));\n+\n+            if let Some(wait_result) = stream.next().await {\n+                let status_code = wait_result\n+                    .map_err(ContainerError::SocketError)?\n+                    .status_code;\n+                if status_code == 0 {\n+                    return Ok(());\n+                }\n+\n+                return Err(capnp::Error::failed(format!(\n+                    \"Container exited with unexpected exit code: {status_code}\"\n+                )));\n+            }\n+\n+            // Stream ended without result - should not happen\n+            Err(capnp::Error::failed(\n+                \"Monitoring stream ended unexpectedly\".to_owned(),\n+            ))\n+        })\n+    }\n+\n+    /// This method is intentionally not implemented right now.\n+    fn listen_tcp(\n+        &mut self,\n+        _params: container::ListenTcpParams,\n+        _results: container::ListenTcpResults,\n+    ) -> Promise<(), capnp::Error> {\n+        Promise::from_future(async move {\n+            Err(capnp::Error::unimplemented(\n+                \"listen_tcp is not implemented\".to_owned(),\n+            ))\n+        })\n+    }\n+\n+    /// TODO(soon): Implement this.\n+    fn get_tcp_port(\n+        &mut self,\n+        _params: container::GetTcpPortParams,\n+        _results: container::GetTcpPortResults,\n+    ) -> Promise<(), capnp::Error> {\n+        Promise::from_future(async move {",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2129855427",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129855427",
        "commented_code": "@@ -0,0 +1,347 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(\n+        &mut self,\n+        _: container::DestroyParams,\n+        _: container::DestroyResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let options = StopContainerOptionsBuilder::default().signal(\"SIGINT\");\n+            docker\n+                .stop_container(&container_name, Some(options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+\n+            let remove_options = RemoveContainerOptionsBuilder::default().force(true);\n+            docker\n+                .remove_container(&container_name, Some(remove_options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+            Ok(())\n+        })\n+    }\n+\n+    fn signal(\n+        &mut self,\n+        params: container::SignalParams,\n+        _: container::SignalResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let signal =\n+                signo_as_string(params.get()?.get_signo()).unwrap_or_else(|| \"SIGINT\".to_owned());\n+\n+            let options = KillContainerOptionsBuilder::default().signal(&signal);\n+            docker\n+                .kill_container(&container_name, Some(options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+            Ok(())\n+        })\n+    }\n+\n+    /// Starts a container.\n+    /// This method doesn't handle enableInternet attribute since\n+    /// it doesn't make sense for the local usage, and will be hard to\n+    /// manage while still having port mapping to the host.\n+    fn start(\n+        &mut self,\n+        raw_params: container::StartParams,\n+        _: container::StartResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let params = raw_params.get()?;\n+            let entrypoint = params\n+                .get_entrypoint()?\n+                .iter()\n+                .map(|s| s.unwrap().to_string().unwrap())\n+                .collect::<Vec<String>>();\n+            let env = params\n+                .get_environment_variables()?\n+                .iter()\n+                .map(|s| s.unwrap().to_string().unwrap())\n+                .collect::<Vec<String>>();\n+\n+            let config = ContainerCreateBody {\n+                image: Some(container_name.clone()),\n+                cmd: Some(entrypoint),\n+                env: Some(env),\n+                ..Default::default()\n+            };\n+\n+            let options = CreateContainerOptionsBuilder::default()\n+                .name(&container_name)\n+                .build();\n+\n+            docker\n+                .create_container(Some(options), config)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            docker\n+                .start_container(&container_name, None::<StartContainerOptions>)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            Ok(())\n+        })\n+    }\n+\n+    fn status(\n+        &mut self,\n+        _: container::StatusParams,\n+        mut results: container::StatusResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let inspect = docker\n+                .inspect_container(&container_name, None::<InspectContainerOptions>)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            let mut builder = results.get();\n+            if let Some(state) = inspect.state {\n+                builder.set_running(state.running.unwrap_or(false));\n+            }\n+            Ok(())\n+        })\n+    }\n+\n+    fn monitor(\n+        &mut self,\n+        _: container::MonitorParams,\n+        _: container::MonitorResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let options = WaitContainerOptionsBuilder::default()\n+                .condition(\"not-running\")\n+                .build();\n+\n+            let mut stream = docker.wait_container(&container_name, Some(options));\n+\n+            if let Some(wait_result) = stream.next().await {\n+                let status_code = wait_result\n+                    .map_err(ContainerError::SocketError)?\n+                    .status_code;\n+                if status_code == 0 {\n+                    return Ok(());\n+                }\n+\n+                return Err(capnp::Error::failed(format!(\n+                    \"Container exited with unexpected exit code: {status_code}\"\n+                )));\n+            }\n+\n+            // Stream ended without result - should not happen\n+            Err(capnp::Error::failed(\n+                \"Monitoring stream ended unexpectedly\".to_owned(),\n+            ))\n+        })\n+    }\n+\n+    /// This method is intentionally not implemented right now.\n+    fn listen_tcp(\n+        &mut self,\n+        _params: container::ListenTcpParams,\n+        _results: container::ListenTcpResults,\n+    ) -> Promise<(), capnp::Error> {\n+        Promise::from_future(async move {\n+            Err(capnp::Error::unimplemented(\n+                \"listen_tcp is not implemented\".to_owned(),\n+            ))\n+        })\n+    }\n+\n+    /// TODO(soon): Implement this.\n+    fn get_tcp_port(\n+        &mut self,\n+        _params: container::GetTcpPortParams,\n+        _results: container::GetTcpPortResults,\n+    ) -> Promise<(), capnp::Error> {\n+        Promise::from_future(async move {",
        "comment_created_at": "2025-06-05T18:53:58+00:00",
        "comment_author": "danlapid",
        "comment_body": "You need to implement a `rpc::Container::Port::Server` and return an object of that kind.\r\nThat object implements `connect` which pumps bytes back and forth between the container tcp port and the incoming bytestream.",
        "pr_file_module": null
      },
      {
        "comment_id": "2129863648",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/rust/container/lib.rs",
        "discussion_id": "2129855427",
        "commented_code": "@@ -0,0 +1,347 @@\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n+use bollard::API_DEFAULT_VERSION;\n+use bollard::Docker;\n+use bollard::models::ContainerCreateBody;\n+use bollard::query_parameters::CreateContainerOptionsBuilder;\n+use bollard::query_parameters::InspectContainerOptions;\n+use bollard::query_parameters::KillContainerOptionsBuilder;\n+use bollard::query_parameters::RemoveContainerOptionsBuilder;\n+use bollard::query_parameters::StartContainerOptions;\n+use bollard::query_parameters::StopContainerOptionsBuilder;\n+use bollard::query_parameters::WaitContainerOptionsBuilder;\n+use capnp::capability::Promise;\n+use capnp::message::ReaderOptions;\n+use capnp_rpc::rpc_twoparty_capnp;\n+use container_capnp::container;\n+use futures::StreamExt;\n+use thiserror::Error;\n+\n+pub mod io;\n+use io::MpscReader;\n+use io::MpscWriter;\n+use io::signo_as_string;\n+\n+#[derive(Debug, Error)]\n+pub enum ContainerError {\n+    #[error(\"Socket error: {0}\")]\n+    SocketError(#[from] bollard::errors::Error),\n+    #[error(\"RPC error: {0}\")]\n+    RpcError(#[from] capnp::Error),\n+    #[error(\"Unimplemented: {0}\")]\n+    Unimplemented(String),\n+}\n+\n+impl From<ContainerError> for capnp::Error {\n+    fn from(value: ContainerError) -> Self {\n+        match value {\n+            ContainerError::SocketError(err) => Self::failed(err.to_string()),\n+            ContainerError::RpcError(err) => err,\n+            ContainerError::Unimplemented(msg) => Self::unimplemented(msg),\n+        }\n+    }\n+}\n+\n+pub struct ContainerService {\n+    r#impl: Arc<Impl>,\n+}\n+\n+#[cxx::bridge(namespace = \"workerd::rust::container\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type ContainerService;\n+        fn new_service(\n+            address: &str,\n+            container_name: &str,\n+            messages_callback: Pin<&'static mut MessageCallback>,\n+        ) -> Result<Box<ContainerService>>;\n+        fn write_data(self: &mut ContainerService, data: &[u8]) -> bool;\n+        fn shutdown_write(self: &mut ContainerService);\n+        fn is_write_disconnected(self: &ContainerService) -> bool;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"workerd/rust/container/bridge.h\");\n+        type MessageCallback;\n+        #[cxx_name = \"operatorCall\"]\n+        fn call(self: Pin<&mut MessageCallback>, message: &[u8]);\n+    }\n+}\n+\n+unsafe impl Send for ffi::MessageCallback {}\n+\n+/// Creates a new container service.\n+///\n+/// # Errors\n+///\n+/// Returns an error if the Docker connection fails or if the service cannot be initialized.\n+pub fn new_service(\n+    address: &str,\n+    container_name: &str,\n+    messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+) -> Result<Box<ContainerService>, ContainerError> {\n+    let r#impl = Arc::new(Impl::new(address, container_name, messages_callback)?);\n+    let service = Box::new(ContainerService { r#impl });\n+    Ok(service)\n+}\n+\n+impl ContainerService {\n+    pub fn write_data(&mut self, data: &[u8]) -> bool {\n+        if self\n+            .r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+        {\n+            return false;\n+        }\n+        self.r#impl.sender.try_send(data.to_vec()).is_ok()\n+    }\n+\n+    pub fn shutdown_write(&mut self) {\n+        self.r#impl\n+            .write_shutdown\n+            .store(true, std::sync::atomic::Ordering::Relaxed);\n+    }\n+\n+    #[must_use]\n+    pub fn is_write_disconnected(&self) -> bool {\n+        self.r#impl\n+            .write_shutdown\n+            .load(std::sync::atomic::Ordering::Relaxed)\n+    }\n+}\n+\n+struct Impl {\n+    sender: mpsc::SyncSender<Vec<u8>>,\n+    write_shutdown: std::sync::atomic::AtomicBool,\n+}\n+\n+impl Impl {\n+    pub fn new(\n+        address: &str,\n+        container_name: &str,\n+        mut messages_callback: Pin<&'static mut ffi::MessageCallback>,\n+    ) -> Result<Self, ContainerError> {\n+        let (input_sender, input_receiver) = mpsc::sync_channel(1000);\n+        let (output_sender, output_receiver) = mpsc::sync_channel::<Vec<u8>>(1000);\n+\n+        let server = Server::connect(address, container_name)?;\n+\n+        cxx_integration::tokio::spawn(async move {\n+            #[allow(clippy::let_underscore_future)]\n+            let _ = tokio::task::LocalSet::new().run_until(async move {\n+                let client: container::Client = capnp_rpc::new_client(server);\n+                let network = capnp_rpc::twoparty::VatNetwork::new(\n+                    MpscReader::new(input_receiver),\n+                    MpscWriter::new(output_sender),\n+                    rpc_twoparty_capnp::Side::Server,\n+                    ReaderOptions::default(),\n+                );\n+                let rpc_system = capnp_rpc::RpcSystem::new(Box::new(network), Some(client.client));\n+\n+                tokio::task::spawn_local(rpc_system);\n+            });\n+\n+            while let Ok(message) = output_receiver.recv() {\n+                messages_callback.as_mut().call(&message);\n+            }\n+        });\n+\n+        Ok(Impl {\n+            sender: input_sender,\n+            write_shutdown: std::sync::atomic::AtomicBool::new(false),\n+        })\n+    }\n+}\n+\n+struct Server {\n+    docker: Arc<Docker>,\n+    container_name: String,\n+}\n+\n+impl Server {\n+    fn connect(address: &str, container_name: &str) -> Result<Self, ContainerError> {\n+        let docker = Docker::connect_with_socket(address, 120, API_DEFAULT_VERSION)?;\n+        Ok(Server {\n+            docker: docker.into(),\n+            container_name: container_name.to_owned(),\n+        })\n+    }\n+}\n+\n+impl container::Server for Server {\n+    fn destroy(\n+        &mut self,\n+        _: container::DestroyParams,\n+        _: container::DestroyResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let options = StopContainerOptionsBuilder::default().signal(\"SIGINT\");\n+            docker\n+                .stop_container(&container_name, Some(options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+\n+            let remove_options = RemoveContainerOptionsBuilder::default().force(true);\n+            docker\n+                .remove_container(&container_name, Some(remove_options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+            Ok(())\n+        })\n+    }\n+\n+    fn signal(\n+        &mut self,\n+        params: container::SignalParams,\n+        _: container::SignalResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let signal =\n+                signo_as_string(params.get()?.get_signo()).unwrap_or_else(|| \"SIGINT\".to_owned());\n+\n+            let options = KillContainerOptionsBuilder::default().signal(&signal);\n+            docker\n+                .kill_container(&container_name, Some(options.build()))\n+                .await\n+                .map_err(ContainerError::SocketError)?;\n+            Ok(())\n+        })\n+    }\n+\n+    /// Starts a container.\n+    /// This method doesn't handle enableInternet attribute since\n+    /// it doesn't make sense for the local usage, and will be hard to\n+    /// manage while still having port mapping to the host.\n+    fn start(\n+        &mut self,\n+        raw_params: container::StartParams,\n+        _: container::StartResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let params = raw_params.get()?;\n+            let entrypoint = params\n+                .get_entrypoint()?\n+                .iter()\n+                .map(|s| s.unwrap().to_string().unwrap())\n+                .collect::<Vec<String>>();\n+            let env = params\n+                .get_environment_variables()?\n+                .iter()\n+                .map(|s| s.unwrap().to_string().unwrap())\n+                .collect::<Vec<String>>();\n+\n+            let config = ContainerCreateBody {\n+                image: Some(container_name.clone()),\n+                cmd: Some(entrypoint),\n+                env: Some(env),\n+                ..Default::default()\n+            };\n+\n+            let options = CreateContainerOptionsBuilder::default()\n+                .name(&container_name)\n+                .build();\n+\n+            docker\n+                .create_container(Some(options), config)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            docker\n+                .start_container(&container_name, None::<StartContainerOptions>)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            Ok(())\n+        })\n+    }\n+\n+    fn status(\n+        &mut self,\n+        _: container::StatusParams,\n+        mut results: container::StatusResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let inspect = docker\n+                .inspect_container(&container_name, None::<InspectContainerOptions>)\n+                .await\n+                .map_err(|e| capnp::Error::failed(e.to_string()))?;\n+\n+            let mut builder = results.get();\n+            if let Some(state) = inspect.state {\n+                builder.set_running(state.running.unwrap_or(false));\n+            }\n+            Ok(())\n+        })\n+    }\n+\n+    fn monitor(\n+        &mut self,\n+        _: container::MonitorParams,\n+        _: container::MonitorResults,\n+    ) -> Promise<(), capnp::Error> {\n+        let container_name = self.container_name.clone();\n+        let docker = self.docker.clone();\n+        Promise::from_future(async move {\n+            let options = WaitContainerOptionsBuilder::default()\n+                .condition(\"not-running\")\n+                .build();\n+\n+            let mut stream = docker.wait_container(&container_name, Some(options));\n+\n+            if let Some(wait_result) = stream.next().await {\n+                let status_code = wait_result\n+                    .map_err(ContainerError::SocketError)?\n+                    .status_code;\n+                if status_code == 0 {\n+                    return Ok(());\n+                }\n+\n+                return Err(capnp::Error::failed(format!(\n+                    \"Container exited with unexpected exit code: {status_code}\"\n+                )));\n+            }\n+\n+            // Stream ended without result - should not happen\n+            Err(capnp::Error::failed(\n+                \"Monitoring stream ended unexpectedly\".to_owned(),\n+            ))\n+        })\n+    }\n+\n+    /// This method is intentionally not implemented right now.\n+    fn listen_tcp(\n+        &mut self,\n+        _params: container::ListenTcpParams,\n+        _results: container::ListenTcpResults,\n+    ) -> Promise<(), capnp::Error> {\n+        Promise::from_future(async move {\n+            Err(capnp::Error::unimplemented(\n+                \"listen_tcp is not implemented\".to_owned(),\n+            ))\n+        })\n+    }\n+\n+    /// TODO(soon): Implement this.\n+    fn get_tcp_port(\n+        &mut self,\n+        _params: container::GetTcpPortParams,\n+        _results: container::GetTcpPortResults,\n+    ) -> Promise<(), capnp::Error> {\n+        Promise::from_future(async move {",
        "comment_created_at": "2025-06-05T18:55:43+00:00",
        "comment_author": "danlapid",
        "comment_body": "See example in fake-container-service.c++ internally.",
        "pr_file_module": null
      }
    ]
  }
]