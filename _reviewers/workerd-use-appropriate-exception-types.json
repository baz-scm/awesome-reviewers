[
  {
    "discussion_id": "2226136197",
    "pr_number": 4005,
    "pr_file": "src/workerd/api/sockets.c++",
    "created_at": "2025-07-23T16:42:37+00:00",
    "commented_code": "jsg::Lock& js, AnySocketAddress address, jsg::Optional<SocketOptions> options) {\n   return connectImpl(js, kj::none, kj::mv(address), kj::mv(options));\n }\n+\n+kj::Own<kj::AsyncIoStream> Socket::takeConnectionStream(jsg::Lock& js) {\n+  writable->detach(js);\n+  readable->detach(js);\n+  // We should set this before closedResolver.resolve() in order to give the user\n+  // the option to check if the closed promise is resolved due to upgrade or not.\n+  upgraded = true;\n+  closedResolver.resolve(js);\n+  return connectionStream->addWrappedRef();\n+}\n+\n+// Definition of the StreamWorkerInterface class\n+class StreamWorkerInterface final: public WorkerInterface {\n+ public:\n+  StreamWorkerInterface(kj::Own<kj::AsyncIoStream> stream, const kj::HttpHeaderTable& headerTable)\n+      : stream(kj::mv(stream)),\n+        headerTable(headerTable) {}\n+\n+  kj::Promise<void> request(kj::HttpMethod method,\n+      kj::StringPtr url,\n+      const kj::HttpHeaders& headers,\n+      kj::AsyncInputStream& requestBody,\n+      kj::HttpService::Response& response) override {\n+    // Parse the URL to extract the path\n+    auto parsedUrl = KJ_REQUIRE_NONNULL(\n+        kj::Url::tryParse(url, kj::Url::Context::HTTP_PROXY_REQUEST), \"invalid url\", url);\n+\n+    // We need to convert the URL from proxy format (full URL in request line) to host format\n+    // (path in request line, hostname in Host header).\n+    auto newHeaders = headers.cloneShallow();\n+    newHeaders.set(kj::HttpHeaderId::HOST, parsedUrl.host);\n+    auto noHostUrl = parsedUrl.toString(kj::Url::Context::HTTP_REQUEST);\n+    // Create a new HTTP client using our stream\n+    auto httpClient = kj::newHttpClient(headerTable, *stream);\n+\n+    // Create a new HTTP service from the client\n+    auto service = kj::newHttpService(*httpClient);\n+\n+    // Forward the request to the service\n+    return service->request(method, noHostUrl, newHeaders, requestBody, response)\n+        .attach(kj::mv(service), kj::mv(httpClient));\n+  }\n+\n+  kj::Promise<void> connect(kj::StringPtr host,\n+      const kj::HttpHeaders& headers,\n+      kj::AsyncIoStream& connection,\n+      ConnectResponse& response,\n+      kj::HttpConnectSettings settings) override {\n+    KJ_UNIMPLEMENTED(\"connect() not supported on StreamWorkerInterface\");",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2226136197",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4005,
        "pr_file": "src/workerd/api/sockets.c++",
        "discussion_id": "2226136197",
        "commented_code": "@@ -511,4 +512,106 @@ jsg::Ref<Socket> SocketsModule::connect(\n     jsg::Lock& js, AnySocketAddress address, jsg::Optional<SocketOptions> options) {\n   return connectImpl(js, kj::none, kj::mv(address), kj::mv(options));\n }\n+\n+kj::Own<kj::AsyncIoStream> Socket::takeConnectionStream(jsg::Lock& js) {\n+  writable->detach(js);\n+  readable->detach(js);\n+  // We should set this before closedResolver.resolve() in order to give the user\n+  // the option to check if the closed promise is resolved due to upgrade or not.\n+  upgraded = true;\n+  closedResolver.resolve(js);\n+  return connectionStream->addWrappedRef();\n+}\n+\n+// Definition of the StreamWorkerInterface class\n+class StreamWorkerInterface final: public WorkerInterface {\n+ public:\n+  StreamWorkerInterface(kj::Own<kj::AsyncIoStream> stream, const kj::HttpHeaderTable& headerTable)\n+      : stream(kj::mv(stream)),\n+        headerTable(headerTable) {}\n+\n+  kj::Promise<void> request(kj::HttpMethod method,\n+      kj::StringPtr url,\n+      const kj::HttpHeaders& headers,\n+      kj::AsyncInputStream& requestBody,\n+      kj::HttpService::Response& response) override {\n+    // Parse the URL to extract the path\n+    auto parsedUrl = KJ_REQUIRE_NONNULL(\n+        kj::Url::tryParse(url, kj::Url::Context::HTTP_PROXY_REQUEST), \"invalid url\", url);\n+\n+    // We need to convert the URL from proxy format (full URL in request line) to host format\n+    // (path in request line, hostname in Host header).\n+    auto newHeaders = headers.cloneShallow();\n+    newHeaders.set(kj::HttpHeaderId::HOST, parsedUrl.host);\n+    auto noHostUrl = parsedUrl.toString(kj::Url::Context::HTTP_REQUEST);\n+    // Create a new HTTP client using our stream\n+    auto httpClient = kj::newHttpClient(headerTable, *stream);\n+\n+    // Create a new HTTP service from the client\n+    auto service = kj::newHttpService(*httpClient);\n+\n+    // Forward the request to the service\n+    return service->request(method, noHostUrl, newHeaders, requestBody, response)\n+        .attach(kj::mv(service), kj::mv(httpClient));\n+  }\n+\n+  kj::Promise<void> connect(kj::StringPtr host,\n+      const kj::HttpHeaders& headers,\n+      kj::AsyncIoStream& connection,\n+      ConnectResponse& response,\n+      kj::HttpConnectSettings settings) override {\n+    KJ_UNIMPLEMENTED(\"connect() not supported on StreamWorkerInterface\");",
        "comment_created_at": "2025-07-23T16:42:37+00:00",
        "comment_author": "kentonv",
        "comment_body": "This is actually reachable if someone tries to call `connect()` on the resulting fetcher, so this should probably be a JSG_FAIL_REQUIRE with a friendly error message, rather than a Sentry error as it is now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254597239",
    "pr_number": 4684,
    "pr_file": "src/workerd/api/worker-rpc.c++",
    "created_at": "2025-08-05T14:50:33+00:00",
    "commented_code": "IoContext::current().addWaitUntil(kj::mv(promise));\n }\n \n+// Static member definitions for RPC class registry\n+kj::Vector<kj::String> EntrypointsModule::registeredRpcClasses;\n+std::mutex EntrypointsModule::registryMutex;\n+\n+void EntrypointsModule::registerRpcTargetClass(jsg::Lock& js, jsg::JsValue constructor) {\n+  v8::Local<v8::Value> handle = constructor;\n+  if (!handle->IsFunction()) {\n+    JSG_FAIL_REQUIRE(TypeError, \"registerRpcTargetClass() requires a constructor function\");\n+  }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2254597239",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4684,
        "pr_file": "src/workerd/api/worker-rpc.c++",
        "discussion_id": "2254597239",
        "commented_code": "@@ -26,6 +28,58 @@ void EntrypointsModule::waitUntil(kj::Promise<void> promise) {\n   IoContext::current().addWaitUntil(kj::mv(promise));\n }\n \n+// Static member definitions for RPC class registry\n+kj::Vector<kj::String> EntrypointsModule::registeredRpcClasses;\n+std::mutex EntrypointsModule::registryMutex;\n+\n+void EntrypointsModule::registerRpcTargetClass(jsg::Lock& js, jsg::JsValue constructor) {\n+  v8::Local<v8::Value> handle = constructor;\n+  if (!handle->IsFunction()) {\n+    JSG_FAIL_REQUIRE(TypeError, \"registerRpcTargetClass() requires a constructor function\");\n+  }",
        "comment_created_at": "2025-08-05T14:50:33+00:00",
        "comment_author": "jasnell",
        "comment_body": "It's better to keep this as a `JsValue` and you can just do...\r\n\r\n```cpp\r\nJSG_REQUIRE(constructor.isFunction(), TypeError, \"...\");\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2246004131",
    "pr_number": 4650,
    "pr_file": "src/workerd/api/node/exceptions.c++",
    "created_at": "2025-07-31T17:37:58+00:00",
    "commented_code": "+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2246004131",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4650,
        "pr_file": "src/workerd/api/node/exceptions.c++",
        "discussion_id": "2246004131",
        "commented_code": "@@ -0,0 +1,107 @@\n+#include \"exceptions.h\"\n+\n+namespace workerd::api::node {\n+\n+namespace {\n+jsg::JsObject createJsError(jsg::Lock& js, JsErrorType type, kj::StringPtr message) {\n+  switch (type) {\n+    case JsErrorType::TypeError: {\n+      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n+    }\n+    case JsErrorType::RangeError: {\n+      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n+    }",
        "comment_created_at": "2025-07-31T17:37:58+00:00",
        "comment_author": "npaun",
        "comment_body": "```suggestion\n    case JsErrorType::TypeError: {\n      return KJ_ASSERT_NONNULL(js.typeError(message).tryCast<jsg::JsObject>());\n    }\n    case JsErrorType::RangeError: {\n      return KJ_ASSERT_NONNULL(js.rangeError(message).tryCast<jsg::JsObject>());\n    }\n```\n\nThere's been an accidental switcheroo here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2017399470",
    "pr_number": 3813,
    "pr_file": "src/workerd/api/messagechannel.c++",
    "created_at": "2025-03-27T18:20:51+00:00",
    "commented_code": "+#include \"messagechannel.h\"\n+\n+#include \"global-scope.h\"\n+#include \"worker-rpc.h\"\n+\n+#include <workerd/io/worker.h>\n+#include <workerd/jsg/ser.h>\n+\n+#include <capnp/message.h>\n+\n+namespace workerd::api {\n+jsg::Ref<MessagePort::MessageEvent> MessagePort::MessageEvent::New(jsg::Lock& js,\n+    jsg::JsRef<jsg::JsValue> data,\n+    kj::String lastEventId,\n+    jsg::Ref<MessagePort> source,\n+    kj::Array<jsg::Ref<MessagePort>> ports) {\n+  return jsg::alloc<MessagePort::MessageEvent>(\n+      kj::str(\"message\"), kj::mv(data), kj::mv(lastEventId), kj::mv(source), kj::mv(ports));\n+}\n+\n+jsg::Ref<MessagePort::MessageEvent> MessagePort::MessageEvent::NewError(jsg::Lock& js,\n+    jsg::JsRef<jsg::JsValue> data,\n+    kj::String lastEventId,\n+    jsg::Ref<MessagePort> source,\n+    kj::Array<jsg::Ref<MessagePort>> ports) {\n+  return jsg::alloc<MessagePort::MessageEvent>(\n+      kj::str(\"messageerror\"), kj::mv(data), kj::mv(lastEventId), kj::mv(source), kj::mv(ports));\n+}\n+\n+MessagePort::MessagePort(IoContext& ioContext): ioContext(ioContext), state(Pending()) {\n+  // We set a callback on the underlying EventTarget to be notified when\n+  // a listener for the message event is added or removed. When there\n+  // are no listeners, we move back to the Pending state, otherwise we\n+  // will switch to the Started state if necessary.\n+  setEventListenerCallback([&](jsg::Lock& js, kj::StringPtr name, size_t count) {\n+    if (name == \"message\"_kj) {\n+      KJ_SWITCH_ONEOF(state) {\n+        KJ_CASE_ONEOF(pending, Pending) {\n+          // If we are in the pending state, start the port if we have listeners.\n+          // This is technically not spec compliant, but it is what Node.js\n+          // supports. Specifically, adding a new message listener using the\n+          // addEventListener method is *technically* not supposed to start\n+          // the port but we're going to do what Node.js does.\n+          if (count > 0 || onmessageValue != kj::none) {\n+            start(js);\n+          }\n+        }\n+        KJ_CASE_ONEOF(started, Started) {\n+          // If we are in the started state, stop the port if there are no listeners.\n+          if (count == 0 && onmessageValue == kj::none) {\n+            state = Pending();\n+          }\n+        }\n+        KJ_CASE_ONEOF(_, Closed) {\n+          // Nothing to do. We're already closed so we don't care.\n+        }\n+      }\n+    }\n+  });\n+}\n+\n+// Deliver the message to the \"message\" or \"messageerror\" event on this port.\n+void MessagePort::deliver(\n+    jsg::Lock& js, kj::Own<rpc::JsValue::Reader> message, jsg::Ref<MessagePort> port) {\n+  auto event = js.tryCatch([&] {\n+    jsg::Deserializer deserializer(js, message->getV8Serialized());\n+    return MessageEvent::New(\n+        js, jsg::JsRef(js, deserializer.readValue(js)), kj::str(), port->addRef(), {});\n+  }, [&](jsg::Value exception) {\n+    return MessageEvent::NewError(\n+        js, jsg::JsRef(js, jsg::JsValue(exception.getHandle(js))), kj::str(), port->addRef(), {});\n+  });\n+\n+  // If any of the message/messageerror event handlers throw,\n+  // capture the error and pass it to reportError instead of\n+  // propagating up.\n+  js.tryCatch([&] { port->dispatchEventImpl(js, kj::mv(event)); }, [&](jsg::Value exception) {\n+    auto context = js.v8Context();\n+    auto& global =\n+        jsg::extractInternalPointer<ServiceWorkerGlobalScope, true>(context, context->Global());\n+    global.reportError(js, jsg::JsValue(exception.getHandle(js)));\n+  });\n+}\n+\n+// Deliver the message to all the jsrpc remotes we have\n+kj::Promise<void> MessagePort::sendToRpc(kj::Own<rpc::JsValue::Reader> message) {\n+  KJ_IF_SOME(outputLocks, ioContext.waitForOutputLocksIfNecessary()) {\n+    co_await outputLocks;\n+  }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (rpc::JsMessagePort::Client cap: rpcClients) {\n+    auto req = cap.callRequest();\n+    req.setData(*message);\n+    // TODO(message-port): Removing the port when dropped?\n+    promises.add(req.send().ignoreResult());\n+  }\n+  co_await kj::joinPromises(promises.releaseAsArray());\n+}\n+\n+// Deliver the message to this port, buffering if necessary if the port\n+// has not been started. Buffered messages will be delivered when the\n+// port is started later.\n+void MessagePort::deliverMessage(jsg::Lock& js, rpc::JsValue::Reader value) {\n+  KJ_SWITCH_ONEOF(state) {\n+    KJ_CASE_ONEOF(pending, Pending) {\n+      // We have not yet started the port so buffer to message.\n+      pending.add(capnp::clone(value));\n+    }\n+    KJ_CASE_ONEOF(started, Started) {\n+      ioContext.addTask(sendToRpc(capnp::clone(value)));\n+      deliver(js, capnp::clone(value), addRef());\n+    }\n+    KJ_CASE_ONEOF(_, Closed) {\n+      // Nothing to do in this case. Drop the message on the floor.\n+    }\n+  }\n+}\n+\n+// Binds two ports to each other such that messages posted to one\n+// are delivered on the other.\n+void MessagePort::entangle(MessagePort& port1, MessagePort& port2) {\n+  port1.other = port2.addRef();\n+  port2.other = port1.addRef();\n+}\n+\n+// Post a message to the entangled port.\n+void MessagePort::postMessage(jsg::Lock& js,\n+    jsg::Optional<jsg::JsRef<jsg::JsValue>> data,\n+    jsg::Optional<TransferListOrOptions> options) {\n+\n+  KJ_IF_SOME(opt, options) {\n+    // We don't currently support transfer lists, even for local\n+    // same-isolate delivery.\n+    // TODO(conform): Implement transfer later?\n+    KJ_SWITCH_ONEOF(opt) {\n+      KJ_CASE_ONEOF(list, TransferList) {\n+        JSG_REQUIRE(list.size() == 0, Error, \"Transfer list is not supported\");\n+      }\n+      KJ_CASE_ONEOF(opts, PostMessageOptions) {\n+        KJ_IF_SOME(list, opts.transfer) {\n+          JSG_REQUIRE(list.size() == 0, Error, \"Transfer list is not supported\");\n+        }\n+      }\n+    }\n+  }\n+\n+  KJ_IF_SOME(o, other) {\n+    // TODO(message-port): Set up the external handler to support more types.\n+    jsg::Serializer ser(js);\n+    KJ_IF_SOME(d, data) {\n+      ser.write(js, d.getHandle(js));\n+    }\n+    auto released = ser.release();\n+    JSG_REQUIRE(released.sharedArrayBuffers.size() == 0, Error, \"SharedArrayBuffer is unsupported\");\n+\n+    capnp::MallocMessageBuilder builder;\n+    rpc::JsValue::Builder val = builder.initRoot<rpc::JsValue>();\n+    val.setV8Serialized(kj::mv(released.data));\n+    o->deliverMessage(js, val.asReader());\n+  }\n+}\n+\n+// Should close this port, the entangle port, and any known rpc clients.\n+void MessagePort::close() {\n+  state = Closed{};\n+  rpcClients.clear();\n+  KJ_IF_SOME(o, other) {\n+    auto closing = kj::mv(o);\n+    other = kj::none;\n+    closing->close();\n+  }\n+}\n+\n+// Start delivering messages on this port. Any messages that are\n+// buffered will be drained immediately.\n+void MessagePort::start(jsg::Lock& js) {\n+  KJ_SWITCH_ONEOF(state) {\n+    KJ_CASE_ONEOF(pending, Pending) {\n+      auto list = kj::mv(pending);\n+      state = Started{};\n+      for (auto& item: list) {\n+        ioContext.addTask(sendToRpc(capnp::clone(*item)));\n+        // Local delivery\n+        deliver(js, kj::mv(item), addRef());\n+      }\n+    }\n+    KJ_CASE_ONEOF(_, Started) {\n+      // Nothing to do in this case. We are already started!\n+    }\n+    KJ_CASE_ONEOF(_, Closed) {\n+      // Nothing to do in this case. Can't start after closing.\n+    }\n+  }\n+}\n+\n+kj::Maybe<jsg::JsValue> MessagePort::getOnMessage(jsg::Lock& js) {\n+  return onmessageValue.map(\n+      [&](jsg::JsRef<jsg::JsValue>& ref) -> jsg::JsValue { return ref.getHandle(js); });\n+}\n+\n+void MessagePort::setOnMessage(jsg::Lock& js, jsg::JsValue value) {\n+  if (!value.isObject() && !value.isFunction()) {\n+    onmessageValue = kj::none;\n+    // If we have no handlers and no onmessage ...\n+    if (getHandlerCount(\"message\"_kj) == 0 && onmessageValue == kj::none) {\n+      // ...Put the port back into a pending state where messages\n+      // will be enqueued until another listener is attached.\n+      state = Pending();\n+    }\n+  } else {\n+    onmessageValue = jsg::JsRef<jsg::JsValue>(js, value);\n+    start(js);\n+  }\n+}\n+\n+namespace {\n+// The jsrpc handler that receives messages posted from the remote and\n+// delivers them to the local port.\n+class JsMessagePortImpl final: public rpc::JsMessagePort::Server {\n+ public:\n+  JsMessagePortImpl(IoContext& ctx, jsg::Ref<MessagePort> port)\n+      : port(kj::mv(port)),\n+        weakIoContext(ctx.getWeakRef()) {}\n+  ~JsMessagePortImpl() {\n+    port->close();\n+  }\n+\n+  kj::Promise<void> call(CallContext context) override {\n+    IoContext& ctx = JSG_REQUIRE_NONNULL(weakIoContext->tryGet(), Error,\n+        \"The destination object for this message port no longer exists.\");\n+\n+    KJ_IF_SOME(other, port->getOther()) {\n+      // We can only dispatch messages under the isolate lock, so acquire\n+      // that here then deliver...\n+      auto lock = co_await ctx.getWorker()->takeAsyncLockWithoutRequest(nullptr);\n+      ctx.getWorker()->runInLockScope(lock, [&](auto& lock) {\n+        JSG_WITHIN_CONTEXT_SCOPE(lock, lock.getContext(), [&](auto& js) {\n+          auto params = context.getParams();\n+          other.deliverMessage(js, params.getData());\n+        });\n+      });\n+    }\n+\n+    context.initResults();\n+  }\n+\n+ private:\n+  jsg::Ref<MessagePort> port;\n+  kj::Own<IoContext::WeakRef> weakIoContext;\n+};\n+}  // namespace\n+\n+void MessagePort::serialize(jsg::Lock& js, jsg::Serializer& serializer) {\n+  auto& handler = JSG_REQUIRE_NONNULL(serializer.getExternalHandler(), DOMDataCloneError,\n+      \"MessagePort can only be serialized for RPC.\");\n+  auto externalHandler = dynamic_cast<RpcSerializerExternalHander*>(&handler);\n+  JSG_REQUIRE(\n+      externalHandler != nullptr, DOMDataCloneError, \"MessagePort can only be serialized for RPC.\");\n+\n+  // Don't send a MessagePort that has been closed already.\n+  JSG_REQUIRE(!state.is<Closed>(), DOMDataCloneError, \"MessagePort is closed\");",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2017399470",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 3813,
        "pr_file": "src/workerd/api/messagechannel.c++",
        "discussion_id": "2017399470",
        "commented_code": "@@ -0,0 +1,317 @@\n+#include \"messagechannel.h\"\n+\n+#include \"global-scope.h\"\n+#include \"worker-rpc.h\"\n+\n+#include <workerd/io/worker.h>\n+#include <workerd/jsg/ser.h>\n+\n+#include <capnp/message.h>\n+\n+namespace workerd::api {\n+jsg::Ref<MessagePort::MessageEvent> MessagePort::MessageEvent::New(jsg::Lock& js,\n+    jsg::JsRef<jsg::JsValue> data,\n+    kj::String lastEventId,\n+    jsg::Ref<MessagePort> source,\n+    kj::Array<jsg::Ref<MessagePort>> ports) {\n+  return jsg::alloc<MessagePort::MessageEvent>(\n+      kj::str(\"message\"), kj::mv(data), kj::mv(lastEventId), kj::mv(source), kj::mv(ports));\n+}\n+\n+jsg::Ref<MessagePort::MessageEvent> MessagePort::MessageEvent::NewError(jsg::Lock& js,\n+    jsg::JsRef<jsg::JsValue> data,\n+    kj::String lastEventId,\n+    jsg::Ref<MessagePort> source,\n+    kj::Array<jsg::Ref<MessagePort>> ports) {\n+  return jsg::alloc<MessagePort::MessageEvent>(\n+      kj::str(\"messageerror\"), kj::mv(data), kj::mv(lastEventId), kj::mv(source), kj::mv(ports));\n+}\n+\n+MessagePort::MessagePort(IoContext& ioContext): ioContext(ioContext), state(Pending()) {\n+  // We set a callback on the underlying EventTarget to be notified when\n+  // a listener for the message event is added or removed. When there\n+  // are no listeners, we move back to the Pending state, otherwise we\n+  // will switch to the Started state if necessary.\n+  setEventListenerCallback([&](jsg::Lock& js, kj::StringPtr name, size_t count) {\n+    if (name == \"message\"_kj) {\n+      KJ_SWITCH_ONEOF(state) {\n+        KJ_CASE_ONEOF(pending, Pending) {\n+          // If we are in the pending state, start the port if we have listeners.\n+          // This is technically not spec compliant, but it is what Node.js\n+          // supports. Specifically, adding a new message listener using the\n+          // addEventListener method is *technically* not supposed to start\n+          // the port but we're going to do what Node.js does.\n+          if (count > 0 || onmessageValue != kj::none) {\n+            start(js);\n+          }\n+        }\n+        KJ_CASE_ONEOF(started, Started) {\n+          // If we are in the started state, stop the port if there are no listeners.\n+          if (count == 0 && onmessageValue == kj::none) {\n+            state = Pending();\n+          }\n+        }\n+        KJ_CASE_ONEOF(_, Closed) {\n+          // Nothing to do. We're already closed so we don't care.\n+        }\n+      }\n+    }\n+  });\n+}\n+\n+// Deliver the message to the \"message\" or \"messageerror\" event on this port.\n+void MessagePort::deliver(\n+    jsg::Lock& js, kj::Own<rpc::JsValue::Reader> message, jsg::Ref<MessagePort> port) {\n+  auto event = js.tryCatch([&] {\n+    jsg::Deserializer deserializer(js, message->getV8Serialized());\n+    return MessageEvent::New(\n+        js, jsg::JsRef(js, deserializer.readValue(js)), kj::str(), port->addRef(), {});\n+  }, [&](jsg::Value exception) {\n+    return MessageEvent::NewError(\n+        js, jsg::JsRef(js, jsg::JsValue(exception.getHandle(js))), kj::str(), port->addRef(), {});\n+  });\n+\n+  // If any of the message/messageerror event handlers throw,\n+  // capture the error and pass it to reportError instead of\n+  // propagating up.\n+  js.tryCatch([&] { port->dispatchEventImpl(js, kj::mv(event)); }, [&](jsg::Value exception) {\n+    auto context = js.v8Context();\n+    auto& global =\n+        jsg::extractInternalPointer<ServiceWorkerGlobalScope, true>(context, context->Global());\n+    global.reportError(js, jsg::JsValue(exception.getHandle(js)));\n+  });\n+}\n+\n+// Deliver the message to all the jsrpc remotes we have\n+kj::Promise<void> MessagePort::sendToRpc(kj::Own<rpc::JsValue::Reader> message) {\n+  KJ_IF_SOME(outputLocks, ioContext.waitForOutputLocksIfNecessary()) {\n+    co_await outputLocks;\n+  }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (rpc::JsMessagePort::Client cap: rpcClients) {\n+    auto req = cap.callRequest();\n+    req.setData(*message);\n+    // TODO(message-port): Removing the port when dropped?\n+    promises.add(req.send().ignoreResult());\n+  }\n+  co_await kj::joinPromises(promises.releaseAsArray());\n+}\n+\n+// Deliver the message to this port, buffering if necessary if the port\n+// has not been started. Buffered messages will be delivered when the\n+// port is started later.\n+void MessagePort::deliverMessage(jsg::Lock& js, rpc::JsValue::Reader value) {\n+  KJ_SWITCH_ONEOF(state) {\n+    KJ_CASE_ONEOF(pending, Pending) {\n+      // We have not yet started the port so buffer to message.\n+      pending.add(capnp::clone(value));\n+    }\n+    KJ_CASE_ONEOF(started, Started) {\n+      ioContext.addTask(sendToRpc(capnp::clone(value)));\n+      deliver(js, capnp::clone(value), addRef());\n+    }\n+    KJ_CASE_ONEOF(_, Closed) {\n+      // Nothing to do in this case. Drop the message on the floor.\n+    }\n+  }\n+}\n+\n+// Binds two ports to each other such that messages posted to one\n+// are delivered on the other.\n+void MessagePort::entangle(MessagePort& port1, MessagePort& port2) {\n+  port1.other = port2.addRef();\n+  port2.other = port1.addRef();\n+}\n+\n+// Post a message to the entangled port.\n+void MessagePort::postMessage(jsg::Lock& js,\n+    jsg::Optional<jsg::JsRef<jsg::JsValue>> data,\n+    jsg::Optional<TransferListOrOptions> options) {\n+\n+  KJ_IF_SOME(opt, options) {\n+    // We don't currently support transfer lists, even for local\n+    // same-isolate delivery.\n+    // TODO(conform): Implement transfer later?\n+    KJ_SWITCH_ONEOF(opt) {\n+      KJ_CASE_ONEOF(list, TransferList) {\n+        JSG_REQUIRE(list.size() == 0, Error, \"Transfer list is not supported\");\n+      }\n+      KJ_CASE_ONEOF(opts, PostMessageOptions) {\n+        KJ_IF_SOME(list, opts.transfer) {\n+          JSG_REQUIRE(list.size() == 0, Error, \"Transfer list is not supported\");\n+        }\n+      }\n+    }\n+  }\n+\n+  KJ_IF_SOME(o, other) {\n+    // TODO(message-port): Set up the external handler to support more types.\n+    jsg::Serializer ser(js);\n+    KJ_IF_SOME(d, data) {\n+      ser.write(js, d.getHandle(js));\n+    }\n+    auto released = ser.release();\n+    JSG_REQUIRE(released.sharedArrayBuffers.size() == 0, Error, \"SharedArrayBuffer is unsupported\");\n+\n+    capnp::MallocMessageBuilder builder;\n+    rpc::JsValue::Builder val = builder.initRoot<rpc::JsValue>();\n+    val.setV8Serialized(kj::mv(released.data));\n+    o->deliverMessage(js, val.asReader());\n+  }\n+}\n+\n+// Should close this port, the entangle port, and any known rpc clients.\n+void MessagePort::close() {\n+  state = Closed{};\n+  rpcClients.clear();\n+  KJ_IF_SOME(o, other) {\n+    auto closing = kj::mv(o);\n+    other = kj::none;\n+    closing->close();\n+  }\n+}\n+\n+// Start delivering messages on this port. Any messages that are\n+// buffered will be drained immediately.\n+void MessagePort::start(jsg::Lock& js) {\n+  KJ_SWITCH_ONEOF(state) {\n+    KJ_CASE_ONEOF(pending, Pending) {\n+      auto list = kj::mv(pending);\n+      state = Started{};\n+      for (auto& item: list) {\n+        ioContext.addTask(sendToRpc(capnp::clone(*item)));\n+        // Local delivery\n+        deliver(js, kj::mv(item), addRef());\n+      }\n+    }\n+    KJ_CASE_ONEOF(_, Started) {\n+      // Nothing to do in this case. We are already started!\n+    }\n+    KJ_CASE_ONEOF(_, Closed) {\n+      // Nothing to do in this case. Can't start after closing.\n+    }\n+  }\n+}\n+\n+kj::Maybe<jsg::JsValue> MessagePort::getOnMessage(jsg::Lock& js) {\n+  return onmessageValue.map(\n+      [&](jsg::JsRef<jsg::JsValue>& ref) -> jsg::JsValue { return ref.getHandle(js); });\n+}\n+\n+void MessagePort::setOnMessage(jsg::Lock& js, jsg::JsValue value) {\n+  if (!value.isObject() && !value.isFunction()) {\n+    onmessageValue = kj::none;\n+    // If we have no handlers and no onmessage ...\n+    if (getHandlerCount(\"message\"_kj) == 0 && onmessageValue == kj::none) {\n+      // ...Put the port back into a pending state where messages\n+      // will be enqueued until another listener is attached.\n+      state = Pending();\n+    }\n+  } else {\n+    onmessageValue = jsg::JsRef<jsg::JsValue>(js, value);\n+    start(js);\n+  }\n+}\n+\n+namespace {\n+// The jsrpc handler that receives messages posted from the remote and\n+// delivers them to the local port.\n+class JsMessagePortImpl final: public rpc::JsMessagePort::Server {\n+ public:\n+  JsMessagePortImpl(IoContext& ctx, jsg::Ref<MessagePort> port)\n+      : port(kj::mv(port)),\n+        weakIoContext(ctx.getWeakRef()) {}\n+  ~JsMessagePortImpl() {\n+    port->close();\n+  }\n+\n+  kj::Promise<void> call(CallContext context) override {\n+    IoContext& ctx = JSG_REQUIRE_NONNULL(weakIoContext->tryGet(), Error,\n+        \"The destination object for this message port no longer exists.\");\n+\n+    KJ_IF_SOME(other, port->getOther()) {\n+      // We can only dispatch messages under the isolate lock, so acquire\n+      // that here then deliver...\n+      auto lock = co_await ctx.getWorker()->takeAsyncLockWithoutRequest(nullptr);\n+      ctx.getWorker()->runInLockScope(lock, [&](auto& lock) {\n+        JSG_WITHIN_CONTEXT_SCOPE(lock, lock.getContext(), [&](auto& js) {\n+          auto params = context.getParams();\n+          other.deliverMessage(js, params.getData());\n+        });\n+      });\n+    }\n+\n+    context.initResults();\n+  }\n+\n+ private:\n+  jsg::Ref<MessagePort> port;\n+  kj::Own<IoContext::WeakRef> weakIoContext;\n+};\n+}  // namespace\n+\n+void MessagePort::serialize(jsg::Lock& js, jsg::Serializer& serializer) {\n+  auto& handler = JSG_REQUIRE_NONNULL(serializer.getExternalHandler(), DOMDataCloneError,\n+      \"MessagePort can only be serialized for RPC.\");\n+  auto externalHandler = dynamic_cast<RpcSerializerExternalHander*>(&handler);\n+  JSG_REQUIRE(\n+      externalHandler != nullptr, DOMDataCloneError, \"MessagePort can only be serialized for RPC.\");\n+\n+  // Don't send a MessagePort that has been closed already.\n+  JSG_REQUIRE(!state.is<Closed>(), DOMDataCloneError, \"MessagePort is closed\");",
        "comment_created_at": "2025-03-27T18:20:51+00:00",
        "comment_author": "anonrig",
        "comment_body": "This should be DOMException not DOMDataCloneError\r\n\r\n> If [this](https://webidl.spec.whatwg.org/#this)'s [closed flag](https://html.spec.whatwg.org/multipage/web-messaging.html#concept-broadcastchannel-closed) is true, then throw an [\"InvalidStateError\"](https://webidl.spec.whatwg.org/#invalidstateerror) [DOMException](https://webidl.spec.whatwg.org/#dfn-DOMException).",
        "pr_file_module": null
      },
      {
        "comment_id": "2017423779",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 3813,
        "pr_file": "src/workerd/api/messagechannel.c++",
        "discussion_id": "2017399470",
        "commented_code": "@@ -0,0 +1,317 @@\n+#include \"messagechannel.h\"\n+\n+#include \"global-scope.h\"\n+#include \"worker-rpc.h\"\n+\n+#include <workerd/io/worker.h>\n+#include <workerd/jsg/ser.h>\n+\n+#include <capnp/message.h>\n+\n+namespace workerd::api {\n+jsg::Ref<MessagePort::MessageEvent> MessagePort::MessageEvent::New(jsg::Lock& js,\n+    jsg::JsRef<jsg::JsValue> data,\n+    kj::String lastEventId,\n+    jsg::Ref<MessagePort> source,\n+    kj::Array<jsg::Ref<MessagePort>> ports) {\n+  return jsg::alloc<MessagePort::MessageEvent>(\n+      kj::str(\"message\"), kj::mv(data), kj::mv(lastEventId), kj::mv(source), kj::mv(ports));\n+}\n+\n+jsg::Ref<MessagePort::MessageEvent> MessagePort::MessageEvent::NewError(jsg::Lock& js,\n+    jsg::JsRef<jsg::JsValue> data,\n+    kj::String lastEventId,\n+    jsg::Ref<MessagePort> source,\n+    kj::Array<jsg::Ref<MessagePort>> ports) {\n+  return jsg::alloc<MessagePort::MessageEvent>(\n+      kj::str(\"messageerror\"), kj::mv(data), kj::mv(lastEventId), kj::mv(source), kj::mv(ports));\n+}\n+\n+MessagePort::MessagePort(IoContext& ioContext): ioContext(ioContext), state(Pending()) {\n+  // We set a callback on the underlying EventTarget to be notified when\n+  // a listener for the message event is added or removed. When there\n+  // are no listeners, we move back to the Pending state, otherwise we\n+  // will switch to the Started state if necessary.\n+  setEventListenerCallback([&](jsg::Lock& js, kj::StringPtr name, size_t count) {\n+    if (name == \"message\"_kj) {\n+      KJ_SWITCH_ONEOF(state) {\n+        KJ_CASE_ONEOF(pending, Pending) {\n+          // If we are in the pending state, start the port if we have listeners.\n+          // This is technically not spec compliant, but it is what Node.js\n+          // supports. Specifically, adding a new message listener using the\n+          // addEventListener method is *technically* not supposed to start\n+          // the port but we're going to do what Node.js does.\n+          if (count > 0 || onmessageValue != kj::none) {\n+            start(js);\n+          }\n+        }\n+        KJ_CASE_ONEOF(started, Started) {\n+          // If we are in the started state, stop the port if there are no listeners.\n+          if (count == 0 && onmessageValue == kj::none) {\n+            state = Pending();\n+          }\n+        }\n+        KJ_CASE_ONEOF(_, Closed) {\n+          // Nothing to do. We're already closed so we don't care.\n+        }\n+      }\n+    }\n+  });\n+}\n+\n+// Deliver the message to the \"message\" or \"messageerror\" event on this port.\n+void MessagePort::deliver(\n+    jsg::Lock& js, kj::Own<rpc::JsValue::Reader> message, jsg::Ref<MessagePort> port) {\n+  auto event = js.tryCatch([&] {\n+    jsg::Deserializer deserializer(js, message->getV8Serialized());\n+    return MessageEvent::New(\n+        js, jsg::JsRef(js, deserializer.readValue(js)), kj::str(), port->addRef(), {});\n+  }, [&](jsg::Value exception) {\n+    return MessageEvent::NewError(\n+        js, jsg::JsRef(js, jsg::JsValue(exception.getHandle(js))), kj::str(), port->addRef(), {});\n+  });\n+\n+  // If any of the message/messageerror event handlers throw,\n+  // capture the error and pass it to reportError instead of\n+  // propagating up.\n+  js.tryCatch([&] { port->dispatchEventImpl(js, kj::mv(event)); }, [&](jsg::Value exception) {\n+    auto context = js.v8Context();\n+    auto& global =\n+        jsg::extractInternalPointer<ServiceWorkerGlobalScope, true>(context, context->Global());\n+    global.reportError(js, jsg::JsValue(exception.getHandle(js)));\n+  });\n+}\n+\n+// Deliver the message to all the jsrpc remotes we have\n+kj::Promise<void> MessagePort::sendToRpc(kj::Own<rpc::JsValue::Reader> message) {\n+  KJ_IF_SOME(outputLocks, ioContext.waitForOutputLocksIfNecessary()) {\n+    co_await outputLocks;\n+  }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (rpc::JsMessagePort::Client cap: rpcClients) {\n+    auto req = cap.callRequest();\n+    req.setData(*message);\n+    // TODO(message-port): Removing the port when dropped?\n+    promises.add(req.send().ignoreResult());\n+  }\n+  co_await kj::joinPromises(promises.releaseAsArray());\n+}\n+\n+// Deliver the message to this port, buffering if necessary if the port\n+// has not been started. Buffered messages will be delivered when the\n+// port is started later.\n+void MessagePort::deliverMessage(jsg::Lock& js, rpc::JsValue::Reader value) {\n+  KJ_SWITCH_ONEOF(state) {\n+    KJ_CASE_ONEOF(pending, Pending) {\n+      // We have not yet started the port so buffer to message.\n+      pending.add(capnp::clone(value));\n+    }\n+    KJ_CASE_ONEOF(started, Started) {\n+      ioContext.addTask(sendToRpc(capnp::clone(value)));\n+      deliver(js, capnp::clone(value), addRef());\n+    }\n+    KJ_CASE_ONEOF(_, Closed) {\n+      // Nothing to do in this case. Drop the message on the floor.\n+    }\n+  }\n+}\n+\n+// Binds two ports to each other such that messages posted to one\n+// are delivered on the other.\n+void MessagePort::entangle(MessagePort& port1, MessagePort& port2) {\n+  port1.other = port2.addRef();\n+  port2.other = port1.addRef();\n+}\n+\n+// Post a message to the entangled port.\n+void MessagePort::postMessage(jsg::Lock& js,\n+    jsg::Optional<jsg::JsRef<jsg::JsValue>> data,\n+    jsg::Optional<TransferListOrOptions> options) {\n+\n+  KJ_IF_SOME(opt, options) {\n+    // We don't currently support transfer lists, even for local\n+    // same-isolate delivery.\n+    // TODO(conform): Implement transfer later?\n+    KJ_SWITCH_ONEOF(opt) {\n+      KJ_CASE_ONEOF(list, TransferList) {\n+        JSG_REQUIRE(list.size() == 0, Error, \"Transfer list is not supported\");\n+      }\n+      KJ_CASE_ONEOF(opts, PostMessageOptions) {\n+        KJ_IF_SOME(list, opts.transfer) {\n+          JSG_REQUIRE(list.size() == 0, Error, \"Transfer list is not supported\");\n+        }\n+      }\n+    }\n+  }\n+\n+  KJ_IF_SOME(o, other) {\n+    // TODO(message-port): Set up the external handler to support more types.\n+    jsg::Serializer ser(js);\n+    KJ_IF_SOME(d, data) {\n+      ser.write(js, d.getHandle(js));\n+    }\n+    auto released = ser.release();\n+    JSG_REQUIRE(released.sharedArrayBuffers.size() == 0, Error, \"SharedArrayBuffer is unsupported\");\n+\n+    capnp::MallocMessageBuilder builder;\n+    rpc::JsValue::Builder val = builder.initRoot<rpc::JsValue>();\n+    val.setV8Serialized(kj::mv(released.data));\n+    o->deliverMessage(js, val.asReader());\n+  }\n+}\n+\n+// Should close this port, the entangle port, and any known rpc clients.\n+void MessagePort::close() {\n+  state = Closed{};\n+  rpcClients.clear();\n+  KJ_IF_SOME(o, other) {\n+    auto closing = kj::mv(o);\n+    other = kj::none;\n+    closing->close();\n+  }\n+}\n+\n+// Start delivering messages on this port. Any messages that are\n+// buffered will be drained immediately.\n+void MessagePort::start(jsg::Lock& js) {\n+  KJ_SWITCH_ONEOF(state) {\n+    KJ_CASE_ONEOF(pending, Pending) {\n+      auto list = kj::mv(pending);\n+      state = Started{};\n+      for (auto& item: list) {\n+        ioContext.addTask(sendToRpc(capnp::clone(*item)));\n+        // Local delivery\n+        deliver(js, kj::mv(item), addRef());\n+      }\n+    }\n+    KJ_CASE_ONEOF(_, Started) {\n+      // Nothing to do in this case. We are already started!\n+    }\n+    KJ_CASE_ONEOF(_, Closed) {\n+      // Nothing to do in this case. Can't start after closing.\n+    }\n+  }\n+}\n+\n+kj::Maybe<jsg::JsValue> MessagePort::getOnMessage(jsg::Lock& js) {\n+  return onmessageValue.map(\n+      [&](jsg::JsRef<jsg::JsValue>& ref) -> jsg::JsValue { return ref.getHandle(js); });\n+}\n+\n+void MessagePort::setOnMessage(jsg::Lock& js, jsg::JsValue value) {\n+  if (!value.isObject() && !value.isFunction()) {\n+    onmessageValue = kj::none;\n+    // If we have no handlers and no onmessage ...\n+    if (getHandlerCount(\"message\"_kj) == 0 && onmessageValue == kj::none) {\n+      // ...Put the port back into a pending state where messages\n+      // will be enqueued until another listener is attached.\n+      state = Pending();\n+    }\n+  } else {\n+    onmessageValue = jsg::JsRef<jsg::JsValue>(js, value);\n+    start(js);\n+  }\n+}\n+\n+namespace {\n+// The jsrpc handler that receives messages posted from the remote and\n+// delivers them to the local port.\n+class JsMessagePortImpl final: public rpc::JsMessagePort::Server {\n+ public:\n+  JsMessagePortImpl(IoContext& ctx, jsg::Ref<MessagePort> port)\n+      : port(kj::mv(port)),\n+        weakIoContext(ctx.getWeakRef()) {}\n+  ~JsMessagePortImpl() {\n+    port->close();\n+  }\n+\n+  kj::Promise<void> call(CallContext context) override {\n+    IoContext& ctx = JSG_REQUIRE_NONNULL(weakIoContext->tryGet(), Error,\n+        \"The destination object for this message port no longer exists.\");\n+\n+    KJ_IF_SOME(other, port->getOther()) {\n+      // We can only dispatch messages under the isolate lock, so acquire\n+      // that here then deliver...\n+      auto lock = co_await ctx.getWorker()->takeAsyncLockWithoutRequest(nullptr);\n+      ctx.getWorker()->runInLockScope(lock, [&](auto& lock) {\n+        JSG_WITHIN_CONTEXT_SCOPE(lock, lock.getContext(), [&](auto& js) {\n+          auto params = context.getParams();\n+          other.deliverMessage(js, params.getData());\n+        });\n+      });\n+    }\n+\n+    context.initResults();\n+  }\n+\n+ private:\n+  jsg::Ref<MessagePort> port;\n+  kj::Own<IoContext::WeakRef> weakIoContext;\n+};\n+}  // namespace\n+\n+void MessagePort::serialize(jsg::Lock& js, jsg::Serializer& serializer) {\n+  auto& handler = JSG_REQUIRE_NONNULL(serializer.getExternalHandler(), DOMDataCloneError,\n+      \"MessagePort can only be serialized for RPC.\");\n+  auto externalHandler = dynamic_cast<RpcSerializerExternalHander*>(&handler);\n+  JSG_REQUIRE(\n+      externalHandler != nullptr, DOMDataCloneError, \"MessagePort can only be serialized for RPC.\");\n+\n+  // Don't send a MessagePort that has been closed already.\n+  JSG_REQUIRE(!state.is<Closed>(), DOMDataCloneError, \"MessagePort is closed\");",
        "comment_created_at": "2025-03-27T18:39:07+00:00",
        "comment_author": "jasnell",
        "comment_body": "`DOMDataCloneError` *is* a `DOMException`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224159460",
    "pr_number": 4480,
    "pr_file": "src/workerd/io/worker-fs.c++",
    "created_at": "2025-07-23T02:07:11+00:00",
    "commented_code": "mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\n') endPos--;\n+  auto context = js.v8Context();\n+  auto console =\n+      jsg::check(context->Global()->Get(context, jsg::v8StrIntern(js.v8Isolate, \"console\")));\n+  KJ_ASSERT(console->IsObject());\n+  auto consoleObj = console.As<v8::Object>();\n+\n+  // Choose the appropriate console method based on stdio type\n+  const char* methodName = (type == VirtualFileSystem::Stdio::OUT) ? \"log\" : \"error\";\n+  auto method = jsg::check(consoleObj->Get(context, jsg::v8StrIntern(js.v8Isolate, methodName)));\n+  KJ_ASSERT(method->IsFunction());",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2224159460",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4480,
        "pr_file": "src/workerd/io/worker-fs.c++",
        "discussion_id": "2224159460",
        "commented_code": "@@ -1632,12 +1632,42 @@ class DevRandomFile final: public File, public kj::EnableAddRefToThis<DevRandomF\n   mutable kj::Maybe<kj::String> maybeUniqueId;\n };\n \n+// Write stdio via console.log. Somewhat convoluted, but this then supports:\n+// - inspector reporting\n+// - structured logging\n+// - stdio output otherwise\n+void writeStdio(jsg::Lock& js, VirtualFileSystem::Stdio type, kj::ArrayPtr<const kj::byte> bytes) {\n+  auto chars = bytes.asChars();\n+  size_t endPos = chars.size();\n+  if (chars[endPos - 1] == '\\n') endPos--;\n+  auto context = js.v8Context();\n+  auto console =\n+      jsg::check(context->Global()->Get(context, jsg::v8StrIntern(js.v8Isolate, \"console\")));\n+  KJ_ASSERT(console->IsObject());\n+  auto consoleObj = console.As<v8::Object>();\n+\n+  // Choose the appropriate console method based on stdio type\n+  const char* methodName = (type == VirtualFileSystem::Stdio::OUT) ? \"log\" : \"error\";\n+  auto method = jsg::check(consoleObj->Get(context, jsg::v8StrIntern(js.v8Isolate, methodName)));\n+  KJ_ASSERT(method->IsFunction());",
        "comment_created_at": "2025-07-23T02:07:11+00:00",
        "comment_author": "jasnell",
        "comment_body": "Probably not a great idea to use `KJ_ASSERT` here. The user code might override `console.log` or `console.error` and this would result in an \"internal error\". I mean, it's exceedingly unlikely but possible. Let's make this a JSG_REQUIRE instead?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2222957408",
    "pr_number": 4548,
    "pr_file": "src/workerd/api/pyodide/pyodide.c++",
    "created_at": "2025-07-22T15:32:42+00:00",
    "commented_code": "co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (const auto& filename: filenames) {\n+    promises.add(loadPyodidePackage(\n+        pyConfig, pyodidePackageManager, packagesVersion, filename, network, timer));\n+  }\n+\n+  co_await kj::joinPromisesFailFast(promises.releaseAsArray());\n+}\n+\n+// Helper functions for bundle file operations\n+kj::Path getPyodideBundleFileName(kj::StringPtr version) {\n+  return kj::Path(kj::str(\"pyodide_\", version, \".capnp.bin\"));\n+}\n+\n+kj::Maybe<kj::Own<const kj::ReadableFile>> getPyodideBundleFile(\n+    const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir, kj::StringPtr version) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto file = dir->tryOpenFile(filename);\n+\n+    return file;\n+  }\n+\n+  return kj::none;\n+}\n+\n+void writePyodideBundleFileToDisk(const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir,\n+    kj::StringPtr version,\n+    kj::ArrayPtr<byte> bytes) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto replacer = dir->replaceFile(filename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY);\n+\n+    replacer->get().writeAll(bytes);\n+    replacer->commit();\n+  }\n+}\n+\n+// Used to preload the Pyodide bundle during workerd startup\n+kj::Promise<kj::Maybe<jsg::Bundle::Reader>> fetchPyodideBundle(\n+    const PythonConfig& pyConfig, kj::String version, kj::Network& network, kj::Timer& timer) {\n+  if (pyConfig.pyodideBundleManager.getPyodideBundle(version) != kj::none) {\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  auto maybePyodideBundleFile = getPyodideBundleFile(pyConfig.pyodideDiskCacheRoot, version);\n+  KJ_IF_SOME(pyodideBundleFile, maybePyodideBundleFile) {\n+    auto body = pyodideBundleFile->readAllBytes();\n+    pyConfig.pyodideBundleManager.setPyodideBundleData(kj::str(version), kj::mv(body));\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  if (version == \"dev\") {\n+    // the \"dev\" version is special and indicates we're using the tip-of-tree version built for testing\n+    // so we shouldn't fetch it from the internet, only check for its existence in the disk cache\n+    co_return kj::none;\n+  }\n+\n+  kj::String url =\n+      kj::str(\"https://pyodide-capnp-bin.edgeworker.net/pyodide_\", version, \".capnp.bin\");\n+  KJ_LOG(INFO, \"Loading Pyodide bundle from internet\", url);\n+  kj::HttpHeaderTable table;\n+\n+  kj::TlsContext::Options options;\n+  options.useSystemTrustStore = true;\n+\n+  kj::Own<kj::TlsContext> tls = kj::heap<kj::TlsContext>(kj::mv(options));\n+  auto tlsNetwork = tls->wrapNetwork(network);\n+  auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n+\n+  kj::HttpHeaders headers(table);\n+\n+  auto req = client->request(kj::HttpMethod::GET, url.asPtr(), headers);\n+\n+  auto res = co_await req.response;\n+  KJ_ASSERT(res.statusCode == 200,\n+      kj::str(\"Request for Pyodide bundle at \", url, \" failed with HTTP status \", res.statusCode));",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2222957408",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4548,
        "pr_file": "src/workerd/api/pyodide/pyodide.c++",
        "discussion_id": "2222957408",
        "commented_code": "@@ -801,41 +806,107 @@ kj::Promise<void> loadPyodidePackage(const PythonConfig& pyConfig,\n   co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (const auto& filename: filenames) {\n+    promises.add(loadPyodidePackage(\n+        pyConfig, pyodidePackageManager, packagesVersion, filename, network, timer));\n+  }\n+\n+  co_await kj::joinPromisesFailFast(promises.releaseAsArray());\n+}\n+\n+// Helper functions for bundle file operations\n+kj::Path getPyodideBundleFileName(kj::StringPtr version) {\n+  return kj::Path(kj::str(\"pyodide_\", version, \".capnp.bin\"));\n+}\n+\n+kj::Maybe<kj::Own<const kj::ReadableFile>> getPyodideBundleFile(\n+    const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir, kj::StringPtr version) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto file = dir->tryOpenFile(filename);\n+\n+    return file;\n+  }\n+\n+  return kj::none;\n+}\n+\n+void writePyodideBundleFileToDisk(const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir,\n+    kj::StringPtr version,\n+    kj::ArrayPtr<byte> bytes) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto replacer = dir->replaceFile(filename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY);\n+\n+    replacer->get().writeAll(bytes);\n+    replacer->commit();\n+  }\n+}\n+\n+// Used to preload the Pyodide bundle during workerd startup\n+kj::Promise<kj::Maybe<jsg::Bundle::Reader>> fetchPyodideBundle(\n+    const PythonConfig& pyConfig, kj::String version, kj::Network& network, kj::Timer& timer) {\n+  if (pyConfig.pyodideBundleManager.getPyodideBundle(version) != kj::none) {\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  auto maybePyodideBundleFile = getPyodideBundleFile(pyConfig.pyodideDiskCacheRoot, version);\n+  KJ_IF_SOME(pyodideBundleFile, maybePyodideBundleFile) {\n+    auto body = pyodideBundleFile->readAllBytes();\n+    pyConfig.pyodideBundleManager.setPyodideBundleData(kj::str(version), kj::mv(body));\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  if (version == \"dev\") {\n+    // the \"dev\" version is special and indicates we're using the tip-of-tree version built for testing\n+    // so we shouldn't fetch it from the internet, only check for its existence in the disk cache\n+    co_return kj::none;\n+  }\n+\n+  kj::String url =\n+      kj::str(\"https://pyodide-capnp-bin.edgeworker.net/pyodide_\", version, \".capnp.bin\");\n+  KJ_LOG(INFO, \"Loading Pyodide bundle from internet\", url);\n+  kj::HttpHeaderTable table;\n+\n+  kj::TlsContext::Options options;\n+  options.useSystemTrustStore = true;\n+\n+  kj::Own<kj::TlsContext> tls = kj::heap<kj::TlsContext>(kj::mv(options));\n+  auto tlsNetwork = tls->wrapNetwork(network);\n+  auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n+\n+  kj::HttpHeaders headers(table);\n+\n+  auto req = client->request(kj::HttpMethod::GET, url.asPtr(), headers);\n+\n+  auto res = co_await req.response;\n+  KJ_ASSERT(res.statusCode == 200,\n+      kj::str(\"Request for Pyodide bundle at \", url, \" failed with HTTP status \", res.statusCode));",
        "comment_created_at": "2025-07-22T15:32:42+00:00",
        "comment_author": "jasnell",
        "comment_body": "Super nit: since this is an internal only error message, it seems unfortunate to allocate the string (kj::str(...)) entirely. This could just be...\r\n\r\n```suggestion\r\n  KJ_ASSERT(res.statusCode == 200,\r\n            \"Request for Pyodide bundle failed\",\r\n            url, res.statusCode);\r\n```\r\n\r\nAnd we'd avoid the additional string allocation.\r\n\r\nObviously extremely minor but still ;-)",
        "pr_file_module": null
      },
      {
        "comment_id": "2223008841",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4548,
        "pr_file": "src/workerd/api/pyodide/pyodide.c++",
        "discussion_id": "2222957408",
        "commented_code": "@@ -801,41 +806,107 @@ kj::Promise<void> loadPyodidePackage(const PythonConfig& pyConfig,\n   co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (const auto& filename: filenames) {\n+    promises.add(loadPyodidePackage(\n+        pyConfig, pyodidePackageManager, packagesVersion, filename, network, timer));\n+  }\n+\n+  co_await kj::joinPromisesFailFast(promises.releaseAsArray());\n+}\n+\n+// Helper functions for bundle file operations\n+kj::Path getPyodideBundleFileName(kj::StringPtr version) {\n+  return kj::Path(kj::str(\"pyodide_\", version, \".capnp.bin\"));\n+}\n+\n+kj::Maybe<kj::Own<const kj::ReadableFile>> getPyodideBundleFile(\n+    const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir, kj::StringPtr version) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto file = dir->tryOpenFile(filename);\n+\n+    return file;\n+  }\n+\n+  return kj::none;\n+}\n+\n+void writePyodideBundleFileToDisk(const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir,\n+    kj::StringPtr version,\n+    kj::ArrayPtr<byte> bytes) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto replacer = dir->replaceFile(filename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY);\n+\n+    replacer->get().writeAll(bytes);\n+    replacer->commit();\n+  }\n+}\n+\n+// Used to preload the Pyodide bundle during workerd startup\n+kj::Promise<kj::Maybe<jsg::Bundle::Reader>> fetchPyodideBundle(\n+    const PythonConfig& pyConfig, kj::String version, kj::Network& network, kj::Timer& timer) {\n+  if (pyConfig.pyodideBundleManager.getPyodideBundle(version) != kj::none) {\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  auto maybePyodideBundleFile = getPyodideBundleFile(pyConfig.pyodideDiskCacheRoot, version);\n+  KJ_IF_SOME(pyodideBundleFile, maybePyodideBundleFile) {\n+    auto body = pyodideBundleFile->readAllBytes();\n+    pyConfig.pyodideBundleManager.setPyodideBundleData(kj::str(version), kj::mv(body));\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  if (version == \"dev\") {\n+    // the \"dev\" version is special and indicates we're using the tip-of-tree version built for testing\n+    // so we shouldn't fetch it from the internet, only check for its existence in the disk cache\n+    co_return kj::none;\n+  }\n+\n+  kj::String url =\n+      kj::str(\"https://pyodide-capnp-bin.edgeworker.net/pyodide_\", version, \".capnp.bin\");\n+  KJ_LOG(INFO, \"Loading Pyodide bundle from internet\", url);\n+  kj::HttpHeaderTable table;\n+\n+  kj::TlsContext::Options options;\n+  options.useSystemTrustStore = true;\n+\n+  kj::Own<kj::TlsContext> tls = kj::heap<kj::TlsContext>(kj::mv(options));\n+  auto tlsNetwork = tls->wrapNetwork(network);\n+  auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n+\n+  kj::HttpHeaders headers(table);\n+\n+  auto req = client->request(kj::HttpMethod::GET, url.asPtr(), headers);\n+\n+  auto res = co_await req.response;\n+  KJ_ASSERT(res.statusCode == 200,\n+      kj::str(\"Request for Pyodide bundle at \", url, \" failed with HTTP status \", res.statusCode));",
        "comment_created_at": "2025-07-22T15:45:25+00:00",
        "comment_author": "dom96",
        "comment_body": "I'll take care of these in a follow up PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "2223034919",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4548,
        "pr_file": "src/workerd/api/pyodide/pyodide.c++",
        "discussion_id": "2222957408",
        "commented_code": "@@ -801,41 +806,107 @@ kj::Promise<void> loadPyodidePackage(const PythonConfig& pyConfig,\n   co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (const auto& filename: filenames) {\n+    promises.add(loadPyodidePackage(\n+        pyConfig, pyodidePackageManager, packagesVersion, filename, network, timer));\n+  }\n+\n+  co_await kj::joinPromisesFailFast(promises.releaseAsArray());\n+}\n+\n+// Helper functions for bundle file operations\n+kj::Path getPyodideBundleFileName(kj::StringPtr version) {\n+  return kj::Path(kj::str(\"pyodide_\", version, \".capnp.bin\"));\n+}\n+\n+kj::Maybe<kj::Own<const kj::ReadableFile>> getPyodideBundleFile(\n+    const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir, kj::StringPtr version) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto file = dir->tryOpenFile(filename);\n+\n+    return file;\n+  }\n+\n+  return kj::none;\n+}\n+\n+void writePyodideBundleFileToDisk(const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir,\n+    kj::StringPtr version,\n+    kj::ArrayPtr<byte> bytes) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto replacer = dir->replaceFile(filename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY);\n+\n+    replacer->get().writeAll(bytes);\n+    replacer->commit();\n+  }\n+}\n+\n+// Used to preload the Pyodide bundle during workerd startup\n+kj::Promise<kj::Maybe<jsg::Bundle::Reader>> fetchPyodideBundle(\n+    const PythonConfig& pyConfig, kj::String version, kj::Network& network, kj::Timer& timer) {\n+  if (pyConfig.pyodideBundleManager.getPyodideBundle(version) != kj::none) {\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  auto maybePyodideBundleFile = getPyodideBundleFile(pyConfig.pyodideDiskCacheRoot, version);\n+  KJ_IF_SOME(pyodideBundleFile, maybePyodideBundleFile) {\n+    auto body = pyodideBundleFile->readAllBytes();\n+    pyConfig.pyodideBundleManager.setPyodideBundleData(kj::str(version), kj::mv(body));\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  if (version == \"dev\") {\n+    // the \"dev\" version is special and indicates we're using the tip-of-tree version built for testing\n+    // so we shouldn't fetch it from the internet, only check for its existence in the disk cache\n+    co_return kj::none;\n+  }\n+\n+  kj::String url =\n+      kj::str(\"https://pyodide-capnp-bin.edgeworker.net/pyodide_\", version, \".capnp.bin\");\n+  KJ_LOG(INFO, \"Loading Pyodide bundle from internet\", url);\n+  kj::HttpHeaderTable table;\n+\n+  kj::TlsContext::Options options;\n+  options.useSystemTrustStore = true;\n+\n+  kj::Own<kj::TlsContext> tls = kj::heap<kj::TlsContext>(kj::mv(options));\n+  auto tlsNetwork = tls->wrapNetwork(network);\n+  auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n+\n+  kj::HttpHeaders headers(table);\n+\n+  auto req = client->request(kj::HttpMethod::GET, url.asPtr(), headers);\n+\n+  auto res = co_await req.response;\n+  KJ_ASSERT(res.statusCode == 200,\n+      kj::str(\"Request for Pyodide bundle at \", url, \" failed with HTTP status \", res.statusCode));",
        "comment_created_at": "2025-07-22T15:55:05+00:00",
        "comment_author": "justin-mp",
        "comment_body": "If we're playing assert golf, I think:\r\n\r\n```\r\nKJ_ASSERT(res.statusCode == 200, \"Request for Pyodide bundle failed\", url)\r\n```\r\nwill print something like:\r\n```\r\nassertion failed: res.statusCode == 200 [404 == 200], Request for Pyodide bundle failed, url = http://...\r\n```\r\nsince the comparison operators inside asserts print both sides if they can.",
        "pr_file_module": null
      },
      {
        "comment_id": "2226060248",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4548,
        "pr_file": "src/workerd/api/pyodide/pyodide.c++",
        "discussion_id": "2222957408",
        "commented_code": "@@ -801,41 +806,107 @@ kj::Promise<void> loadPyodidePackage(const PythonConfig& pyConfig,\n   co_return;\n }\n \n-void fetchPyodidePackages(const PythonConfig& pyConfig,\n+kj::Promise<void> fetchPyodidePackages(const PythonConfig& pyConfig,\n     const PyodidePackageManager& pyodidePackageManager,\n     kj::ArrayPtr<kj::String> pythonRequirements,\n-    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease) {\n+    workerd::PythonSnapshotRelease::Reader pythonSnapshotRelease,\n+    kj::Network& network,\n+    kj::Timer& timer) {\n   auto packagesVersion = pythonSnapshotRelease.getPackages();\n \n   auto pyodideLock = getPyodideLock(pythonSnapshotRelease);\n   if (pyodideLock == kj::none) {\n     KJ_LOG(WARNING, \"No lock file found for Python packages version\", packagesVersion);\n-    return;\n+    co_return;\n   }\n \n   auto filenames =\n       getPythonPackageFiles(KJ_ASSERT_NONNULL(pyodideLock), pythonRequirements, packagesVersion);\n \n-  kj::Thread([&]() {\n-    kj::AsyncIoContext ioContext = kj::setupAsyncIo();\n-    kj::HttpHeaderTable table;\n-    kj::TlsContext::Options tlsOptions;\n-    tlsOptions.useSystemTrustStore = true;\n-    kj::Own<kj::TlsContext> tlsContext = kj::heap<kj::TlsContext>(kj::mv(tlsOptions));\n-\n-    auto& network = ioContext.provider->getNetwork();\n-    auto tlsNetwork = tlsContext->wrapNetwork(network);\n-    auto& timer = ioContext.provider->getTimer();\n-\n-    auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n-    kj::Vector<kj::Promise<void>> promises;\n-    for (const auto& filename: filenames) {\n-      promises.add(loadPyodidePackage(\n-          pyConfig, pyodidePackageManager, packagesVersion, filename, *client, timer, table));\n-    }\n+  kj::Vector<kj::Promise<void>> promises;\n+  for (const auto& filename: filenames) {\n+    promises.add(loadPyodidePackage(\n+        pyConfig, pyodidePackageManager, packagesVersion, filename, network, timer));\n+  }\n+\n+  co_await kj::joinPromisesFailFast(promises.releaseAsArray());\n+}\n+\n+// Helper functions for bundle file operations\n+kj::Path getPyodideBundleFileName(kj::StringPtr version) {\n+  return kj::Path(kj::str(\"pyodide_\", version, \".capnp.bin\"));\n+}\n+\n+kj::Maybe<kj::Own<const kj::ReadableFile>> getPyodideBundleFile(\n+    const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir, kj::StringPtr version) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto file = dir->tryOpenFile(filename);\n+\n+    return file;\n+  }\n+\n+  return kj::none;\n+}\n+\n+void writePyodideBundleFileToDisk(const kj::Maybe<kj::Own<const kj::Directory>>& maybeDir,\n+    kj::StringPtr version,\n+    kj::ArrayPtr<byte> bytes) {\n+  KJ_IF_SOME(dir, maybeDir) {\n+    kj::Path filename = getPyodideBundleFileName(version);\n+    auto replacer = dir->replaceFile(filename, kj::WriteMode::CREATE | kj::WriteMode::MODIFY);\n+\n+    replacer->get().writeAll(bytes);\n+    replacer->commit();\n+  }\n+}\n+\n+// Used to preload the Pyodide bundle during workerd startup\n+kj::Promise<kj::Maybe<jsg::Bundle::Reader>> fetchPyodideBundle(\n+    const PythonConfig& pyConfig, kj::String version, kj::Network& network, kj::Timer& timer) {\n+  if (pyConfig.pyodideBundleManager.getPyodideBundle(version) != kj::none) {\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  auto maybePyodideBundleFile = getPyodideBundleFile(pyConfig.pyodideDiskCacheRoot, version);\n+  KJ_IF_SOME(pyodideBundleFile, maybePyodideBundleFile) {\n+    auto body = pyodideBundleFile->readAllBytes();\n+    pyConfig.pyodideBundleManager.setPyodideBundleData(kj::str(version), kj::mv(body));\n+    co_return pyConfig.pyodideBundleManager.getPyodideBundle(version);\n+  }\n+\n+  if (version == \"dev\") {\n+    // the \"dev\" version is special and indicates we're using the tip-of-tree version built for testing\n+    // so we shouldn't fetch it from the internet, only check for its existence in the disk cache\n+    co_return kj::none;\n+  }\n+\n+  kj::String url =\n+      kj::str(\"https://pyodide-capnp-bin.edgeworker.net/pyodide_\", version, \".capnp.bin\");\n+  KJ_LOG(INFO, \"Loading Pyodide bundle from internet\", url);\n+  kj::HttpHeaderTable table;\n+\n+  kj::TlsContext::Options options;\n+  options.useSystemTrustStore = true;\n+\n+  kj::Own<kj::TlsContext> tls = kj::heap<kj::TlsContext>(kj::mv(options));\n+  auto tlsNetwork = tls->wrapNetwork(network);\n+  auto client = kj::newHttpClient(timer, table, network, *tlsNetwork);\n+\n+  kj::HttpHeaders headers(table);\n+\n+  auto req = client->request(kj::HttpMethod::GET, url.asPtr(), headers);\n+\n+  auto res = co_await req.response;\n+  KJ_ASSERT(res.statusCode == 200,\n+      kj::str(\"Request for Pyodide bundle at \", url, \" failed with HTTP status \", res.statusCode));",
        "comment_created_at": "2025-07-23T16:06:09+00:00",
        "comment_author": "kentonv",
        "comment_body": "In fact, the difference is more than just superficial. As written currently, Sentry will produce a different error fingerprint for every different value of `url` and `res.statusCode`. Whereas with @jasnell's or @justin-mp's version, it'll all be fingerprinted into one issue.\r\n\r\nIn general, you should almost never use `kj::str` to manually stringify a message for a KJ_LOG/KJ_ASSERT.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216580456",
    "pr_number": 4572,
    "pr_file": "src/workerd/api/worker-rpc.h",
    "created_at": "2025-07-18T17:37:36+00:00",
    "commented_code": "EntrypointsModule() = default;\n   EntrypointsModule(jsg::Lock&, const jsg::Url&) {}\n \n+  void waitUntil(kj::Promise<void> promise) {\n+    JSG_REQUIRE(IoContext::hasCurrent(), Error, \"waitUntil requires an active request\");",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2216580456",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4572,
        "pr_file": "src/workerd/api/worker-rpc.h",
        "discussion_id": "2216580456",
        "commented_code": "@@ -554,6 +554,11 @@ class EntrypointsModule: public jsg::Object {\n   EntrypointsModule() = default;\n   EntrypointsModule(jsg::Lock&, const jsg::Url&) {}\n \n+  void waitUntil(kj::Promise<void> promise) {\n+    JSG_REQUIRE(IoContext::hasCurrent(), Error, \"waitUntil requires an active request\");",
        "comment_created_at": "2025-07-18T17:37:36+00:00",
        "comment_author": "kentonv",
        "comment_body": "You don't really need this line, `current()` will already throw a JSG exception if there's no active request.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216586502",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4572,
        "pr_file": "src/workerd/api/worker-rpc.h",
        "discussion_id": "2216580456",
        "commented_code": "@@ -554,6 +554,11 @@ class EntrypointsModule: public jsg::Object {\n   EntrypointsModule() = default;\n   EntrypointsModule(jsg::Lock&, const jsg::Url&) {}\n \n+  void waitUntil(kj::Promise<void> promise) {\n+    JSG_REQUIRE(IoContext::hasCurrent(), Error, \"waitUntil requires an active request\");",
        "comment_created_at": "2025-07-18T17:41:45+00:00",
        "comment_author": "anonrig",
        "comment_body": "Thanks. Yes, I'll update.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2130802772",
    "pr_number": 4238,
    "pr_file": "src/workerd/io/container-client.c++",
    "created_at": "2025-06-05T22:58:31+00:00",
    "commented_code": "+// Copyright (c) 2025 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+#include \"container-client.h\"\n+\n+#include <kj/array.h>\n+#include <kj/debug.h>\n+\n+namespace workerd::io {\n+\n+ContainerStreamSharedState::ContainerStreamSharedState() {}\n+\n+void ContainerStreamSharedState::enqueueMessage(::rust::Slice<const uint8_t> message) {\n+  auto lockedQueue = messageQueue.lockExclusive();\n+  for (auto& byte : message) {\n+    lockedQueue->push(byte);\n+  }\n+\n+  auto lockedWaiter = readWaiter.lockExclusive();\n+  KJ_IF_SOME(fulfiller, *lockedWaiter) {\n+    fulfiller->fulfill();\n+    *lockedWaiter = kj::none;\n+  }\n+}\n+\n+kj::Maybe<size_t> ContainerStreamSharedState::tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n+  auto lockedQueue = messageQueue.lockExclusive();\n+  if (lockedQueue->empty()) {\n+    return kj::none;\n+  }\n+\n+  size_t min = kj::min(lockedQueue->size(), maxBytes);\n+  KJ_REQUIRE(min > 0, \"Should never happen\");",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2130802772",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4238,
        "pr_file": "src/workerd/io/container-client.c++",
        "discussion_id": "2130802772",
        "commented_code": "@@ -0,0 +1,80 @@\n+// Copyright (c) 2025 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+\n+#include \"container-client.h\"\n+\n+#include <kj/array.h>\n+#include <kj/debug.h>\n+\n+namespace workerd::io {\n+\n+ContainerStreamSharedState::ContainerStreamSharedState() {}\n+\n+void ContainerStreamSharedState::enqueueMessage(::rust::Slice<const uint8_t> message) {\n+  auto lockedQueue = messageQueue.lockExclusive();\n+  for (auto& byte : message) {\n+    lockedQueue->push(byte);\n+  }\n+\n+  auto lockedWaiter = readWaiter.lockExclusive();\n+  KJ_IF_SOME(fulfiller, *lockedWaiter) {\n+    fulfiller->fulfill();\n+    *lockedWaiter = kj::none;\n+  }\n+}\n+\n+kj::Maybe<size_t> ContainerStreamSharedState::tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n+  auto lockedQueue = messageQueue.lockExclusive();\n+  if (lockedQueue->empty()) {\n+    return kj::none;\n+  }\n+\n+  size_t min = kj::min(lockedQueue->size(), maxBytes);\n+  KJ_REQUIRE(min > 0, \"Should never happen\");",
        "comment_created_at": "2025-06-05T22:58:31+00:00",
        "comment_author": "jasnell",
        "comment_body": "For these, use `KJ_ASSERT` rather than `KJ_REQUIRE`",
        "pr_file_module": null
      }
    ]
  }
]