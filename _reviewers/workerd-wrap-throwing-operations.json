[
  {
    "discussion_id": "2268859171",
    "pr_number": 4699,
    "pr_file": "src/pyodide/internal/snapshot.ts",
    "created_at": "2025-08-12T07:19:27+00:00",
    "commented_code": "return deduplicatedModules;\n }\n \n+function describeValue(val: any): string {\n+  try {\n+    const out = [];\n+\n+    const type = typeof val;\n+    const isObject = type === 'object';\n+    out.push(`Value: ${val}`);\n+    out.push(`Type: ${type}`);\n+\n+    if (val && isObject) {\n+      try {\n+        out.push(\n+          `Keys: ${Object.keys(val as Record<string, unknown>)\n+            .slice(0, 10)\n+            .join(', ')}`\n+        );\n+      } catch {\n+        // Ignore errors when getting keys\n+      }\n+    }\n+\n+    if (val && isObject && val.stack && typeof val.stack === 'string') {\n+      out.push(`Stack:\n${val.stack}`);\n+    }",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2268859171",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4699,
        "pr_file": "src/pyodide/internal/snapshot.ts",
        "discussion_id": "2268859171",
        "commented_code": "@@ -383,22 +425,105 @@ function memorySnapshotDoImports(Module: Module): string[] {\n   return deduplicatedModules;\n }\n \n+function describeValue(val: any): string {\n+  try {\n+    const out = [];\n+\n+    const type = typeof val;\n+    const isObject = type === 'object';\n+    out.push(`Value: ${val}`);\n+    out.push(`Type: ${type}`);\n+\n+    if (val && isObject) {\n+      try {\n+        out.push(\n+          `Keys: ${Object.keys(val as Record<string, unknown>)\n+            .slice(0, 10)\n+            .join(', ')}`\n+        );\n+      } catch {\n+        // Ignore errors when getting keys\n+      }\n+    }\n+\n+    if (val && isObject && val.stack && typeof val.stack === 'string') {\n+      out.push(`Stack:\\n${val.stack}`);\n+    }",
        "comment_created_at": "2025-08-12T07:19:27+00:00",
        "comment_author": "hoodmane",
        "comment_body": "We need another try/catch around this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2269346054",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4699,
        "pr_file": "src/pyodide/internal/snapshot.ts",
        "discussion_id": "2268859171",
        "commented_code": "@@ -383,22 +425,105 @@ function memorySnapshotDoImports(Module: Module): string[] {\n   return deduplicatedModules;\n }\n \n+function describeValue(val: any): string {\n+  try {\n+    const out = [];\n+\n+    const type = typeof val;\n+    const isObject = type === 'object';\n+    out.push(`Value: ${val}`);\n+    out.push(`Type: ${type}`);\n+\n+    if (val && isObject) {\n+      try {\n+        out.push(\n+          `Keys: ${Object.keys(val as Record<string, unknown>)\n+            .slice(0, 10)\n+            .join(', ')}`\n+        );\n+      } catch {\n+        // Ignore errors when getting keys\n+      }\n+    }\n+\n+    if (val && isObject && val.stack && typeof val.stack === 'string') {\n+      out.push(`Stack:\\n${val.stack}`);\n+    }",
        "comment_created_at": "2025-08-12T10:01:18+00:00",
        "comment_author": "dom96",
        "comment_body": "Why?",
        "pr_file_module": null
      },
      {
        "comment_id": "2269424663",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4699,
        "pr_file": "src/pyodide/internal/snapshot.ts",
        "discussion_id": "2268859171",
        "commented_code": "@@ -383,22 +425,105 @@ function memorySnapshotDoImports(Module: Module): string[] {\n   return deduplicatedModules;\n }\n \n+function describeValue(val: any): string {\n+  try {\n+    const out = [];\n+\n+    const type = typeof val;\n+    const isObject = type === 'object';\n+    out.push(`Value: ${val}`);\n+    out.push(`Type: ${type}`);\n+\n+    if (val && isObject) {\n+      try {\n+        out.push(\n+          `Keys: ${Object.keys(val as Record<string, unknown>)\n+            .slice(0, 10)\n+            .join(', ')}`\n+        );\n+      } catch {\n+        // Ignore errors when getting keys\n+      }\n+    }\n+\n+    if (val && isObject && val.stack && typeof val.stack === 'string') {\n+      out.push(`Stack:\\n${val.stack}`);\n+    }",
        "comment_created_at": "2025-08-12T10:34:29+00:00",
        "comment_author": "hoodmane",
        "comment_body": "`val.stack` can throw an error.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2232132457",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_incoming.ts",
    "created_at": "2025-07-25T22:44:00+00:00",
    "commented_code": "});\n \n     this.on('timeout', () => {\n-      this.#reading = false;\n+      this._consuming = false;\n     });\n \n-    this.#reader = this.#response.body?.getReader();\n-    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n-    this.#tryRead();\n+    this._stream = this.#response.body;\n   }\n \n   async #tryRead(): Promise<void> {\n-    if (!this.#reader || this.#reading || this.#aborted) return;\n-\n-    this.#reading = true;\n+    if (this._stream == null) return;\n \n+    this.#reader ??= this._stream.getReader();\n     try {\n-      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n-      while (true) {\n-        const { done, value } = await this.#reader.read();\n-        if (done) {\n-          break;\n-        }\n-        this.push(value);\n+      const data = await this.#reader.read();",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2232132457",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_incoming.ts",
        "discussion_id": "2232132457",
        "commented_code": "@@ -60,86 +94,335 @@ export class IncomingMessage extends Readable implements _IncomingMessage {\n     });\n \n     this.on('timeout', () => {\n-      this.#reading = false;\n+      this._consuming = false;\n     });\n \n-    this.#reader = this.#response.body?.getReader();\n-    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n-    this.#tryRead();\n+    this._stream = this.#response.body;\n   }\n \n   async #tryRead(): Promise<void> {\n-    if (!this.#reader || this.#reading || this.#aborted) return;\n-\n-    this.#reading = true;\n+    if (this._stream == null) return;\n \n+    this.#reader ??= this._stream.getReader();\n     try {\n-      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n-      while (true) {\n-        const { done, value } = await this.#reader.read();\n-        if (done) {\n-          break;\n-        }\n-        this.push(value);\n+      const data = await this.#reader.read();",
        "comment_created_at": "2025-07-25T22:44:00+00:00",
        "comment_author": "jasnell",
        "comment_body": "I'd move the `getReader()` call into the `try` here. getReader() can throw and that should not be ignored and should lead to `this` being destroyed.\r\n\r\n```suggestion\r\n      this.#reader ??= this._stream.getReader();\r\n      const data = await this.#reader.read();\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2232354157",
    "pr_number": 4591,
    "pr_file": "src/node/internal/internal_http_server.ts",
    "created_at": "2025-07-26T01:53:44+00:00",
    "commented_code": "+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+// This module implements Node.js-compatible HTTP server functionality on top of\n+// the fetch API due to workerd limitations. The key challenge is bridging Node.js's\n+// stream-based API with the Fetch API's Request/Response model.\n+//\n+// The ServerResponse class implements a single-buffer strategy to minimize memory\n+// usage when converting from Node.js streams to Fetch Response bodies:\n+// - Pre-header data is temporarily buffered until headers are sent\n+// - Post-header data streams directly without intermediate buffering\n+// - Memory is freed immediately after the transition point\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import { STATUS_CODES } from 'node-internal:internal_http_constants';\n+import {\n+  kServerResponse,\n+  kIncomingMessage,\n+} from 'node-internal:internal_http_util';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket, AddressInfo } from 'node:net';\n+import { default as flags } from 'workerd:compatibility-flags';\n+\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+let serverRegistry: FinalizationRegistry<number> | null = null;\n+\n+// Since finalization registry is only available under a specific compat flag,\n+// let's check if it's enabled to preserve backward compatibility.\n+if (flags.jsWeakRef) {\n+  serverRegistry = new FinalizationRegistry((port) => {\n+    portMapper.delete(port);\n+  });\n+}\n+\n+export type StreamController = ReadableStreamDefaultController<Uint8Array>;\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kIncomingMessage]: typeof IncomingMessage = IncomingMessage;\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kServerResponse]: typeof ServerResponse = ServerResponse;\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+  connectionsCheckingInterval = 30_000;\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port: number | null = null;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    if (!flags.enableNodejsHttpServerModules) {\n+      throw new ERR_METHOD_NOT_IMPLEMENTED('Server');\n+    }\n+    super();\n+\n+    if (options != null) {\n+      // @ts-expect-error TS2345 TODO(soon): Find a better way to handle this type mismatch.\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    // TODO(soon): Support options.highWaterMark option.\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(callback?: VoidFunction): this {\n+    httpServerPreClose(this);\n+    if (this.port != null) {\n+      portMapper.delete(this.port);\n+      serverRegistry?.unregister(this);\n+      this.port = null;\n+    }\n+    this.emit('close');\n+    queueMicrotask(() => {\n+      callback?.();\n+    });\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);",
    "repo_full_name": "cloudflare/workerd",
    "discussion_comments": [
      {
        "comment_id": "2232354157",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2232354157",
        "commented_code": "@@ -0,0 +1,760 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+// This module implements Node.js-compatible HTTP server functionality on top of\n+// the fetch API due to workerd limitations. The key challenge is bridging Node.js's\n+// stream-based API with the Fetch API's Request/Response model.\n+//\n+// The ServerResponse class implements a single-buffer strategy to minimize memory\n+// usage when converting from Node.js streams to Fetch Response bodies:\n+// - Pre-header data is temporarily buffered until headers are sent\n+// - Post-header data streams directly without intermediate buffering\n+// - Memory is freed immediately after the transition point\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import { STATUS_CODES } from 'node-internal:internal_http_constants';\n+import {\n+  kServerResponse,\n+  kIncomingMessage,\n+} from 'node-internal:internal_http_util';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket, AddressInfo } from 'node:net';\n+import { default as flags } from 'workerd:compatibility-flags';\n+\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+let serverRegistry: FinalizationRegistry<number> | null = null;\n+\n+// Since finalization registry is only available under a specific compat flag,\n+// let's check if it's enabled to preserve backward compatibility.\n+if (flags.jsWeakRef) {\n+  serverRegistry = new FinalizationRegistry((port) => {\n+    portMapper.delete(port);\n+  });\n+}\n+\n+export type StreamController = ReadableStreamDefaultController<Uint8Array>;\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kIncomingMessage]: typeof IncomingMessage = IncomingMessage;\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kServerResponse]: typeof ServerResponse = ServerResponse;\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+  connectionsCheckingInterval = 30_000;\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port: number | null = null;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    if (!flags.enableNodejsHttpServerModules) {\n+      throw new ERR_METHOD_NOT_IMPLEMENTED('Server');\n+    }\n+    super();\n+\n+    if (options != null) {\n+      // @ts-expect-error TS2345 TODO(soon): Find a better way to handle this type mismatch.\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    // TODO(soon): Support options.highWaterMark option.\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(callback?: VoidFunction): this {\n+    httpServerPreClose(this);\n+    if (this.port != null) {\n+      portMapper.delete(this.port);\n+      serverRegistry?.unregister(this);\n+      this.port = null;\n+    }\n+    this.emit('close');\n+    queueMicrotask(() => {\n+      callback?.();\n+    });\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);",
        "comment_created_at": "2025-07-26T01:53:44+00:00",
        "comment_author": "jasnell",
        "comment_body": "Currently, if any errors are thrown synchronously here they will bubble up to the regular fetch handler, erroring the request, which is fine if that's what we want. However, I think we should consider wrapping this in a try/catch and erroring the server.",
        "pr_file_module": null
      },
      {
        "comment_id": "2236566076",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2232354157",
        "commented_code": "@@ -0,0 +1,760 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+// This module implements Node.js-compatible HTTP server functionality on top of\n+// the fetch API due to workerd limitations. The key challenge is bridging Node.js's\n+// stream-based API with the Fetch API's Request/Response model.\n+//\n+// The ServerResponse class implements a single-buffer strategy to minimize memory\n+// usage when converting from Node.js streams to Fetch Response bodies:\n+// - Pre-header data is temporarily buffered until headers are sent\n+// - Post-header data streams directly without intermediate buffering\n+// - Memory is freed immediately after the transition point\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import { STATUS_CODES } from 'node-internal:internal_http_constants';\n+import {\n+  kServerResponse,\n+  kIncomingMessage,\n+} from 'node-internal:internal_http_util';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket, AddressInfo } from 'node:net';\n+import { default as flags } from 'workerd:compatibility-flags';\n+\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+let serverRegistry: FinalizationRegistry<number> | null = null;\n+\n+// Since finalization registry is only available under a specific compat flag,\n+// let's check if it's enabled to preserve backward compatibility.\n+if (flags.jsWeakRef) {\n+  serverRegistry = new FinalizationRegistry((port) => {\n+    portMapper.delete(port);\n+  });\n+}\n+\n+export type StreamController = ReadableStreamDefaultController<Uint8Array>;\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kIncomingMessage]: typeof IncomingMessage = IncomingMessage;\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kServerResponse]: typeof ServerResponse = ServerResponse;\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+  connectionsCheckingInterval = 30_000;\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port: number | null = null;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    if (!flags.enableNodejsHttpServerModules) {\n+      throw new ERR_METHOD_NOT_IMPLEMENTED('Server');\n+    }\n+    super();\n+\n+    if (options != null) {\n+      // @ts-expect-error TS2345 TODO(soon): Find a better way to handle this type mismatch.\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    // TODO(soon): Support options.highWaterMark option.\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(callback?: VoidFunction): this {\n+    httpServerPreClose(this);\n+    if (this.port != null) {\n+      portMapper.delete(this.port);\n+      serverRegistry?.unregister(this);\n+      this.port = null;\n+    }\n+    this.emit('close');\n+    queueMicrotask(() => {\n+      callback?.();\n+    });\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);",
        "comment_created_at": "2025-07-28T13:49:17+00:00",
        "comment_author": "jasnell",
        "comment_body": "Not sure why this was marked resolved. I think we still need to answer this question about whether the error should bubble up or should just error the server.",
        "pr_file_module": null
      },
      {
        "comment_id": "2236960147",
        "repo_full_name": "cloudflare/workerd",
        "pr_number": 4591,
        "pr_file": "src/node/internal/internal_http_server.ts",
        "discussion_id": "2232354157",
        "commented_code": "@@ -0,0 +1,760 @@\n+// Copyright (c) 2017-2022 Cloudflare, Inc.\n+// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n+//     https://opensource.org/licenses/Apache-2.0\n+// Copyright Joyent and Node contributors. All rights reserved. MIT license.\n+\n+// This module implements Node.js-compatible HTTP server functionality on top of\n+// the fetch API due to workerd limitations. The key challenge is bridging Node.js's\n+// stream-based API with the Fetch API's Request/Response model.\n+//\n+// The ServerResponse class implements a single-buffer strategy to minimize memory\n+// usage when converting from Node.js streams to Fetch Response bodies:\n+// - Pre-header data is temporarily buffered until headers are sent\n+// - Post-header data streams directly without intermediate buffering\n+// - Memory is freed immediately after the transition point\n+\n+import {\n+  ERR_METHOD_NOT_IMPLEMENTED,\n+  ERR_HTTP_HEADERS_SENT,\n+  ERR_HTTP_INVALID_STATUS_CODE,\n+  ERR_INVALID_CHAR,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_OUT_OF_RANGE,\n+  ERR_OPTION_NOT_IMPLEMENTED,\n+  ERR_SERVER_ALREADY_LISTEN,\n+} from 'node-internal:internal_errors';\n+import { EventEmitter } from 'node-internal:events';\n+import {\n+  kUniqueHeaders,\n+  OutgoingMessage,\n+  parseUniqueHeadersOption,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  validateBoolean,\n+  validateInteger,\n+  validateObject,\n+  validatePort,\n+} from 'node-internal:validators';\n+import { portMapper } from 'cloudflare-internal:http';\n+import { IncomingMessage } from 'node-internal:internal_http_incoming';\n+import { STATUS_CODES } from 'node-internal:internal_http_constants';\n+import {\n+  kServerResponse,\n+  kIncomingMessage,\n+} from 'node-internal:internal_http_util';\n+import {\n+  kOutHeaders,\n+  WrittenDataBufferEntry,\n+  HeadersSentEvent,\n+} from 'node-internal:internal_http_outgoing';\n+import {\n+  chunkExpression,\n+  _checkInvalidHeaderChar,\n+} from 'node-internal:internal_http';\n+import { _normalizeArgs } from 'node-internal:internal_net';\n+import { Buffer } from 'node-internal:internal_buffer';\n+\n+import type {\n+  Server as _Server,\n+  ServerResponse as _ServerResponse,\n+  RequestListener,\n+  ServerOptions,\n+  OutgoingHttpHeaders,\n+  OutgoingHttpHeader,\n+} from 'node:http';\n+import type { Socket, AddressInfo } from 'node:net';\n+import { default as flags } from 'workerd:compatibility-flags';\n+\n+export const kConnectionsCheckingInterval = Symbol(\n+  'http.server.connectionsCheckingInterval'\n+);\n+\n+let serverRegistry: FinalizationRegistry<number> | null = null;\n+\n+// Since finalization registry is only available under a specific compat flag,\n+// let's check if it's enabled to preserve backward compatibility.\n+if (flags.jsWeakRef) {\n+  serverRegistry = new FinalizationRegistry((port) => {\n+    portMapper.delete(port);\n+  });\n+}\n+\n+export type StreamController = ReadableStreamDefaultController<Uint8Array>;\n+\n+export type DataWrittenEvent = {\n+  index: number;\n+  entry: WrittenDataBufferEntry;\n+};\n+\n+export class Server\n+  extends EventEmitter\n+  implements _Server, BaseWithHttpOptions\n+{\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kIncomingMessage]: typeof IncomingMessage = IncomingMessage;\n+  // @ts-expect-error TS2416 Server is not assignable to same property in base type.\n+  [kServerResponse]: typeof ServerResponse = ServerResponse;\n+  [kConnectionsCheckingInterval]?: number;\n+  [kUniqueHeaders]: Set<string> | null = null;\n+\n+  // Similar option to this. Too lazy to write my own docs.\n+  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n+  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n+  httpAllowHalfOpen = false;\n+  timeout = 0;\n+  maxHeadersCount: number | null = null;\n+  maxRequestsPerSocket = 0;\n+  connectionsCheckingInterval = 30_000;\n+  requestTimeout: number = 0;\n+  headersTimeout: number = 0;\n+  requireHostHeader: boolean = false;\n+  joinDuplicateHeaders: boolean = false;\n+  rejectNonStandardBodyWrites: boolean = false;\n+  keepAliveTimeout: number = 5_000;\n+  port: number | null = null;\n+\n+  constructor(options?: ServerOptions, requestListener?: RequestListener) {\n+    if (!flags.enableNodejsHttpServerModules) {\n+      throw new ERR_METHOD_NOT_IMPLEMENTED('Server');\n+    }\n+    super();\n+\n+    if (options != null) {\n+      // @ts-expect-error TS2345 TODO(soon): Find a better way to handle this type mismatch.\n+      storeHTTPOptions.call(this, options);\n+    }\n+\n+    // TODO(soon): Support options.highWaterMark option.\n+\n+    if (typeof options === 'function') {\n+      requestListener = options;\n+      options = {};\n+    } else if (options == null) {\n+      options = {};\n+    } else {\n+      validateObject(options, 'options');\n+    }\n+\n+    if (requestListener) {\n+      this.on('request', requestListener);\n+    }\n+\n+    this[kUniqueHeaders] = parseUniqueHeadersOption(\n+      options.uniqueHeaders as (string | string[])[]\n+    );\n+  }\n+\n+  close(callback?: VoidFunction): this {\n+    httpServerPreClose(this);\n+    if (this.port != null) {\n+      portMapper.delete(this.port);\n+      serverRegistry?.unregister(this);\n+      this.port = null;\n+    }\n+    this.emit('close');\n+    queueMicrotask(() => {\n+      callback?.();\n+    });\n+    return this;\n+  }\n+\n+  closeAllConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  closeIdleConnections(): void {\n+    // It doesn't make sense to support this method.\n+    // Leave it as a noop.\n+  }\n+\n+  setTimeout(\n+    msecs?: number | ((socket: Socket) => void),\n+    callback?: (socket: Socket) => void\n+  ): this {\n+    if (typeof msecs === 'function') {\n+      callback = msecs;\n+      msecs = undefined;\n+    } else if (typeof msecs === 'number') {\n+      this.timeout = msecs;\n+    }\n+\n+    if (typeof callback === 'function') {\n+      this.once('timeout', callback);\n+    }\n+    return this;\n+  }\n+\n+  async #onRequest(request: Request): Promise<Response> {\n+    const { incoming, response } = this.#toReqRes(request);\n+    this.emit('connection', this, incoming);\n+    this.emit('request', incoming, response);\n+    return getServerResponseFetchResponse(response);",
        "comment_created_at": "2025-07-28T15:29:40+00:00",
        "comment_author": "anonrig",
        "comment_body": "I updated the code to imitate Node.js \r\n\r\n```js\r\n  async #onRequest(request: Request): Promise<Response> {\r\n    const { incoming, response } = this.#toReqRes(request);\r\n    try {\r\n      this.emit('connection', this, incoming);\r\n      this.emit('request', incoming, response);\r\n      return await getServerResponseFetchResponse(response);\r\n    } catch (error: unknown) {\r\n      response.destroy(error);\r\n      throw error;\r\n    }\r\n  }\r\n```",
        "pr_file_module": null
      }
    ]
  }
]