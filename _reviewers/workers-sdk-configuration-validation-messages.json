[
  {
    "discussion_id": "2282449159",
    "pr_number": 10393,
    "pr_file": "packages/wrangler/src/deploy/config-diffs.ts",
    "created_at": "2025-08-18T13:44:10+00:00",
    "commented_code": "return true;\n }\n \n+/**\n+ * Normalized a local (resolved) config object so that it can be compared against\n+ * the remote config object. This mainly means resolving and setting defaults to\n+ * the local configuration to match the values in the remote one.\n+ *\n+ * @param localResolvedConfig The local (resolved) config object to normalize\n+ * @returns The normalized config\n+ */\n+function normalizeLocalResolvedConfigAsRemote(\n+\tlocalResolvedConfig: Config\n+): Config {\n+\tconst normalizedConfig: Config = {\n+\t\t...localResolvedConfig,\n+\t\tworkers_dev: getResolvedWorkersDev(\n+\t\t\tlocalResolvedConfig.workers_dev,\n+\t\t\tlocalResolvedConfig.routes ?? []\n+\t\t),\n+\t};\n+\n+\tif (!normalizedConfig.observability) {\n+\t\tnormalizedConfig.observability = {};\n+\t}\n+\n+\tif (!(\"enabled\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.enabled = true;\n+\t}\n+\n+\tif (!(\"head_sampling_rate\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.head_sampling_rate = 1;\n+\t}\n+\n+\tif (normalizedConfig.observability.logs) {\n+\t\t// If the `logs` observability sub-field is present we make\n+\t\t// sure to set its default remote values if not present\n+\n+\t\tif (!(\"enabled\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.enabled = true;\n+\t\t}\n+\n+\t\tif (!(\"head_sampling_rate\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.head_sampling_rate = 1;\n+\t\t}\n+\n+\t\tif (!(\"invocation_logs\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.invocation_logs = true;\n+\t\t}\n+\t}\n+\n+\treturn normalizedConfig;\n+}",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2282449159",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10393,
        "pr_file": "packages/wrangler/src/deploy/config-diffs.ts",
        "discussion_id": "2282449159",
        "commented_code": "@@ -108,6 +111,57 @@ function configDiffOnlyHasAdditionsIfAny(diff: Diff): boolean {\n \treturn true;\n }\n \n+/**\n+ * Normalized a local (resolved) config object so that it can be compared against\n+ * the remote config object. This mainly means resolving and setting defaults to\n+ * the local configuration to match the values in the remote one.\n+ *\n+ * @param localResolvedConfig The local (resolved) config object to normalize\n+ * @returns The normalized config\n+ */\n+function normalizeLocalResolvedConfigAsRemote(\n+\tlocalResolvedConfig: Config\n+): Config {\n+\tconst normalizedConfig: Config = {\n+\t\t...localResolvedConfig,\n+\t\tworkers_dev: getResolvedWorkersDev(\n+\t\t\tlocalResolvedConfig.workers_dev,\n+\t\t\tlocalResolvedConfig.routes ?? []\n+\t\t),\n+\t};\n+\n+\tif (!normalizedConfig.observability) {\n+\t\tnormalizedConfig.observability = {};\n+\t}\n+\n+\tif (!(\"enabled\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.enabled = true;\n+\t}\n+\n+\tif (!(\"head_sampling_rate\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.head_sampling_rate = 1;\n+\t}\n+\n+\tif (normalizedConfig.observability.logs) {\n+\t\t// If the `logs` observability sub-field is present we make\n+\t\t// sure to set its default remote values if not present\n+\n+\t\tif (!(\"enabled\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.enabled = true;\n+\t\t}\n+\n+\t\tif (!(\"head_sampling_rate\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.head_sampling_rate = 1;\n+\t\t}\n+\n+\t\tif (!(\"invocation_logs\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.invocation_logs = true;\n+\t\t}\n+\t}\n+\n+\treturn normalizedConfig;\n+}",
        "comment_created_at": "2025-08-18T13:44:10+00:00",
        "comment_author": "edmundhung",
        "comment_body": "I wonder if this is better be done in `normalizeAndValidateConfig` directly:\r\n\r\nhttps://github.com/cloudflare/workers-sdk/blob/516dc20be624042533af0cd0b4205f92e256bb3f/packages/wrangler/src/config/index.ts#L101C34-L106\r\n\r\nThat way we can share the same default value as in the dashboard everywhere.",
        "pr_file_module": null
      },
      {
        "comment_id": "2282769991",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10393,
        "pr_file": "packages/wrangler/src/deploy/config-diffs.ts",
        "discussion_id": "2282449159",
        "commented_code": "@@ -108,6 +111,57 @@ function configDiffOnlyHasAdditionsIfAny(diff: Diff): boolean {\n \treturn true;\n }\n \n+/**\n+ * Normalized a local (resolved) config object so that it can be compared against\n+ * the remote config object. This mainly means resolving and setting defaults to\n+ * the local configuration to match the values in the remote one.\n+ *\n+ * @param localResolvedConfig The local (resolved) config object to normalize\n+ * @returns The normalized config\n+ */\n+function normalizeLocalResolvedConfigAsRemote(\n+\tlocalResolvedConfig: Config\n+): Config {\n+\tconst normalizedConfig: Config = {\n+\t\t...localResolvedConfig,\n+\t\tworkers_dev: getResolvedWorkersDev(\n+\t\t\tlocalResolvedConfig.workers_dev,\n+\t\t\tlocalResolvedConfig.routes ?? []\n+\t\t),\n+\t};\n+\n+\tif (!normalizedConfig.observability) {\n+\t\tnormalizedConfig.observability = {};\n+\t}\n+\n+\tif (!(\"enabled\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.enabled = true;\n+\t}\n+\n+\tif (!(\"head_sampling_rate\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.head_sampling_rate = 1;\n+\t}\n+\n+\tif (normalizedConfig.observability.logs) {\n+\t\t// If the `logs` observability sub-field is present we make\n+\t\t// sure to set its default remote values if not present\n+\n+\t\tif (!(\"enabled\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.enabled = true;\n+\t\t}\n+\n+\t\tif (!(\"head_sampling_rate\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.head_sampling_rate = 1;\n+\t\t}\n+\n+\t\tif (!(\"invocation_logs\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.invocation_logs = true;\n+\t\t}\n+\t}\n+\n+\treturn normalizedConfig;\n+}",
        "comment_created_at": "2025-08-18T15:37:54+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "I think that `workers_dev` shouldn't be done there since its resolution is specific to the deploy command\r\n\r\n(\r\nsee: https://github.com/cloudflare/workers-sdk/blob/0c04da9b3a8dcf1220b46a0fdd463ba0bad0f9a1/packages/wrangler/src/triggers/deploy.ts#L55 where `routes` comes from:\r\nhttps://github.com/cloudflare/workers-sdk/blob/0c04da9b3a8dcf1220b46a0fdd463ba0bad0f9a1/packages/wrangler/src/triggers/deploy.ts#L41-L42)\r\n\r\nBut the other normalizations/default settings yes I think you're right that they should be done as part of `normalizeAndValidateConfig` \ud83e\udd14 \ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "2301653102",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10393,
        "pr_file": "packages/wrangler/src/deploy/config-diffs.ts",
        "discussion_id": "2282449159",
        "commented_code": "@@ -108,6 +111,57 @@ function configDiffOnlyHasAdditionsIfAny(diff: Diff): boolean {\n \treturn true;\n }\n \n+/**\n+ * Normalized a local (resolved) config object so that it can be compared against\n+ * the remote config object. This mainly means resolving and setting defaults to\n+ * the local configuration to match the values in the remote one.\n+ *\n+ * @param localResolvedConfig The local (resolved) config object to normalize\n+ * @returns The normalized config\n+ */\n+function normalizeLocalResolvedConfigAsRemote(\n+\tlocalResolvedConfig: Config\n+): Config {\n+\tconst normalizedConfig: Config = {\n+\t\t...localResolvedConfig,\n+\t\tworkers_dev: getResolvedWorkersDev(\n+\t\t\tlocalResolvedConfig.workers_dev,\n+\t\t\tlocalResolvedConfig.routes ?? []\n+\t\t),\n+\t};\n+\n+\tif (!normalizedConfig.observability) {\n+\t\tnormalizedConfig.observability = {};\n+\t}\n+\n+\tif (!(\"enabled\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.enabled = true;\n+\t}\n+\n+\tif (!(\"head_sampling_rate\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.head_sampling_rate = 1;\n+\t}\n+\n+\tif (normalizedConfig.observability.logs) {\n+\t\t// If the `logs` observability sub-field is present we make\n+\t\t// sure to set its default remote values if not present\n+\n+\t\tif (!(\"enabled\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.enabled = true;\n+\t\t}\n+\n+\t\tif (!(\"head_sampling_rate\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.head_sampling_rate = 1;\n+\t\t}\n+\n+\t\tif (!(\"invocation_logs\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.invocation_logs = true;\n+\t\t}\n+\t}\n+\n+\treturn normalizedConfig;\n+}",
        "comment_created_at": "2025-08-26T17:23:22+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "Done, I've moved the defaulting logic to `normalizeAndValidateConfig` \ud83d\ude04, please have another look \ud83d\ude4f ",
        "pr_file_module": null
      },
      {
        "comment_id": "2301904969",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10393,
        "pr_file": "packages/wrangler/src/deploy/config-diffs.ts",
        "discussion_id": "2282449159",
        "commented_code": "@@ -108,6 +111,57 @@ function configDiffOnlyHasAdditionsIfAny(diff: Diff): boolean {\n \treturn true;\n }\n \n+/**\n+ * Normalized a local (resolved) config object so that it can be compared against\n+ * the remote config object. This mainly means resolving and setting defaults to\n+ * the local configuration to match the values in the remote one.\n+ *\n+ * @param localResolvedConfig The local (resolved) config object to normalize\n+ * @returns The normalized config\n+ */\n+function normalizeLocalResolvedConfigAsRemote(\n+\tlocalResolvedConfig: Config\n+): Config {\n+\tconst normalizedConfig: Config = {\n+\t\t...localResolvedConfig,\n+\t\tworkers_dev: getResolvedWorkersDev(\n+\t\t\tlocalResolvedConfig.workers_dev,\n+\t\t\tlocalResolvedConfig.routes ?? []\n+\t\t),\n+\t};\n+\n+\tif (!normalizedConfig.observability) {\n+\t\tnormalizedConfig.observability = {};\n+\t}\n+\n+\tif (!(\"enabled\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.enabled = true;\n+\t}\n+\n+\tif (!(\"head_sampling_rate\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.head_sampling_rate = 1;\n+\t}\n+\n+\tif (normalizedConfig.observability.logs) {\n+\t\t// If the `logs` observability sub-field is present we make\n+\t\t// sure to set its default remote values if not present\n+\n+\t\tif (!(\"enabled\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.enabled = true;\n+\t\t}\n+\n+\t\tif (!(\"head_sampling_rate\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.head_sampling_rate = 1;\n+\t\t}\n+\n+\t\tif (!(\"invocation_logs\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.invocation_logs = true;\n+\t\t}\n+\t}\n+\n+\treturn normalizedConfig;\n+}",
        "comment_created_at": "2025-08-26T19:13:46+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "I'm working though moving the logic into `normalizeAndValidateConfig`, unfortunately I am hitting a bit of a road block here: https://github.com/cloudflare/workers-sdk/blob/7c339aeb0392e41b9a306c84538950f32c9a0dd4/packages/wrangler/src/__tests__/containers/deploy.test.ts#L1396\r\n\r\nI'll try to see if there's a workaround \ud83d\ude13",
        "pr_file_module": null
      },
      {
        "comment_id": "2304602370",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10393,
        "pr_file": "packages/wrangler/src/deploy/config-diffs.ts",
        "discussion_id": "2282449159",
        "commented_code": "@@ -108,6 +111,57 @@ function configDiffOnlyHasAdditionsIfAny(diff: Diff): boolean {\n \treturn true;\n }\n \n+/**\n+ * Normalized a local (resolved) config object so that it can be compared against\n+ * the remote config object. This mainly means resolving and setting defaults to\n+ * the local configuration to match the values in the remote one.\n+ *\n+ * @param localResolvedConfig The local (resolved) config object to normalize\n+ * @returns The normalized config\n+ */\n+function normalizeLocalResolvedConfigAsRemote(\n+\tlocalResolvedConfig: Config\n+): Config {\n+\tconst normalizedConfig: Config = {\n+\t\t...localResolvedConfig,\n+\t\tworkers_dev: getResolvedWorkersDev(\n+\t\t\tlocalResolvedConfig.workers_dev,\n+\t\t\tlocalResolvedConfig.routes ?? []\n+\t\t),\n+\t};\n+\n+\tif (!normalizedConfig.observability) {\n+\t\tnormalizedConfig.observability = {};\n+\t}\n+\n+\tif (!(\"enabled\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.enabled = true;\n+\t}\n+\n+\tif (!(\"head_sampling_rate\" in normalizedConfig.observability)) {\n+\t\tnormalizedConfig.observability.head_sampling_rate = 1;\n+\t}\n+\n+\tif (normalizedConfig.observability.logs) {\n+\t\t// If the `logs` observability sub-field is present we make\n+\t\t// sure to set its default remote values if not present\n+\n+\t\tif (!(\"enabled\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.enabled = true;\n+\t\t}\n+\n+\t\tif (!(\"head_sampling_rate\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.head_sampling_rate = 1;\n+\t\t}\n+\n+\t\tif (!(\"invocation_logs\" in normalizedConfig.observability.logs)) {\n+\t\t\tnormalizedConfig.observability.logs.invocation_logs = true;\n+\t\t}\n+\t}\n+\n+\treturn normalizedConfig;\n+}",
        "comment_created_at": "2025-08-27T16:33:55+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "I've updated this logic as it was a bit off.\r\n\r\nHowever regarding moving it to the `normalizeAndValidateConfig` I no longer think that that's necessarily appropriate since we're trying to make the local config similar to the remote one, but doing that in the `normalizeAndValidateConfig` function could potentially change how values are resolved, potentially causing unexpected behaviors.\r\n\r\nAlso this is very much geared towards aligning the local config to the remote one and trying to follow what the remote one does. If the remote one were to change later on, updating the logic here would be all we'd need to do in order to support that change, but if this logic was embedded into `normalizeAndValidateConfig` updating it could be more risky/potentially breaky.\r\n\r\nwhat do you think? \ud83e\udd14 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293511760",
    "pr_number": 10437,
    "pr_file": "packages/miniflare/src/index.ts",
    "created_at": "2025-08-22T11:49:20+00:00",
    "commented_code": "// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n-\t\t\t\t\tthrow new MiniflareCoreError(\n-\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n-\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n-\t\t\t\t\t\t\tenableSql\n-\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n-\t\t\t\t\t);\n+\t\t\t\tif (existingInfo && existingInfo?.enableSql !== enableSql) {\n+\t\t\t\t\tconst existingEnableSql = existingInfo.enableSql;\n+\t\t\t\t\t// If one of the `enableSql` flags (either the current one or the existing one)\n+\t\t\t\t\t// is `true` and the other is `undefined`, we might be in a potentially valid\n+\t\t\t\t\t// situation in which worker A defines a DO marking it as SQL based, while worker\n+\t\t\t\t\t// B simply uses the DO from worker A without defining it, thus leaving `enableSql`\n+\t\t\t\t\t// as `undefined` (this is exactly what Wrangler does)\n+\t\t\t\t\tconst potentiallyValidSqlDiff =\n+\t\t\t\t\t\t(existingEnableSql === undefined && enableSql === true) ||\n+\t\t\t\t\t\t(enableSql === undefined && existingEnableSql === true);\n+\n+\t\t\t\t\tif (!potentiallyValidSqlDiff) {\n+\t\t\t\t\t\t// We only want to throw this error is we know that the DO configuration cannot\n+\t\t\t\t\t\t// be potentially valid\n+\t\t\t\t\t\tthrow new MiniflareCoreError(\n+\t\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n+\t\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n+\t\t\t\t\t\t\t\tenableSql\n+\t\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2293511760",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2293511760",
        "commented_code": "@@ -355,13 +355,27 @@ function getDurableObjectClassNames(\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n-\t\t\t\t\tthrow new MiniflareCoreError(\n-\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n-\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n-\t\t\t\t\t\t\tenableSql\n-\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n-\t\t\t\t\t);\n+\t\t\t\tif (existingInfo && existingInfo?.enableSql !== enableSql) {\n+\t\t\t\t\tconst existingEnableSql = existingInfo.enableSql;\n+\t\t\t\t\t// If one of the `enableSql` flags (either the current one or the existing one)\n+\t\t\t\t\t// is `true` and the other is `undefined`, we might be in a potentially valid\n+\t\t\t\t\t// situation in which worker A defines a DO marking it as SQL based, while worker\n+\t\t\t\t\t// B simply uses the DO from worker A without defining it, thus leaving `enableSql`\n+\t\t\t\t\t// as `undefined` (this is exactly what Wrangler does)\n+\t\t\t\t\tconst potentiallyValidSqlDiff =\n+\t\t\t\t\t\t(existingEnableSql === undefined && enableSql === true) ||\n+\t\t\t\t\t\t(enableSql === undefined && existingEnableSql === true);\n+\n+\t\t\t\t\tif (!potentiallyValidSqlDiff) {\n+\t\t\t\t\t\t// We only want to throw this error is we know that the DO configuration cannot\n+\t\t\t\t\t\t// be potentially valid\n+\t\t\t\t\t\tthrow new MiniflareCoreError(\n+\t\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n+\t\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n+\t\t\t\t\t\t\t\tenableSql\n+\t\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}",
        "comment_created_at": "2025-08-22T11:49:20+00:00",
        "comment_author": "edmundhung",
        "comment_body": "You might need to update the map with regards to the `enableSql` if `existingInfo.enableSql` is `undefined` but `enableSql` is `true`. I think we will use the map for some follow up operations (?)\r\n\r\nShould we apply the same check for `unsafeUniqueKey` and `unsafePreventEviction`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2294008099",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2293511760",
        "commented_code": "@@ -355,13 +355,27 @@ function getDurableObjectClassNames(\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n-\t\t\t\t\tthrow new MiniflareCoreError(\n-\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n-\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n-\t\t\t\t\t\t\tenableSql\n-\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n-\t\t\t\t\t);\n+\t\t\t\tif (existingInfo && existingInfo?.enableSql !== enableSql) {\n+\t\t\t\t\tconst existingEnableSql = existingInfo.enableSql;\n+\t\t\t\t\t// If one of the `enableSql` flags (either the current one or the existing one)\n+\t\t\t\t\t// is `true` and the other is `undefined`, we might be in a potentially valid\n+\t\t\t\t\t// situation in which worker A defines a DO marking it as SQL based, while worker\n+\t\t\t\t\t// B simply uses the DO from worker A without defining it, thus leaving `enableSql`\n+\t\t\t\t\t// as `undefined` (this is exactly what Wrangler does)\n+\t\t\t\t\tconst potentiallyValidSqlDiff =\n+\t\t\t\t\t\t(existingEnableSql === undefined && enableSql === true) ||\n+\t\t\t\t\t\t(enableSql === undefined && existingEnableSql === true);\n+\n+\t\t\t\t\tif (!potentiallyValidSqlDiff) {\n+\t\t\t\t\t\t// We only want to throw this error is we know that the DO configuration cannot\n+\t\t\t\t\t\t// be potentially valid\n+\t\t\t\t\t\tthrow new MiniflareCoreError(\n+\t\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n+\t\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n+\t\t\t\t\t\t\t\tenableSql\n+\t\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}",
        "comment_created_at": "2025-08-22T15:11:27+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "> You might need to update the map with regards to the enableSql if existingInfo.enableSql is undefined but enableSql is true. I think we will use the map for some follow up operations (?)\r\n\r\nI don't think that we use `existingInfo` for sql logic besides this? \ud83e\udd14 Also via manual testing my changes seemed enough in this regard, so unless something would break I think this should be ok? do you see/think of anything that could specifically break by not updating the map? \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2294025565",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2293511760",
        "commented_code": "@@ -355,13 +355,27 @@ function getDurableObjectClassNames(\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n-\t\t\t\t\tthrow new MiniflareCoreError(\n-\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n-\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n-\t\t\t\t\t\t\tenableSql\n-\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n-\t\t\t\t\t);\n+\t\t\t\tif (existingInfo && existingInfo?.enableSql !== enableSql) {\n+\t\t\t\t\tconst existingEnableSql = existingInfo.enableSql;\n+\t\t\t\t\t// If one of the `enableSql` flags (either the current one or the existing one)\n+\t\t\t\t\t// is `true` and the other is `undefined`, we might be in a potentially valid\n+\t\t\t\t\t// situation in which worker A defines a DO marking it as SQL based, while worker\n+\t\t\t\t\t// B simply uses the DO from worker A without defining it, thus leaving `enableSql`\n+\t\t\t\t\t// as `undefined` (this is exactly what Wrangler does)\n+\t\t\t\t\tconst potentiallyValidSqlDiff =\n+\t\t\t\t\t\t(existingEnableSql === undefined && enableSql === true) ||\n+\t\t\t\t\t\t(enableSql === undefined && existingEnableSql === true);\n+\n+\t\t\t\t\tif (!potentiallyValidSqlDiff) {\n+\t\t\t\t\t\t// We only want to throw this error is we know that the DO configuration cannot\n+\t\t\t\t\t\t// be potentially valid\n+\t\t\t\t\t\tthrow new MiniflareCoreError(\n+\t\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n+\t\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n+\t\t\t\t\t\t\t\tenableSql\n+\t\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}",
        "comment_created_at": "2025-08-22T15:17:36+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "> Should we apply the same check for unsafeUniqueKey and unsafePreventEviction?\r\n\r\nmh.... good question.... yeah I might just as well! \ud83e\udd14\ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "2294712631",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2293511760",
        "commented_code": "@@ -355,13 +355,27 @@ function getDurableObjectClassNames(\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n-\t\t\t\t\tthrow new MiniflareCoreError(\n-\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n-\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n-\t\t\t\t\t\t\tenableSql\n-\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n-\t\t\t\t\t);\n+\t\t\t\tif (existingInfo && existingInfo?.enableSql !== enableSql) {\n+\t\t\t\t\tconst existingEnableSql = existingInfo.enableSql;\n+\t\t\t\t\t// If one of the `enableSql` flags (either the current one or the existing one)\n+\t\t\t\t\t// is `true` and the other is `undefined`, we might be in a potentially valid\n+\t\t\t\t\t// situation in which worker A defines a DO marking it as SQL based, while worker\n+\t\t\t\t\t// B simply uses the DO from worker A without defining it, thus leaving `enableSql`\n+\t\t\t\t\t// as `undefined` (this is exactly what Wrangler does)\n+\t\t\t\t\tconst potentiallyValidSqlDiff =\n+\t\t\t\t\t\t(existingEnableSql === undefined && enableSql === true) ||\n+\t\t\t\t\t\t(enableSql === undefined && existingEnableSql === true);\n+\n+\t\t\t\t\tif (!potentiallyValidSqlDiff) {\n+\t\t\t\t\t\t// We only want to throw this error is we know that the DO configuration cannot\n+\t\t\t\t\t\t// be potentially valid\n+\t\t\t\t\t\tthrow new MiniflareCoreError(\n+\t\t\t\t\t\t\t\"ERR_DIFFERENT_STORAGE_BACKEND\",\n+\t\t\t\t\t\t\t`Different storage backends defined for Durable Object \"${className}\" in \"${serviceName}\": ${JSON.stringify(\n+\t\t\t\t\t\t\t\tenableSql\n+\t\t\t\t\t\t\t)} and ${JSON.stringify(existingInfo?.enableSql)}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}",
        "comment_created_at": "2025-08-22T20:43:47+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "@edmundhung I've addressed the other configs checking, but not updating the map, please have another look and let me know if this works for you \ud83d\ude47 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301517394",
    "pr_number": 10437,
    "pr_file": "packages/miniflare/src/index.ts",
    "created_at": "2025-08-26T16:22:48+00:00",
    "commented_code": "className,\n \t\t\t\t// Fallback to current worker service if name not defined\n \t\t\t\tserviceName = workerServiceName,\n-\t\t\t\tenableSql,\n-\t\t\t\tunsafeUniqueKey,\n-\t\t\t\tunsafePreventEviction,\n \t\t\t\tcontainer,\n+\t\t\t\t...doConfigs\n \t\t\t} = normaliseDurableObject(designator);\n \t\t\t// Get or create `Map` mapping class name to optional unsafe unique key\n \t\t\tlet classNames = serviceClassNames.get(serviceName);\n \t\t\tif (classNames === undefined) {\n \t\t\t\tclassNames = new Map();\n \t\t\t\tserviceClassNames.set(serviceName, classNames);\n \t\t\t}\n+\n \t\t\tif (classNames.has(className)) {\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n+\n+\t\t\t\tconst isDoUnacceptableDiff = (\n+\t\t\t\t\tfield: Extract<\n+\t\t\t\t\t\tkeyof typeof doConfigs,\n+\t\t\t\t\t\t\"enableSql\" | \"unsafeUniqueKey\" | \"unsafePreventEviction\"\n+\t\t\t\t\t>\n+\t\t\t\t) => {\n+\t\t\t\t\tif (!existingInfo) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst same = existingInfo[field] === doConfigs[field];\n+\t\t\t\t\tif (same) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst oneIsUndefined =\n+\t\t\t\t\t\texistingInfo[field] === undefined || doConfigs[field] === undefined;\n+\n+\t\t\t\t\t// If one of the configurations is `undefined` (either the current one or the existing one) then there we\n+\t\t\t\t\t// want to consider this as an acceptable difference since we might be in a potentially valid situation in\n+\t\t\t\t\t// which worker A defines a DO with a config, while worker B simply uses the DO from worker A but without\n+\t\t\t\t\t// providing the configuration (thus leaving it `undefined`) (this for example is exactly what Wrangler does\n+\t\t\t\t\t// with the implicitly defined `enableSql` flag)\n+\t\t\t\t\tif (oneIsUndefined) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t};",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2301517394",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2301517394",
        "commented_code": "@@ -340,51 +340,83 @@ function getDurableObjectClassNames(\n \t\t\t\tclassName,\n \t\t\t\t// Fallback to current worker service if name not defined\n \t\t\t\tserviceName = workerServiceName,\n-\t\t\t\tenableSql,\n-\t\t\t\tunsafeUniqueKey,\n-\t\t\t\tunsafePreventEviction,\n \t\t\t\tcontainer,\n+\t\t\t\t...doConfigs\n \t\t\t} = normaliseDurableObject(designator);\n \t\t\t// Get or create `Map` mapping class name to optional unsafe unique key\n \t\t\tlet classNames = serviceClassNames.get(serviceName);\n \t\t\tif (classNames === undefined) {\n \t\t\t\tclassNames = new Map();\n \t\t\t\tserviceClassNames.set(serviceName, classNames);\n \t\t\t}\n+\n \t\t\tif (classNames.has(className)) {\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n+\n+\t\t\t\tconst isDoUnacceptableDiff = (\n+\t\t\t\t\tfield: Extract<\n+\t\t\t\t\t\tkeyof typeof doConfigs,\n+\t\t\t\t\t\t\"enableSql\" | \"unsafeUniqueKey\" | \"unsafePreventEviction\"\n+\t\t\t\t\t>\n+\t\t\t\t) => {\n+\t\t\t\t\tif (!existingInfo) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst same = existingInfo[field] === doConfigs[field];\n+\t\t\t\t\tif (same) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst oneIsUndefined =\n+\t\t\t\t\t\texistingInfo[field] === undefined || doConfigs[field] === undefined;\n+\n+\t\t\t\t\t// If one of the configurations is `undefined` (either the current one or the existing one) then there we\n+\t\t\t\t\t// want to consider this as an acceptable difference since we might be in a potentially valid situation in\n+\t\t\t\t\t// which worker A defines a DO with a config, while worker B simply uses the DO from worker A but without\n+\t\t\t\t\t// providing the configuration (thus leaving it `undefined`) (this for example is exactly what Wrangler does\n+\t\t\t\t\t// with the implicitly defined `enableSql` flag)\n+\t\t\t\t\tif (oneIsUndefined) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t};",
        "comment_created_at": "2025-08-26T16:22:48+00:00",
        "comment_author": "edmundhung",
        "comment_body": "Nit: I think one minor issue with this check is that if the `existingInfo[field]` is undefined, even when later there are DOs with `doConfigs[field]` being `true` and some being `false`, this is still being accepted.\r\n\r\nIdeally, it would be great to only accept `true | undefined` or `false | undefined` among a set of DO configs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2301521387",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2301517394",
        "commented_code": "@@ -340,51 +340,83 @@ function getDurableObjectClassNames(\n \t\t\t\tclassName,\n \t\t\t\t// Fallback to current worker service if name not defined\n \t\t\t\tserviceName = workerServiceName,\n-\t\t\t\tenableSql,\n-\t\t\t\tunsafeUniqueKey,\n-\t\t\t\tunsafePreventEviction,\n \t\t\t\tcontainer,\n+\t\t\t\t...doConfigs\n \t\t\t} = normaliseDurableObject(designator);\n \t\t\t// Get or create `Map` mapping class name to optional unsafe unique key\n \t\t\tlet classNames = serviceClassNames.get(serviceName);\n \t\t\tif (classNames === undefined) {\n \t\t\t\tclassNames = new Map();\n \t\t\t\tserviceClassNames.set(serviceName, classNames);\n \t\t\t}\n+\n \t\t\tif (classNames.has(className)) {\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n+\n+\t\t\t\tconst isDoUnacceptableDiff = (\n+\t\t\t\t\tfield: Extract<\n+\t\t\t\t\t\tkeyof typeof doConfigs,\n+\t\t\t\t\t\t\"enableSql\" | \"unsafeUniqueKey\" | \"unsafePreventEviction\"\n+\t\t\t\t\t>\n+\t\t\t\t) => {\n+\t\t\t\t\tif (!existingInfo) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst same = existingInfo[field] === doConfigs[field];\n+\t\t\t\t\tif (same) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst oneIsUndefined =\n+\t\t\t\t\t\texistingInfo[field] === undefined || doConfigs[field] === undefined;\n+\n+\t\t\t\t\t// If one of the configurations is `undefined` (either the current one or the existing one) then there we\n+\t\t\t\t\t// want to consider this as an acceptable difference since we might be in a potentially valid situation in\n+\t\t\t\t\t// which worker A defines a DO with a config, while worker B simply uses the DO from worker A but without\n+\t\t\t\t\t// providing the configuration (thus leaving it `undefined`) (this for example is exactly what Wrangler does\n+\t\t\t\t\t// with the implicitly defined `enableSql` flag)\n+\t\t\t\t\tif (oneIsUndefined) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t};",
        "comment_created_at": "2025-08-26T16:24:40+00:00",
        "comment_author": "edmundhung",
        "comment_body": "In reality this shouldn't really happen as the config will be `true` or `false` only from the worker that define the DO, the rest of the workers would only be `undefined`. So this is just a nitpick :)",
        "pr_file_module": null
      },
      {
        "comment_id": "2301545133",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2301517394",
        "commented_code": "@@ -340,51 +340,83 @@ function getDurableObjectClassNames(\n \t\t\t\tclassName,\n \t\t\t\t// Fallback to current worker service if name not defined\n \t\t\t\tserviceName = workerServiceName,\n-\t\t\t\tenableSql,\n-\t\t\t\tunsafeUniqueKey,\n-\t\t\t\tunsafePreventEviction,\n \t\t\t\tcontainer,\n+\t\t\t\t...doConfigs\n \t\t\t} = normaliseDurableObject(designator);\n \t\t\t// Get or create `Map` mapping class name to optional unsafe unique key\n \t\t\tlet classNames = serviceClassNames.get(serviceName);\n \t\t\tif (classNames === undefined) {\n \t\t\t\tclassNames = new Map();\n \t\t\t\tserviceClassNames.set(serviceName, classNames);\n \t\t\t}\n+\n \t\t\tif (classNames.has(className)) {\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n+\n+\t\t\t\tconst isDoUnacceptableDiff = (\n+\t\t\t\t\tfield: Extract<\n+\t\t\t\t\t\tkeyof typeof doConfigs,\n+\t\t\t\t\t\t\"enableSql\" | \"unsafeUniqueKey\" | \"unsafePreventEviction\"\n+\t\t\t\t\t>\n+\t\t\t\t) => {\n+\t\t\t\t\tif (!existingInfo) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst same = existingInfo[field] === doConfigs[field];\n+\t\t\t\t\tif (same) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst oneIsUndefined =\n+\t\t\t\t\t\texistingInfo[field] === undefined || doConfigs[field] === undefined;\n+\n+\t\t\t\t\t// If one of the configurations is `undefined` (either the current one or the existing one) then there we\n+\t\t\t\t\t// want to consider this as an acceptable difference since we might be in a potentially valid situation in\n+\t\t\t\t\t// which worker A defines a DO with a config, while worker B simply uses the DO from worker A but without\n+\t\t\t\t\t// providing the configuration (thus leaving it `undefined`) (this for example is exactly what Wrangler does\n+\t\t\t\t\t// with the implicitly defined `enableSql` flag)\n+\t\t\t\t\tif (oneIsUndefined) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t};",
        "comment_created_at": "2025-08-26T16:34:51+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "I understand what you are suggesting, and I can make the change (you are suggesting to collect all the values and check them together right?), but I am not sure if that is necessary, because this check applies to all DO configuration so let's say that as some point we have `existingInfo[field] === undefined` and `doConfigs[field] === true`, this will pass, if later all the `doConfigs[field]` values are `true` then everything will work fine, if one will be `false` we will detect that then (and vice versa).\r\n\r\nSo either way if there is a conflict between two DOs we are going to detect it sooner or later and the order of DOs doesn't even matter, no?",
        "pr_file_module": null
      },
      {
        "comment_id": "2303305130",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10437,
        "pr_file": "packages/miniflare/src/index.ts",
        "discussion_id": "2301517394",
        "commented_code": "@@ -340,51 +340,83 @@ function getDurableObjectClassNames(\n \t\t\t\tclassName,\n \t\t\t\t// Fallback to current worker service if name not defined\n \t\t\t\tserviceName = workerServiceName,\n-\t\t\t\tenableSql,\n-\t\t\t\tunsafeUniqueKey,\n-\t\t\t\tunsafePreventEviction,\n \t\t\t\tcontainer,\n+\t\t\t\t...doConfigs\n \t\t\t} = normaliseDurableObject(designator);\n \t\t\t// Get or create `Map` mapping class name to optional unsafe unique key\n \t\t\tlet classNames = serviceClassNames.get(serviceName);\n \t\t\tif (classNames === undefined) {\n \t\t\t\tclassNames = new Map();\n \t\t\t\tserviceClassNames.set(serviceName, classNames);\n \t\t\t}\n+\n \t\t\tif (classNames.has(className)) {\n \t\t\t\t// If we've already seen this class in this service, make sure the\n \t\t\t\t// unsafe unique keys and unsafe prevent eviction values match\n \t\t\t\tconst existingInfo = classNames.get(className);\n-\t\t\t\tif (existingInfo?.enableSql !== enableSql) {\n+\n+\t\t\t\tconst isDoUnacceptableDiff = (\n+\t\t\t\t\tfield: Extract<\n+\t\t\t\t\t\tkeyof typeof doConfigs,\n+\t\t\t\t\t\t\"enableSql\" | \"unsafeUniqueKey\" | \"unsafePreventEviction\"\n+\t\t\t\t\t>\n+\t\t\t\t) => {\n+\t\t\t\t\tif (!existingInfo) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst same = existingInfo[field] === doConfigs[field];\n+\t\t\t\t\tif (same) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst oneIsUndefined =\n+\t\t\t\t\t\texistingInfo[field] === undefined || doConfigs[field] === undefined;\n+\n+\t\t\t\t\t// If one of the configurations is `undefined` (either the current one or the existing one) then there we\n+\t\t\t\t\t// want to consider this as an acceptable difference since we might be in a potentially valid situation in\n+\t\t\t\t\t// which worker A defines a DO with a config, while worker B simply uses the DO from worker A but without\n+\t\t\t\t\t// providing the configuration (thus leaving it `undefined`) (this for example is exactly what Wrangler does\n+\t\t\t\t\t// with the implicitly defined `enableSql` flag)\n+\t\t\t\t\tif (oneIsUndefined) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t};",
        "comment_created_at": "2025-08-27T08:51:19+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "As discussed async you were right, sorry I misremembered how the `existingInfo` are being set \ud83d\ude47 \r\n\r\nd81c85e72659b6348784f844d531ee6d9f5cc0f6 should address your concerns \ud83d\ude42",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2270652759",
    "pr_number": 10337,
    "pr_file": "packages/wrangler/src/containers/deploy.ts",
    "created_at": "2025-08-12T17:36:07+00:00",
    "commented_code": "return cleanedPreviousApp;\n }\n+\n+export const configRolloutStepsToAPI = (rolloutSteps: number | number[]) => {\n+\tif (typeof rolloutSteps === \"number\") {\n+\t\treturn { step_percentage: rolloutSteps };\n+\t} else {\n+\t\tconst output: RolloutStepRequest[] = [];\n+\t\tlet index = 1;\n+\t\tfor (const step of rolloutSteps) {\n+\t\t\toutput.push({\n+\t\t\t\tstep_size: { percentage: step },\n+\t\t\t\tdescription: `Step ${index} of ${rolloutSteps.length} applying to ${step}% of instances`,",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2270652759",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10337,
        "pr_file": "packages/wrangler/src/containers/deploy.ts",
        "discussion_id": "2270652759",
        "commented_code": "@@ -531,3 +530,20 @@ export function cleanApplicationFromAPI(\n \n \treturn cleanedPreviousApp;\n }\n+\n+export const configRolloutStepsToAPI = (rolloutSteps: number | number[]) => {\n+\tif (typeof rolloutSteps === \"number\") {\n+\t\treturn { step_percentage: rolloutSteps };\n+\t} else {\n+\t\tconst output: RolloutStepRequest[] = [];\n+\t\tlet index = 1;\n+\t\tfor (const step of rolloutSteps) {\n+\t\t\toutput.push({\n+\t\t\t\tstep_size: { percentage: step },\n+\t\t\t\tdescription: `Step ${index} of ${rolloutSteps.length} applying to ${step}% of instances`,",
        "comment_created_at": "2025-08-12T17:36:07+00:00",
        "comment_author": "emily-shen",
        "comment_body": "not really sure what this description field should be, but this seems reasonable?",
        "pr_file_module": null
      },
      {
        "comment_id": "2270816321",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10337,
        "pr_file": "packages/wrangler/src/containers/deploy.ts",
        "discussion_id": "2270652759",
        "commented_code": "@@ -531,3 +530,20 @@ export function cleanApplicationFromAPI(\n \n \treturn cleanedPreviousApp;\n }\n+\n+export const configRolloutStepsToAPI = (rolloutSteps: number | number[]) => {\n+\tif (typeof rolloutSteps === \"number\") {\n+\t\treturn { step_percentage: rolloutSteps };\n+\t} else {\n+\t\tconst output: RolloutStepRequest[] = [];\n+\t\tlet index = 1;\n+\t\tfor (const step of rolloutSteps) {\n+\t\t\toutput.push({\n+\t\t\t\tstep_size: { percentage: step },\n+\t\t\t\tdescription: `Step ${index} of ${rolloutSteps.length} applying to ${step}% of instances`,",
        "comment_created_at": "2025-08-12T18:45:56+00:00",
        "comment_author": "nikitassharma",
        "comment_body": "fwiw when the api is given a number, it uses `Rollout to ${total}% of instances`.\r\n\r\nmaybe change step to be the total % of instances so far to match what's generated by the api? but I like the \"Step _ of _\" in this description and I think keep that part",
        "pr_file_module": null
      },
      {
        "comment_id": "2273628513",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10337,
        "pr_file": "packages/wrangler/src/containers/deploy.ts",
        "discussion_id": "2270652759",
        "commented_code": "@@ -531,3 +530,20 @@ export function cleanApplicationFromAPI(\n \n \treturn cleanedPreviousApp;\n }\n+\n+export const configRolloutStepsToAPI = (rolloutSteps: number | number[]) => {\n+\tif (typeof rolloutSteps === \"number\") {\n+\t\treturn { step_percentage: rolloutSteps };\n+\t} else {\n+\t\tconst output: RolloutStepRequest[] = [];\n+\t\tlet index = 1;\n+\t\tfor (const step of rolloutSteps) {\n+\t\t\toutput.push({\n+\t\t\t\tstep_size: { percentage: step },\n+\t\t\t\tdescription: `Step ${index} of ${rolloutSteps.length} applying to ${step}% of instances`,",
        "comment_created_at": "2025-08-13T14:20:20+00:00",
        "comment_author": "emily-shen",
        "comment_body": "so a sequence like this?\r\n\"Step 1 of 3 - rolled out for 20% of instances\",\r\n\"Step 2 of 3 - rolled out for 50% of instances\",\r\n\"Step 3 of 3 - rolled out for 100% of instances\"",
        "pr_file_module": null
      },
      {
        "comment_id": "2273709314",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10337,
        "pr_file": "packages/wrangler/src/containers/deploy.ts",
        "discussion_id": "2270652759",
        "commented_code": "@@ -531,3 +530,20 @@ export function cleanApplicationFromAPI(\n \n \treturn cleanedPreviousApp;\n }\n+\n+export const configRolloutStepsToAPI = (rolloutSteps: number | number[]) => {\n+\tif (typeof rolloutSteps === \"number\") {\n+\t\treturn { step_percentage: rolloutSteps };\n+\t} else {\n+\t\tconst output: RolloutStepRequest[] = [];\n+\t\tlet index = 1;\n+\t\tfor (const step of rolloutSteps) {\n+\t\t\toutput.push({\n+\t\t\t\tstep_size: { percentage: step },\n+\t\t\t\tdescription: `Step ${index} of ${rolloutSteps.length} applying to ${step}% of instances`,",
        "comment_created_at": "2025-08-13T14:47:45+00:00",
        "comment_author": "nikitassharma",
        "comment_body": "yup!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2276254997",
    "pr_number": 10337,
    "pr_file": "packages/wrangler/src/config/validation.ts",
    "created_at": "2025-08-14T10:39:22+00:00",
    "commented_code": "containerAppOptional.image = resolvedImage;\n \t\t\tcontainerAppOptional.image_build_context = resolvedBuildContextPath;\n \n-\t\t\t// Validate rollout related configs\n-\t\t\tif (\n-\t\t\t\t!isOptionalProperty(\n-\t\t\t\t\tcontainerAppOptional,\n-\t\t\t\t\t\"rollout_step_percentage\",\n-\t\t\t\t\t\"number\"\n-\t\t\t\t) ||\n-\t\t\t\tcontainerAppOptional.rollout_step_percentage > 100 ||\n-\t\t\t\tcontainerAppOptional.rollout_step_percentage < 25\n-\t\t\t) {\n-\t\t\t\tdiagnostics.errors.push(\n-\t\t\t\t\t`\"containers.rollout_step_percentage\" field should be a number between 25 and 100, but got \"${containerAppOptional.rollout_step_percentage}\"`\n-\t\t\t\t);\n+\t\t\t// Validate rollout related configuration\n+\t\t\tif (containerAppOptional.rollout_step_percentage !== undefined) {\n+\t\t\t\tconst rolloutStep = containerAppOptional.rollout_step_percentage;\n+\n+\t\t\t\tif (typeof rolloutStep === \"number\") {\n+\t\t\t\t\t// If it's a number, it must be one of the allowed values\n+\t\t\t\t\tconst allowedSingleValues = [5, 10, 20, 25, 50, 100];\n+\t\t\t\t\tif (!allowedSingleValues.includes(rolloutStep)) {\n+\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" must be one of [5, 10, 20, 25, 50, 100], but got ${rolloutStep}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (Array.isArray(rolloutStep)) {\n+\t\t\t\t\t// If it's an array, validate each step and ensure they sum to 100\n+\t\t\t\t\tconst nonNumber: unknown[] = [];\n+\t\t\t\t\tconst outOfRange: number[] = [];\n+\t\t\t\t\tfor (const step of rolloutStep) {\n+\t\t\t\t\t\tif (typeof step !== \"number\") {\n+\t\t\t\t\t\t\tnonNumber.push(step);\n+\t\t\t\t\t\t} else if (step < 10 || step > 100) {\n+\t\t\t\t\t\t\toutOfRange.push(step);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Only check sum if no type/range errors\n+\n+\t\t\t\t\tif (nonNumber.length === 0 && outOfRange.length === 0) {\n+\t\t\t\t\t\tconst sum = rolloutStep.reduce(\n+\t\t\t\t\t\t\t(acc: number, step: number) => acc + step,\n+\t\t\t\t\t\t\t0\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tif (sum !== 100) {\n+\t\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must sum to 100, but values summed to \"${sum}\"`\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (nonNumber.length) {\n+\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must be numbers, but got \"${nonNumber.join(\", \")}\"`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (outOfRange.length) {\n+\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must be between 10 and 100, but got \"${outOfRange.join(\", \")}\"`",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2276254997",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10337,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2276254997",
        "commented_code": "@@ -2556,19 +2556,58 @@ function validateContainerApp(\n \t\t\tcontainerAppOptional.image = resolvedImage;\n \t\t\tcontainerAppOptional.image_build_context = resolvedBuildContextPath;\n \n-\t\t\t// Validate rollout related configs\n-\t\t\tif (\n-\t\t\t\t!isOptionalProperty(\n-\t\t\t\t\tcontainerAppOptional,\n-\t\t\t\t\t\"rollout_step_percentage\",\n-\t\t\t\t\t\"number\"\n-\t\t\t\t) ||\n-\t\t\t\tcontainerAppOptional.rollout_step_percentage > 100 ||\n-\t\t\t\tcontainerAppOptional.rollout_step_percentage < 25\n-\t\t\t) {\n-\t\t\t\tdiagnostics.errors.push(\n-\t\t\t\t\t`\"containers.rollout_step_percentage\" field should be a number between 25 and 100, but got \"${containerAppOptional.rollout_step_percentage}\"`\n-\t\t\t\t);\n+\t\t\t// Validate rollout related configuration\n+\t\t\tif (containerAppOptional.rollout_step_percentage !== undefined) {\n+\t\t\t\tconst rolloutStep = containerAppOptional.rollout_step_percentage;\n+\n+\t\t\t\tif (typeof rolloutStep === \"number\") {\n+\t\t\t\t\t// If it's a number, it must be one of the allowed values\n+\t\t\t\t\tconst allowedSingleValues = [5, 10, 20, 25, 50, 100];\n+\t\t\t\t\tif (!allowedSingleValues.includes(rolloutStep)) {\n+\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" must be one of [5, 10, 20, 25, 50, 100], but got ${rolloutStep}`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (Array.isArray(rolloutStep)) {\n+\t\t\t\t\t// If it's an array, validate each step and ensure they sum to 100\n+\t\t\t\t\tconst nonNumber: unknown[] = [];\n+\t\t\t\t\tconst outOfRange: number[] = [];\n+\t\t\t\t\tfor (const step of rolloutStep) {\n+\t\t\t\t\t\tif (typeof step !== \"number\") {\n+\t\t\t\t\t\t\tnonNumber.push(step);\n+\t\t\t\t\t\t} else if (step < 10 || step > 100) {\n+\t\t\t\t\t\t\toutOfRange.push(step);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Only check sum if no type/range errors\n+\n+\t\t\t\t\tif (nonNumber.length === 0 && outOfRange.length === 0) {\n+\t\t\t\t\t\tconst sum = rolloutStep.reduce(\n+\t\t\t\t\t\t\t(acc: number, step: number) => acc + step,\n+\t\t\t\t\t\t\t0\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tif (sum !== 100) {\n+\t\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must sum to 100, but values summed to \"${sum}\"`\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (nonNumber.length) {\n+\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must be numbers, but got \"${nonNumber.join(\", \")}\"`\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (outOfRange.length) {\n+\t\t\t\t\t\tdiagnostics.errors.push(\n+\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must be between 10 and 100, but got \"${outOfRange.join(\", \")}\"`",
        "comment_created_at": "2025-08-14T10:39:22+00:00",
        "comment_author": "CarmenPopoviciu",
        "comment_body": "```suggestion\r\n\t\t\t\t\t\t\t`\"containers.rollout_step_percentage\" array elements must be numbers between 10 and 100, but got \"${outOfRange.join(\", \")}\"`\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2276263563",
    "pr_number": 10337,
    "pr_file": "packages/wrangler/src/__tests__/containers/deploy.test.ts",
    "created_at": "2025-08-14T10:43:28+00:00",
    "commented_code": ");\n \t});\n \n+\tdescribe(\"rollout_percentage_steps\", () => {\n+\t\tit(\"should create rollout with step_percentage when rollout_step_percentage is a number\", async () => {\n+\t\t\twriteWranglerConfig({\n+\t\t\t\t...DEFAULT_DURABLE_OBJECTS,\n+\t\t\t\tcontainers: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\t...DEFAULT_CONTAINER_FROM_REGISTRY,\n+\t\t\t\t\t\trollout_step_percentage: 50,\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t});\n+\n+\t\t\tmockGetVersion(\"Galaxy-Class\");\n+\n+\t\t\tmockGetApplications([]);\n+\n+\t\t\tmockCreateApplication();\n+\n+\t\t\tmockCreateApplicationRollout({\n+\t\t\t\tdescription: \"Progressive update\",\n+\t\t\t\tstrategy: \"rolling\",\n+\t\t\t\tkind: \"full_auto\",\n+\t\t\t\tstep_percentage: 50,\n+\t\t\t});\n+\n+\t\t\tfs.writeFileSync(\n+\t\t\t\t\"index.js\",\n+\t\t\t\t`export class ExampleDurableObject {}; export default{};`\n+\t\t\t);\n+\t\t\tawait runWrangler(\"deploy index.js\");\n+\n+\t\t\texpect(std.err).toMatchInlineSnapshot(`\"\"`);\n+\t\t});\n+\n+\t\tit(\"should create rollout with step_percentage when rollout_step_percentage is a number\", async () => {",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2276263563",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 10337,
        "pr_file": "packages/wrangler/src/__tests__/containers/deploy.test.ts",
        "discussion_id": "2276263563",
        "commented_code": "@@ -840,6 +840,109 @@ describe(\"wrangler deploy with containers\", () => {\n \t\t);\n \t});\n \n+\tdescribe(\"rollout_percentage_steps\", () => {\n+\t\tit(\"should create rollout with step_percentage when rollout_step_percentage is a number\", async () => {\n+\t\t\twriteWranglerConfig({\n+\t\t\t\t...DEFAULT_DURABLE_OBJECTS,\n+\t\t\t\tcontainers: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\t...DEFAULT_CONTAINER_FROM_REGISTRY,\n+\t\t\t\t\t\trollout_step_percentage: 50,\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t});\n+\n+\t\t\tmockGetVersion(\"Galaxy-Class\");\n+\n+\t\t\tmockGetApplications([]);\n+\n+\t\t\tmockCreateApplication();\n+\n+\t\t\tmockCreateApplicationRollout({\n+\t\t\t\tdescription: \"Progressive update\",\n+\t\t\t\tstrategy: \"rolling\",\n+\t\t\t\tkind: \"full_auto\",\n+\t\t\t\tstep_percentage: 50,\n+\t\t\t});\n+\n+\t\t\tfs.writeFileSync(\n+\t\t\t\t\"index.js\",\n+\t\t\t\t`export class ExampleDurableObject {}; export default{};`\n+\t\t\t);\n+\t\t\tawait runWrangler(\"deploy index.js\");\n+\n+\t\t\texpect(std.err).toMatchInlineSnapshot(`\"\"`);\n+\t\t});\n+\n+\t\tit(\"should create rollout with step_percentage when rollout_step_percentage is a number\", async () => {",
        "comment_created_at": "2025-08-14T10:43:28+00:00",
        "comment_author": "CarmenPopoviciu",
        "comment_body": "```suggestion\r\n\t\tit(\"should create rollout with step_percentage when rollout_step_percentage is an array of numbers\", async () => {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135336932",
    "pr_number": 9509,
    "pr_file": "packages/wrangler/src/config/validation.ts",
    "created_at": "2025-06-09T09:01:53+00:00",
    "commented_code": "[\"single-page-application\", \"404-page\", \"none\"]\n \t\t) && isValid;\n \n-\tisValid =\n-\t\tvalidateOptionalProperty(\n-\t\t\tdiagnostics,\n-\t\t\tfield,\n-\t\t\t\"run_worker_first\",\n-\t\t\t(value as Assets).run_worker_first,\n-\t\t\t\"boolean\"\n-\t\t) && isValid;\n-\n+\tif ((value as Assets).run_worker_first !== undefined) {\n+\t\tif (typeof (value as Assets).run_worker_first === \"boolean\") {\n+\t\t\tisValid =\n+\t\t\t\tvalidateOptionalProperty(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\tfield,\n+\t\t\t\t\t\"run_worker_first\",\n+\t\t\t\t\t(value as Assets).run_worker_first,\n+\t\t\t\t\t\"boolean\"\n+\t\t\t\t) && isValid;\n+\t\t} else if (Array.isArray((value as Assets).run_worker_first)) {\n+\t\t\tisValid =\n+\t\t\t\tvalidateOptionalTypedArray(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\t\"assets.run_worker_first\",\n+\t\t\t\t\t(value as Assets).run_worker_first,\n+\t\t\t\t\t\"string\"\n+\t\t\t\t) && isValid;\n+\t\t} else {\n+\t\t\tdiagnostics.errors.push(\n+\t\t\t\t`The field \"${field}.run_worker_first\" should be a boolean or an array of strings, but got ${JSON.stringify(",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2135336932",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 9509,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2135336932",
        "commented_code": "@@ -2077,15 +2077,33 @@ const validateAssetsConfig: ValidatorFn = (diagnostics, field, value) => {\n \t\t\t[\"single-page-application\", \"404-page\", \"none\"]\n \t\t) && isValid;\n \n-\tisValid =\n-\t\tvalidateOptionalProperty(\n-\t\t\tdiagnostics,\n-\t\t\tfield,\n-\t\t\t\"run_worker_first\",\n-\t\t\t(value as Assets).run_worker_first,\n-\t\t\t\"boolean\"\n-\t\t) && isValid;\n-\n+\tif ((value as Assets).run_worker_first !== undefined) {\n+\t\tif (typeof (value as Assets).run_worker_first === \"boolean\") {\n+\t\t\tisValid =\n+\t\t\t\tvalidateOptionalProperty(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\tfield,\n+\t\t\t\t\t\"run_worker_first\",\n+\t\t\t\t\t(value as Assets).run_worker_first,\n+\t\t\t\t\t\"boolean\"\n+\t\t\t\t) && isValid;\n+\t\t} else if (Array.isArray((value as Assets).run_worker_first)) {\n+\t\t\tisValid =\n+\t\t\t\tvalidateOptionalTypedArray(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\t\"assets.run_worker_first\",\n+\t\t\t\t\t(value as Assets).run_worker_first,\n+\t\t\t\t\t\"string\"\n+\t\t\t\t) && isValid;\n+\t\t} else {\n+\t\t\tdiagnostics.errors.push(\n+\t\t\t\t`The field \"${field}.run_worker_first\" should be a boolean or an array of strings, but got ${JSON.stringify(",
        "comment_created_at": "2025-06-09T09:01:53+00:00",
        "comment_author": "jamesopstad",
        "comment_body": "```suggestion\r\n\t\t\t\t`The field \"${field}.run_worker_first\" should be an array of strings or a boolean, but got ${JSON.stringify(\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2139827476",
    "pr_number": 9509,
    "pr_file": "packages/wrangler/src/assets.ts",
    "created_at": "2025-06-11T10:54:08+00:00",
    "commented_code": "assetConfig,\n \t\t_redirects,\n \t\t_headers,\n+\t\t// unsplit static routing rules for upload",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2139827476",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 9509,
        "pr_file": "packages/wrangler/src/assets.ts",
        "discussion_id": "2139827476",
        "commented_code": "@@ -483,6 +502,8 @@ export function getAssetsOptions(\n \t\tassetConfig,\n \t\t_redirects,\n \t\t_headers,\n+\t\t// unsplit static routing rules for upload",
        "comment_created_at": "2025-06-11T10:54:08+00:00",
        "comment_author": "petebacondarwin",
        "comment_body": "what does this mean?",
        "pr_file_module": null
      },
      {
        "comment_id": "2140316260",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 9509,
        "pr_file": "packages/wrangler/src/assets.ts",
        "discussion_id": "2139827476",
        "commented_code": "@@ -483,6 +502,8 @@ export function getAssetsOptions(\n \t\tassetConfig,\n \t\t_redirects,\n \t\t_headers,\n+\t\t// unsplit static routing rules for upload",
        "comment_created_at": "2025-06-11T14:16:21+00:00",
        "comment_author": "emily-shen",
        "comment_body": "getAssetsOptions gets asset options for both dev and deploy, which are quite different shapes. so routerConfig has run_worker_first parsed, but we also want raw run_worker_first for upload. i've updated the comment",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2028528213",
    "pr_number": 8596,
    "pr_file": "packages/wrangler/src/config/validation.ts",
    "created_at": "2025-04-04T10:10:41+00:00",
    "commented_code": "isDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2028528213",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 8596,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2028528213",
        "commented_code": "@@ -155,74 +155,90 @@ export function normalizeAndValidateConfig(\n \t\tisDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
        "comment_created_at": "2025-04-04T10:10:41+00:00",
        "comment_author": "emily-shen",
        "comment_body": "should it not error instead of warning, to prevent accidentally deploying the wrong configuration? \r\nand then maybe something like this?\r\n`You have specified the environment \"${envName}\", but are using a redirected configuration, produced by a build tool such as Vite. You need to set the environment in your build tool, rather than via Wrangler. For example, if you are using Vite, refer to these docs:`",
        "pr_file_module": null
      },
      {
        "comment_id": "2028561498",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 8596,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2028528213",
        "commented_code": "@@ -155,74 +155,90 @@ export function normalizeAndValidateConfig(\n \t\tisDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
        "comment_created_at": "2025-04-04T10:34:49+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "I went off of the requirements Pete set in the issue: https://github.com/cloudflare/workers-sdk/issues/8359\r\n\r\nMaybe erroring would just be too restrictive?\r\n\r\nI'm happy to make this hard error if you prefer, but I'd like to hear @petebacondarwin's opinion on it \ud83d\ude42 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2028578742",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 8596,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2028528213",
        "commented_code": "@@ -155,74 +155,90 @@ export function normalizeAndValidateConfig(\n \t\tisDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
        "comment_created_at": "2025-04-04T10:49:30+00:00",
        "comment_author": "petebacondarwin",
        "comment_body": "I was worried that a hard error here might be a breaking change??\r\nIf we are happy with that then errors are better.",
        "pr_file_module": null
      },
      {
        "comment_id": "2028579824",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 8596,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2028528213",
        "commented_code": "@@ -155,74 +155,90 @@ export function normalizeAndValidateConfig(\n \t\tisDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
        "comment_created_at": "2025-04-04T10:50:29+00:00",
        "comment_author": "petebacondarwin",
        "comment_body": "I guess that ignoring the `--env` is as much of a breaking change. So let's go with an error?",
        "pr_file_module": null
      },
      {
        "comment_id": "2028645024",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 8596,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2028528213",
        "commented_code": "@@ -155,74 +155,90 @@ export function normalizeAndValidateConfig(\n \t\tisDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
        "comment_created_at": "2025-04-04T11:34:07+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "Ok we agreed that this should error, I'll update this then \ud83d\ude42 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2028900798",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 8596,
        "pr_file": "packages/wrangler/src/config/validation.ts",
        "discussion_id": "2028528213",
        "commented_code": "@@ -155,74 +155,90 @@ export function normalizeAndValidateConfig(\n \t\tisDispatchNamespace\n \t);\n \n+\tconst isRedirectedConfig = configPath && configPath !== userConfigPath;\n+\n+\tconst definedEnvironments = Object.keys(rawConfig.env ?? {});\n+\n+\tif (isRedirectedConfig && definedEnvironments.length > 0) {\n+\t\tdiagnostics.errors.push(\n+\t\t\t`Redirected configurations cannot include environments, instead the following have been found: ${definedEnvironments.map((env) => JSON.stringify(env)).join(\", \")}`\n+\t\t);\n+\t}\n+\n \t//TODO: find a better way to define the type of Args that can be passed to the normalizeAndValidateConfig()\n \tconst envName = args.env;\n \tassert(envName === undefined || typeof envName === \"string\");\n \n \tlet activeEnv = topLevelEnv;\n \n \tif (envName !== undefined) {\n-\t\tconst envDiagnostics = new Diagnostics(\n-\t\t\t`\"env.${envName}\" environment configuration`\n-\t\t);\n-\t\tconst rawEnv = rawConfig.env?.[envName];\n-\n-\t\t/**\n-\t\t * If an environment name was specified, and we found corresponding configuration\n-\t\t * for it in the config file, we will use that corresponding environment. If the\n-\t\t * environment name was specified, but no configuration for it was found, we will:\n-\t\t *\n-\t\t * - default to the top-level environment for Pages. For Pages, Wrangler does not\n-\t\t * require both of supported named environments (\"preview\" or \"production\") to be\n-\t\t * explicitly defined in the config file. If either`[env.production]` or\n-\t\t * `[env.preview]` is left unspecified, we will use the top-level environment when\n-\t\t * targeting that named Pages environment.\n-\t\t *\n-\t\t * - create a fake active environment with the specified `envName` for Workers.\n-\t\t * This is done to cover any legacy environment cases, where the `envName` is used.\n-\t\t */\n-\t\tif (rawEnv !== undefined) {\n-\t\t\tactiveEnv = normalizeAndValidateEnvironment(\n-\t\t\t\tenvDiagnostics,\n-\t\t\t\tconfigPath,\n-\t\t\t\trawEnv,\n-\t\t\t\tisDispatchNamespace,\n-\t\t\t\tenvName,\n-\t\t\t\ttopLevelEnv,\n-\t\t\t\tisLegacyEnv,\n-\t\t\t\trawConfig\n+\t\tif (isRedirectedConfig) {\n+\t\t\tdiagnostics.warnings.push(",
        "comment_created_at": "2025-04-04T14:19:01+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "Updated \ud83e\udee1 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1775335824",
    "pr_number": 6824,
    "pr_file": "packages/wrangler/src/__tests__/deploy.test.ts",
    "created_at": "2024-09-25T14:24:55+00:00",
    "commented_code": "`);\n \t\t});\n \n-\t\tit(\"should recommend node compatibility mode when using node builtins and node-compat isn't enabled\", async () => {\n+\t\tit(\"should recommend node compatibility flag mode when using node builtins and no node compat is enabled\", async () => {",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "1775335824",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/wrangler/src/__tests__/deploy.test.ts",
        "discussion_id": "1775335824",
        "commented_code": "@@ -9256,27 +9256,103 @@ export default{\n \t\t\t`);\n \t\t});\n \n-\t\tit(\"should recommend node compatibility mode when using node builtins and node-compat isn't enabled\", async () => {\n+\t\tit(\"should recommend node compatibility flag mode when using node builtins and no node compat is enabled\", async () => {",
        "comment_created_at": "2024-09-25T14:24:55+00:00",
        "comment_author": "vicb",
        "comment_body": "```suggestion\r\n\t\tit(\"should recommend node compatibility flag when using node builtins and no node compat is enabled\", async () => {\r\n```\r\n\r\nThis should also be applied to the new tests",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1775343564",
    "pr_number": 6824,
    "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
    "created_at": "2024-09-25T14:29:08+00:00",
    "commented_code": "+/**\n+ * Wrangler can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTE:\n+ * Currently v2 mode is configured via `nodejs_compat_v2` compat flag.\n+ * At a future compatibility date, the use of `nodejs_compat` flag will imply `nodejs_compat_v2`.\n+ *\n+ * see `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDateStr: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = new Date(2024, 8, 23); // 2024 Sept 23\n+\tconst [compatYear, compatMonth, compatDay] = compatibilityDateStr.split(\"-\");\n+\tconst compatibilityDate = new Date(\n+\t\tNumber(compatYear),\n+\t\tNumber(compatMonth) - 1,\n+\t\tNumber(compatDay)\n+\t);",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "1775343564",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
        "discussion_id": "1775343564",
        "commented_code": "@@ -0,0 +1,81 @@\n+/**\n+ * Wrangler can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTE:\n+ * Currently v2 mode is configured via `nodejs_compat_v2` compat flag.\n+ * At a future compatibility date, the use of `nodejs_compat` flag will imply `nodejs_compat_v2`.\n+ *\n+ * see `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDateStr: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = new Date(2024, 8, 23); // 2024 Sept 23\n+\tconst [compatYear, compatMonth, compatDay] = compatibilityDateStr.split(\"-\");\n+\tconst compatibilityDate = new Date(\n+\t\tNumber(compatYear),\n+\t\tNumber(compatMonth) - 1,\n+\t\tNumber(compatDay)\n+\t);",
        "comment_created_at": "2024-09-25T14:29:08+00:00",
        "comment_author": "penalosa",
        "comment_body": "Would a simple string comparison work here? `compatibilityDateStr >= \"2024-09-23\"`",
        "pr_file_module": null
      },
      {
        "comment_id": "1775358317",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
        "discussion_id": "1775343564",
        "commented_code": "@@ -0,0 +1,81 @@\n+/**\n+ * Wrangler can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTE:\n+ * Currently v2 mode is configured via `nodejs_compat_v2` compat flag.\n+ * At a future compatibility date, the use of `nodejs_compat` flag will imply `nodejs_compat_v2`.\n+ *\n+ * see `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDateStr: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = new Date(2024, 8, 23); // 2024 Sept 23\n+\tconst [compatYear, compatMonth, compatDay] = compatibilityDateStr.split(\"-\");\n+\tconst compatibilityDate = new Date(\n+\t\tNumber(compatYear),\n+\t\tNumber(compatMonth) - 1,\n+\t\tNumber(compatDay)\n+\t);",
        "comment_created_at": "2024-09-25T14:35:55+00:00",
        "comment_author": "petebacondarwin",
        "comment_body": "Hmm... I guess so?",
        "pr_file_module": null
      },
      {
        "comment_id": "1775457263",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
        "discussion_id": "1775343564",
        "commented_code": "@@ -0,0 +1,81 @@\n+/**\n+ * Wrangler can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTE:\n+ * Currently v2 mode is configured via `nodejs_compat_v2` compat flag.\n+ * At a future compatibility date, the use of `nodejs_compat` flag will imply `nodejs_compat_v2`.\n+ *\n+ * see `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDateStr: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = new Date(2024, 8, 23); // 2024 Sept 23\n+\tconst [compatYear, compatMonth, compatDay] = compatibilityDateStr.split(\"-\");\n+\tconst compatibilityDate = new Date(\n+\t\tNumber(compatYear),\n+\t\tNumber(compatMonth) - 1,\n+\t\tNumber(compatDay)\n+\t);",
        "comment_created_at": "2024-09-25T15:30:09+00:00",
        "comment_author": "petebacondarwin",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1775766611",
    "pr_number": 6824,
    "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
    "created_at": "2024-09-25T18:33:00+00:00",
    "commented_code": "+/**\n+ * We can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTES:\n+ * - The v2 mode is configured via `nodejs_compat_v2` compat flag or via `nodejs_compat` plus a compatibility date of Sept 23rd. 2024 or later.\n+ * - See `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDate: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasNoNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = \"2024-09-23\";\n+\tconst legacy = nodeCompat === true;\n+\tlet mode: NodeJSCompatMode = null;\n+\tif (\n+\t\thasNodejsCompatV2Flag ||\n+\t\t(hasNodejsCompatFlag &&\n+\t\t\tcompatibilityDate >= nodeCompatSwitchOverDate &&\n+\t\t\t!hasNoNodejsCompatV2Flag)",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "1775766611",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
        "discussion_id": "1775766611",
        "commented_code": "@@ -0,0 +1,78 @@\n+/**\n+ * We can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTES:\n+ * - The v2 mode is configured via `nodejs_compat_v2` compat flag or via `nodejs_compat` plus a compatibility date of Sept 23rd. 2024 or later.\n+ * - See `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDate: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasNoNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = \"2024-09-23\";\n+\tconst legacy = nodeCompat === true;\n+\tlet mode: NodeJSCompatMode = null;\n+\tif (\n+\t\thasNodejsCompatV2Flag ||\n+\t\t(hasNodejsCompatFlag &&\n+\t\t\tcompatibilityDate >= nodeCompatSwitchOverDate &&\n+\t\t\t!hasNoNodejsCompatV2Flag)",
        "comment_created_at": "2024-09-25T18:33:00+00:00",
        "comment_author": "vicb",
        "comment_body": "```suggestion\r\n\t\thasNodejsCompatV2Flag ||\r\n\t\t(hasNodejsCompatFlag && compatibilityDate >= nodeCompatSwitchOverDate)\r\n```\r\n`!hasNoNodejsCompatV2Flag` should not affect the result because `hasNodejsCompatV2Flag` is true when this is false and `true || false` is true\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1775781611",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
        "discussion_id": "1775766611",
        "commented_code": "@@ -0,0 +1,78 @@\n+/**\n+ * We can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTES:\n+ * - The v2 mode is configured via `nodejs_compat_v2` compat flag or via `nodejs_compat` plus a compatibility date of Sept 23rd. 2024 or later.\n+ * - See `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDate: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasNoNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = \"2024-09-23\";\n+\tconst legacy = nodeCompat === true;\n+\tlet mode: NodeJSCompatMode = null;\n+\tif (\n+\t\thasNodejsCompatV2Flag ||\n+\t\t(hasNodejsCompatFlag &&\n+\t\t\tcompatibilityDate >= nodeCompatSwitchOverDate &&\n+\t\t\t!hasNoNodejsCompatV2Flag)",
        "comment_created_at": "2024-09-25T18:46:39+00:00",
        "comment_author": "petebacondarwin",
        "comment_body": "\r\n- `hasNodejsCompatV2Flag`  means that there is a compat flag called `nodejs_compat_v2`.\r\n- `hasNoNodejsCompatV2Flag` means that there is a compat flag called `no_nodejs_compat_v2`.\r\n\r\nSo the logic here is to catch the case where we have:\r\n\r\n```toml\r\ncompatibility_date = \"2024-09-23\" # new date triggers v2\r\ncompatibility_flags = [\"nodejs_compat\", \"no_nodejs_compat_v2\"] # second flag turns off v2 despite the date\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1775800791",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6824,
        "pr_file": "packages/miniflare/src/plugins/core/node-compat.ts",
        "discussion_id": "1775766611",
        "commented_code": "@@ -0,0 +1,78 @@\n+/**\n+ * We can provide Node.js compatibility in a number of different modes:\n+ * - \"legacy\" - this mode adds compile-time polyfills that are not well maintained and cannot work with workerd runtime builtins.\n+ * - \"als\": this mode tells the workerd runtime to enable only the Async Local Storage builtin library (accessible via `node:async_hooks`).\n+ * - \"v1\" - this mode tells the workerd runtime to enable some Node.js builtin libraries (accessible only via `node:...` imports) but no globals.\n+ * - \"v2\" - this mode tells the workerd runtime to enable more Node.js builtin libraries (accessible both with and without the `node:` prefix)\n+ *   and also some Node.js globals such as `Buffer`; it also turns on additional compile-time polyfills for those that are not provided by the runtime.\n+ *  - null - no Node.js compatibility.\n+ */\n+export type NodeJSCompatMode = \"legacy\" | \"als\" | \"v1\" | \"v2\" | null;\n+\n+/**\n+ * Computes the Node.js compatibility mode we are running.\n+ *\n+ * NOTES:\n+ * - The v2 mode is configured via `nodejs_compat_v2` compat flag or via `nodejs_compat` plus a compatibility date of Sept 23rd. 2024 or later.\n+ * - See `EnvironmentInheritable` for `nodeCompat` and `noBundle`.\n+ *\n+ * @param compatibilityDateStr The compatibility date\n+ * @param compatibilityFlags The compatibility flags\n+ * @param opts.nodeCompat Whether the legacy node_compat arg is being used\n+ * @returns the mode and flags to indicate specific configuration for validating.\n+ */\n+export function getNodeCompatMode(\n+\tcompatibilityDate: string = \"2000-01-01\", // Default to some arbitrary old date\n+\tcompatibilityFlags: string[],\n+\topts?: {\n+\t\tnodeCompat?: boolean;\n+\t}\n+) {\n+\tconst { nodeCompat = false } = opts ?? {};\n+\tconst {\n+\t\thasNodejsAlsFlag,\n+\t\thasNodejsCompatFlag,\n+\t\thasNodejsCompatV2Flag,\n+\t\thasNoNodejsCompatV2Flag,\n+\t\thasExperimentalNodejsCompatV2Flag,\n+\t} = parseNodeCompatibilityFlags(compatibilityFlags);\n+\n+\tconst nodeCompatSwitchOverDate = \"2024-09-23\";\n+\tconst legacy = nodeCompat === true;\n+\tlet mode: NodeJSCompatMode = null;\n+\tif (\n+\t\thasNodejsCompatV2Flag ||\n+\t\t(hasNodejsCompatFlag &&\n+\t\t\tcompatibilityDate >= nodeCompatSwitchOverDate &&\n+\t\t\t!hasNoNodejsCompatV2Flag)",
        "comment_created_at": "2024-09-25T19:01:49+00:00",
        "comment_author": "vicb",
        "comment_body": "Oops... I missed the **No**, we want nodejs_compat_v1 here ;)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1771655158",
    "pr_number": 6802,
    "pr_file": "packages/wrangler/src/deploy/index.ts",
    "created_at": "2024-09-23T15:15:25+00:00",
    "commented_code": "hidden: true,\n \t\t\t})\n \t\t\t.option(\"legacy-assets\", {",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "1771655158",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6802,
        "pr_file": "packages/wrangler/src/deploy/index.ts",
        "discussion_id": "1771655158",
        "commented_code": "@@ -105,20 +102,14 @@ export function deployOptions(yargs: CommonYargsArgv) {\n \t\t\t\thidden: true,\n \t\t\t})\n \t\t\t.option(\"legacy-assets\", {",
        "comment_created_at": "2024-09-23T15:15:25+00:00",
        "comment_author": "CarmenPopoviciu",
        "comment_body": "are we good with hiding `legacy-assets`? IMO makes sense to, but want to sanity check with the rest of the team <3",
        "pr_file_module": null
      },
      {
        "comment_id": "1771664889",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6802,
        "pr_file": "packages/wrangler/src/deploy/index.ts",
        "discussion_id": "1771655158",
        "commented_code": "@@ -105,20 +102,14 @@ export function deployOptions(yargs: CommonYargsArgv) {\n \t\t\t\thidden: true,\n \t\t\t})\n \t\t\t.option(\"legacy-assets\", {",
        "comment_created_at": "2024-09-23T15:21:50+00:00",
        "comment_author": "emily-shen",
        "comment_body": "should we hide `--sites` as well?",
        "pr_file_module": null
      },
      {
        "comment_id": "1771688862",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6802,
        "pr_file": "packages/wrangler/src/deploy/index.ts",
        "discussion_id": "1771655158",
        "commented_code": "@@ -105,20 +102,14 @@ export function deployOptions(yargs: CommonYargsArgv) {\n \t\t\t\thidden: true,\n \t\t\t})\n \t\t\t.option(\"legacy-assets\", {",
        "comment_created_at": "2024-09-23T15:37:00+00:00",
        "comment_author": "CarmenPopoviciu",
        "comment_body": "hmmm...good question. I'll defer to @tanushree-sharma ",
        "pr_file_module": null
      },
      {
        "comment_id": "1771871569",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 6802,
        "pr_file": "packages/wrangler/src/deploy/index.ts",
        "discussion_id": "1771655158",
        "commented_code": "@@ -105,20 +102,14 @@ export function deployOptions(yargs: CommonYargsArgv) {\n \t\t\t\thidden: true,\n \t\t\t})\n \t\t\t.option(\"legacy-assets\", {",
        "comment_created_at": "2024-09-23T18:01:58+00:00",
        "comment_author": "CarmenPopoviciu",
        "comment_body": "for posterity, we went with:\r\n- hide `legacy-assets`\r\n- hide `site` & site related\r\n\r\nin `dev`, `deploy` and `versions upload`",
        "pr_file_module": null
      }
    ]
  }
]