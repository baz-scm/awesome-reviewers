[
  {
    "discussion_id": "2182102346",
    "pr_number": 9816,
    "pr_file": "packages/wrangler/src/config/auto-update-helpers.ts",
    "created_at": "2025-07-03T07:47:28+00:00",
    "commented_code": "+import { confirm, prompt } from \"../dialogs\";\n+import { logger } from \"../logger\";\n+import { isValidIdentifier } from \"../type-generation\";\n+import { formatConfigSnippet } from \"./index\";\n+import type { ResourceBinding } from \"./auto-update\";\n+import type { RawConfig } from \"./config\";\n+\n+// Registry of resource configuration patterns for better maintainability\n+export const RESOURCE_CONFIG_REGISTRY = {\n+\td1_databases: {\n+\t\tdisplayName: \"D1 Database\",\n+\t\tgenericBindingName: \"DB\",\n+\t\tidentifierField: \"database_id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tdatabase_name: resource.name,\n+\t\t\tdatabase_id: resource.id,\n+\t\t}),\n+\t},\n+\tr2_buckets: {\n+\t\tdisplayName: \"R2 Bucket\",\n+\t\tgenericBindingName: \"BUCKET\",\n+\t\tidentifierField: \"bucket_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tbucket_name: resource.name,\n+\t\t}),\n+\t},\n+\tkv_namespaces: {\n+\t\tdisplayName: \"KV Namespace\",\n+\t\tgenericBindingName: \"KV\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+\tvectorize: {\n+\t\tdisplayName: \"Vectorize Index\",\n+\t\tgenericBindingName: \"VECTORIZE\",\n+\t\tidentifierField: \"index_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tindex_name: resource.name,\n+\t\t}),\n+\t},\n+\thyperdrive: {\n+\t\tdisplayName: \"Hyperdrive Configuration\",\n+\t\tgenericBindingName: \"HYPERDRIVE\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+} as const;\n+\n+export function createBindingConfig(\n+\tresource: ResourceBinding,\n+\tbindingName: string\n+): Record<string, unknown> {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[resource.type];\n+\tif (!configTemplate) {\n+\t\tthrow new Error(`Unsupported resource type: ${resource.type}`);\n+\t}\n+\treturn configTemplate.createConfig(resource, bindingName);\n+}\n+\n+export function getBindingIdentifier(\n+\tbinding: Record<string, unknown>,\n+\ttype: ResourceBinding[\"type\"]\n+): string | undefined {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[type];\n+\tif (!configTemplate) {\n+\t\treturn undefined;\n+\t}\n+\n+\tconst field = configTemplate.identifierField;\n+\treturn binding[field] as string;\n+}\n+\n+/**\n+ * Checks if a binding name conflicts with existing bindings across all resource types.\n+ * Binding names are case-insensitive in JavaScript.\n+ */\n+export function hasBindingNameConflict(\n+\tconfig: RawConfig,\n+\tbindingName: string\n+): boolean {\n+\tconst normalizedName = bindingName.toUpperCase();\n+\n+\t// Check all resource types for existing bindings\n+\tfor (const resourceType of Object.keys(RESOURCE_CONFIG_REGISTRY)) {\n+\t\tconst bindings = config[\n+\t\t\tresourceType as keyof typeof RESOURCE_CONFIG_REGISTRY\n+\t\t] as Array<Record<string, unknown>> | undefined;\n+\t\tif (bindings) {\n+\t\t\tfor (const binding of bindings) {\n+\t\t\t\tif (binding.binding && typeof binding.binding === \"string\") {\n+\t\t\t\t\tif (binding.binding.toUpperCase() === normalizedName) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2182102346",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 9816,
        "pr_file": "packages/wrangler/src/config/auto-update-helpers.ts",
        "discussion_id": "2182102346",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { confirm, prompt } from \"../dialogs\";\n+import { logger } from \"../logger\";\n+import { isValidIdentifier } from \"../type-generation\";\n+import { formatConfigSnippet } from \"./index\";\n+import type { ResourceBinding } from \"./auto-update\";\n+import type { RawConfig } from \"./config\";\n+\n+// Registry of resource configuration patterns for better maintainability\n+export const RESOURCE_CONFIG_REGISTRY = {\n+\td1_databases: {\n+\t\tdisplayName: \"D1 Database\",\n+\t\tgenericBindingName: \"DB\",\n+\t\tidentifierField: \"database_id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tdatabase_name: resource.name,\n+\t\t\tdatabase_id: resource.id,\n+\t\t}),\n+\t},\n+\tr2_buckets: {\n+\t\tdisplayName: \"R2 Bucket\",\n+\t\tgenericBindingName: \"BUCKET\",\n+\t\tidentifierField: \"bucket_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tbucket_name: resource.name,\n+\t\t}),\n+\t},\n+\tkv_namespaces: {\n+\t\tdisplayName: \"KV Namespace\",\n+\t\tgenericBindingName: \"KV\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+\tvectorize: {\n+\t\tdisplayName: \"Vectorize Index\",\n+\t\tgenericBindingName: \"VECTORIZE\",\n+\t\tidentifierField: \"index_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tindex_name: resource.name,\n+\t\t}),\n+\t},\n+\thyperdrive: {\n+\t\tdisplayName: \"Hyperdrive Configuration\",\n+\t\tgenericBindingName: \"HYPERDRIVE\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+} as const;\n+\n+export function createBindingConfig(\n+\tresource: ResourceBinding,\n+\tbindingName: string\n+): Record<string, unknown> {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[resource.type];\n+\tif (!configTemplate) {\n+\t\tthrow new Error(`Unsupported resource type: ${resource.type}`);\n+\t}\n+\treturn configTemplate.createConfig(resource, bindingName);\n+}\n+\n+export function getBindingIdentifier(\n+\tbinding: Record<string, unknown>,\n+\ttype: ResourceBinding[\"type\"]\n+): string | undefined {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[type];\n+\tif (!configTemplate) {\n+\t\treturn undefined;\n+\t}\n+\n+\tconst field = configTemplate.identifierField;\n+\treturn binding[field] as string;\n+}\n+\n+/**\n+ * Checks if a binding name conflicts with existing bindings across all resource types.\n+ * Binding names are case-insensitive in JavaScript.\n+ */\n+export function hasBindingNameConflict(\n+\tconfig: RawConfig,\n+\tbindingName: string\n+): boolean {\n+\tconst normalizedName = bindingName.toUpperCase();\n+\n+\t// Check all resource types for existing bindings\n+\tfor (const resourceType of Object.keys(RESOURCE_CONFIG_REGISTRY)) {\n+\t\tconst bindings = config[\n+\t\t\tresourceType as keyof typeof RESOURCE_CONFIG_REGISTRY\n+\t\t] as Array<Record<string, unknown>> | undefined;\n+\t\tif (bindings) {\n+\t\t\tfor (const binding of bindings) {\n+\t\t\t\tif (binding.binding && typeof binding.binding === \"string\") {\n+\t\t\t\t\tif (binding.binding.toUpperCase() === normalizedName) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}",
        "comment_created_at": "2025-07-03T07:47:28+00:00",
        "comment_author": "vicb",
        "comment_body": "Collapse the 2 conditions?\r\n\r\n```ts\r\n\t\t\t\tif (binding.binding && typeof binding.binding === \"string\" && binding.binding.toUpperCase() === normalizedName) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n```\t\t\t\t\t\r\n\r\nI don't think `binding.binding` is needed with the typeof?\r\n\r\n```ts\r\n\t\t\t\tif (typeof binding.binding === \"string\" && binding.binding.toUpperCase() === normalizedName) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n```\t\t\t\t\t\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182107280",
    "pr_number": 9816,
    "pr_file": "packages/wrangler/src/config/auto-update-helpers.ts",
    "created_at": "2025-07-03T07:50:00+00:00",
    "commented_code": "+import { confirm, prompt } from \"../dialogs\";\n+import { logger } from \"../logger\";\n+import { isValidIdentifier } from \"../type-generation\";\n+import { formatConfigSnippet } from \"./index\";\n+import type { ResourceBinding } from \"./auto-update\";\n+import type { RawConfig } from \"./config\";\n+\n+// Registry of resource configuration patterns for better maintainability\n+export const RESOURCE_CONFIG_REGISTRY = {\n+\td1_databases: {\n+\t\tdisplayName: \"D1 Database\",\n+\t\tgenericBindingName: \"DB\",\n+\t\tidentifierField: \"database_id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tdatabase_name: resource.name,\n+\t\t\tdatabase_id: resource.id,\n+\t\t}),\n+\t},\n+\tr2_buckets: {\n+\t\tdisplayName: \"R2 Bucket\",\n+\t\tgenericBindingName: \"BUCKET\",\n+\t\tidentifierField: \"bucket_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tbucket_name: resource.name,\n+\t\t}),\n+\t},\n+\tkv_namespaces: {\n+\t\tdisplayName: \"KV Namespace\",\n+\t\tgenericBindingName: \"KV\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+\tvectorize: {\n+\t\tdisplayName: \"Vectorize Index\",\n+\t\tgenericBindingName: \"VECTORIZE\",\n+\t\tidentifierField: \"index_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tindex_name: resource.name,\n+\t\t}),\n+\t},\n+\thyperdrive: {\n+\t\tdisplayName: \"Hyperdrive Configuration\",\n+\t\tgenericBindingName: \"HYPERDRIVE\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+} as const;\n+\n+export function createBindingConfig(\n+\tresource: ResourceBinding,\n+\tbindingName: string\n+): Record<string, unknown> {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[resource.type];\n+\tif (!configTemplate) {\n+\t\tthrow new Error(`Unsupported resource type: ${resource.type}`);\n+\t}\n+\treturn configTemplate.createConfig(resource, bindingName);\n+}\n+\n+export function getBindingIdentifier(\n+\tbinding: Record<string, unknown>,\n+\ttype: ResourceBinding[\"type\"]\n+): string | undefined {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[type];\n+\tif (!configTemplate) {\n+\t\treturn undefined;\n+\t}\n+\n+\tconst field = configTemplate.identifierField;\n+\treturn binding[field] as string;\n+}\n+\n+/**\n+ * Checks if a binding name conflicts with existing bindings across all resource types.\n+ * Binding names are case-insensitive in JavaScript.\n+ */\n+export function hasBindingNameConflict(\n+\tconfig: RawConfig,\n+\tbindingName: string\n+): boolean {\n+\tconst normalizedName = bindingName.toUpperCase();\n+\n+\t// Check all resource types for existing bindings\n+\tfor (const resourceType of Object.keys(RESOURCE_CONFIG_REGISTRY)) {\n+\t\tconst bindings = config[\n+\t\t\tresourceType as keyof typeof RESOURCE_CONFIG_REGISTRY\n+\t\t] as Array<Record<string, unknown>> | undefined;\n+\t\tif (bindings) {\n+\t\t\tfor (const binding of bindings) {\n+\t\t\t\tif (binding.binding && typeof binding.binding === \"string\") {\n+\t\t\t\t\tif (binding.binding.toUpperCase() === normalizedName) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n+/**\n+ * Gets the display name for a resource type from the registry.\n+ */\n+export function getResourceDisplayName(\n+\tresourceType: ResourceBinding[\"type\"]\n+): string {\n+\tconst config = RESOURCE_CONFIG_REGISTRY[resourceType];\n+\treturn config?.displayName || resourceType.replace(/_/g, \" \");\n+}\n+\n+/**\n+ * Gets the generic binding name for a resource type from the registry.\n+ */\n+export function getGenericBindingName(\n+\tresourceType: ResourceBinding[\"type\"]\n+): string {\n+\tconst config = RESOURCE_CONFIG_REGISTRY[resourceType];\n+\treturn config?.genericBindingName || resourceType.toUpperCase();\n+}\n+\n+/**\n+ * Display a configuration snippet for a resource binding.\n+ * This is used to show users how to manually add the binding if auto-update fails.\n+ */\n+export function displayConfigSnippet(\n+\tresource: ResourceBinding,\n+\tconfigPath: string | undefined,\n+\tbindingName?: string\n+) {\n+\tconst actualBindingName =\n+\t\tbindingName || resource.binding || getGenericBindingName(resource.type);\n+\tconst newBinding = createBindingConfig(resource, actualBindingName);\n+\tconst snippet = { [resource.type]: [newBinding] };\n+\n+\tlogger.log(\"\n\" + formatConfigSnippet(snippet, configPath));\n+}\n+\n+/**\n+ * Validates that a binding name is a valid JavaScript identifier and doesn't conflict with existing bindings.\n+ */\n+export function validateBindingName(\n+\tconfig: RawConfig,\n+\tbindingName: string\n+): { valid: boolean; error?: string } {\n+\t// Check if it's a valid JavaScript identifier\n+\tif (!isValidIdentifier(bindingName)) {\n+\t\treturn {\n+\t\t\tvalid: false,\n+\t\t\terror: `\"${bindingName}\" is not a valid JavaScript identifier. Binding names must start with a letter, underscore, or $ and contain only letters, numbers, underscores, and $.`,\n+\t\t};\n+\t}\n+\n+\t// Check for conflicts with existing bindings\n+\tif (hasBindingNameConflict(config, bindingName)) {\n+\t\treturn {\n+\t\t\tvalid: false,\n+\t\t\terror: `Binding name \"${bindingName}\" already exists. Please choose a different name.`,\n+\t\t};\n+\t}\n+\n+\treturn { valid: true };\n+}\n+\n+/**\n+ * Asks if the user wants to add the resource to their wrangler config.\n+ */\n+export async function promptForConfigUpdate(\n+\tresourceType: ResourceBinding[\"type\"]\n+): Promise<boolean> {\n+\treturn await confirm(\n+\t\t`Would you like to add this ${getResourceDisplayName(resourceType)} to your wrangler.jsonc?`,\n+\t\t{ defaultValue: true, fallbackValue: false }\n+\t);\n+}\n+\n+/**\n+ * Prompts the user for a binding name with conflict resolution.\n+ * Shows a placeholder based on the resource type and handles conflicts by re-prompting.\n+ */\n+export async function promptForValidBindingName(\n+\tconfig: RawConfig,\n+\tresourceType: ResourceBinding[\"type\"],\n+\tconflictingName?: string\n+): Promise<string> {\n+\tconst placeholder = getGenericBindingName(resourceType);\n+\n+\t// If there's a conflicting name, ask if they want to enter a new one\n+\tif (conflictingName) {\n+\t\tconst shouldTryAgain = await confirm(\n+\t\t\t`That binding name is not available. Would you like to enter a new binding name?`,\n+\t\t\t{ defaultValue: true, fallbackValue: false }\n+\t\t);\n+\n+\t\tif (!shouldTryAgain) {\n+\t\t\tthrow new Error(\n+\t\t\t\t\"Binding name conflict - user chose not to provide alternative\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\tlet bindingName: string = \"\";\n+\tlet isValid = false;\n+\tlet currentDefault: string | undefined = placeholder;\n+\n+\twhile (!isValid) {\n+\t\tconst promptOptions = currentDefault \n+\t\t\t? { defaultValue: currentDefault }\n+\t\t\t: {};\n+\t\t\n+\t\tbindingName = await prompt(`What binding name would you like to use?`, promptOptions);\n+\n+\t\t// Use currentDefault if user just pressed enter and we have a default\n+\t\tif (!bindingName || bindingName.trim() === \"\") {\n+\t\t\tif (currentDefault) {\n+\t\t\t\tbindingName = currentDefault;\n+\t\t\t} else {\n+\t\t\t\t// If no default and user pressed enter, continue the loop\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t}\n+\n+\t\tconst validation = validateBindingName(config, bindingName);\n+\t\tif (validation.valid) {\n+\t\t\tisValid = true;",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "2182107280",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 9816,
        "pr_file": "packages/wrangler/src/config/auto-update-helpers.ts",
        "discussion_id": "2182107280",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { confirm, prompt } from \"../dialogs\";\n+import { logger } from \"../logger\";\n+import { isValidIdentifier } from \"../type-generation\";\n+import { formatConfigSnippet } from \"./index\";\n+import type { ResourceBinding } from \"./auto-update\";\n+import type { RawConfig } from \"./config\";\n+\n+// Registry of resource configuration patterns for better maintainability\n+export const RESOURCE_CONFIG_REGISTRY = {\n+\td1_databases: {\n+\t\tdisplayName: \"D1 Database\",\n+\t\tgenericBindingName: \"DB\",\n+\t\tidentifierField: \"database_id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tdatabase_name: resource.name,\n+\t\t\tdatabase_id: resource.id,\n+\t\t}),\n+\t},\n+\tr2_buckets: {\n+\t\tdisplayName: \"R2 Bucket\",\n+\t\tgenericBindingName: \"BUCKET\",\n+\t\tidentifierField: \"bucket_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tbucket_name: resource.name,\n+\t\t}),\n+\t},\n+\tkv_namespaces: {\n+\t\tdisplayName: \"KV Namespace\",\n+\t\tgenericBindingName: \"KV\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+\tvectorize: {\n+\t\tdisplayName: \"Vectorize Index\",\n+\t\tgenericBindingName: \"VECTORIZE\",\n+\t\tidentifierField: \"index_name\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tindex_name: resource.name,\n+\t\t}),\n+\t},\n+\thyperdrive: {\n+\t\tdisplayName: \"Hyperdrive Configuration\",\n+\t\tgenericBindingName: \"HYPERDRIVE\",\n+\t\tidentifierField: \"id\" as const,\n+\t\tcreateConfig: (resource: ResourceBinding, bindingName: string) => ({\n+\t\t\tbinding: bindingName,\n+\t\t\tid: resource.id,\n+\t\t}),\n+\t},\n+} as const;\n+\n+export function createBindingConfig(\n+\tresource: ResourceBinding,\n+\tbindingName: string\n+): Record<string, unknown> {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[resource.type];\n+\tif (!configTemplate) {\n+\t\tthrow new Error(`Unsupported resource type: ${resource.type}`);\n+\t}\n+\treturn configTemplate.createConfig(resource, bindingName);\n+}\n+\n+export function getBindingIdentifier(\n+\tbinding: Record<string, unknown>,\n+\ttype: ResourceBinding[\"type\"]\n+): string | undefined {\n+\tconst configTemplate = RESOURCE_CONFIG_REGISTRY[type];\n+\tif (!configTemplate) {\n+\t\treturn undefined;\n+\t}\n+\n+\tconst field = configTemplate.identifierField;\n+\treturn binding[field] as string;\n+}\n+\n+/**\n+ * Checks if a binding name conflicts with existing bindings across all resource types.\n+ * Binding names are case-insensitive in JavaScript.\n+ */\n+export function hasBindingNameConflict(\n+\tconfig: RawConfig,\n+\tbindingName: string\n+): boolean {\n+\tconst normalizedName = bindingName.toUpperCase();\n+\n+\t// Check all resource types for existing bindings\n+\tfor (const resourceType of Object.keys(RESOURCE_CONFIG_REGISTRY)) {\n+\t\tconst bindings = config[\n+\t\t\tresourceType as keyof typeof RESOURCE_CONFIG_REGISTRY\n+\t\t] as Array<Record<string, unknown>> | undefined;\n+\t\tif (bindings) {\n+\t\t\tfor (const binding of bindings) {\n+\t\t\t\tif (binding.binding && typeof binding.binding === \"string\") {\n+\t\t\t\t\tif (binding.binding.toUpperCase() === normalizedName) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n+/**\n+ * Gets the display name for a resource type from the registry.\n+ */\n+export function getResourceDisplayName(\n+\tresourceType: ResourceBinding[\"type\"]\n+): string {\n+\tconst config = RESOURCE_CONFIG_REGISTRY[resourceType];\n+\treturn config?.displayName || resourceType.replace(/_/g, \" \");\n+}\n+\n+/**\n+ * Gets the generic binding name for a resource type from the registry.\n+ */\n+export function getGenericBindingName(\n+\tresourceType: ResourceBinding[\"type\"]\n+): string {\n+\tconst config = RESOURCE_CONFIG_REGISTRY[resourceType];\n+\treturn config?.genericBindingName || resourceType.toUpperCase();\n+}\n+\n+/**\n+ * Display a configuration snippet for a resource binding.\n+ * This is used to show users how to manually add the binding if auto-update fails.\n+ */\n+export function displayConfigSnippet(\n+\tresource: ResourceBinding,\n+\tconfigPath: string | undefined,\n+\tbindingName?: string\n+) {\n+\tconst actualBindingName =\n+\t\tbindingName || resource.binding || getGenericBindingName(resource.type);\n+\tconst newBinding = createBindingConfig(resource, actualBindingName);\n+\tconst snippet = { [resource.type]: [newBinding] };\n+\n+\tlogger.log(\"\\n\" + formatConfigSnippet(snippet, configPath));\n+}\n+\n+/**\n+ * Validates that a binding name is a valid JavaScript identifier and doesn't conflict with existing bindings.\n+ */\n+export function validateBindingName(\n+\tconfig: RawConfig,\n+\tbindingName: string\n+): { valid: boolean; error?: string } {\n+\t// Check if it's a valid JavaScript identifier\n+\tif (!isValidIdentifier(bindingName)) {\n+\t\treturn {\n+\t\t\tvalid: false,\n+\t\t\terror: `\"${bindingName}\" is not a valid JavaScript identifier. Binding names must start with a letter, underscore, or $ and contain only letters, numbers, underscores, and $.`,\n+\t\t};\n+\t}\n+\n+\t// Check for conflicts with existing bindings\n+\tif (hasBindingNameConflict(config, bindingName)) {\n+\t\treturn {\n+\t\t\tvalid: false,\n+\t\t\terror: `Binding name \"${bindingName}\" already exists. Please choose a different name.`,\n+\t\t};\n+\t}\n+\n+\treturn { valid: true };\n+}\n+\n+/**\n+ * Asks if the user wants to add the resource to their wrangler config.\n+ */\n+export async function promptForConfigUpdate(\n+\tresourceType: ResourceBinding[\"type\"]\n+): Promise<boolean> {\n+\treturn await confirm(\n+\t\t`Would you like to add this ${getResourceDisplayName(resourceType)} to your wrangler.jsonc?`,\n+\t\t{ defaultValue: true, fallbackValue: false }\n+\t);\n+}\n+\n+/**\n+ * Prompts the user for a binding name with conflict resolution.\n+ * Shows a placeholder based on the resource type and handles conflicts by re-prompting.\n+ */\n+export async function promptForValidBindingName(\n+\tconfig: RawConfig,\n+\tresourceType: ResourceBinding[\"type\"],\n+\tconflictingName?: string\n+): Promise<string> {\n+\tconst placeholder = getGenericBindingName(resourceType);\n+\n+\t// If there's a conflicting name, ask if they want to enter a new one\n+\tif (conflictingName) {\n+\t\tconst shouldTryAgain = await confirm(\n+\t\t\t`That binding name is not available. Would you like to enter a new binding name?`,\n+\t\t\t{ defaultValue: true, fallbackValue: false }\n+\t\t);\n+\n+\t\tif (!shouldTryAgain) {\n+\t\t\tthrow new Error(\n+\t\t\t\t\"Binding name conflict - user chose not to provide alternative\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\tlet bindingName: string = \"\";\n+\tlet isValid = false;\n+\tlet currentDefault: string | undefined = placeholder;\n+\n+\twhile (!isValid) {\n+\t\tconst promptOptions = currentDefault \n+\t\t\t? { defaultValue: currentDefault }\n+\t\t\t: {};\n+\t\t\n+\t\tbindingName = await prompt(`What binding name would you like to use?`, promptOptions);\n+\n+\t\t// Use currentDefault if user just pressed enter and we have a default\n+\t\tif (!bindingName || bindingName.trim() === \"\") {\n+\t\t\tif (currentDefault) {\n+\t\t\t\tbindingName = currentDefault;\n+\t\t\t} else {\n+\t\t\t\t// If no default and user pressed enter, continue the loop\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t}\n+\n+\t\tconst validation = validateBindingName(config, bindingName);\n+\t\tif (validation.valid) {\n+\t\t\tisValid = true;",
        "comment_created_at": "2025-07-03T07:50:00+00:00",
        "comment_author": "vicb",
        "comment_body": "Do you need `isValid` here or can you `while(true)` and `return bindingName;` here?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1469815759",
    "pr_number": 4797,
    "pr_file": "packages/pages-shared/asset-server/handler.ts",
    "created_at": "2024-01-29T15:59:27+00:00",
    "commented_code": "response.headers.set(\"x-robots-tag\", \"noindex\");\n \t\t\t}\n \n-\t\t\tif (options.preserve) {\n-\t\t\t\t// https://fetch.spec.whatwg.org/#null-body-status\n-\t\t\t\tconst preservedResponse = new Response(\n-\t\t\t\t\t[101, 204, 205, 304].includes(response.status)\n-\t\t\t\t\t\t? null\n-\t\t\t\t\t\t: response.clone().body,\n-\t\t\t\t\tresponse\n-\t\t\t\t);\n-\t\t\t\tpreservedResponse.headers.set(\n-\t\t\t\t\t\"cache-control\",\n-\t\t\t\t\tCACHE_CONTROL_PRESERVATION\n-\t\t\t\t);\n-\t\t\t\tpreservedResponse.headers.set(\"x-robots-tag\", \"noindex\");\n+\t\t\tif (options.preserve && waitUntil && caches) {\n+\t\t\t\twaitUntil(\n+\t\t\t\t\t(async () => {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst assetPreservationCache = await caches.open(\n+\t\t\t\t\t\t\t\tASSET_PRESERVATION_CACHE\n+\t\t\t\t\t\t\t);\n \n-\t\t\t\tif (waitUntil && caches) {\n-\t\t\t\t\twaitUntil(\n-\t\t\t\t\t\tcaches\n-\t\t\t\t\t\t\t.open(ASSET_PRESERVATION_CACHE)\n-\t\t\t\t\t\t\t.then((assetPreservationCache) =>\n-\t\t\t\t\t\t\t\tassetPreservationCache.put(request.url, preservedResponse)\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t.catch((err) => {\n-\t\t\t\t\t\t\t\tlogError(err);\n-\t\t\t\t\t\t\t})\n-\t\t\t\t\t);\n-\t\t\t\t}\n+\t\t\t\t\t\t\tlet shouldUpdateCache = true;\n+\n+\t\t\t\t\t\t\t// Check if the asset has changed since last written to cache\n+\t\t\t\t\t\t\tconst match = await assetPreservationCache.match(request);\n+\t\t\t\t\t\t\tif (match) {\n+\t\t\t\t\t\t\t\tconst cachedAssetKey = await match.text();\n+\t\t\t\t\t\t\t\tif (cachedAssetKey === assetKey) {\n+\t\t\t\t\t\t\t\t\tshouldUpdateCache = false;\n+\t\t\t\t\t\t\t\t}",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "1469815759",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 4797,
        "pr_file": "packages/pages-shared/asset-server/handler.ts",
        "discussion_id": "1469815759",
        "commented_code": "@@ -516,32 +527,46 @@ export async function generateHandler<\n \t\t\t\tresponse.headers.set(\"x-robots-tag\", \"noindex\");\n \t\t\t}\n \n-\t\t\tif (options.preserve) {\n-\t\t\t\t// https://fetch.spec.whatwg.org/#null-body-status\n-\t\t\t\tconst preservedResponse = new Response(\n-\t\t\t\t\t[101, 204, 205, 304].includes(response.status)\n-\t\t\t\t\t\t? null\n-\t\t\t\t\t\t: response.clone().body,\n-\t\t\t\t\tresponse\n-\t\t\t\t);\n-\t\t\t\tpreservedResponse.headers.set(\n-\t\t\t\t\t\"cache-control\",\n-\t\t\t\t\tCACHE_CONTROL_PRESERVATION\n-\t\t\t\t);\n-\t\t\t\tpreservedResponse.headers.set(\"x-robots-tag\", \"noindex\");\n+\t\t\tif (options.preserve && waitUntil && caches) {\n+\t\t\t\twaitUntil(\n+\t\t\t\t\t(async () => {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst assetPreservationCache = await caches.open(\n+\t\t\t\t\t\t\t\tASSET_PRESERVATION_CACHE\n+\t\t\t\t\t\t\t);\n \n-\t\t\t\tif (waitUntil && caches) {\n-\t\t\t\t\twaitUntil(\n-\t\t\t\t\t\tcaches\n-\t\t\t\t\t\t\t.open(ASSET_PRESERVATION_CACHE)\n-\t\t\t\t\t\t\t.then((assetPreservationCache) =>\n-\t\t\t\t\t\t\t\tassetPreservationCache.put(request.url, preservedResponse)\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t.catch((err) => {\n-\t\t\t\t\t\t\t\tlogError(err);\n-\t\t\t\t\t\t\t})\n-\t\t\t\t\t);\n-\t\t\t\t}\n+\t\t\t\t\t\t\tlet shouldUpdateCache = true;\n+\n+\t\t\t\t\t\t\t// Check if the asset has changed since last written to cache\n+\t\t\t\t\t\t\tconst match = await assetPreservationCache.match(request);\n+\t\t\t\t\t\t\tif (match) {\n+\t\t\t\t\t\t\t\tconst cachedAssetKey = await match.text();\n+\t\t\t\t\t\t\t\tif (cachedAssetKey === assetKey) {\n+\t\t\t\t\t\t\t\t\tshouldUpdateCache = false;\n+\t\t\t\t\t\t\t\t}",
        "comment_created_at": "2024-01-29T15:59:27+00:00",
        "comment_author": "mrbbot",
        "comment_body": "Maybe remove the `if` here? Equally, this is quite nice for readability, so maybe just keep it as is?\r\n```suggestion\r\n\t\t\t\t\t\t\t\tshouldUpdateCache = cachedAssetKey !== assetKey;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1575401383",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 4797,
        "pr_file": "packages/pages-shared/asset-server/handler.ts",
        "discussion_id": "1469815759",
        "commented_code": "@@ -516,32 +527,46 @@ export async function generateHandler<\n \t\t\t\tresponse.headers.set(\"x-robots-tag\", \"noindex\");\n \t\t\t}\n \n-\t\t\tif (options.preserve) {\n-\t\t\t\t// https://fetch.spec.whatwg.org/#null-body-status\n-\t\t\t\tconst preservedResponse = new Response(\n-\t\t\t\t\t[101, 204, 205, 304].includes(response.status)\n-\t\t\t\t\t\t? null\n-\t\t\t\t\t\t: response.clone().body,\n-\t\t\t\t\tresponse\n-\t\t\t\t);\n-\t\t\t\tpreservedResponse.headers.set(\n-\t\t\t\t\t\"cache-control\",\n-\t\t\t\t\tCACHE_CONTROL_PRESERVATION\n-\t\t\t\t);\n-\t\t\t\tpreservedResponse.headers.set(\"x-robots-tag\", \"noindex\");\n+\t\t\tif (options.preserve && waitUntil && caches) {\n+\t\t\t\twaitUntil(\n+\t\t\t\t\t(async () => {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst assetPreservationCache = await caches.open(\n+\t\t\t\t\t\t\t\tASSET_PRESERVATION_CACHE\n+\t\t\t\t\t\t\t);\n \n-\t\t\t\tif (waitUntil && caches) {\n-\t\t\t\t\twaitUntil(\n-\t\t\t\t\t\tcaches\n-\t\t\t\t\t\t\t.open(ASSET_PRESERVATION_CACHE)\n-\t\t\t\t\t\t\t.then((assetPreservationCache) =>\n-\t\t\t\t\t\t\t\tassetPreservationCache.put(request.url, preservedResponse)\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t.catch((err) => {\n-\t\t\t\t\t\t\t\tlogError(err);\n-\t\t\t\t\t\t\t})\n-\t\t\t\t\t);\n-\t\t\t\t}\n+\t\t\t\t\t\t\tlet shouldUpdateCache = true;\n+\n+\t\t\t\t\t\t\t// Check if the asset has changed since last written to cache\n+\t\t\t\t\t\t\tconst match = await assetPreservationCache.match(request);\n+\t\t\t\t\t\t\tif (match) {\n+\t\t\t\t\t\t\t\tconst cachedAssetKey = await match.text();\n+\t\t\t\t\t\t\t\tif (cachedAssetKey === assetKey) {\n+\t\t\t\t\t\t\t\t\tshouldUpdateCache = false;\n+\t\t\t\t\t\t\t\t}",
        "comment_created_at": "2024-04-22T22:00:22+00:00",
        "comment_author": "jahands",
        "comment_body": "A lot of ASW is pretty hard to read, so i'm going to stick with the more readable version here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1539139290",
    "pr_number": 5376,
    "pr_file": "packages/create-cloudflare/src/help.ts",
    "created_at": "2024-03-26T12:33:36+00:00",
    "commented_code": "+import { logRaw } from \"@cloudflare/cli\";\n+import { bold, brandColor, dim } from \"@cloudflare/cli/colors\";\n+import { detectPackageManager } from \"helpers/packageManagers\";\n+import indentString from \"indent-string\";\n+import wrap from \"wrap-ansi\";\n+import { version } from \"../package.json\";\n+import type {\n+\tAllowedValueDefinition,\n+\tArgDefinition,\n+\tArgumentsDefinition,\n+\tOptionDefinition,\n+} from \"helpers/args\";\n+\n+const MAX_WIDTH = 100;\n+const PADDING_RIGHT = 5;\n+\n+export const showHelp = ({\n+\tpositionals,\n+\toptions,\n+\tintro,\n+}: ArgumentsDefinition) => {\n+\tconst { name: pm } = detectPackageManager();\n+\n+\tlogRaw(`${brandColor(\"create-cloudflare\")} ${dim(\"v\" + version)}\n`);\n+\tindent(`${intro.trim()}\n`, 1);\n+\n+\tlogRaw(bold(\"USAGE\n\"));\n+\tconst latest = pm === \"yarn\" ? \"\" : `@latest`;\n+\tconst opts = pm === \"npm\" ? \"-- options\" : `options`;\n+\tindent(`${pm} create cloudflare${latest} [directory] [${opts}]\n`, 1);\n+\n+\tlogRaw(bold(\"OPTIONS\n\"));\n+\n+\trenderPositionals(positionals);\n+\trenderOptions(options);\n+};\n+\n+/**\n+ * Indent the provided string by the specified level and write to stdout. Lines\n+ * will be wrapped to the width of the terminal or a preset maximum width, whichever\n+ * is smaller.\n+ *\n+ * @param str The string to be indented\n+ * @param level The indentation level\n+ */\n+const indent = (str: string, level = 0) => {\n+\tconst maxWidth = Math.min(MAX_WIDTH, process.stdout.columns - PADDING_RIGHT);\n+\tlogRaw(indentString(wrap(str, maxWidth - level), level, { indent: \"  \" }));\n+};\n+\n+const renderPositionals = (positionals?: ArgDefinition[]) => {\n+\tif (!positionals) {\n+\t\treturn;\n+\t}\n+\n+\tif (positionals) {\n+\t\tfor (const { name, description } of positionals) {\n+\t\t\tindent(bold(`${name}`), 1);\n+\t\t\tindent(`${description.trim()}\n`, 2);\n+\t\t}\n+\t}\n+};\n+\n+const renderOptions = (options?: OptionDefinition[]) => {\n+\tif (!options) {\n+\t\treturn;\n+\t}\n+\n+\tfor (const option of options) {\n+\t\tconst { name, description, alias, values, type, hidden } = option;\n+\t\tif (hidden) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tlet heading =\n+\t\t\ttype === \"string\"\n+\t\t\t\t? `${bold(`--${name}`)}=<value>`\n+\t\t\t\t: bold(`--${name}, --no-${name}`);",
    "repo_full_name": "cloudflare/workers-sdk",
    "discussion_comments": [
      {
        "comment_id": "1539139290",
        "repo_full_name": "cloudflare/workers-sdk",
        "pr_number": 5376,
        "pr_file": "packages/create-cloudflare/src/help.ts",
        "discussion_id": "1539139290",
        "commented_code": "@@ -0,0 +1,108 @@\n+import { logRaw } from \"@cloudflare/cli\";\n+import { bold, brandColor, dim } from \"@cloudflare/cli/colors\";\n+import { detectPackageManager } from \"helpers/packageManagers\";\n+import indentString from \"indent-string\";\n+import wrap from \"wrap-ansi\";\n+import { version } from \"../package.json\";\n+import type {\n+\tAllowedValueDefinition,\n+\tArgDefinition,\n+\tArgumentsDefinition,\n+\tOptionDefinition,\n+} from \"helpers/args\";\n+\n+const MAX_WIDTH = 100;\n+const PADDING_RIGHT = 5;\n+\n+export const showHelp = ({\n+\tpositionals,\n+\toptions,\n+\tintro,\n+}: ArgumentsDefinition) => {\n+\tconst { name: pm } = detectPackageManager();\n+\n+\tlogRaw(`${brandColor(\"create-cloudflare\")} ${dim(\"v\" + version)}\\n`);\n+\tindent(`${intro.trim()}\\n`, 1);\n+\n+\tlogRaw(bold(\"USAGE\\n\"));\n+\tconst latest = pm === \"yarn\" ? \"\" : `@latest`;\n+\tconst opts = pm === \"npm\" ? \"-- options\" : `options`;\n+\tindent(`${pm} create cloudflare${latest} [directory] [${opts}]\\n`, 1);\n+\n+\tlogRaw(bold(\"OPTIONS\\n\"));\n+\n+\trenderPositionals(positionals);\n+\trenderOptions(options);\n+};\n+\n+/**\n+ * Indent the provided string by the specified level and write to stdout. Lines\n+ * will be wrapped to the width of the terminal or a preset maximum width, whichever\n+ * is smaller.\n+ *\n+ * @param str The string to be indented\n+ * @param level The indentation level\n+ */\n+const indent = (str: string, level = 0) => {\n+\tconst maxWidth = Math.min(MAX_WIDTH, process.stdout.columns - PADDING_RIGHT);\n+\tlogRaw(indentString(wrap(str, maxWidth - level), level, { indent: \"  \" }));\n+};\n+\n+const renderPositionals = (positionals?: ArgDefinition[]) => {\n+\tif (!positionals) {\n+\t\treturn;\n+\t}\n+\n+\tif (positionals) {\n+\t\tfor (const { name, description } of positionals) {\n+\t\t\tindent(bold(`${name}`), 1);\n+\t\t\tindent(`${description.trim()}\\n`, 2);\n+\t\t}\n+\t}\n+};\n+\n+const renderOptions = (options?: OptionDefinition[]) => {\n+\tif (!options) {\n+\t\treturn;\n+\t}\n+\n+\tfor (const option of options) {\n+\t\tconst { name, description, alias, values, type, hidden } = option;\n+\t\tif (hidden) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tlet heading =\n+\t\t\ttype === \"string\"\n+\t\t\t\t? `${bold(`--${name}`)}=<value>`\n+\t\t\t\t: bold(`--${name}, --no-${name}`);",
        "comment_created_at": "2024-03-26T12:33:36+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "Nit:\r\nI feel like inverting the check could be better for future proofing this? (in case other types could be needed in the future)\r\n```suggestion\r\n\t\tlet heading =\r\n\t\t\ttype === \"boolean\"\r\n\t\t\t\t? bold(`--${name}, --no-${name}`)\r\n\t\t\t\t: `${bold(`--${name}`)}=<value>`;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]