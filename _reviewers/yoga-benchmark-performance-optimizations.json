[
  {
    "discussion_id": "38879067",
    "pr_number": 121,
    "pr_file": "src/Layout.js",
    "created_at": "2015-09-07T20:36:12+00:00",
    "commented_code": "var/*float*/ totalFlexible = 0;\n       var/*int*/ nonFlexibleChildrenCount = 0;\n \n+      var/*int*/ firstFlex = -1;\n+      var/*int*/ lastFlex = -1;\n+\n       var/*float*/ maxWidth;\n-      for (i = startLine; i < node.children.length; ++i) {\n+      for (i = startLine; i < childCount; ++i) {\n         child = node.children[i];\n+\n+        // Pre-fill cross axis dimensions when the child is using stretch before\n+        // we call the recursive layout pass\n+        if (getAlignItem(node, child) === CSS_ALIGN_STRETCH &&\n+            getPositionType(child) === CSS_POSITION_RELATIVE &&\n+            isCrossDimDefined &&\n+            !isDimDefined(child, crossAxis)) {\n+          child.layout[dim[crossAxis]] = fmaxf(\n+            boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n+              paddingAndBorderAxisCross -\n+              getMarginAxis(child, crossAxis)),\n+            // You never want to go smaller than padding\n+            getPaddingAndBorderAxis(child, crossAxis)\n+          );\n+        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n+          absoluteChildrenCount++;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "38879067",
        "repo_full_name": "facebook/yoga",
        "pr_number": 121,
        "pr_file": "src/Layout.js",
        "discussion_id": "38879067",
        "commented_code": "@@ -528,16 +504,62 @@ var computeLayout = (function() {\n       var/*float*/ totalFlexible = 0;\n       var/*int*/ nonFlexibleChildrenCount = 0;\n \n+      var/*int*/ firstFlex = -1;\n+      var/*int*/ lastFlex = -1;\n+\n       var/*float*/ maxWidth;\n-      for (i = startLine; i < node.children.length; ++i) {\n+      for (i = startLine; i < childCount; ++i) {\n         child = node.children[i];\n+\n+        // Pre-fill cross axis dimensions when the child is using stretch before\n+        // we call the recursive layout pass\n+        if (getAlignItem(node, child) === CSS_ALIGN_STRETCH &&\n+            getPositionType(child) === CSS_POSITION_RELATIVE &&\n+            isCrossDimDefined &&\n+            !isDimDefined(child, crossAxis)) {\n+          child.layout[dim[crossAxis]] = fmaxf(\n+            boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n+              paddingAndBorderAxisCross -\n+              getMarginAxis(child, crossAxis)),\n+            // You never want to go smaller than padding\n+            getPaddingAndBorderAxis(child, crossAxis)\n+          );\n+        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n+          absoluteChildrenCount++;",
        "comment_created_at": "2015-09-07T20:36:12+00:00",
        "comment_author": "lucasr",
        "comment_body": "@kastiglione Generally, we try very hard to avoid allocations during layout as 1) allocations are not free (on Android, at least) 2) More allocations -> more likely GC calls and main thread stalls. It's a trade-off: more stable memory behaviour vs computational cost. \n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "33444135",
    "pr_number": 94,
    "pr_file": "src/Layout.js",
    "created_at": "2015-06-29T08:45:13+00:00",
    "commented_code": "var location = locations[i];\n \n       var key = type + capitalizeFirst(location) + suffix;\n-      if (key in node.style) {\n-        return node.style[key];\n-      }\n-\n-      key = type + suffix;\n-      if (key in node.style) {\n-        return node.style[key];\n-      }\n+  \n+        return node.style[key] || node.style[type + key + suffix];",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "33444135",
        "repo_full_name": "facebook/yoga",
        "pr_number": 94,
        "pr_file": "src/Layout.js",
        "discussion_id": "33444135",
        "commented_code": "@@ -68,14 +68,8 @@ var computeLayout = (function() {\n       var location = locations[i];\n \n       var key = type + capitalizeFirst(location) + suffix;\n-      if (key in node.style) {\n-        return node.style[key];\n-      }\n-\n-      key = type + suffix;\n-      if (key in node.style) {\n-        return node.style[key];\n-      }\n+  \n+        return node.style[key] || node.style[type + key + suffix];",
        "comment_created_at": "2015-06-29T08:45:13+00:00",
        "comment_author": "vjeux",
        "comment_body": "A safe way to do it is by writing `node.style['marginTop'] !== undefined`. But, in order to make sure that it has performance improvement, we need to benchmark it.\n\nCan you use the code that generates a random test to generate a big random tree and then time the layout algorithm before and after? Otherwise we can't know if this is a performance optimization or not.\n",
        "pr_file_module": null
      }
    ]
  }
]