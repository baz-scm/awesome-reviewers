[
  {
    "discussion_id": "985989097",
    "pr_number": 1123,
    "pr_file": "yoga/Yoga.cpp",
    "created_at": "2022-10-03T16:19:44+00:00",
    "commented_code": "#undef YG_UNUSED\n #endif\n \n+#ifdef _MSC_VER\n+#define YG_ALLOC_ALIGNED ([](size_t a, size_t s) -> void* { \\\n+  return _aligned_malloc(s, a);                             \\\n+})\n+#define YG_FREE_ALIGNED ([](void* m) -> void {              \\\n+  _aligned_free(m);                                         \\\n+})\n+#else\n+#define YG_ALLOC_ALIGNED ([](size_t a, size_t s) -> void* { \\\n+  return aligned_alloc(a, s);                               \\\n+})\n+#define YG_FREE_ALIGNED ([](void* m) -> void {              \\\n+  free(m);                                                  \\\n+})\n+#endif\n+\n+static YGAllocatorAllocateFunc gAllocatorAllocateFunc = YG_ALLOC_ALIGNED;\n+static YGAllocatorFreeFunc gAllocatorFreeFunc = YG_FREE_ALIGNED;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "985989097",
        "repo_full_name": "facebook/yoga",
        "pr_number": 1123,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "985989097",
        "commented_code": "@@ -106,6 +105,51 @@ static int YGDefaultLog(\n #undef YG_UNUSED\n #endif\n \n+#ifdef _MSC_VER\n+#define YG_ALLOC_ALIGNED ([](size_t a, size_t s) -> void* { \\\n+  return _aligned_malloc(s, a);                             \\\n+})\n+#define YG_FREE_ALIGNED ([](void* m) -> void {              \\\n+  _aligned_free(m);                                         \\\n+})\n+#else\n+#define YG_ALLOC_ALIGNED ([](size_t a, size_t s) -> void* { \\\n+  return aligned_alloc(a, s);                               \\\n+})\n+#define YG_FREE_ALIGNED ([](void* m) -> void {              \\\n+  free(m);                                                  \\\n+})\n+#endif\n+\n+static YGAllocatorAllocateFunc gAllocatorAllocateFunc = YG_ALLOC_ALIGNED;\n+static YGAllocatorFreeFunc gAllocatorFreeFunc = YG_FREE_ALIGNED;",
        "comment_created_at": "2022-10-03T16:19:44+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "If these are global, they will need to be protected by mutex, in case multiple threads are using Yoga at once.\r\n\r\nI think it would be cleaner if the allocator was set as part of YGConfig, though it would mean YGConfig itself could not be allocated using the custom allocator. Though, Yoga may otherwise call functions which perform their dynamic allocations, so if the goal is just for the large structures, I think it could still be okay.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "247846653",
    "pr_number": 852,
    "pr_file": "yoga/Yoga.cpp",
    "created_at": "2019-01-15T10:56:34+00:00",
    "commented_code": "\"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "247846653",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-15T10:56:34+00:00",
        "comment_author": "jpap",
        "comment_body": "Looks like this loop always terminates early: the parent is set to `nullptr` above the loop on line 242.\r\n\r\nMight be a good idea to add a test? ;-)",
        "pr_file_module": null
      },
      {
        "comment_id": "247851163",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-15T11:11:30+00:00",
        "comment_author": "tcdat96",
        "comment_body": "Oh my apologies, thought it just a simple loop, so didn't test it thoroughly :-(\r\nOkay, let me add a test :+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "247858622",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-15T11:37:51+00:00",
        "comment_author": "jpap",
        "comment_body": "No worries.\r\n\r\nThinking about this a bit more, I'm not sure we need to do this extra work on clone: the generation is incremented each time we perform a `YGNodeCalculateLayout`, so even if we preserved the root generation counter for a cloned subtree, we're still incrementing it on a call to `YGNodeCalculateLayout` for that subtree and before we proceed with any work.  Any comparison to the old generation count will be false.\r\n\r\nIs the counter used to help avoid node recalculations **during** multiple passes of a given layout (generation) calculation?  I'd need to spend some time to really understand how the generation counter is used for this; and unfortunately the code isn't terribly straightforward or self-documenting.  If you're on the FB team, can you ask the original author for a short-cut?\r\n\r\nIt might be that all is needed is for the generation counter to be monotonically increase on each call to `YGNodeCalculateLayout`, which means we'll still have to stash it in the root node (if so, the clone stuff should remain).  What happens when it wraps to zero?",
        "pr_file_module": null
      },
      {
        "comment_id": "247867738",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-15T12:11:08+00:00",
        "comment_author": "tcdat96",
        "comment_body": "Unfortunately we aren't from the FB team and neither do we have a full understanding how generetionCount works. My team encounter the race condition problem several months ago, so we opened the previous pull request to try to fix that.  \r\nI actually thought you are the one on the FB team ;-)",
        "pr_file_module": null
      },
      {
        "comment_id": "248143585",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-16T03:45:26+00:00",
        "comment_author": "rockerhieu",
        "comment_body": "I would suggest us to stick to the original idea of #791 because it focus on solving the data race condition issue without worrying about optimizing the `generationCount` itself. This can be done in a separated PR and leave this PR with minimal changes.",
        "pr_file_module": null
      },
      {
        "comment_id": "248150107",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-16T04:44:12+00:00",
        "comment_author": "jpap",
        "comment_body": "> I would suggest us to stick to the original idea of #791 because it focus on solving the data race condition issue without worrying about optimizing the `generationCount` itself. This can be done in a separated PR and leave this PR with minimal changes.\r\n\r\nThat would be unwise because #791:\r\n1. uses more heap than necessary;\r\n1. introduces an expensive subtree traversal to set up the pointer-to-the-root, which is performed often; and\r\n1. does not address node cloning.\r\n\r\nI am reading through the code to understand how the generation is treated and will report back shortly.",
        "pr_file_module": null
      },
      {
        "comment_id": "248166302",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-16T06:45:36+00:00",
        "comment_author": "jpap",
        "comment_body": "Here's what I've learned from reading the code...\r\n\r\nThere are two generation counters: `generationCount` and `computedFlexBasisGeneration` stored in `YGLayout`, which are compared to the global `gCurrentGenerationCount`.  An overview of each is given below.\r\n\r\nAt the end, I'll provide a few options on how to move forward with this PR.  Apologies for the length in advance.\r\n\r\n#### YGLayout::generationCount\r\n\r\n1. This counter is used to invalidate the layout cache in `YGLayoutNodeInternal` when a node is dirty, and the node has not been visited thus far for a given `YGNodeCalculateLayout` call.\r\n1. It is updated on exit of the function whenever layout is performed.\r\n1. In `YGNodeCalculateLayout`, the `gCurrentGenerationCount` is incremented a second time before performing the optional a legacy \"stretch behavior\" comparison on a cloned tree that has all nodes marked dirty.  The new `gCurrentGenerationCount` here is to ensure the layout cache is cleared as above.\r\n1. It looks like the purpose of this counter is to ensure the layout cache is invalidated whenever a node is dirty once per `YGNodeCalculateLayout` call.\r\n\r\n\r\n#### YGLayout::computedFlexBasisGeneration\r\n\r\n1. This counter is used exclusively in `YGNodeComputeFlexBasisForChild`.\r\n1. It gates computation of a child's computed flex basis when the `YGExperimentalFeatureWebFlexBasis` feature is in use.\r\n1. It is updated on exit of the function every time.\r\n1. It looks like the purpose of this counter is to limit the above computation once per `YGNodeCalculateLayout` call.\r\n\r\n#### gCurrentGenerationCount\r\n\r\n1. This counter is incremented in `YGNodeCalculateLayout` before performing a full-tree layout.\r\n1. It looks like the purpose of this counter is to uniquely identify a given layout run, which makes sense when you consider its name: \"generation\" implying that each layout gives birth to a new tree.\r\n1. Because of the way the counter is used (compare with equality only; node update on exit of relevant function), I don't think it matters when it wraps.  This means we could probably get away with an even smaller storage type (e.g. `uint8_t`) for the global counter and associated class member storage.  For cloning, what is important is that we use a value different to the \"last time\".\r\n1. With the above in mind, the comments in the source now make more sense (to me):\r\n    ```\r\n    // Instead of recomputing the entire layout every single time, we\r\n    // cache some information to break early when nothing changed\r\n    ```\r\n    and\r\n    ```\r\n    // Increment the generation count. This will force the recursive routine to\r\n    // visit\r\n    // all dirty nodes at least once. Subsequent visits will be skipped if the\r\n    // input\r\n    // parameters don't change.\r\n    ```\r\n\r\n### Moving forward\r\n\r\nSome options:\r\n\r\n1. Minimize changes:\r\n    * Drop the `YGNodeClone` change.\r\n    * Remove the `generationCount_` member from `YGNode` and bring back the global `gCurrentGenerationCount`.\r\n    * Increment and retrieve `gCurrentGenerationCount` atomically in `YGNodeCalculateLayout` and use it to seed the `generationCount` stack variable that is passed around by function call.\r\n    * Keep the other changes in the current PR, relating to `depth` and `PRINT_XXX`.\r\n1. Minimize changes with some further heap memory savings:\r\n    * As above, but using the `uint8_t` type for the generation counters.\r\n1. Minimize heap memory use:\r\n    * Drop the `gCurrentGenerationCount` global.\r\n    * Drop the `computedFlexBasisGeneration` and `generationCount` members of `YGLayout`.\r\n    * Declare a new `std::map<YGNode,uint8_t>` stack variable in `YGNodeCalculateLayout` that is passed around like `depth` is in the current PR.  (Or to minimize function call overhead, the `depth` and a pointer to the map can be placed in a struct, and a pointer to that struct is passed around instead.)\r\n    * The `uint8_t` value field of the map is a bitfield:\r\n        * define bit 0 as \"I have visited the node\" in lieu of the existing `layout->generationCount != gCurrentGenerationCount` check in `YGLayoutNodeInternal`.\r\n        * define bit 1 as \"I have computed the flex basis for this child\" in lieu of the existing `computedFlexBasisGeneration != gCurrentGenerationCount` check in `YGNodeComputeFlexBasisForChild`.\r\n    * Throw out the map on return of `YGNodeCalculateLayout`.\r\n\r\nWhat do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "248237212",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-16T10:59:39+00:00",
        "comment_author": "tcdat96",
        "comment_body": "The implementation for the first and second options would be quite straightforward, but I'm having a hard time understanding the third optimization. How exactly can we substitute those 3 variables with the map approach? Personally, I find it really risky to make such a big change, and we don't really have the confidence in our understanding of Yoga to carry out the implementation by ourselves neither.",
        "pr_file_module": null
      },
      {
        "comment_id": "248522724",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-17T02:42:20+00:00",
        "comment_author": "jpap",
        "comment_body": "I've submitted PR #855 that takes the third approach: it appears to work well!\r\n\r\nSo from here, let's see if @davidaurelio or others on the FB team can offer their input.  @tcdat96, in the meantime if you have time to update your PR with option 2, it can give others an opportunity to review both PRs and weigh in.\r\n\r\nHopefully we can land this thread-safety fix soon.  I'm happy to amend my PR if there are preferences on style, etc.",
        "pr_file_module": null
      },
      {
        "comment_id": "248601869",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-17T09:51:20+00:00",
        "comment_author": "tcdat96",
        "comment_body": "I updated the PR with the first 2 options, but ran into error ```undefined reference to `pthread_getspecific'``` when running gtest. Have you ever encountered a similar problem, @jpap?",
        "pr_file_module": null
      },
      {
        "comment_id": "248895708",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-18T00:54:57+00:00",
        "comment_author": "jpap",
        "comment_body": "> error `` undefined reference to `pthread_getspecific' `` when running gtest.\r\n\r\nSadly I've never experienced that; sounds like a linker configuration problem?  Perhaps you've inadvertently modified some of the build configuration someplace.  I would try:\r\n\r\n* Clean and rebuild?\r\n* Create a new local branch based off master, then cherry-pick **only** your changes then rebuild/test.",
        "pr_file_module": null
      },
      {
        "comment_id": "249313257",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-21T02:50:29+00:00",
        "comment_author": "tcdat96",
        "comment_body": "I've already tried both but unfortunately nothing works. The error appeared even with the master commit so I think it should be my configuration problem, but sadly I don't really have any experience in this type of problem :-(",
        "pr_file_module": null
      },
      {
        "comment_id": "251310507",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "247846653",
        "commented_code": "@@ -240,6 +240,11 @@ YGNodeRef YGNodeClone(YGNodeRef oldNode) {\n       \"Could not allocate memory for node\");\n   gNodeInstanceCount++;\n   node->setOwner(nullptr);\n+\n+  YGNodeRef root = node;\n+  for (; root->getParent() != nullptr; root = root->getParent());",
        "comment_created_at": "2019-01-28T08:06:43+00:00",
        "comment_author": "tcdat96",
        "comment_body": "It seems that the error only emerges in our ubuntu machines, the same source code runs without any issue in MacOS. \r\nI modified the BUCK file in lib/gtest with the workaround described in https://github.com/facebook/buck/issues/1443 and it worked. Now this PR runs successfully with all tests passed.\r\n\r\nIf you have the time, please take a look at both PRs, @davidaurelio :-) ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "251569119",
    "pr_number": 852,
    "pr_file": "yoga/Yoga.cpp",
    "created_at": "2019-01-28T19:54:22+00:00",
    "commented_code": "return node->markDirtyAndPropogateDownwards();\n }\n \n-int32_t gNodeInstanceCount = 0;\n-int32_t gConfigInstanceCount = 0;\n+std::atomic<int32_t> gNodeInstanceCount(0);\n+std::atomic<int32_t> gConfigInstanceCount(0);",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "251569119",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "251569119",
        "commented_code": "@@ -206,8 +206,8 @@ void YGNodeMarkDirtyAndPropogateToDescendants(const YGNodeRef node) {\n   return node->markDirtyAndPropogateDownwards();\n }\n \n-int32_t gNodeInstanceCount = 0;\n-int32_t gConfigInstanceCount = 0;\n+std::atomic<int32_t> gNodeInstanceCount(0);\n+std::atomic<int32_t> gConfigInstanceCount(0);",
        "comment_created_at": "2019-01-28T19:54:22+00:00",
        "comment_author": "davidaurelio",
        "comment_body": "While this serialises the access to these variables, it causes additional synchronisation needs between cores when creating nodes on different threads in parallel.\r\n\r\nAt this point, I\u2019d rather let the count go out of sync, instead of adding any bus overhead. Its accuracy isn\u2019t a correctness problem, is it?",
        "pr_file_module": null
      },
      {
        "comment_id": "251689077",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "251569119",
        "commented_code": "@@ -206,8 +206,8 @@ void YGNodeMarkDirtyAndPropogateToDescendants(const YGNodeRef node) {\n   return node->markDirtyAndPropogateDownwards();\n }\n \n-int32_t gNodeInstanceCount = 0;\n-int32_t gConfigInstanceCount = 0;\n+std::atomic<int32_t> gNodeInstanceCount(0);\n+std::atomic<int32_t> gConfigInstanceCount(0);",
        "comment_created_at": "2019-01-29T04:35:38+00:00",
        "comment_author": "tcdat96",
        "comment_body": "Honestly, I don't have the full knowledge about how these variables could affect the correctness of Yoga. These variables were flagged by ThreadSanitizer to be a possible data race problem, so I only tried to fix it at the language level.\r\nBut if its accuracy is not important to the program's flow, then what's the point of having these variables?",
        "pr_file_module": null
      },
      {
        "comment_id": "252092547",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "251569119",
        "commented_code": "@@ -206,8 +206,8 @@ void YGNodeMarkDirtyAndPropogateToDescendants(const YGNodeRef node) {\n   return node->markDirtyAndPropogateDownwards();\n }\n \n-int32_t gNodeInstanceCount = 0;\n-int32_t gConfigInstanceCount = 0;\n+std::atomic<int32_t> gNodeInstanceCount(0);\n+std::atomic<int32_t> gConfigInstanceCount(0);",
        "comment_created_at": "2019-01-30T02:02:32+00:00",
        "comment_author": "jpap",
        "comment_body": "These instance tracking variables are only used for tests. You could conditionally compile in this functionality for tests by adding a new preprocessor token in the `BUCK` file, under `TEST_COMPILER_FLAGS`.",
        "pr_file_module": null
      },
      {
        "comment_id": "252092660",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "251569119",
        "commented_code": "@@ -206,8 +206,8 @@ void YGNodeMarkDirtyAndPropogateToDescendants(const YGNodeRef node) {\n   return node->markDirtyAndPropogateDownwards();\n }\n \n-int32_t gNodeInstanceCount = 0;\n-int32_t gConfigInstanceCount = 0;\n+std::atomic<int32_t> gNodeInstanceCount(0);\n+std::atomic<int32_t> gConfigInstanceCount(0);",
        "comment_created_at": "2019-01-30T02:03:22+00:00",
        "comment_author": "jpap",
        "comment_body": "These instance tracking variables are only used for tests. You could conditionally compile in this functionality for tests by adding a new preprocessor token in the `BUCK` file, under `TEST_COMPILER_FLAGS`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "251578032",
    "pr_number": 852,
    "pr_file": "yoga/Yoga.cpp",
    "created_at": "2019-01-28T20:20:38+00:00",
    "commented_code": "return node->getLayout().doesLegacyStretchFlagAffectsLayout;\n }\n \n-uint32_t gCurrentGenerationCount = 0;\n+std::atomic<uint8_t> gCurrentGenerationCount(0);",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "251578032",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/Yoga.cpp",
        "discussion_id": "251578032",
        "commented_code": "@@ -1007,7 +1007,7 @@ bool YGNodeLayoutGetDidLegacyStretchFlagAffectLayout(const YGNodeRef node) {\n   return node->getLayout().doesLegacyStretchFlagAffectsLayout;\n }\n \n-uint32_t gCurrentGenerationCount = 0;\n+std::atomic<uint8_t> gCurrentGenerationCount(0);",
        "comment_created_at": "2019-01-28T20:20:38+00:00",
        "comment_author": "davidaurelio",
        "comment_body": "Again, this causes additional synchronisation, and I am not sure it\u2019s necessary:\r\n\r\nthis will usually be loaded into a register, incremented, and written back to memory.\r\n\r\nWhen two threads do this in parallel, they might both load the old value, increment by one, and write back \u2013 with the global value being incremented by one, not two, as a result.\r\n\r\nThat will still increment the count, and cause layouts to be run \u2013 there isn\u2019t really a need to synchronise it.\r\n\r\nAm I missing something?\r\n\r\nMinor nitpick, please use uniform initialization (`std::atomic<uint8_t> gCurrentGenerationCount{0};`)\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]