[
  {
    "discussion_id": "102736049",
    "pr_number": 431,
    "pr_file": "yoga/Yoga.c",
    "created_at": "2017-02-23T15:21:59+00:00",
    "commented_code": "return 0.0f;\n }\n \n-inline float YGNodeStyleGetFlexShrink(const YGNodeRef node) {\n+float YGNodeStyleGetFlexGrow(const YGNodeRef node) {\n+  return YGFloatIsUndefined(node->style.flexGrow) ? 0.0f : node->style.flexGrow;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "102736049",
        "repo_full_name": "facebook/yoga",
        "pr_number": 431,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "102736049",
        "commented_code": "@@ -423,7 +423,15 @@ inline float YGNodeStyleGetFlexGrow(const YGNodeRef node) {\n   return 0.0f;\n }\n \n-inline float YGNodeStyleGetFlexShrink(const YGNodeRef node) {\n+float YGNodeStyleGetFlexGrow(const YGNodeRef node) {\n+  return YGFloatIsUndefined(node->style.flexGrow) ? 0.0f : node->style.flexGrow;",
        "comment_created_at": "2017-02-23T15:21:59+00:00",
        "comment_author": "astreet",
        "comment_body": "Instead of 0.0f, can we have the reference the defaults instead for clarity and to not introduce bugs?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "94830359",
    "pr_number": 317,
    "pr_file": "yoga/Yoga.c",
    "created_at": "2017-01-05T19:07:40+00:00",
    "commented_code": "}\n }\n \n+static float YGBaseline(const YGNodeRef node,\n+                        const YGFlexDirection crossAxis) {\n+  if (node->baseline != NULL) {\n+    const float baseline = node->baseline(node);\n+    if (YGFloatIsUndefined(baseline)) {",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "94830359",
        "repo_full_name": "facebook/yoga",
        "pr_number": 317,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "94830359",
        "commented_code": "@@ -941,6 +955,41 @@ static inline YGDirection YGNodeResolveDirection(const YGNodeRef node,\n   }\n }\n \n+static float YGBaseline(const YGNodeRef node,\n+                        const YGFlexDirection crossAxis) {\n+  if (node->baseline != NULL) {\n+    const float baseline = node->baseline(node);\n+    if (YGFloatIsUndefined(baseline)) {",
        "comment_created_at": "2017-01-05T19:07:40+00:00",
        "comment_author": "emilsjolander",
        "comment_body": "Is there a good reason to allow undefined return value for baseline? I would prefer asserting and crashing as it would probably indicate a bug. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "94833509",
        "repo_full_name": "facebook/yoga",
        "pr_number": 317,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "94830359",
        "commented_code": "@@ -941,6 +955,41 @@ static inline YGDirection YGNodeResolveDirection(const YGNodeRef node,\n   }\n }\n \n+static float YGBaseline(const YGNodeRef node,\n+                        const YGFlexDirection crossAxis) {\n+  if (node->baseline != NULL) {\n+    const float baseline = node->baseline(node);\n+    if (YGFloatIsUndefined(baseline)) {",
        "comment_created_at": "2017-01-05T19:25:14+00:00",
        "comment_author": "woehrl01",
        "comment_body": "I'm not sure my self about this. I thought this could be a kind of \"feature\", so if you return undefined, you simply use the nodes height. But crashing would be fine too for me. What I'm not sure about is if we explicitly add the padding-top here or if the implementation of the custom function needs to consider this.",
        "pr_file_module": null
      },
      {
        "comment_id": "94836576",
        "repo_full_name": "facebook/yoga",
        "pr_number": 317,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "94830359",
        "commented_code": "@@ -941,6 +955,41 @@ static inline YGDirection YGNodeResolveDirection(const YGNodeRef node,\n   }\n }\n \n+static float YGBaseline(const YGNodeRef node,\n+                        const YGFlexDirection crossAxis) {\n+  if (node->baseline != NULL) {\n+    const float baseline = node->baseline(node);\n+    if (YGFloatIsUndefined(baseline)) {",
        "comment_created_at": "2017-01-05T19:40:10+00:00",
        "comment_author": "emilsjolander",
        "comment_body": "The custom function should not take padding into account. We don't expect this for the measure function so I would like to preserve that here if possible.\r\n\r\nLet's crash for now. If we find a valid reason to have this feature we can implement it later.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "92973471",
    "pr_number": 258,
    "pr_file": "yoga/Yoga.c",
    "created_at": "2016-12-19T06:22:01+00:00",
    "commented_code": "node->style.flex = YGUndefined;\n   node->style.flexGrow = YGUndefined;\n   node->style.flexShrink = YGUndefined;\n-  node->style.flexBasis = YGUndefined;\n+  node->style.flexBasis.value = YGUndefined;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "92973471",
        "repo_full_name": "facebook/yoga",
        "pr_number": 258,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "92973471",
        "commented_code": "@@ -194,7 +210,9 @@ static void YGNodeInit(const YGNodeRef node) {\n   node->style.flex = YGUndefined;\n   node->style.flexGrow = YGUndefined;\n   node->style.flexShrink = YGUndefined;\n-  node->style.flexBasis = YGUndefined;\n+  node->style.flexBasis.value = YGUndefined;",
        "comment_created_at": "2016-12-19T06:22:01+00:00",
        "comment_author": "emilsjolander",
        "comment_body": "Create a `YGValueUndefined` static instance which you just copy here and below.",
        "pr_file_module": null
      },
      {
        "comment_id": "92976831",
        "repo_full_name": "facebook/yoga",
        "pr_number": 258,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "92973471",
        "commented_code": "@@ -194,7 +210,9 @@ static void YGNodeInit(const YGNodeRef node) {\n   node->style.flex = YGUndefined;\n   node->style.flexGrow = YGUndefined;\n   node->style.flexShrink = YGUndefined;\n-  node->style.flexBasis = YGUndefined;\n+  node->style.flexBasis.value = YGUndefined;",
        "comment_created_at": "2016-12-19T07:00:05+00:00",
        "comment_author": "woehrl01",
        "comment_body": "you mean a \"global\" instance? I could use this in ```YGComputedEdgeValue```, too.",
        "pr_file_module": null
      },
      {
        "comment_id": "92978197",
        "repo_full_name": "facebook/yoga",
        "pr_number": 258,
        "pr_file": "yoga/Yoga.c",
        "discussion_id": "92973471",
        "commented_code": "@@ -194,7 +210,9 @@ static void YGNodeInit(const YGNodeRef node) {\n   node->style.flex = YGUndefined;\n   node->style.flexGrow = YGUndefined;\n   node->style.flexShrink = YGUndefined;\n-  node->style.flexBasis = YGUndefined;\n+  node->style.flexBasis.value = YGUndefined;",
        "comment_created_at": "2016-12-19T07:13:56+00:00",
        "comment_author": "emilsjolander",
        "comment_body": "yes, easy to mix up terminology when working with many languages \ud83d\ude15 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "64994275",
    "pr_number": 185,
    "pr_file": "src/Layout.c",
    "created_at": "2016-05-28T20:59:35+00:00",
    "commented_code": "} else if (alignContent == CSS_ALIGN_CENTER) {\n       currentLead += remainingAlignContentDim / 2;\n     } else if (alignContent == CSS_ALIGN_STRETCH) {\n-      if (nodeCrossAxisInnerSize > linesCrossDim) {\n-        crossDimLead = (remainingAlignContentDim / linesCount);\n+      if (availableInnerCrossDim > totalLineCrossDim) {\n+        crossDimLead = (remainingAlignContentDim / lineCount);\n       }\n     }\n \n     int endIndex = 0;\n-    for (i = 0; i < linesCount; ++i) {\n+    for (i = 0; i < lineCount; ++i) {\n       int startIndex = endIndex;\n+      int j;\n \n       // compute the line's height and find the endIndex\n       float lineHeight = 0;\n-      for (ii = startIndex; ii < childCount; ++ii) {\n-        child = node->get_child(node->context, ii);\n+      for (j = startIndex; j < childCount; ++j) {\n+        child = node->get_child(node->context, j);\n         if (child->style.position_type != CSS_POSITION_RELATIVE) {\n           continue;\n         }\n         if (child->line_index != i) {\n           break;\n         }\n         if (isLayoutDimDefined(child, crossAxis)) {\n-          lineHeight = fmaxf(\n-            lineHeight,\n-            child->layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n-          );\n+          lineHeight = fmaxf(lineHeight,\n+            child->layout.measured_dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis));\n         }\n       }\n-      endIndex = ii;\n+      endIndex = j;\n       lineHeight += crossDimLead;\n \n-      for (ii = startIndex; ii < endIndex; ++ii) {\n-        child = node->get_child(node->context, ii);\n-        if (child->style.position_type != CSS_POSITION_RELATIVE) {\n-          continue;\n-        }\n+      if (performLayout) {\n+        for (j = startIndex; j < endIndex; ++j) {\n+          child = node->get_child(node->context, j);\n+          if (child->style.position_type != CSS_POSITION_RELATIVE) {\n+            continue;\n+          }\n \n-        css_align_t alignContentAlignItem = getAlignItem(node, child);\n-        if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-        } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n-          child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.dimensions[dim[crossAxis]];\n-        } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n-          float childHeight = child->layout.dimensions[dim[crossAxis]];\n-          child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n-        } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-          // TODO(prenaux): Correctly set the height of items with undefined\n-          //                (auto) crossAxis dimension.\n+          css_align_t alignContentAlignItem = getAlignItem(node, child);\n+          if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+          } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n+            child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.measured_dimensions[dim[crossAxis]];\n+          } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n+            childHeight = child->layout.measured_dimensions[dim[crossAxis]];\n+            child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n+          } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+            // TODO(prenaux): Correctly set the height of items with indefinite\n+            //                (auto) crossAxis dimension.\n+          }\n         }\n       }\n \n       currentLead += lineHeight;\n     }\n   }\n \n-  bool needsMainTrailingPos = false;\n-  bool needsCrossTrailingPos = false;\n+  // STEP 9: COMPUTING FINAL DIMENSIONS\n+  node->layout.measured_dimensions[CSS_WIDTH] = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n+  node->layout.measured_dimensions[CSS_HEIGHT] = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n+\n+  // If the user didn't specify a width or height for the node, set the\n+  // dimensions based on the children.\n+  if (measureModeMainDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[mainAxis]] = boundAxis(node, mainAxis, maxLineMainDim);\n+  } else if (measureModeMainDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[mainAxis]] = fmaxf(\n+      fminf(availableInnerMainDim + paddingAndBorderAxisMain,\n+        boundAxisWithinMinAndMax(node, mainAxis, maxLineMainDim)),\n+      paddingAndBorderAxisMain);\n+  }\n \n-  // If the user didn't specify a width or height, and it has not been set\n-  // by the container, then we set it via the children.\n-  if (!isMainDimDefined) {\n-    node->layout.dimensions[dim[mainAxis]] = fmaxf(\n-      // We're missing the last padding at this point to get the final\n-      // dimension\n-      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n-      // We can never assign a width smaller than the padding and borders\n-      paddingAndBorderAxisMain\n-    );\n+  if (measureModeCrossDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[crossAxis]] = boundAxis(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross);\n+  } else if (measureModeCrossDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[crossAxis]] = fmaxf(\n+      fminf(availableInnerCrossDim + paddingAndBorderAxisCross,\n+        boundAxisWithinMinAndMax(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross)),\n+      paddingAndBorderAxisCross);\n+  }\n+  \n+  // STEP 10: SETTING TRAILING POSITIONS FOR CHILDREN\n+  if (performLayout) {\n+    bool needsMainTrailingPos = false;\n+    bool needsCrossTrailingPos = false;\n \n     if (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsMainTrailingPos = true;\n     }\n-  }\n-\n-  if (!isCrossDimDefined) {\n-    node->layout.dimensions[dim[crossAxis]] = fmaxf(\n-      // For the cross dim, we add both sides at the end because the value\n-      // is aggregate via a max function. Intermediate negative values\n-      // can mess this computation otherwise\n-      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n-      paddingAndBorderAxisCross\n-    );\n \n     if (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsCrossTrailingPos = true;\n     }\n-  }\n \n-  // <Loop F> Set trailing position if necessary\n-  if (needsMainTrailingPos || needsCrossTrailingPos) {\n-    for (i = 0; i < childCount; ++i) {\n-      child = node->get_child(node->context, i);\n+    // Set trailing position if necessary.\n+    if (needsMainTrailingPos || needsCrossTrailingPos) {\n+      for (i = 0; i < childCount; ++i) {\n+        child = node->get_child(node->context, i);\n \n-      if (needsMainTrailingPos) {\n-        setTrailingPosition(node, child, mainAxis);\n-      }\n+        if (needsMainTrailingPos) {\n+          setTrailingPosition(node, child, mainAxis);\n+        }\n \n-      if (needsCrossTrailingPos) {\n-        setTrailingPosition(node, child, crossAxis);\n+        if (needsCrossTrailingPos) {\n+          setTrailingPosition(node, child, crossAxis);\n+        }\n       }\n     }\n   }\n-\n-  // <Loop G> Calculate dimensions for absolutely positioned elements\n+  \n+  // STEP 11: SIZING AND POSITIONING ABSOLUTE CHILDREN\n   currentAbsoluteChild = firstAbsoluteChild;\n   while (currentAbsoluteChild != NULL) {\n-    // Pre-fill dimensions when using absolute position and both offsets for\n-    // the axis are defined (either both left and right or top and bottom).\n-    for (ii = 0; ii < 2; ii++) {\n-      axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n-\n-      if (isLayoutDimDefined(node, axis) &&\n-          !isStyleDimDefined(currentAbsoluteChild, axis) &&\n-          isPosDefined(currentAbsoluteChild, leading[axis]) &&\n-          isPosDefined(currentAbsoluteChild, trailing[axis])) {\n-        currentAbsoluteChild->layout.dimensions[dim[axis]] = fmaxf(\n-          boundAxis(currentAbsoluteChild, axis, node->layout.dimensions[dim[axis]] -\n-            getBorderAxis(node, axis) -\n-            getMarginAxis(currentAbsoluteChild, axis) -\n-            getPosition(currentAbsoluteChild, leading[axis]) -\n-            getPosition(currentAbsoluteChild, trailing[axis])\n-          ),\n-          // You never want to go smaller than padding\n-          getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n-        );\n+    // Now that we know the bounds of the container, perform layout again on the\n+    // absolutely-positioned children.\n+    if (performLayout) {\n+\n+      childWidth = CSS_UNDEFINED;\n+      childHeight = CSS_UNDEFINED;\n+\n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW)) {\n+        childWidth = currentAbsoluteChild->style.dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+      } else {\n+        // If the child doesn't have a specified width, compute the width based on the left/right offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_LEFT) && isPosDefined(currentAbsoluteChild, CSS_RIGHT)) {\n+          childWidth = node->layout.measured_dimensions[CSS_WIDTH] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_ROW) + getTrailingBorder(node, CSS_FLEX_DIRECTION_ROW)) -\n+            (currentAbsoluteChild->style.position[CSS_LEFT] + currentAbsoluteChild->style.position[CSS_RIGHT]);\n+          childWidth = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW, childWidth);\n+        }\n       }\n+      \n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN)) {\n+        childHeight = currentAbsoluteChild->style.dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      } else {\n+        // If the child doesn't have a specified height, compute the height based on the top/bottom offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_TOP) && isPosDefined(currentAbsoluteChild, CSS_BOTTOM)) {\n+          childHeight = node->layout.measured_dimensions[CSS_HEIGHT] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_COLUMN) + getTrailingBorder(node, CSS_FLEX_DIRECTION_COLUMN)) -\n+            (currentAbsoluteChild->style.position[CSS_TOP] + currentAbsoluteChild->style.position[CSS_BOTTOM]);\n+          childHeight = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN, childHeight);\n+        }\n+      }\n+\n+      // If we're still missing one or the other dimension, measure the content.\n+      if (isUndefined(childWidth) || isUndefined(childHeight)) {\n+        childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        \n+        // According to the spec, if the main size is not definite and the\n+        // child's inline axis is parallel to the main axis (i.e. it's\n+        // horizontal), the child should be sized using \"UNDEFINED\" in\n+        // the main size. Otherwise use \"AT_MOST\" in the cross axis.\n+        if (!isMainAxisRow && isUndefined(childWidth) && !isUndefined(availableInnerWidth)) {\n+          childWidth = availableInnerWidth;\n+          childWidthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+        }\n+\n+        // The W3C spec doesn't say anything about the 'overflow' property,\n+        // but all major browsers appear to implement the following logic.\n+        if (node->style.overflow == CSS_OVERFLOW_HIDDEN) {\n+          if (isMainAxisRow && isUndefined(childHeight) && !isUndefined(availableInnerHeight)) {\n+            childHeight = availableInnerHeight;\n+            childHeightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+          }\n+        }\n \n-      if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n-          !isPosDefined(currentAbsoluteChild, leading[axis])) {\n-        currentAbsoluteChild->layout.position[leading[axis]] =\n-          node->layout.dimensions[dim[axis]] -\n-          currentAbsoluteChild->layout.dimensions[dim[axis]] -\n-          getPosition(currentAbsoluteChild, trailing[axis]);\n+        layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, false, \"abs-measure\");\n+        childWidth = currentAbsoluteChild->layout.measured_dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+        childHeight = currentAbsoluteChild->layout.measured_dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      }\n+      \n+      layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_EXACTLY, true, \"abs-layout\");\n+    \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_ROW])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_ROW]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]);\n+      }\n+      \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_COLUMN])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_COLUMN]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]);\n       }\n     }\n \n-    child = currentAbsoluteChild;\n-    currentAbsoluteChild = currentAbsoluteChild->next_absolute_child;\n-    child->next_absolute_child = NULL;\n+    currentAbsoluteChild = currentAbsoluteChild->next_child;\n   }\n   /** END_GENERATED **/\n }\n \n-void layoutNode(css_node_t *node, float parentMaxWidth, float parentMaxHeight, css_direction_t parentDirection) {\n-  css_layout_t *layout = &node->layout;\n-  css_direction_t direction = node->style.direction;\n-  layout->should_update = true;\n-\n-  bool skipLayout =\n-    !node->is_dirty(node->context) &&\n-    eq(layout->last_requested_dimensions[CSS_WIDTH], layout->dimensions[CSS_WIDTH]) &&\n-    eq(layout->last_requested_dimensions[CSS_HEIGHT], layout->dimensions[CSS_HEIGHT]) &&\n-    eq(layout->last_parent_max_width, parentMaxWidth) &&\n-    eq(layout->last_parent_max_height, parentMaxHeight) &&\n-    eq(layout->last_direction, direction);\n-\n-  if (skipLayout) {\n-    layout->dimensions[CSS_WIDTH] = layout->last_dimensions[CSS_WIDTH];\n-    layout->dimensions[CSS_HEIGHT] = layout->last_dimensions[CSS_HEIGHT];\n-    layout->position[CSS_TOP] = layout->last_position[CSS_TOP];\n-    layout->position[CSS_LEFT] = layout->last_position[CSS_LEFT];\n+int gDepth = 0;\n+bool gPrintTree = false;\n+bool gPrintChanges = false;\n+bool gPrintSkips = false;\n+\n+static const char* spacer = \"                                                            \";\n+\n+static const char* getSpacer(unsigned long level) {\n+  unsigned long spacerLen = strlen(spacer);\n+  if (level > spacerLen) {\n+    level = spacerLen;\n+  }\n+  return &spacer[spacerLen - level];\n+}\n+\n+static const char* getModeName(css_measure_mode_t mode, bool performLayout) {\n+  const char* kMeasureModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"UNDEFINED\",\n+    \"EXACTLY\",\n+    \"AT_MOST\"\n+  };\n+  const char* kLayoutModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"LAY_UNDEFINED\",\n+    \"LAY_EXACTLY\",\n+    \"LAY_AT_MOST\"\n+  };\n+  \n+  if (mode >= CSS_MEASURE_MODE_COUNT) {\n+    return \"\";\n+  }\n+  \n+  return performLayout? kLayoutModeNames[mode] : kMeasureModeNames[mode];\n+}\n+\n+static bool canUseCachedMeasurement(float availableWidth, float availableHeight,\n+  float marginRow, float marginColumn,\n+  css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode,\n+  css_cached_measurement_t cachedLayout) {\n+\n+  // Is it an exact match?\n+  if (eq(cachedLayout.available_width, availableWidth) &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      cachedLayout.width_measure_mode == widthMeasureMode &&\n+      cachedLayout.height_measure_mode == heightMeasureMode) {\n+    return true;\n+  }\n+  \n+  // If the width is an exact match, try a fuzzy match on the height.\n+  if (cachedLayout.width_measure_mode == widthMeasureMode &&\n+      eq(cachedLayout.available_width, availableWidth) &&\n+      heightMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableHeight - marginColumn, cachedLayout.computed_height)) {\n+    return true;\n+  }\n+  \n+  // If the height is an exact match, try a fuzzy match on the width.\n+  if (cachedLayout.height_measure_mode == heightMeasureMode &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      widthMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableWidth - marginRow, cachedLayout.computed_width)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+//\n+// This is a wrapper around the layoutNodeImpl function. It determines\n+// whether the layout request is redundant and can be skipped.\n+//\n+// Parameters:\n+//  Input parameters are the same as layoutNodeImpl (see above)\n+//  Return parameter is true if layout was performed, false if skipped\n+//\n+bool layoutNodeInternal(css_node_t* node, float availableWidth, float availableHeight,\n+    css_direction_t parentDirection, css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode, bool performLayout, char* reason) {\n+  css_layout_t* layout = &node->layout;\n+  \n+  gDepth++;\n+\n+  bool needToVisitNode = (node->is_dirty(node->context) && layout->generation_count != gCurrentGenerationCount) ||\n+    layout->last_parent_direction != parentDirection;\n+\n+  if (needToVisitNode) {\n+    // Invalidate the cached results.\n+    layout->next_cached_measurements_index = 0;\n+    layout->cached_layout.width_measure_mode = (css_measure_mode_t)-1;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "64994275",
        "repo_full_name": "facebook/yoga",
        "pr_number": 185,
        "pr_file": "src/Layout.c",
        "discussion_id": "64994275",
        "commented_code": "@@ -1133,191 +1282,449 @@ static void layoutNodeImpl(css_node_t *node, float parentMaxWidth, float parentM\n     } else if (alignContent == CSS_ALIGN_CENTER) {\n       currentLead += remainingAlignContentDim / 2;\n     } else if (alignContent == CSS_ALIGN_STRETCH) {\n-      if (nodeCrossAxisInnerSize > linesCrossDim) {\n-        crossDimLead = (remainingAlignContentDim / linesCount);\n+      if (availableInnerCrossDim > totalLineCrossDim) {\n+        crossDimLead = (remainingAlignContentDim / lineCount);\n       }\n     }\n \n     int endIndex = 0;\n-    for (i = 0; i < linesCount; ++i) {\n+    for (i = 0; i < lineCount; ++i) {\n       int startIndex = endIndex;\n+      int j;\n \n       // compute the line's height and find the endIndex\n       float lineHeight = 0;\n-      for (ii = startIndex; ii < childCount; ++ii) {\n-        child = node->get_child(node->context, ii);\n+      for (j = startIndex; j < childCount; ++j) {\n+        child = node->get_child(node->context, j);\n         if (child->style.position_type != CSS_POSITION_RELATIVE) {\n           continue;\n         }\n         if (child->line_index != i) {\n           break;\n         }\n         if (isLayoutDimDefined(child, crossAxis)) {\n-          lineHeight = fmaxf(\n-            lineHeight,\n-            child->layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n-          );\n+          lineHeight = fmaxf(lineHeight,\n+            child->layout.measured_dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis));\n         }\n       }\n-      endIndex = ii;\n+      endIndex = j;\n       lineHeight += crossDimLead;\n \n-      for (ii = startIndex; ii < endIndex; ++ii) {\n-        child = node->get_child(node->context, ii);\n-        if (child->style.position_type != CSS_POSITION_RELATIVE) {\n-          continue;\n-        }\n+      if (performLayout) {\n+        for (j = startIndex; j < endIndex; ++j) {\n+          child = node->get_child(node->context, j);\n+          if (child->style.position_type != CSS_POSITION_RELATIVE) {\n+            continue;\n+          }\n \n-        css_align_t alignContentAlignItem = getAlignItem(node, child);\n-        if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-        } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n-          child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.dimensions[dim[crossAxis]];\n-        } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n-          float childHeight = child->layout.dimensions[dim[crossAxis]];\n-          child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n-        } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-          // TODO(prenaux): Correctly set the height of items with undefined\n-          //                (auto) crossAxis dimension.\n+          css_align_t alignContentAlignItem = getAlignItem(node, child);\n+          if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+          } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n+            child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.measured_dimensions[dim[crossAxis]];\n+          } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n+            childHeight = child->layout.measured_dimensions[dim[crossAxis]];\n+            child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n+          } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+            // TODO(prenaux): Correctly set the height of items with indefinite\n+            //                (auto) crossAxis dimension.\n+          }\n         }\n       }\n \n       currentLead += lineHeight;\n     }\n   }\n \n-  bool needsMainTrailingPos = false;\n-  bool needsCrossTrailingPos = false;\n+  // STEP 9: COMPUTING FINAL DIMENSIONS\n+  node->layout.measured_dimensions[CSS_WIDTH] = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n+  node->layout.measured_dimensions[CSS_HEIGHT] = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n+\n+  // If the user didn't specify a width or height for the node, set the\n+  // dimensions based on the children.\n+  if (measureModeMainDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[mainAxis]] = boundAxis(node, mainAxis, maxLineMainDim);\n+  } else if (measureModeMainDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[mainAxis]] = fmaxf(\n+      fminf(availableInnerMainDim + paddingAndBorderAxisMain,\n+        boundAxisWithinMinAndMax(node, mainAxis, maxLineMainDim)),\n+      paddingAndBorderAxisMain);\n+  }\n \n-  // If the user didn't specify a width or height, and it has not been set\n-  // by the container, then we set it via the children.\n-  if (!isMainDimDefined) {\n-    node->layout.dimensions[dim[mainAxis]] = fmaxf(\n-      // We're missing the last padding at this point to get the final\n-      // dimension\n-      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n-      // We can never assign a width smaller than the padding and borders\n-      paddingAndBorderAxisMain\n-    );\n+  if (measureModeCrossDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[crossAxis]] = boundAxis(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross);\n+  } else if (measureModeCrossDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[crossAxis]] = fmaxf(\n+      fminf(availableInnerCrossDim + paddingAndBorderAxisCross,\n+        boundAxisWithinMinAndMax(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross)),\n+      paddingAndBorderAxisCross);\n+  }\n+  \n+  // STEP 10: SETTING TRAILING POSITIONS FOR CHILDREN\n+  if (performLayout) {\n+    bool needsMainTrailingPos = false;\n+    bool needsCrossTrailingPos = false;\n \n     if (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsMainTrailingPos = true;\n     }\n-  }\n-\n-  if (!isCrossDimDefined) {\n-    node->layout.dimensions[dim[crossAxis]] = fmaxf(\n-      // For the cross dim, we add both sides at the end because the value\n-      // is aggregate via a max function. Intermediate negative values\n-      // can mess this computation otherwise\n-      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n-      paddingAndBorderAxisCross\n-    );\n \n     if (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsCrossTrailingPos = true;\n     }\n-  }\n \n-  // <Loop F> Set trailing position if necessary\n-  if (needsMainTrailingPos || needsCrossTrailingPos) {\n-    for (i = 0; i < childCount; ++i) {\n-      child = node->get_child(node->context, i);\n+    // Set trailing position if necessary.\n+    if (needsMainTrailingPos || needsCrossTrailingPos) {\n+      for (i = 0; i < childCount; ++i) {\n+        child = node->get_child(node->context, i);\n \n-      if (needsMainTrailingPos) {\n-        setTrailingPosition(node, child, mainAxis);\n-      }\n+        if (needsMainTrailingPos) {\n+          setTrailingPosition(node, child, mainAxis);\n+        }\n \n-      if (needsCrossTrailingPos) {\n-        setTrailingPosition(node, child, crossAxis);\n+        if (needsCrossTrailingPos) {\n+          setTrailingPosition(node, child, crossAxis);\n+        }\n       }\n     }\n   }\n-\n-  // <Loop G> Calculate dimensions for absolutely positioned elements\n+  \n+  // STEP 11: SIZING AND POSITIONING ABSOLUTE CHILDREN\n   currentAbsoluteChild = firstAbsoluteChild;\n   while (currentAbsoluteChild != NULL) {\n-    // Pre-fill dimensions when using absolute position and both offsets for\n-    // the axis are defined (either both left and right or top and bottom).\n-    for (ii = 0; ii < 2; ii++) {\n-      axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n-\n-      if (isLayoutDimDefined(node, axis) &&\n-          !isStyleDimDefined(currentAbsoluteChild, axis) &&\n-          isPosDefined(currentAbsoluteChild, leading[axis]) &&\n-          isPosDefined(currentAbsoluteChild, trailing[axis])) {\n-        currentAbsoluteChild->layout.dimensions[dim[axis]] = fmaxf(\n-          boundAxis(currentAbsoluteChild, axis, node->layout.dimensions[dim[axis]] -\n-            getBorderAxis(node, axis) -\n-            getMarginAxis(currentAbsoluteChild, axis) -\n-            getPosition(currentAbsoluteChild, leading[axis]) -\n-            getPosition(currentAbsoluteChild, trailing[axis])\n-          ),\n-          // You never want to go smaller than padding\n-          getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n-        );\n+    // Now that we know the bounds of the container, perform layout again on the\n+    // absolutely-positioned children.\n+    if (performLayout) {\n+\n+      childWidth = CSS_UNDEFINED;\n+      childHeight = CSS_UNDEFINED;\n+\n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW)) {\n+        childWidth = currentAbsoluteChild->style.dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+      } else {\n+        // If the child doesn't have a specified width, compute the width based on the left/right offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_LEFT) && isPosDefined(currentAbsoluteChild, CSS_RIGHT)) {\n+          childWidth = node->layout.measured_dimensions[CSS_WIDTH] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_ROW) + getTrailingBorder(node, CSS_FLEX_DIRECTION_ROW)) -\n+            (currentAbsoluteChild->style.position[CSS_LEFT] + currentAbsoluteChild->style.position[CSS_RIGHT]);\n+          childWidth = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW, childWidth);\n+        }\n       }\n+      \n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN)) {\n+        childHeight = currentAbsoluteChild->style.dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      } else {\n+        // If the child doesn't have a specified height, compute the height based on the top/bottom offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_TOP) && isPosDefined(currentAbsoluteChild, CSS_BOTTOM)) {\n+          childHeight = node->layout.measured_dimensions[CSS_HEIGHT] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_COLUMN) + getTrailingBorder(node, CSS_FLEX_DIRECTION_COLUMN)) -\n+            (currentAbsoluteChild->style.position[CSS_TOP] + currentAbsoluteChild->style.position[CSS_BOTTOM]);\n+          childHeight = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN, childHeight);\n+        }\n+      }\n+\n+      // If we're still missing one or the other dimension, measure the content.\n+      if (isUndefined(childWidth) || isUndefined(childHeight)) {\n+        childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        \n+        // According to the spec, if the main size is not definite and the\n+        // child's inline axis is parallel to the main axis (i.e. it's\n+        // horizontal), the child should be sized using \"UNDEFINED\" in\n+        // the main size. Otherwise use \"AT_MOST\" in the cross axis.\n+        if (!isMainAxisRow && isUndefined(childWidth) && !isUndefined(availableInnerWidth)) {\n+          childWidth = availableInnerWidth;\n+          childWidthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+        }\n+\n+        // The W3C spec doesn't say anything about the 'overflow' property,\n+        // but all major browsers appear to implement the following logic.\n+        if (node->style.overflow == CSS_OVERFLOW_HIDDEN) {\n+          if (isMainAxisRow && isUndefined(childHeight) && !isUndefined(availableInnerHeight)) {\n+            childHeight = availableInnerHeight;\n+            childHeightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+          }\n+        }\n \n-      if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n-          !isPosDefined(currentAbsoluteChild, leading[axis])) {\n-        currentAbsoluteChild->layout.position[leading[axis]] =\n-          node->layout.dimensions[dim[axis]] -\n-          currentAbsoluteChild->layout.dimensions[dim[axis]] -\n-          getPosition(currentAbsoluteChild, trailing[axis]);\n+        layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, false, \"abs-measure\");\n+        childWidth = currentAbsoluteChild->layout.measured_dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+        childHeight = currentAbsoluteChild->layout.measured_dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      }\n+      \n+      layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_EXACTLY, true, \"abs-layout\");\n+    \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_ROW])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_ROW]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]);\n+      }\n+      \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_COLUMN])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_COLUMN]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]);\n       }\n     }\n \n-    child = currentAbsoluteChild;\n-    currentAbsoluteChild = currentAbsoluteChild->next_absolute_child;\n-    child->next_absolute_child = NULL;\n+    currentAbsoluteChild = currentAbsoluteChild->next_child;\n   }\n   /** END_GENERATED **/\n }\n \n-void layoutNode(css_node_t *node, float parentMaxWidth, float parentMaxHeight, css_direction_t parentDirection) {\n-  css_layout_t *layout = &node->layout;\n-  css_direction_t direction = node->style.direction;\n-  layout->should_update = true;\n-\n-  bool skipLayout =\n-    !node->is_dirty(node->context) &&\n-    eq(layout->last_requested_dimensions[CSS_WIDTH], layout->dimensions[CSS_WIDTH]) &&\n-    eq(layout->last_requested_dimensions[CSS_HEIGHT], layout->dimensions[CSS_HEIGHT]) &&\n-    eq(layout->last_parent_max_width, parentMaxWidth) &&\n-    eq(layout->last_parent_max_height, parentMaxHeight) &&\n-    eq(layout->last_direction, direction);\n-\n-  if (skipLayout) {\n-    layout->dimensions[CSS_WIDTH] = layout->last_dimensions[CSS_WIDTH];\n-    layout->dimensions[CSS_HEIGHT] = layout->last_dimensions[CSS_HEIGHT];\n-    layout->position[CSS_TOP] = layout->last_position[CSS_TOP];\n-    layout->position[CSS_LEFT] = layout->last_position[CSS_LEFT];\n+int gDepth = 0;\n+bool gPrintTree = false;\n+bool gPrintChanges = false;\n+bool gPrintSkips = false;\n+\n+static const char* spacer = \"                                                            \";\n+\n+static const char* getSpacer(unsigned long level) {\n+  unsigned long spacerLen = strlen(spacer);\n+  if (level > spacerLen) {\n+    level = spacerLen;\n+  }\n+  return &spacer[spacerLen - level];\n+}\n+\n+static const char* getModeName(css_measure_mode_t mode, bool performLayout) {\n+  const char* kMeasureModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"UNDEFINED\",\n+    \"EXACTLY\",\n+    \"AT_MOST\"\n+  };\n+  const char* kLayoutModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"LAY_UNDEFINED\",\n+    \"LAY_EXACTLY\",\n+    \"LAY_AT_MOST\"\n+  };\n+  \n+  if (mode >= CSS_MEASURE_MODE_COUNT) {\n+    return \"\";\n+  }\n+  \n+  return performLayout? kLayoutModeNames[mode] : kMeasureModeNames[mode];\n+}\n+\n+static bool canUseCachedMeasurement(float availableWidth, float availableHeight,\n+  float marginRow, float marginColumn,\n+  css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode,\n+  css_cached_measurement_t cachedLayout) {\n+\n+  // Is it an exact match?\n+  if (eq(cachedLayout.available_width, availableWidth) &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      cachedLayout.width_measure_mode == widthMeasureMode &&\n+      cachedLayout.height_measure_mode == heightMeasureMode) {\n+    return true;\n+  }\n+  \n+  // If the width is an exact match, try a fuzzy match on the height.\n+  if (cachedLayout.width_measure_mode == widthMeasureMode &&\n+      eq(cachedLayout.available_width, availableWidth) &&\n+      heightMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableHeight - marginColumn, cachedLayout.computed_height)) {\n+    return true;\n+  }\n+  \n+  // If the height is an exact match, try a fuzzy match on the width.\n+  if (cachedLayout.height_measure_mode == heightMeasureMode &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      widthMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableWidth - marginRow, cachedLayout.computed_width)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+//\n+// This is a wrapper around the layoutNodeImpl function. It determines\n+// whether the layout request is redundant and can be skipped.\n+//\n+// Parameters:\n+//  Input parameters are the same as layoutNodeImpl (see above)\n+//  Return parameter is true if layout was performed, false if skipped\n+//\n+bool layoutNodeInternal(css_node_t* node, float availableWidth, float availableHeight,\n+    css_direction_t parentDirection, css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode, bool performLayout, char* reason) {\n+  css_layout_t* layout = &node->layout;\n+  \n+  gDepth++;\n+\n+  bool needToVisitNode = (node->is_dirty(node->context) && layout->generation_count != gCurrentGenerationCount) ||\n+    layout->last_parent_direction != parentDirection;\n+\n+  if (needToVisitNode) {\n+    // Invalidate the cached results.\n+    layout->next_cached_measurements_index = 0;\n+    layout->cached_layout.width_measure_mode = (css_measure_mode_t)-1;",
        "comment_created_at": "2016-05-28T20:59:35+00:00",
        "comment_author": "jordwalke",
        "comment_body": "What is the meaning of this `-1`? Shouldn't you make a new enum state to model whatever this special kind of undefined means?\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "64995699",
    "pr_number": 185,
    "pr_file": "src/Layout.c",
    "created_at": "2016-05-28T23:32:21+00:00",
    "commented_code": "} else if (alignContent == CSS_ALIGN_CENTER) {\n       currentLead += remainingAlignContentDim / 2;\n     } else if (alignContent == CSS_ALIGN_STRETCH) {\n-      if (nodeCrossAxisInnerSize > linesCrossDim) {\n-        crossDimLead = (remainingAlignContentDim / linesCount);\n+      if (availableInnerCrossDim > totalLineCrossDim) {\n+        crossDimLead = (remainingAlignContentDim / lineCount);\n       }\n     }\n \n     int endIndex = 0;\n-    for (i = 0; i < linesCount; ++i) {\n+    for (i = 0; i < lineCount; ++i) {\n       int startIndex = endIndex;\n+      int j;\n \n       // compute the line's height and find the endIndex\n       float lineHeight = 0;\n-      for (ii = startIndex; ii < childCount; ++ii) {\n-        child = node->get_child(node->context, ii);\n+      for (j = startIndex; j < childCount; ++j) {\n+        child = node->get_child(node->context, j);\n         if (child->style.position_type != CSS_POSITION_RELATIVE) {\n           continue;\n         }\n         if (child->line_index != i) {\n           break;\n         }\n         if (isLayoutDimDefined(child, crossAxis)) {\n-          lineHeight = fmaxf(\n-            lineHeight,\n-            child->layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n-          );\n+          lineHeight = fmaxf(lineHeight,\n+            child->layout.measured_dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis));\n         }\n       }\n-      endIndex = ii;\n+      endIndex = j;\n       lineHeight += crossDimLead;\n \n-      for (ii = startIndex; ii < endIndex; ++ii) {\n-        child = node->get_child(node->context, ii);\n-        if (child->style.position_type != CSS_POSITION_RELATIVE) {\n-          continue;\n-        }\n+      if (performLayout) {\n+        for (j = startIndex; j < endIndex; ++j) {\n+          child = node->get_child(node->context, j);\n+          if (child->style.position_type != CSS_POSITION_RELATIVE) {\n+            continue;\n+          }\n \n-        css_align_t alignContentAlignItem = getAlignItem(node, child);\n-        if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-        } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n-          child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.dimensions[dim[crossAxis]];\n-        } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n-          float childHeight = child->layout.dimensions[dim[crossAxis]];\n-          child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n-        } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-          // TODO(prenaux): Correctly set the height of items with undefined\n-          //                (auto) crossAxis dimension.\n+          css_align_t alignContentAlignItem = getAlignItem(node, child);\n+          if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+          } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n+            child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.measured_dimensions[dim[crossAxis]];\n+          } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n+            childHeight = child->layout.measured_dimensions[dim[crossAxis]];\n+            child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n+          } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+            // TODO(prenaux): Correctly set the height of items with indefinite\n+            //                (auto) crossAxis dimension.\n+          }\n         }\n       }\n \n       currentLead += lineHeight;\n     }\n   }\n \n-  bool needsMainTrailingPos = false;\n-  bool needsCrossTrailingPos = false;\n+  // STEP 9: COMPUTING FINAL DIMENSIONS\n+  node->layout.measured_dimensions[CSS_WIDTH] = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n+  node->layout.measured_dimensions[CSS_HEIGHT] = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n+\n+  // If the user didn't specify a width or height for the node, set the\n+  // dimensions based on the children.\n+  if (measureModeMainDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[mainAxis]] = boundAxis(node, mainAxis, maxLineMainDim);\n+  } else if (measureModeMainDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[mainAxis]] = fmaxf(\n+      fminf(availableInnerMainDim + paddingAndBorderAxisMain,\n+        boundAxisWithinMinAndMax(node, mainAxis, maxLineMainDim)),\n+      paddingAndBorderAxisMain);\n+  }\n \n-  // If the user didn't specify a width or height, and it has not been set\n-  // by the container, then we set it via the children.\n-  if (!isMainDimDefined) {\n-    node->layout.dimensions[dim[mainAxis]] = fmaxf(\n-      // We're missing the last padding at this point to get the final\n-      // dimension\n-      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n-      // We can never assign a width smaller than the padding and borders\n-      paddingAndBorderAxisMain\n-    );\n+  if (measureModeCrossDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[crossAxis]] = boundAxis(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross);\n+  } else if (measureModeCrossDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[crossAxis]] = fmaxf(\n+      fminf(availableInnerCrossDim + paddingAndBorderAxisCross,\n+        boundAxisWithinMinAndMax(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross)),\n+      paddingAndBorderAxisCross);\n+  }\n+  \n+  // STEP 10: SETTING TRAILING POSITIONS FOR CHILDREN\n+  if (performLayout) {\n+    bool needsMainTrailingPos = false;\n+    bool needsCrossTrailingPos = false;\n \n     if (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsMainTrailingPos = true;\n     }\n-  }\n-\n-  if (!isCrossDimDefined) {\n-    node->layout.dimensions[dim[crossAxis]] = fmaxf(\n-      // For the cross dim, we add both sides at the end because the value\n-      // is aggregate via a max function. Intermediate negative values\n-      // can mess this computation otherwise\n-      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n-      paddingAndBorderAxisCross\n-    );\n \n     if (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsCrossTrailingPos = true;\n     }\n-  }\n \n-  // <Loop F> Set trailing position if necessary\n-  if (needsMainTrailingPos || needsCrossTrailingPos) {\n-    for (i = 0; i < childCount; ++i) {\n-      child = node->get_child(node->context, i);\n+    // Set trailing position if necessary.\n+    if (needsMainTrailingPos || needsCrossTrailingPos) {\n+      for (i = 0; i < childCount; ++i) {\n+        child = node->get_child(node->context, i);\n \n-      if (needsMainTrailingPos) {\n-        setTrailingPosition(node, child, mainAxis);\n-      }\n+        if (needsMainTrailingPos) {\n+          setTrailingPosition(node, child, mainAxis);\n+        }\n \n-      if (needsCrossTrailingPos) {\n-        setTrailingPosition(node, child, crossAxis);\n+        if (needsCrossTrailingPos) {\n+          setTrailingPosition(node, child, crossAxis);\n+        }\n       }\n     }\n   }\n-\n-  // <Loop G> Calculate dimensions for absolutely positioned elements\n+  \n+  // STEP 11: SIZING AND POSITIONING ABSOLUTE CHILDREN\n   currentAbsoluteChild = firstAbsoluteChild;\n   while (currentAbsoluteChild != NULL) {\n-    // Pre-fill dimensions when using absolute position and both offsets for\n-    // the axis are defined (either both left and right or top and bottom).\n-    for (ii = 0; ii < 2; ii++) {\n-      axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n-\n-      if (isLayoutDimDefined(node, axis) &&\n-          !isStyleDimDefined(currentAbsoluteChild, axis) &&\n-          isPosDefined(currentAbsoluteChild, leading[axis]) &&\n-          isPosDefined(currentAbsoluteChild, trailing[axis])) {\n-        currentAbsoluteChild->layout.dimensions[dim[axis]] = fmaxf(\n-          boundAxis(currentAbsoluteChild, axis, node->layout.dimensions[dim[axis]] -\n-            getBorderAxis(node, axis) -\n-            getMarginAxis(currentAbsoluteChild, axis) -\n-            getPosition(currentAbsoluteChild, leading[axis]) -\n-            getPosition(currentAbsoluteChild, trailing[axis])\n-          ),\n-          // You never want to go smaller than padding\n-          getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n-        );\n+    // Now that we know the bounds of the container, perform layout again on the\n+    // absolutely-positioned children.\n+    if (performLayout) {\n+\n+      childWidth = CSS_UNDEFINED;\n+      childHeight = CSS_UNDEFINED;\n+\n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW)) {\n+        childWidth = currentAbsoluteChild->style.dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+      } else {\n+        // If the child doesn't have a specified width, compute the width based on the left/right offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_LEFT) && isPosDefined(currentAbsoluteChild, CSS_RIGHT)) {\n+          childWidth = node->layout.measured_dimensions[CSS_WIDTH] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_ROW) + getTrailingBorder(node, CSS_FLEX_DIRECTION_ROW)) -\n+            (currentAbsoluteChild->style.position[CSS_LEFT] + currentAbsoluteChild->style.position[CSS_RIGHT]);\n+          childWidth = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW, childWidth);\n+        }\n       }\n+      \n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN)) {\n+        childHeight = currentAbsoluteChild->style.dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      } else {\n+        // If the child doesn't have a specified height, compute the height based on the top/bottom offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_TOP) && isPosDefined(currentAbsoluteChild, CSS_BOTTOM)) {\n+          childHeight = node->layout.measured_dimensions[CSS_HEIGHT] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_COLUMN) + getTrailingBorder(node, CSS_FLEX_DIRECTION_COLUMN)) -\n+            (currentAbsoluteChild->style.position[CSS_TOP] + currentAbsoluteChild->style.position[CSS_BOTTOM]);\n+          childHeight = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN, childHeight);\n+        }\n+      }\n+\n+      // If we're still missing one or the other dimension, measure the content.\n+      if (isUndefined(childWidth) || isUndefined(childHeight)) {\n+        childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        \n+        // According to the spec, if the main size is not definite and the\n+        // child's inline axis is parallel to the main axis (i.e. it's\n+        // horizontal), the child should be sized using \"UNDEFINED\" in\n+        // the main size. Otherwise use \"AT_MOST\" in the cross axis.\n+        if (!isMainAxisRow && isUndefined(childWidth) && !isUndefined(availableInnerWidth)) {\n+          childWidth = availableInnerWidth;\n+          childWidthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+        }\n+\n+        // The W3C spec doesn't say anything about the 'overflow' property,\n+        // but all major browsers appear to implement the following logic.\n+        if (node->style.overflow == CSS_OVERFLOW_HIDDEN) {\n+          if (isMainAxisRow && isUndefined(childHeight) && !isUndefined(availableInnerHeight)) {\n+            childHeight = availableInnerHeight;\n+            childHeightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+          }\n+        }\n \n-      if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n-          !isPosDefined(currentAbsoluteChild, leading[axis])) {\n-        currentAbsoluteChild->layout.position[leading[axis]] =\n-          node->layout.dimensions[dim[axis]] -\n-          currentAbsoluteChild->layout.dimensions[dim[axis]] -\n-          getPosition(currentAbsoluteChild, trailing[axis]);\n+        layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, false, \"abs-measure\");\n+        childWidth = currentAbsoluteChild->layout.measured_dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+        childHeight = currentAbsoluteChild->layout.measured_dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      }\n+      \n+      layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_EXACTLY, true, \"abs-layout\");\n+    \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_ROW])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_ROW]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]);\n+      }\n+      \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_COLUMN])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_COLUMN]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]);\n       }\n     }\n \n-    child = currentAbsoluteChild;\n-    currentAbsoluteChild = currentAbsoluteChild->next_absolute_child;\n-    child->next_absolute_child = NULL;\n+    currentAbsoluteChild = currentAbsoluteChild->next_child;\n   }\n   /** END_GENERATED **/\n }\n \n-void layoutNode(css_node_t *node, float parentMaxWidth, float parentMaxHeight, css_direction_t parentDirection) {\n-  css_layout_t *layout = &node->layout;\n-  css_direction_t direction = node->style.direction;\n-  layout->should_update = true;\n-\n-  bool skipLayout =\n-    !node->is_dirty(node->context) &&\n-    eq(layout->last_requested_dimensions[CSS_WIDTH], layout->dimensions[CSS_WIDTH]) &&\n-    eq(layout->last_requested_dimensions[CSS_HEIGHT], layout->dimensions[CSS_HEIGHT]) &&\n-    eq(layout->last_parent_max_width, parentMaxWidth) &&\n-    eq(layout->last_parent_max_height, parentMaxHeight) &&\n-    eq(layout->last_direction, direction);\n-\n-  if (skipLayout) {\n-    layout->dimensions[CSS_WIDTH] = layout->last_dimensions[CSS_WIDTH];\n-    layout->dimensions[CSS_HEIGHT] = layout->last_dimensions[CSS_HEIGHT];\n-    layout->position[CSS_TOP] = layout->last_position[CSS_TOP];\n-    layout->position[CSS_LEFT] = layout->last_position[CSS_LEFT];\n+int gDepth = 0;\n+bool gPrintTree = false;\n+bool gPrintChanges = false;\n+bool gPrintSkips = false;\n+\n+static const char* spacer = \"                                                            \";\n+\n+static const char* getSpacer(unsigned long level) {\n+  unsigned long spacerLen = strlen(spacer);\n+  if (level > spacerLen) {\n+    level = spacerLen;\n+  }\n+  return &spacer[spacerLen - level];\n+}\n+\n+static const char* getModeName(css_measure_mode_t mode, bool performLayout) {\n+  const char* kMeasureModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"UNDEFINED\",\n+    \"EXACTLY\",\n+    \"AT_MOST\"\n+  };\n+  const char* kLayoutModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"LAY_UNDEFINED\",\n+    \"LAY_EXACTLY\",\n+    \"LAY_AT_MOST\"\n+  };\n+  \n+  if (mode >= CSS_MEASURE_MODE_COUNT) {\n+    return \"\";\n+  }\n+  \n+  return performLayout? kLayoutModeNames[mode] : kMeasureModeNames[mode];\n+}\n+\n+static bool canUseCachedMeasurement(float availableWidth, float availableHeight,\n+  float marginRow, float marginColumn,\n+  css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode,\n+  css_cached_measurement_t cachedLayout) {\n+\n+  // Is it an exact match?\n+  if (eq(cachedLayout.available_width, availableWidth) &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      cachedLayout.width_measure_mode == widthMeasureMode &&\n+      cachedLayout.height_measure_mode == heightMeasureMode) {\n+    return true;\n+  }\n+  \n+  // If the width is an exact match, try a fuzzy match on the height.\n+  if (cachedLayout.width_measure_mode == widthMeasureMode &&\n+      eq(cachedLayout.available_width, availableWidth) &&\n+      heightMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableHeight - marginColumn, cachedLayout.computed_height)) {\n+    return true;\n+  }\n+  \n+  // If the height is an exact match, try a fuzzy match on the width.\n+  if (cachedLayout.height_measure_mode == heightMeasureMode &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      widthMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableWidth - marginRow, cachedLayout.computed_width)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+//\n+// This is a wrapper around the layoutNodeImpl function. It determines\n+// whether the layout request is redundant and can be skipped.\n+//\n+// Parameters:\n+//  Input parameters are the same as layoutNodeImpl (see above)\n+//  Return parameter is true if layout was performed, false if skipped\n+//\n+bool layoutNodeInternal(css_node_t* node, float availableWidth, float availableHeight,\n+    css_direction_t parentDirection, css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode, bool performLayout, char* reason) {\n+  css_layout_t* layout = &node->layout;\n+  \n+  gDepth++;\n+\n+  bool needToVisitNode = (node->is_dirty(node->context) && layout->generation_count != gCurrentGenerationCount) ||\n+    layout->last_parent_direction != parentDirection;\n+\n+  if (needToVisitNode) {\n+    // Invalidate the cached results.\n+    layout->next_cached_measurements_index = 0;\n+    layout->cached_layout.width_measure_mode = (css_measure_mode_t)-1;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "64995699",
        "repo_full_name": "facebook/yoga",
        "pr_number": 185,
        "pr_file": "src/Layout.c",
        "discussion_id": "64995699",
        "commented_code": "@@ -1133,191 +1282,449 @@ static void layoutNodeImpl(css_node_t *node, float parentMaxWidth, float parentM\n     } else if (alignContent == CSS_ALIGN_CENTER) {\n       currentLead += remainingAlignContentDim / 2;\n     } else if (alignContent == CSS_ALIGN_STRETCH) {\n-      if (nodeCrossAxisInnerSize > linesCrossDim) {\n-        crossDimLead = (remainingAlignContentDim / linesCount);\n+      if (availableInnerCrossDim > totalLineCrossDim) {\n+        crossDimLead = (remainingAlignContentDim / lineCount);\n       }\n     }\n \n     int endIndex = 0;\n-    for (i = 0; i < linesCount; ++i) {\n+    for (i = 0; i < lineCount; ++i) {\n       int startIndex = endIndex;\n+      int j;\n \n       // compute the line's height and find the endIndex\n       float lineHeight = 0;\n-      for (ii = startIndex; ii < childCount; ++ii) {\n-        child = node->get_child(node->context, ii);\n+      for (j = startIndex; j < childCount; ++j) {\n+        child = node->get_child(node->context, j);\n         if (child->style.position_type != CSS_POSITION_RELATIVE) {\n           continue;\n         }\n         if (child->line_index != i) {\n           break;\n         }\n         if (isLayoutDimDefined(child, crossAxis)) {\n-          lineHeight = fmaxf(\n-            lineHeight,\n-            child->layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n-          );\n+          lineHeight = fmaxf(lineHeight,\n+            child->layout.measured_dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis));\n         }\n       }\n-      endIndex = ii;\n+      endIndex = j;\n       lineHeight += crossDimLead;\n \n-      for (ii = startIndex; ii < endIndex; ++ii) {\n-        child = node->get_child(node->context, ii);\n-        if (child->style.position_type != CSS_POSITION_RELATIVE) {\n-          continue;\n-        }\n+      if (performLayout) {\n+        for (j = startIndex; j < endIndex; ++j) {\n+          child = node->get_child(node->context, j);\n+          if (child->style.position_type != CSS_POSITION_RELATIVE) {\n+            continue;\n+          }\n \n-        css_align_t alignContentAlignItem = getAlignItem(node, child);\n-        if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-        } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n-          child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.dimensions[dim[crossAxis]];\n-        } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n-          float childHeight = child->layout.dimensions[dim[crossAxis]];\n-          child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n-        } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n-          child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n-          // TODO(prenaux): Correctly set the height of items with undefined\n-          //                (auto) crossAxis dimension.\n+          css_align_t alignContentAlignItem = getAlignItem(node, child);\n+          if (alignContentAlignItem == CSS_ALIGN_FLEX_START) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+          } else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) {\n+            child->layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child->layout.measured_dimensions[dim[crossAxis]];\n+          } else if (alignContentAlignItem == CSS_ALIGN_CENTER) {\n+            childHeight = child->layout.measured_dimensions[dim[crossAxis]];\n+            child->layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n+          } else if (alignContentAlignItem == CSS_ALIGN_STRETCH) {\n+            child->layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n+            // TODO(prenaux): Correctly set the height of items with indefinite\n+            //                (auto) crossAxis dimension.\n+          }\n         }\n       }\n \n       currentLead += lineHeight;\n     }\n   }\n \n-  bool needsMainTrailingPos = false;\n-  bool needsCrossTrailingPos = false;\n+  // STEP 9: COMPUTING FINAL DIMENSIONS\n+  node->layout.measured_dimensions[CSS_WIDTH] = boundAxis(node, CSS_FLEX_DIRECTION_ROW, availableWidth - marginAxisRow);\n+  node->layout.measured_dimensions[CSS_HEIGHT] = boundAxis(node, CSS_FLEX_DIRECTION_COLUMN, availableHeight - marginAxisColumn);\n+\n+  // If the user didn't specify a width or height for the node, set the\n+  // dimensions based on the children.\n+  if (measureModeMainDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[mainAxis]] = boundAxis(node, mainAxis, maxLineMainDim);\n+  } else if (measureModeMainDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[mainAxis]] = fmaxf(\n+      fminf(availableInnerMainDim + paddingAndBorderAxisMain,\n+        boundAxisWithinMinAndMax(node, mainAxis, maxLineMainDim)),\n+      paddingAndBorderAxisMain);\n+  }\n \n-  // If the user didn't specify a width or height, and it has not been set\n-  // by the container, then we set it via the children.\n-  if (!isMainDimDefined) {\n-    node->layout.dimensions[dim[mainAxis]] = fmaxf(\n-      // We're missing the last padding at this point to get the final\n-      // dimension\n-      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n-      // We can never assign a width smaller than the padding and borders\n-      paddingAndBorderAxisMain\n-    );\n+  if (measureModeCrossDim == CSS_MEASURE_MODE_UNDEFINED) {\n+    // Clamp the size to the min/max size, if specified, and make sure it\n+    // doesn't go below the padding and border amount.\n+    node->layout.measured_dimensions[dim[crossAxis]] = boundAxis(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross);\n+  } else if (measureModeCrossDim == CSS_MEASURE_MODE_AT_MOST) {\n+    node->layout.measured_dimensions[dim[crossAxis]] = fmaxf(\n+      fminf(availableInnerCrossDim + paddingAndBorderAxisCross,\n+        boundAxisWithinMinAndMax(node, crossAxis, totalLineCrossDim + paddingAndBorderAxisCross)),\n+      paddingAndBorderAxisCross);\n+  }\n+  \n+  // STEP 10: SETTING TRAILING POSITIONS FOR CHILDREN\n+  if (performLayout) {\n+    bool needsMainTrailingPos = false;\n+    bool needsCrossTrailingPos = false;\n \n     if (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsMainTrailingPos = true;\n     }\n-  }\n-\n-  if (!isCrossDimDefined) {\n-    node->layout.dimensions[dim[crossAxis]] = fmaxf(\n-      // For the cross dim, we add both sides at the end because the value\n-      // is aggregate via a max function. Intermediate negative values\n-      // can mess this computation otherwise\n-      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n-      paddingAndBorderAxisCross\n-    );\n \n     if (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||\n         crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n       needsCrossTrailingPos = true;\n     }\n-  }\n \n-  // <Loop F> Set trailing position if necessary\n-  if (needsMainTrailingPos || needsCrossTrailingPos) {\n-    for (i = 0; i < childCount; ++i) {\n-      child = node->get_child(node->context, i);\n+    // Set trailing position if necessary.\n+    if (needsMainTrailingPos || needsCrossTrailingPos) {\n+      for (i = 0; i < childCount; ++i) {\n+        child = node->get_child(node->context, i);\n \n-      if (needsMainTrailingPos) {\n-        setTrailingPosition(node, child, mainAxis);\n-      }\n+        if (needsMainTrailingPos) {\n+          setTrailingPosition(node, child, mainAxis);\n+        }\n \n-      if (needsCrossTrailingPos) {\n-        setTrailingPosition(node, child, crossAxis);\n+        if (needsCrossTrailingPos) {\n+          setTrailingPosition(node, child, crossAxis);\n+        }\n       }\n     }\n   }\n-\n-  // <Loop G> Calculate dimensions for absolutely positioned elements\n+  \n+  // STEP 11: SIZING AND POSITIONING ABSOLUTE CHILDREN\n   currentAbsoluteChild = firstAbsoluteChild;\n   while (currentAbsoluteChild != NULL) {\n-    // Pre-fill dimensions when using absolute position and both offsets for\n-    // the axis are defined (either both left and right or top and bottom).\n-    for (ii = 0; ii < 2; ii++) {\n-      axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n-\n-      if (isLayoutDimDefined(node, axis) &&\n-          !isStyleDimDefined(currentAbsoluteChild, axis) &&\n-          isPosDefined(currentAbsoluteChild, leading[axis]) &&\n-          isPosDefined(currentAbsoluteChild, trailing[axis])) {\n-        currentAbsoluteChild->layout.dimensions[dim[axis]] = fmaxf(\n-          boundAxis(currentAbsoluteChild, axis, node->layout.dimensions[dim[axis]] -\n-            getBorderAxis(node, axis) -\n-            getMarginAxis(currentAbsoluteChild, axis) -\n-            getPosition(currentAbsoluteChild, leading[axis]) -\n-            getPosition(currentAbsoluteChild, trailing[axis])\n-          ),\n-          // You never want to go smaller than padding\n-          getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n-        );\n+    // Now that we know the bounds of the container, perform layout again on the\n+    // absolutely-positioned children.\n+    if (performLayout) {\n+\n+      childWidth = CSS_UNDEFINED;\n+      childHeight = CSS_UNDEFINED;\n+\n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW)) {\n+        childWidth = currentAbsoluteChild->style.dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+      } else {\n+        // If the child doesn't have a specified width, compute the width based on the left/right offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_LEFT) && isPosDefined(currentAbsoluteChild, CSS_RIGHT)) {\n+          childWidth = node->layout.measured_dimensions[CSS_WIDTH] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_ROW) + getTrailingBorder(node, CSS_FLEX_DIRECTION_ROW)) -\n+            (currentAbsoluteChild->style.position[CSS_LEFT] + currentAbsoluteChild->style.position[CSS_RIGHT]);\n+          childWidth = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW, childWidth);\n+        }\n       }\n+      \n+      if (isStyleDimDefined(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN)) {\n+        childHeight = currentAbsoluteChild->style.dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      } else {\n+        // If the child doesn't have a specified height, compute the height based on the top/bottom offsets if they're defined.\n+        if (isPosDefined(currentAbsoluteChild, CSS_TOP) && isPosDefined(currentAbsoluteChild, CSS_BOTTOM)) {\n+          childHeight = node->layout.measured_dimensions[CSS_HEIGHT] -\n+            (getLeadingBorder(node, CSS_FLEX_DIRECTION_COLUMN) + getTrailingBorder(node, CSS_FLEX_DIRECTION_COLUMN)) -\n+            (currentAbsoluteChild->style.position[CSS_TOP] + currentAbsoluteChild->style.position[CSS_BOTTOM]);\n+          childHeight = boundAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN, childHeight);\n+        }\n+      }\n+\n+      // If we're still missing one or the other dimension, measure the content.\n+      if (isUndefined(childWidth) || isUndefined(childHeight)) {\n+        childWidthMeasureMode = isUndefined(childWidth) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        childHeightMeasureMode = isUndefined(childHeight) ? CSS_MEASURE_MODE_UNDEFINED : CSS_MEASURE_MODE_EXACTLY;\n+        \n+        // According to the spec, if the main size is not definite and the\n+        // child's inline axis is parallel to the main axis (i.e. it's\n+        // horizontal), the child should be sized using \"UNDEFINED\" in\n+        // the main size. Otherwise use \"AT_MOST\" in the cross axis.\n+        if (!isMainAxisRow && isUndefined(childWidth) && !isUndefined(availableInnerWidth)) {\n+          childWidth = availableInnerWidth;\n+          childWidthMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+        }\n+\n+        // The W3C spec doesn't say anything about the 'overflow' property,\n+        // but all major browsers appear to implement the following logic.\n+        if (node->style.overflow == CSS_OVERFLOW_HIDDEN) {\n+          if (isMainAxisRow && isUndefined(childHeight) && !isUndefined(availableInnerHeight)) {\n+            childHeight = availableInnerHeight;\n+            childHeightMeasureMode = CSS_MEASURE_MODE_AT_MOST;\n+          }\n+        }\n \n-      if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n-          !isPosDefined(currentAbsoluteChild, leading[axis])) {\n-        currentAbsoluteChild->layout.position[leading[axis]] =\n-          node->layout.dimensions[dim[axis]] -\n-          currentAbsoluteChild->layout.dimensions[dim[axis]] -\n-          getPosition(currentAbsoluteChild, trailing[axis]);\n+        layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, childWidthMeasureMode, childHeightMeasureMode, false, \"abs-measure\");\n+        childWidth = currentAbsoluteChild->layout.measured_dimensions[CSS_WIDTH] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_ROW);\n+        childHeight = currentAbsoluteChild->layout.measured_dimensions[CSS_HEIGHT] + getMarginAxis(currentAbsoluteChild, CSS_FLEX_DIRECTION_COLUMN);\n+      }\n+      \n+      layoutNodeInternal(currentAbsoluteChild, childWidth, childHeight, direction, CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_EXACTLY, true, \"abs-layout\");\n+    \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_ROW])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_ROW]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_ROW]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_ROW]);\n+      }\n+      \n+      if (isPosDefined(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]) &&\n+          !isPosDefined(currentAbsoluteChild, leading[CSS_FLEX_DIRECTION_COLUMN])) {\n+        currentAbsoluteChild->layout.position[leading[CSS_FLEX_DIRECTION_COLUMN]] =\n+          node->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          currentAbsoluteChild->layout.measured_dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n+          getPosition(currentAbsoluteChild, trailing[CSS_FLEX_DIRECTION_COLUMN]);\n       }\n     }\n \n-    child = currentAbsoluteChild;\n-    currentAbsoluteChild = currentAbsoluteChild->next_absolute_child;\n-    child->next_absolute_child = NULL;\n+    currentAbsoluteChild = currentAbsoluteChild->next_child;\n   }\n   /** END_GENERATED **/\n }\n \n-void layoutNode(css_node_t *node, float parentMaxWidth, float parentMaxHeight, css_direction_t parentDirection) {\n-  css_layout_t *layout = &node->layout;\n-  css_direction_t direction = node->style.direction;\n-  layout->should_update = true;\n-\n-  bool skipLayout =\n-    !node->is_dirty(node->context) &&\n-    eq(layout->last_requested_dimensions[CSS_WIDTH], layout->dimensions[CSS_WIDTH]) &&\n-    eq(layout->last_requested_dimensions[CSS_HEIGHT], layout->dimensions[CSS_HEIGHT]) &&\n-    eq(layout->last_parent_max_width, parentMaxWidth) &&\n-    eq(layout->last_parent_max_height, parentMaxHeight) &&\n-    eq(layout->last_direction, direction);\n-\n-  if (skipLayout) {\n-    layout->dimensions[CSS_WIDTH] = layout->last_dimensions[CSS_WIDTH];\n-    layout->dimensions[CSS_HEIGHT] = layout->last_dimensions[CSS_HEIGHT];\n-    layout->position[CSS_TOP] = layout->last_position[CSS_TOP];\n-    layout->position[CSS_LEFT] = layout->last_position[CSS_LEFT];\n+int gDepth = 0;\n+bool gPrintTree = false;\n+bool gPrintChanges = false;\n+bool gPrintSkips = false;\n+\n+static const char* spacer = \"                                                            \";\n+\n+static const char* getSpacer(unsigned long level) {\n+  unsigned long spacerLen = strlen(spacer);\n+  if (level > spacerLen) {\n+    level = spacerLen;\n+  }\n+  return &spacer[spacerLen - level];\n+}\n+\n+static const char* getModeName(css_measure_mode_t mode, bool performLayout) {\n+  const char* kMeasureModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"UNDEFINED\",\n+    \"EXACTLY\",\n+    \"AT_MOST\"\n+  };\n+  const char* kLayoutModeNames[CSS_MEASURE_MODE_COUNT] = {\n+    \"LAY_UNDEFINED\",\n+    \"LAY_EXACTLY\",\n+    \"LAY_AT_MOST\"\n+  };\n+  \n+  if (mode >= CSS_MEASURE_MODE_COUNT) {\n+    return \"\";\n+  }\n+  \n+  return performLayout? kLayoutModeNames[mode] : kMeasureModeNames[mode];\n+}\n+\n+static bool canUseCachedMeasurement(float availableWidth, float availableHeight,\n+  float marginRow, float marginColumn,\n+  css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode,\n+  css_cached_measurement_t cachedLayout) {\n+\n+  // Is it an exact match?\n+  if (eq(cachedLayout.available_width, availableWidth) &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      cachedLayout.width_measure_mode == widthMeasureMode &&\n+      cachedLayout.height_measure_mode == heightMeasureMode) {\n+    return true;\n+  }\n+  \n+  // If the width is an exact match, try a fuzzy match on the height.\n+  if (cachedLayout.width_measure_mode == widthMeasureMode &&\n+      eq(cachedLayout.available_width, availableWidth) &&\n+      heightMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableHeight - marginColumn, cachedLayout.computed_height)) {\n+    return true;\n+  }\n+  \n+  // If the height is an exact match, try a fuzzy match on the width.\n+  if (cachedLayout.height_measure_mode == heightMeasureMode &&\n+      eq(cachedLayout.available_height, availableHeight) &&\n+      widthMeasureMode == CSS_MEASURE_MODE_EXACTLY &&\n+      eq(availableWidth - marginRow, cachedLayout.computed_width)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+//\n+// This is a wrapper around the layoutNodeImpl function. It determines\n+// whether the layout request is redundant and can be skipped.\n+//\n+// Parameters:\n+//  Input parameters are the same as layoutNodeImpl (see above)\n+//  Return parameter is true if layout was performed, false if skipped\n+//\n+bool layoutNodeInternal(css_node_t* node, float availableWidth, float availableHeight,\n+    css_direction_t parentDirection, css_measure_mode_t widthMeasureMode, css_measure_mode_t heightMeasureMode, bool performLayout, char* reason) {\n+  css_layout_t* layout = &node->layout;\n+  \n+  gDepth++;\n+\n+  bool needToVisitNode = (node->is_dirty(node->context) && layout->generation_count != gCurrentGenerationCount) ||\n+    layout->last_parent_direction != parentDirection;\n+\n+  if (needToVisitNode) {\n+    // Invalidate the cached results.\n+    layout->next_cached_measurements_index = 0;\n+    layout->cached_layout.width_measure_mode = (css_measure_mode_t)-1;",
        "comment_created_at": "2016-05-28T23:32:21+00:00",
        "comment_author": "rigdern",
        "comment_body": "Thanks for the feedback.\n\nIt means that `width_measure_mode` is uninitialized. The idea is that while a cache entry's `width_measure_mode` has this value, `layoutNodeInternal` will never return that cache entry because the `widthMeasureMode` given to `layoutNodeInternal` will never match `-1`.\n\nThis pattern was used for `layout.last_direction` prior to this PR: https://github.com/facebook/css-layout/blob/b0d00ad33850d83450139d994bded89d20ddac32/src/Layout.c#L80\n\nIf we were to create an explicit enum value instead of using `-1`, it might give people the idea that it is okay to call `layoutNode` with that enum value for `widthMeasureMode` or `heightMeasureMode` which is not the case. This could be mitigated with documentation.\n\nThat's the rationale. I'm not sure whether or not having an explicit enum value would result in more idiomatic C code.\n",
        "pr_file_module": null
      }
    ]
  }
]