[
  {
    "discussion_id": "1799840285",
    "pr_number": 1726,
    "pr_file": "yoga/node/Node.h",
    "created_at": "2024-10-14T17:03:57+00:00",
    "commented_code": "class YG_EXPORT Node : public ::YGNode {\n  public:\n+  class LayoutableChildren {\n+   public:\n+    using Backtrack = std::vector<std::pair<const Node*, size_t>>;\n+    struct Iterator {\n+      using iterator_category = std::forward_iterator_tag;\n+\n+      Iterator(const Node* node, size_t childIndex)\n+          : node_(node), childIndex_(childIndex) {}\n+      Iterator(const Node* node, size_t childIndex, Backtrack&& backtrack)\n+          : node_(node),\n+            childIndex_(childIndex),\n+            backtrack_(std::move(backtrack)) {}\n+\n+      Node* operator*() const {\n+        return node_->getChild(childIndex_);\n+      }\n+\n+      Iterator& operator++() {\n+        next();\n+        currentNodeIndex_++;\n+        return *this;\n+      }\n+\n+      Iterator operator++(int) {\n+        Iterator tmp = *this;\n+        ++(*this);\n+        return tmp;\n+      }\n+\n+      size_t index() const {\n+        return currentNodeIndex_;\n+      }\n+\n+      friend bool operator==(const Iterator& a, const Iterator& b) {\n+        return a.node_ == b.node_ && a.childIndex_ == b.childIndex_;\n+      };\n+\n+      friend bool operator!=(const Iterator& a, const Iterator& b) {\n+        return a.node_ != b.node_ || a.childIndex_ != b.childIndex_;\n+      };\n+\n+     private:\n+      void next() {\n+        if (childIndex_ + 1 >= node_->getChildCount()) {\n+          // if the current node has no more children, try to backtrack and\n+          // visit its successor\n+          if (backtrack_.empty()) {\n+            // if there are no nodes to backtrack to, the last node has been\n+            // visited\n+            node_ = nullptr;\n+            childIndex_ = -1;\n+          } else {\n+            // pop and restore the latest backtrack entry\n+            const auto back = backtrack_.back();\n+            backtrack_.pop_back();\n+            node_ = back.first;\n+            childIndex_ = back.second;\n+\n+            // go to the next node\n+            next();\n+          }\n+        } else {\n+          // current node has more children to visit, go to next\n+          ++childIndex_;\n+          // skip all display: contents nodes, possibly going deeper into the\n+          // tree\n+          skipContentsNodes();\n+        }\n+      }\n+\n+      void skipContentsNodes() {\n+        // get the node that would be returned from the iterator\n+        auto currentNode = node_->getChild(childIndex_);\n+        while (currentNode->style().display() == Display::Contents &&\n+               currentNode->getChildCount() > 0) {\n+          // if it has display: contents set, it shouldn't be returned but its\n+          // children should in its place push the current node and child index\n+          // so that the current state can be restored when backtracking\n+          backtrack_.push_back({node_, childIndex_});\n+          // traverse the child\n+          node_ = currentNode;\n+          childIndex_ = 0;\n+\n+          // repeat until a node without display: contents is found in the\n+          // subtree or a leaf is reached\n+          currentNode = currentNode->getChild(childIndex_);\n+        }\n+\n+        // if no node without display: contents was found, try to backtrack\n+        if (currentNode->style().display() == Display::Contents) {\n+          next();\n+        }\n+      }\n+\n+      const Node* node_;\n+      size_t childIndex_;\n+      size_t currentNodeIndex_{0};\n+      Backtrack backtrack_;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "1799840285",
        "repo_full_name": "facebook/yoga",
        "pr_number": 1726,
        "pr_file": "yoga/node/Node.h",
        "discussion_id": "1799840285",
        "commented_code": "@@ -31,6 +31,128 @@ namespace facebook::yoga {\n \n class YG_EXPORT Node : public ::YGNode {\n  public:\n+  class LayoutableChildren {\n+   public:\n+    using Backtrack = std::vector<std::pair<const Node*, size_t>>;\n+    struct Iterator {\n+      using iterator_category = std::forward_iterator_tag;\n+\n+      Iterator(const Node* node, size_t childIndex)\n+          : node_(node), childIndex_(childIndex) {}\n+      Iterator(const Node* node, size_t childIndex, Backtrack&& backtrack)\n+          : node_(node),\n+            childIndex_(childIndex),\n+            backtrack_(std::move(backtrack)) {}\n+\n+      Node* operator*() const {\n+        return node_->getChild(childIndex_);\n+      }\n+\n+      Iterator& operator++() {\n+        next();\n+        currentNodeIndex_++;\n+        return *this;\n+      }\n+\n+      Iterator operator++(int) {\n+        Iterator tmp = *this;\n+        ++(*this);\n+        return tmp;\n+      }\n+\n+      size_t index() const {\n+        return currentNodeIndex_;\n+      }\n+\n+      friend bool operator==(const Iterator& a, const Iterator& b) {\n+        return a.node_ == b.node_ && a.childIndex_ == b.childIndex_;\n+      };\n+\n+      friend bool operator!=(const Iterator& a, const Iterator& b) {\n+        return a.node_ != b.node_ || a.childIndex_ != b.childIndex_;\n+      };\n+\n+     private:\n+      void next() {\n+        if (childIndex_ + 1 >= node_->getChildCount()) {\n+          // if the current node has no more children, try to backtrack and\n+          // visit its successor\n+          if (backtrack_.empty()) {\n+            // if there are no nodes to backtrack to, the last node has been\n+            // visited\n+            node_ = nullptr;\n+            childIndex_ = -1;\n+          } else {\n+            // pop and restore the latest backtrack entry\n+            const auto back = backtrack_.back();\n+            backtrack_.pop_back();\n+            node_ = back.first;\n+            childIndex_ = back.second;\n+\n+            // go to the next node\n+            next();\n+          }\n+        } else {\n+          // current node has more children to visit, go to next\n+          ++childIndex_;\n+          // skip all display: contents nodes, possibly going deeper into the\n+          // tree\n+          skipContentsNodes();\n+        }\n+      }\n+\n+      void skipContentsNodes() {\n+        // get the node that would be returned from the iterator\n+        auto currentNode = node_->getChild(childIndex_);\n+        while (currentNode->style().display() == Display::Contents &&\n+               currentNode->getChildCount() > 0) {\n+          // if it has display: contents set, it shouldn't be returned but its\n+          // children should in its place push the current node and child index\n+          // so that the current state can be restored when backtracking\n+          backtrack_.push_back({node_, childIndex_});\n+          // traverse the child\n+          node_ = currentNode;\n+          childIndex_ = 0;\n+\n+          // repeat until a node without display: contents is found in the\n+          // subtree or a leaf is reached\n+          currentNode = currentNode->getChild(childIndex_);\n+        }\n+\n+        // if no node without display: contents was found, try to backtrack\n+        if (currentNode->style().display() == Display::Contents) {\n+          next();\n+        }\n+      }\n+\n+      const Node* node_;\n+      size_t childIndex_;\n+      size_t currentNodeIndex_{0};\n+      Backtrack backtrack_;",
        "comment_created_at": "2024-10-14T17:03:57+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "Most of the time it will be an empty vector, so no heap allocation, but I wonder if this could refer to e.g. single parent iterator (and that iterator could point to parent), such that iteration only allocates memory on the stack.",
        "pr_file_module": null
      },
      {
        "comment_id": "1801137750",
        "repo_full_name": "facebook/yoga",
        "pr_number": 1726,
        "pr_file": "yoga/node/Node.h",
        "discussion_id": "1799840285",
        "commented_code": "@@ -31,6 +31,128 @@ namespace facebook::yoga {\n \n class YG_EXPORT Node : public ::YGNode {\n  public:\n+  class LayoutableChildren {\n+   public:\n+    using Backtrack = std::vector<std::pair<const Node*, size_t>>;\n+    struct Iterator {\n+      using iterator_category = std::forward_iterator_tag;\n+\n+      Iterator(const Node* node, size_t childIndex)\n+          : node_(node), childIndex_(childIndex) {}\n+      Iterator(const Node* node, size_t childIndex, Backtrack&& backtrack)\n+          : node_(node),\n+            childIndex_(childIndex),\n+            backtrack_(std::move(backtrack)) {}\n+\n+      Node* operator*() const {\n+        return node_->getChild(childIndex_);\n+      }\n+\n+      Iterator& operator++() {\n+        next();\n+        currentNodeIndex_++;\n+        return *this;\n+      }\n+\n+      Iterator operator++(int) {\n+        Iterator tmp = *this;\n+        ++(*this);\n+        return tmp;\n+      }\n+\n+      size_t index() const {\n+        return currentNodeIndex_;\n+      }\n+\n+      friend bool operator==(const Iterator& a, const Iterator& b) {\n+        return a.node_ == b.node_ && a.childIndex_ == b.childIndex_;\n+      };\n+\n+      friend bool operator!=(const Iterator& a, const Iterator& b) {\n+        return a.node_ != b.node_ || a.childIndex_ != b.childIndex_;\n+      };\n+\n+     private:\n+      void next() {\n+        if (childIndex_ + 1 >= node_->getChildCount()) {\n+          // if the current node has no more children, try to backtrack and\n+          // visit its successor\n+          if (backtrack_.empty()) {\n+            // if there are no nodes to backtrack to, the last node has been\n+            // visited\n+            node_ = nullptr;\n+            childIndex_ = -1;\n+          } else {\n+            // pop and restore the latest backtrack entry\n+            const auto back = backtrack_.back();\n+            backtrack_.pop_back();\n+            node_ = back.first;\n+            childIndex_ = back.second;\n+\n+            // go to the next node\n+            next();\n+          }\n+        } else {\n+          // current node has more children to visit, go to next\n+          ++childIndex_;\n+          // skip all display: contents nodes, possibly going deeper into the\n+          // tree\n+          skipContentsNodes();\n+        }\n+      }\n+\n+      void skipContentsNodes() {\n+        // get the node that would be returned from the iterator\n+        auto currentNode = node_->getChild(childIndex_);\n+        while (currentNode->style().display() == Display::Contents &&\n+               currentNode->getChildCount() > 0) {\n+          // if it has display: contents set, it shouldn't be returned but its\n+          // children should in its place push the current node and child index\n+          // so that the current state can be restored when backtracking\n+          backtrack_.push_back({node_, childIndex_});\n+          // traverse the child\n+          node_ = currentNode;\n+          childIndex_ = 0;\n+\n+          // repeat until a node without display: contents is found in the\n+          // subtree or a leaf is reached\n+          currentNode = currentNode->getChild(childIndex_);\n+        }\n+\n+        // if no node without display: contents was found, try to backtrack\n+        if (currentNode->style().display() == Display::Contents) {\n+          next();\n+        }\n+      }\n+\n+      const Node* node_;\n+      size_t childIndex_;\n+      size_t currentNodeIndex_{0};\n+      Backtrack backtrack_;",
        "comment_created_at": "2024-10-15T13:09:21+00:00",
        "comment_author": "j-piasecki",
        "comment_body": "I don't think this is easily achievable. I see two main problems with it:\r\n- incrementing the iterator would have to return a new instance with a pointer to the previous one when going deeper into the tree, we would need to prolong the lifetime of the previous iterator somehow, so that it's valid when actually backtracking.\r\n- modifying the \"parent\" iterator would possibly break backtracking logic. To prevent that, each iterator would need to keep a deep copy of all ancestors.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1315962960",
    "pr_number": 1359,
    "pr_file": "yoga/node/LayoutResults.h",
    "created_at": "2023-09-05T14:12:33+00:00",
    "commented_code": "CachedMeasurement cachedLayout{};\n \n   YGDirection direction() const {\n-    return getEnumData<YGDirection>(flags, directionOffset);\n+    return static_cast<YGDirection>(flags_.direction);\n   }\n \n   void setDirection(YGDirection direction) {\n-    setEnumData<YGDirection>(flags, directionOffset, direction);\n+    flags_.direction = static_cast<uint8_t>(direction);",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "1315962960",
        "repo_full_name": "facebook/yoga",
        "pr_number": 1359,
        "pr_file": "yoga/node/LayoutResults.h",
        "discussion_id": "1315962960",
        "commented_code": "@@ -48,17 +53,15 @@ struct LayoutResults {\n   CachedMeasurement cachedLayout{};\n \n   YGDirection direction() const {\n-    return getEnumData<YGDirection>(flags, directionOffset);\n+    return static_cast<YGDirection>(flags_.direction);\n   }\n \n   void setDirection(YGDirection direction) {\n-    setEnumData<YGDirection>(flags, directionOffset, direction);\n+    flags_.direction = static_cast<uint8_t>(direction);",
        "comment_created_at": "2023-09-05T14:12:33+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "```suggestion\r\n    flags_.direction = static_cast<uint8_t>(direction) & 0x03;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "251565064",
    "pr_number": 852,
    "pr_file": "yoga/YGLayout.h",
    "created_at": "2019-01-28T19:43:15+00:00",
    "commented_code": "bool doesLegacyStretchFlagAffectsLayout : 1;\n   bool hadOverflow : 1;\n \n-  uint32_t computedFlexBasisGeneration = 0;\n+  uint8_t computedFlexBasisGeneration = 0;",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "251565064",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/YGLayout.h",
        "discussion_id": "251565064",
        "commented_code": "@@ -22,12 +22,12 @@ struct YGLayout {\n   bool doesLegacyStretchFlagAffectsLayout : 1;\n   bool hadOverflow : 1;\n \n-  uint32_t computedFlexBasisGeneration = 0;\n+  uint8_t computedFlexBasisGeneration = 0;",
        "comment_created_at": "2019-01-28T19:43:15+00:00",
        "comment_author": "davidaurelio",
        "comment_body": "What was the motivation for this change? Due to alignment requirements, this won\u2019t even save memory without reordering data members.",
        "pr_file_module": null
      },
      {
        "comment_id": "252094073",
        "repo_full_name": "facebook/yoga",
        "pr_number": 852,
        "pr_file": "yoga/YGLayout.h",
        "discussion_id": "251565064",
        "commented_code": "@@ -22,12 +22,12 @@ struct YGLayout {\n   bool doesLegacyStretchFlagAffectsLayout : 1;\n   bool hadOverflow : 1;\n \n-  uint32_t computedFlexBasisGeneration = 0;\n+  uint8_t computedFlexBasisGeneration = 0;",
        "comment_created_at": "2019-01-30T02:11:49+00:00",
        "comment_author": "jpap",
        "comment_body": "The motivation is to save heap: there are many bits left over from alignment of the bitfields above it, so you could combine `computedFlexBasisGeneration` with it.  I suspect you can get away with just one bit, so long as the generation counter is the same width (or is truncated with a logical AND mask when the generation is incremented).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "65584380",
    "pr_number": 193,
    "pr_file": "dist/css-layout.h",
    "created_at": "2016-06-02T17:37:32+00:00",
    "commented_code": "}\n         }\n \n+        // If child has no defined size in the cross axis and is set to stretch, set the cross\n+        // axis to be measured exactly with the available inner width\n+        if (!isMainAxisRow && !isUndefined(availableInnerWidth) && !isStyleDimDefined(child, CSS_FLEX_DIRECTION_ROW) && widthMeasureMode == CSS_MEASURE_MODE_EXACTLY && getAlignItem(node, child) == CSS_ALIGN_STRETCH) {",
    "repo_full_name": "facebook/yoga",
    "discussion_comments": [
      {
        "comment_id": "65584380",
        "repo_full_name": "facebook/yoga",
        "pr_number": 193,
        "pr_file": "dist/css-layout.h",
        "discussion_id": "65584380",
        "commented_code": "@@ -1064,31 +1064,42 @@ static void layoutNodeImpl(css_node_t* node, float availableWidth, float availab\n           }\n         }\n \n+        // If child has no defined size in the cross axis and is set to stretch, set the cross\n+        // axis to be measured exactly with the available inner width\n+        if (!isMainAxisRow && !isUndefined(availableInnerWidth) && !isStyleDimDefined(child, CSS_FLEX_DIRECTION_ROW) && widthMeasureMode == CSS_MEASURE_MODE_EXACTLY && getAlignItem(node, child) == CSS_ALIGN_STRETCH) {",
        "comment_created_at": "2016-06-02T17:37:32+00:00",
        "comment_author": "emilsjolander",
        "comment_body": "It is not just for perf though. It is also more correct to measure children with EXACTLY as that is what and alignment of stretch enforces.\n",
        "pr_file_module": null
      }
    ]
  }
]