[
  {
    "discussion_id": "2182036629",
    "pr_number": 29145,
    "pr_file": "crates/askpass/src/askpass.rs",
    "created_at": "2025-07-03T07:14:17+00:00",
    "commented_code": "exit(1);\n     }\n }\n+\n #[cfg(not(unix))]\n-pub fn main(_socket: &str) {}\n+pub fn main(socket: &str) {\n+    use std::io::{self, Read, Write};\n+    use std::process::exit;\n+\n+    use windows_net::UnixStream;\n+\n+    let mut stream = match UnixStream::connect(socket) {\n+        Ok(stream) => stream,\n+        Err(err) => {\n+            eprintln!(\"Error connecting to socket {}: {}\", socket, err);\n+            exit(1);\n+        }\n+    };\n+\n+    let mut buffer = Vec::new();\n+    if let Err(err) = io::stdin().read_to_end(&mut buffer) {\n+        eprintln!(\"Error reading from stdin: {}\", err);\n+        exit(1);\n+    }\n+\n+    while buffer.last().map_or(false, |&b| b == b'\n' || b == b'\\r') {\n+        buffer.pop();\n+    }\n+    if buffer.last() != Some(&b'\\0') {\n+        buffer.push(b'\\0');\n+    }\n+\n+    if let Err(err) = stream.write_all(&buffer) {\n+        eprintln!(\"Error writing to socket: {}\", err);\n+        exit(1);\n+    }\n+\n+    let mut response = Vec::new();\n+    if let Err(err) = stream.read_to_end(&mut response) {\n+        eprintln!(\"Error reading from socket: {}\", err);\n+        exit(1);\n+    }\n+\n+    if let Err(err) = io::stdout().write_all(&response) {\n+        eprintln!(\"Error writing to stdout: {}\", err);\n+        exit(1);\n+    }\n+}\n \n #[cfg(not(unix))]\n pub struct AskPassSession {\n-    path: PathBuf,\n+    askpass_helper: String,\n+    _askpass_task: Task<()>,\n+    secrete: std::sync::Arc<std::sync::Mutex<String>>,\n+    askpass_opened_rx: Option<oneshot::Receiver<()>>,\n+    askpass_kill_master_rx: Option<oneshot::Receiver<()>>,\n }\n \n #[cfg(not(unix))]\n impl AskPassSession {\n-    pub async fn new(_: &BackgroundExecutor, _: AskPassDelegate) -> anyhow::Result<Self> {\n+    #[must_use]\n+    pub async fn new(\n+        executor: &BackgroundExecutor,\n+        mut delegate: AskPassDelegate,\n+    ) -> anyhow::Result<Self> {\n+        use windows_net::async_net::UnixListener;\n+\n+        let secrete = std::sync::Arc::new(std::sync::Mutex::new(String::new()));\n+        let temp_dir = tempfile::Builder::new().prefix(\"zed-askpass\").tempdir()?;\n+        let askpass_socket = temp_dir.path().join(\"askpass.sock\");\n+        let askpass_script_path = temp_dir.path().join(\"askpass.ps1\");\n+        let (askpass_opened_tx, askpass_opened_rx) = oneshot::channel::<()>();\n+        let listener =\n+            UnixListener::bind(&askpass_socket).context(\"failed to create askpass socket\")?;\n+        let zed_path = std::env::current_exe()\n+            .context(\"Failed to figure out current executable path for use in askpass\")?;\n+\n+        let (askpass_kill_master_tx, askpass_kill_master_rx) = oneshot::channel::<()>();\n+        let mut kill_tx = Some(askpass_kill_master_tx);\n+\n+        let askpass_task = executor.spawn({\n+            let secrete = secrete.clone();\n+            async move {\n+                let mut askpass_opened_tx = Some(askpass_opened_tx);\n+\n+                while let Ok(mut stream) = listener.accept().await {\n+                    if let Some(askpass_opened_tx) = askpass_opened_tx.take() {\n+                        askpass_opened_tx.send(()).ok();\n+                    }\n+                    let mut buffer = Vec::new();\n+                    let mut reader = BufReader::new(&mut stream);\n+                    if reader.read_until(b'\\0', &mut buffer).await.is_err() {\n+                        buffer.clear();\n+                    }\n+                    let prompt = String::from_utf8_lossy(&buffer);\n+                    if let Some(password) = delegate\n+                        .ask_password(prompt.to_string())\n+                        .await\n+                        .context(\"failed to get askpass password\")\n+                        .log_err()\n+                    {\n+                        stream.write_all(password.as_bytes()).await.log_err();\n+                        *secrete.lock().unwrap() = password;\n+                    } else {\n+                        if let Some(kill_tx) = kill_tx.take() {\n+                            kill_tx.send(()).log_err();\n+                        }\n+                        // note: we expect the caller to drop this task when it's done.\n+                        // We need to keep the stream open until the caller is done to avoid\n+                        // spurious errors from ssh.\n+                        std::future::pending::<()>().await;\n+                        drop(stream);\n+                    }\n+                }\n+                drop(temp_dir)\n+            }\n+        });\n+\n+        // Create an askpass script that communicates back to this process.\n+        let askpass_script = format!(\n+            r#\"\n+            $ErrorActionPreference = 'Stop';\n+            ($args -join [char]0) | & \"{zed_exe}\" --askpass={askpass_socket} 2> $null\n+            \"#,\n+            zed_exe = zed_path.display(),\n+            askpass_socket = askpass_socket.display(),\n+        );\n+        fs::write(&askpass_script_path, askpass_script).await?;",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2182036629",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29145,
        "pr_file": "crates/askpass/src/askpass.rs",
        "discussion_id": "2182036629",
        "commented_code": "@@ -202,28 +198,177 @@ pub fn main(socket: &str) {\n         exit(1);\n     }\n }\n+\n #[cfg(not(unix))]\n-pub fn main(_socket: &str) {}\n+pub fn main(socket: &str) {\n+    use std::io::{self, Read, Write};\n+    use std::process::exit;\n+\n+    use windows_net::UnixStream;\n+\n+    let mut stream = match UnixStream::connect(socket) {\n+        Ok(stream) => stream,\n+        Err(err) => {\n+            eprintln!(\"Error connecting to socket {}: {}\", socket, err);\n+            exit(1);\n+        }\n+    };\n+\n+    let mut buffer = Vec::new();\n+    if let Err(err) = io::stdin().read_to_end(&mut buffer) {\n+        eprintln!(\"Error reading from stdin: {}\", err);\n+        exit(1);\n+    }\n+\n+    while buffer.last().map_or(false, |&b| b == b'\\n' || b == b'\\r') {\n+        buffer.pop();\n+    }\n+    if buffer.last() != Some(&b'\\0') {\n+        buffer.push(b'\\0');\n+    }\n+\n+    if let Err(err) = stream.write_all(&buffer) {\n+        eprintln!(\"Error writing to socket: {}\", err);\n+        exit(1);\n+    }\n+\n+    let mut response = Vec::new();\n+    if let Err(err) = stream.read_to_end(&mut response) {\n+        eprintln!(\"Error reading from socket: {}\", err);\n+        exit(1);\n+    }\n+\n+    if let Err(err) = io::stdout().write_all(&response) {\n+        eprintln!(\"Error writing to stdout: {}\", err);\n+        exit(1);\n+    }\n+}\n \n #[cfg(not(unix))]\n pub struct AskPassSession {\n-    path: PathBuf,\n+    askpass_helper: String,\n+    _askpass_task: Task<()>,\n+    secrete: std::sync::Arc<std::sync::Mutex<String>>,\n+    askpass_opened_rx: Option<oneshot::Receiver<()>>,\n+    askpass_kill_master_rx: Option<oneshot::Receiver<()>>,\n }\n \n #[cfg(not(unix))]\n impl AskPassSession {\n-    pub async fn new(_: &BackgroundExecutor, _: AskPassDelegate) -> anyhow::Result<Self> {\n+    #[must_use]\n+    pub async fn new(\n+        executor: &BackgroundExecutor,\n+        mut delegate: AskPassDelegate,\n+    ) -> anyhow::Result<Self> {\n+        use windows_net::async_net::UnixListener;\n+\n+        let secrete = std::sync::Arc::new(std::sync::Mutex::new(String::new()));\n+        let temp_dir = tempfile::Builder::new().prefix(\"zed-askpass\").tempdir()?;\n+        let askpass_socket = temp_dir.path().join(\"askpass.sock\");\n+        let askpass_script_path = temp_dir.path().join(\"askpass.ps1\");\n+        let (askpass_opened_tx, askpass_opened_rx) = oneshot::channel::<()>();\n+        let listener =\n+            UnixListener::bind(&askpass_socket).context(\"failed to create askpass socket\")?;\n+        let zed_path = std::env::current_exe()\n+            .context(\"Failed to figure out current executable path for use in askpass\")?;\n+\n+        let (askpass_kill_master_tx, askpass_kill_master_rx) = oneshot::channel::<()>();\n+        let mut kill_tx = Some(askpass_kill_master_tx);\n+\n+        let askpass_task = executor.spawn({\n+            let secrete = secrete.clone();\n+            async move {\n+                let mut askpass_opened_tx = Some(askpass_opened_tx);\n+\n+                while let Ok(mut stream) = listener.accept().await {\n+                    if let Some(askpass_opened_tx) = askpass_opened_tx.take() {\n+                        askpass_opened_tx.send(()).ok();\n+                    }\n+                    let mut buffer = Vec::new();\n+                    let mut reader = BufReader::new(&mut stream);\n+                    if reader.read_until(b'\\0', &mut buffer).await.is_err() {\n+                        buffer.clear();\n+                    }\n+                    let prompt = String::from_utf8_lossy(&buffer);\n+                    if let Some(password) = delegate\n+                        .ask_password(prompt.to_string())\n+                        .await\n+                        .context(\"failed to get askpass password\")\n+                        .log_err()\n+                    {\n+                        stream.write_all(password.as_bytes()).await.log_err();\n+                        *secrete.lock().unwrap() = password;\n+                    } else {\n+                        if let Some(kill_tx) = kill_tx.take() {\n+                            kill_tx.send(()).log_err();\n+                        }\n+                        // note: we expect the caller to drop this task when it's done.\n+                        // We need to keep the stream open until the caller is done to avoid\n+                        // spurious errors from ssh.\n+                        std::future::pending::<()>().await;\n+                        drop(stream);\n+                    }\n+                }\n+                drop(temp_dir)\n+            }\n+        });\n+\n+        // Create an askpass script that communicates back to this process.\n+        let askpass_script = format!(\n+            r#\"\n+            $ErrorActionPreference = 'Stop';\n+            ($args -join [char]0) | & \"{zed_exe}\" --askpass={askpass_socket} 2> $null\n+            \"#,\n+            zed_exe = zed_path.display(),\n+            askpass_socket = askpass_socket.display(),\n+        );\n+        fs::write(&askpass_script_path, askpass_script).await?;",
        "comment_created_at": "2025-07-03T07:14:17+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "```suggestion\n        fs::write(&askpass_script_path, askpass_script).await.with_context(|| format!(\"Creating askpass script at {askpass_script_path:?}\"))?;\n```\n\nNot sure about `smol`, but stdlib's FS errors are notorious to not include a flie path.\n\nE.g. if script's parent directory is not created in an analogous method, the error returned would be smth. like `Err(\"not a directory\")`.\nTo be on a safe side, seems worth to add some context.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1922418415",
    "pr_number": 19230,
    "pr_file": "crates/project/src/lsp_command.rs",
    "created_at": "2025-01-20T13:37:50+00:00",
    "commented_code": "BufferId::new(message.buffer_id)\n     }\n }\n+\n+impl GetDocumentDiagnostics {\n+    pub fn deserialize_lsp_diagnostic(diagnostic: proto::LspDiagnostic) -> Result<lsp::Diagnostic> {\n+        let start = diagnostic\n+            .start\n+            .ok_or_else(|| anyhow!(\"invalid start range\"))?;\n+        let end = diagnostic.end.ok_or_else(|| anyhow!(\"invalid end range\"))?;\n+\n+        let range = Range::<PointUtf16> {\n+            start: PointUtf16 {\n+                row: start.row,\n+                column: start.column,\n+            },\n+            end: PointUtf16 {\n+                row: end.row,\n+                column: end.column,\n+            },\n+        };\n+\n+        let data = diagnostic.data.and_then(|data| Value::from_str(&data).ok());\n+        let code = diagnostic.code.map(lsp::NumberOrString::String);\n+\n+        let related_information = diagnostic\n+            .related_information\n+            .into_iter()\n+            .map(|info| {\n+                let start = info.location_range_start.unwrap();\n+                let end = info.location_range_end.unwrap();\n+\n+                lsp::DiagnosticRelatedInformation {\n+                    location: lsp::Location {\n+                        range: lsp::Range {\n+                            start: point_to_lsp(PointUtf16::new(start.row, start.column)),\n+                            end: point_to_lsp(PointUtf16::new(end.row, end.column)),\n+                        },\n+                        uri: lsp::Url::parse(&info.location_url.unwrap()).unwrap(),\n+                    },\n+                    message: info.message.clone(),\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        Ok(lsp::Diagnostic {\n+            range: language::range_to_lsp(range)?,\n+            severity: match proto::lsp_diagnostic::Severity::from_i32(diagnostic.severity).unwrap()\n+            {\n+                proto::lsp_diagnostic::Severity::Error => Some(lsp::DiagnosticSeverity::ERROR),\n+                proto::lsp_diagnostic::Severity::Warning => Some(lsp::DiagnosticSeverity::WARNING),\n+                proto::lsp_diagnostic::Severity::Information => {\n+                    Some(lsp::DiagnosticSeverity::INFORMATION)\n+                }\n+                proto::lsp_diagnostic::Severity::Hint => Some(lsp::DiagnosticSeverity::HINT),\n+                _ => None,\n+            },\n+            code,\n+            code_description: match diagnostic.code_description {\n+                Some(code_description) => Some(CodeDescription {\n+                    href: lsp::Url::parse(&code_description).unwrap(),\n+                }),\n+                None => None,\n+            },\n+            related_information: Some(related_information),\n+            tags: Some(vec![]),\n+            source: diagnostic.source.clone(),\n+            message: diagnostic.message,\n+            data,\n+        })\n+    }\n+\n+    pub fn serialize_lsp_diagnostic(diagnostic: lsp::Diagnostic) -> Result<proto::LspDiagnostic> {\n+        let range = language::range_from_lsp(diagnostic.range);\n+        let related_information = diagnostic\n+            .related_information\n+            .unwrap_or_default()\n+            .into_iter()\n+            .map(|related_information| {\n+                let location_range_start =\n+                    point_from_lsp(related_information.location.range.start).0;\n+                let location_range_end = point_from_lsp(related_information.location.range.end).0;\n+\n+                Ok(proto::LspDiagnosticRelatedInformation {\n+                    location_url: Some(related_information.location.uri.to_string()),\n+                    location_range_start: Some(proto::PointUtf16 {\n+                        row: location_range_start.row,\n+                        column: location_range_start.column,\n+                    }),\n+                    location_range_end: Some(proto::PointUtf16 {\n+                        row: location_range_end.row,\n+                        column: location_range_end.column,\n+                    }),\n+                    message: related_information.message,\n+                })\n+            })\n+            .collect::<Result<Vec<_>>>()?;\n+\n+        let tags = diagnostic\n+            .tags\n+            .map(|tags| {\n+                tags.into_iter()\n+                    .map(|tag| match tag {\n+                        lsp::DiagnosticTag::UNNECESSARY => proto::LspDiagnosticTag::Unnecessary,\n+                        lsp::DiagnosticTag::DEPRECATED => proto::LspDiagnosticTag::Deprecated,\n+                        _ => proto::LspDiagnosticTag::None,\n+                    } as i32)\n+                    .collect()\n+            })\n+            .unwrap_or_default();\n+\n+        Ok(proto::LspDiagnostic {\n+            start: Some(proto::PointUtf16 {\n+                row: range.start.0.row,\n+                column: range.start.0.column,\n+            }),\n+            end: Some(proto::PointUtf16 {\n+                row: range.end.0.row,\n+                column: range.end.0.column,\n+            }),\n+            severity: match diagnostic.severity {\n+                Some(lsp::DiagnosticSeverity::ERROR) => proto::lsp_diagnostic::Severity::Error,\n+                Some(lsp::DiagnosticSeverity::WARNING) => proto::lsp_diagnostic::Severity::Warning,\n+                Some(lsp::DiagnosticSeverity::INFORMATION) => {\n+                    proto::lsp_diagnostic::Severity::Information\n+                }\n+                Some(lsp::DiagnosticSeverity::HINT) => proto::lsp_diagnostic::Severity::Hint,\n+                _ => proto::lsp_diagnostic::Severity::None,\n+            } as i32,\n+            code: diagnostic.code.as_ref().map(|code| match code {\n+                lsp::NumberOrString::Number(code) => code.to_string(),\n+                lsp::NumberOrString::String(code) => code.clone(),\n+            }),\n+            source: diagnostic.source.clone(),\n+            related_information,\n+            tags,\n+            code_description: diagnostic\n+                .code_description\n+                .map(|desc| desc.href.to_string()),\n+            message: diagnostic.message,\n+            data: diagnostic.data.as_ref().map(|data| data.to_string()),\n+        })\n+    }\n+}\n+\n+#[async_trait(?Send)]\n+impl LspCommand for GetDocumentDiagnostics {\n+    type Response = Option<LspDiagnostics>;\n+    type LspRequest = lsp::request::DocumentDiagnosticRequest;\n+    type ProtoRequest = proto::GetDocumentDiagnostics;\n+\n+    fn display_name(&self) -> &str {\n+        \"Get diagnostics\"\n+    }\n+\n+    fn check_capabilities(&self, server_capabilities: AdapterServerCapabilities) -> bool {\n+        server_capabilities\n+            .server_capabilities\n+            .diagnostic_provider\n+            .is_some()\n+    }\n+\n+    fn to_lsp(\n+        &self,\n+        path: &Path,\n+        _: &Buffer,\n+        language_server: &Arc<LanguageServer>,\n+        _: &AppContext,\n+    ) -> Result<lsp::DocumentDiagnosticParams> {\n+        let identifier = match language_server.capabilities().diagnostic_provider {\n+            Some(lsp::DiagnosticServerCapabilities::Options(options)) => options.identifier.clone(),\n+            Some(lsp::DiagnosticServerCapabilities::RegistrationOptions(options)) => {\n+                options.diagnostic_options.identifier.clone()\n+            }\n+            None => None,\n+        };\n+\n+        Ok(lsp::DocumentDiagnosticParams {\n+            text_document: lsp::TextDocumentIdentifier {\n+                uri: lsp::Url::from_file_path(path).unwrap(),\n+            },\n+            identifier,\n+            previous_result_id: None,\n+            partial_result_params: Default::default(),\n+            work_done_progress_params: Default::default(),\n+        })\n+    }\n+\n+    async fn response_from_lsp(\n+        self,\n+        message: lsp::DocumentDiagnosticReportResult,\n+        lsp_store: Model<LspStore>,\n+        buffer: Model<Buffer>,\n+        server_id: LanguageServerId,\n+        mut cx: AsyncAppContext,\n+    ) -> Result<Self::Response> {\n+        let uri = buffer.read_with(&cx, |buffer, cx| {\n+            buffer\n+                .file()\n+                .and_then(|file| file.as_local())\n+                .map(|file| lsp::Url::from_file_path(file.abs_path(cx).clone()).unwrap())\n+        })?;\n+\n+        let Some(uri) = uri else {\n+            return Ok(None);\n+        };\n+\n+        match message {\n+            lsp::DocumentDiagnosticReportResult::Report(report) => match report {\n+                lsp::DocumentDiagnosticReport::Full(report) => {\n+                    lsp_store.update(&mut cx, |store, cx| {\n+                        for (uri, report) in report.related_documents.into_iter().flatten() {\n+                            match report {\n+                                lsp::DocumentDiagnosticReportKind::Full(report) => {\n+                                    store.update_diagnostics(\n+                                        server_id,\n+                                        lsp::PublishDiagnosticsParams {\n+                                            diagnostics: report.items.clone(),\n+                                            uri,\n+                                            version: None,\n+                                        },\n+                                        &[],\n+                                        cx,\n+                                    ).expect(\"Failed to update diagnostics for the related document\");\n+                                }\n+                                lsp::DocumentDiagnosticReportKind::Unchanged(_) => (),\n+                            }\n+                        }\n+                    }).expect(\"Failed to update diagnostics for related documents\");",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1922418415",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 19230,
        "pr_file": "crates/project/src/lsp_command.rs",
        "discussion_id": "1922418415",
        "commented_code": "@@ -3178,3 +3183,477 @@ impl LspCommand for LinkedEditingRange {\n         BufferId::new(message.buffer_id)\n     }\n }\n+\n+impl GetDocumentDiagnostics {\n+    pub fn deserialize_lsp_diagnostic(diagnostic: proto::LspDiagnostic) -> Result<lsp::Diagnostic> {\n+        let start = diagnostic\n+            .start\n+            .ok_or_else(|| anyhow!(\"invalid start range\"))?;\n+        let end = diagnostic.end.ok_or_else(|| anyhow!(\"invalid end range\"))?;\n+\n+        let range = Range::<PointUtf16> {\n+            start: PointUtf16 {\n+                row: start.row,\n+                column: start.column,\n+            },\n+            end: PointUtf16 {\n+                row: end.row,\n+                column: end.column,\n+            },\n+        };\n+\n+        let data = diagnostic.data.and_then(|data| Value::from_str(&data).ok());\n+        let code = diagnostic.code.map(lsp::NumberOrString::String);\n+\n+        let related_information = diagnostic\n+            .related_information\n+            .into_iter()\n+            .map(|info| {\n+                let start = info.location_range_start.unwrap();\n+                let end = info.location_range_end.unwrap();\n+\n+                lsp::DiagnosticRelatedInformation {\n+                    location: lsp::Location {\n+                        range: lsp::Range {\n+                            start: point_to_lsp(PointUtf16::new(start.row, start.column)),\n+                            end: point_to_lsp(PointUtf16::new(end.row, end.column)),\n+                        },\n+                        uri: lsp::Url::parse(&info.location_url.unwrap()).unwrap(),\n+                    },\n+                    message: info.message.clone(),\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        Ok(lsp::Diagnostic {\n+            range: language::range_to_lsp(range)?,\n+            severity: match proto::lsp_diagnostic::Severity::from_i32(diagnostic.severity).unwrap()\n+            {\n+                proto::lsp_diagnostic::Severity::Error => Some(lsp::DiagnosticSeverity::ERROR),\n+                proto::lsp_diagnostic::Severity::Warning => Some(lsp::DiagnosticSeverity::WARNING),\n+                proto::lsp_diagnostic::Severity::Information => {\n+                    Some(lsp::DiagnosticSeverity::INFORMATION)\n+                }\n+                proto::lsp_diagnostic::Severity::Hint => Some(lsp::DiagnosticSeverity::HINT),\n+                _ => None,\n+            },\n+            code,\n+            code_description: match diagnostic.code_description {\n+                Some(code_description) => Some(CodeDescription {\n+                    href: lsp::Url::parse(&code_description).unwrap(),\n+                }),\n+                None => None,\n+            },\n+            related_information: Some(related_information),\n+            tags: Some(vec![]),\n+            source: diagnostic.source.clone(),\n+            message: diagnostic.message,\n+            data,\n+        })\n+    }\n+\n+    pub fn serialize_lsp_diagnostic(diagnostic: lsp::Diagnostic) -> Result<proto::LspDiagnostic> {\n+        let range = language::range_from_lsp(diagnostic.range);\n+        let related_information = diagnostic\n+            .related_information\n+            .unwrap_or_default()\n+            .into_iter()\n+            .map(|related_information| {\n+                let location_range_start =\n+                    point_from_lsp(related_information.location.range.start).0;\n+                let location_range_end = point_from_lsp(related_information.location.range.end).0;\n+\n+                Ok(proto::LspDiagnosticRelatedInformation {\n+                    location_url: Some(related_information.location.uri.to_string()),\n+                    location_range_start: Some(proto::PointUtf16 {\n+                        row: location_range_start.row,\n+                        column: location_range_start.column,\n+                    }),\n+                    location_range_end: Some(proto::PointUtf16 {\n+                        row: location_range_end.row,\n+                        column: location_range_end.column,\n+                    }),\n+                    message: related_information.message,\n+                })\n+            })\n+            .collect::<Result<Vec<_>>>()?;\n+\n+        let tags = diagnostic\n+            .tags\n+            .map(|tags| {\n+                tags.into_iter()\n+                    .map(|tag| match tag {\n+                        lsp::DiagnosticTag::UNNECESSARY => proto::LspDiagnosticTag::Unnecessary,\n+                        lsp::DiagnosticTag::DEPRECATED => proto::LspDiagnosticTag::Deprecated,\n+                        _ => proto::LspDiagnosticTag::None,\n+                    } as i32)\n+                    .collect()\n+            })\n+            .unwrap_or_default();\n+\n+        Ok(proto::LspDiagnostic {\n+            start: Some(proto::PointUtf16 {\n+                row: range.start.0.row,\n+                column: range.start.0.column,\n+            }),\n+            end: Some(proto::PointUtf16 {\n+                row: range.end.0.row,\n+                column: range.end.0.column,\n+            }),\n+            severity: match diagnostic.severity {\n+                Some(lsp::DiagnosticSeverity::ERROR) => proto::lsp_diagnostic::Severity::Error,\n+                Some(lsp::DiagnosticSeverity::WARNING) => proto::lsp_diagnostic::Severity::Warning,\n+                Some(lsp::DiagnosticSeverity::INFORMATION) => {\n+                    proto::lsp_diagnostic::Severity::Information\n+                }\n+                Some(lsp::DiagnosticSeverity::HINT) => proto::lsp_diagnostic::Severity::Hint,\n+                _ => proto::lsp_diagnostic::Severity::None,\n+            } as i32,\n+            code: diagnostic.code.as_ref().map(|code| match code {\n+                lsp::NumberOrString::Number(code) => code.to_string(),\n+                lsp::NumberOrString::String(code) => code.clone(),\n+            }),\n+            source: diagnostic.source.clone(),\n+            related_information,\n+            tags,\n+            code_description: diagnostic\n+                .code_description\n+                .map(|desc| desc.href.to_string()),\n+            message: diagnostic.message,\n+            data: diagnostic.data.as_ref().map(|data| data.to_string()),\n+        })\n+    }\n+}\n+\n+#[async_trait(?Send)]\n+impl LspCommand for GetDocumentDiagnostics {\n+    type Response = Option<LspDiagnostics>;\n+    type LspRequest = lsp::request::DocumentDiagnosticRequest;\n+    type ProtoRequest = proto::GetDocumentDiagnostics;\n+\n+    fn display_name(&self) -> &str {\n+        \"Get diagnostics\"\n+    }\n+\n+    fn check_capabilities(&self, server_capabilities: AdapterServerCapabilities) -> bool {\n+        server_capabilities\n+            .server_capabilities\n+            .diagnostic_provider\n+            .is_some()\n+    }\n+\n+    fn to_lsp(\n+        &self,\n+        path: &Path,\n+        _: &Buffer,\n+        language_server: &Arc<LanguageServer>,\n+        _: &AppContext,\n+    ) -> Result<lsp::DocumentDiagnosticParams> {\n+        let identifier = match language_server.capabilities().diagnostic_provider {\n+            Some(lsp::DiagnosticServerCapabilities::Options(options)) => options.identifier.clone(),\n+            Some(lsp::DiagnosticServerCapabilities::RegistrationOptions(options)) => {\n+                options.diagnostic_options.identifier.clone()\n+            }\n+            None => None,\n+        };\n+\n+        Ok(lsp::DocumentDiagnosticParams {\n+            text_document: lsp::TextDocumentIdentifier {\n+                uri: lsp::Url::from_file_path(path).unwrap(),\n+            },\n+            identifier,\n+            previous_result_id: None,\n+            partial_result_params: Default::default(),\n+            work_done_progress_params: Default::default(),\n+        })\n+    }\n+\n+    async fn response_from_lsp(\n+        self,\n+        message: lsp::DocumentDiagnosticReportResult,\n+        lsp_store: Model<LspStore>,\n+        buffer: Model<Buffer>,\n+        server_id: LanguageServerId,\n+        mut cx: AsyncAppContext,\n+    ) -> Result<Self::Response> {\n+        let uri = buffer.read_with(&cx, |buffer, cx| {\n+            buffer\n+                .file()\n+                .and_then(|file| file.as_local())\n+                .map(|file| lsp::Url::from_file_path(file.abs_path(cx).clone()).unwrap())\n+        })?;\n+\n+        let Some(uri) = uri else {\n+            return Ok(None);\n+        };\n+\n+        match message {\n+            lsp::DocumentDiagnosticReportResult::Report(report) => match report {\n+                lsp::DocumentDiagnosticReport::Full(report) => {\n+                    lsp_store.update(&mut cx, |store, cx| {\n+                        for (uri, report) in report.related_documents.into_iter().flatten() {\n+                            match report {\n+                                lsp::DocumentDiagnosticReportKind::Full(report) => {\n+                                    store.update_diagnostics(\n+                                        server_id,\n+                                        lsp::PublishDiagnosticsParams {\n+                                            diagnostics: report.items.clone(),\n+                                            uri,\n+                                            version: None,\n+                                        },\n+                                        &[],\n+                                        cx,\n+                                    ).expect(\"Failed to update diagnostics for the related document\");\n+                                }\n+                                lsp::DocumentDiagnosticReportKind::Unchanged(_) => (),\n+                            }\n+                        }\n+                    }).expect(\"Failed to update diagnostics for related documents\");",
        "comment_created_at": "2025-01-20T13:37:50+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "I'm concerned by the amount of new `.unwrap()`, `.expect(..)` in the new code, esp. given that this function returns `Result`.\r\nLet's not write the code that may panic here, as it's quite a core feature, queried frequently, and we're parsing things from a potentially malicious server.",
        "pr_file_module": null
      },
      {
        "comment_id": "1938348605",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 19230,
        "pr_file": "crates/project/src/lsp_command.rs",
        "discussion_id": "1922418415",
        "commented_code": "@@ -3178,3 +3183,477 @@ impl LspCommand for LinkedEditingRange {\n         BufferId::new(message.buffer_id)\n     }\n }\n+\n+impl GetDocumentDiagnostics {\n+    pub fn deserialize_lsp_diagnostic(diagnostic: proto::LspDiagnostic) -> Result<lsp::Diagnostic> {\n+        let start = diagnostic\n+            .start\n+            .ok_or_else(|| anyhow!(\"invalid start range\"))?;\n+        let end = diagnostic.end.ok_or_else(|| anyhow!(\"invalid end range\"))?;\n+\n+        let range = Range::<PointUtf16> {\n+            start: PointUtf16 {\n+                row: start.row,\n+                column: start.column,\n+            },\n+            end: PointUtf16 {\n+                row: end.row,\n+                column: end.column,\n+            },\n+        };\n+\n+        let data = diagnostic.data.and_then(|data| Value::from_str(&data).ok());\n+        let code = diagnostic.code.map(lsp::NumberOrString::String);\n+\n+        let related_information = diagnostic\n+            .related_information\n+            .into_iter()\n+            .map(|info| {\n+                let start = info.location_range_start.unwrap();\n+                let end = info.location_range_end.unwrap();\n+\n+                lsp::DiagnosticRelatedInformation {\n+                    location: lsp::Location {\n+                        range: lsp::Range {\n+                            start: point_to_lsp(PointUtf16::new(start.row, start.column)),\n+                            end: point_to_lsp(PointUtf16::new(end.row, end.column)),\n+                        },\n+                        uri: lsp::Url::parse(&info.location_url.unwrap()).unwrap(),\n+                    },\n+                    message: info.message.clone(),\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        Ok(lsp::Diagnostic {\n+            range: language::range_to_lsp(range)?,\n+            severity: match proto::lsp_diagnostic::Severity::from_i32(diagnostic.severity).unwrap()\n+            {\n+                proto::lsp_diagnostic::Severity::Error => Some(lsp::DiagnosticSeverity::ERROR),\n+                proto::lsp_diagnostic::Severity::Warning => Some(lsp::DiagnosticSeverity::WARNING),\n+                proto::lsp_diagnostic::Severity::Information => {\n+                    Some(lsp::DiagnosticSeverity::INFORMATION)\n+                }\n+                proto::lsp_diagnostic::Severity::Hint => Some(lsp::DiagnosticSeverity::HINT),\n+                _ => None,\n+            },\n+            code,\n+            code_description: match diagnostic.code_description {\n+                Some(code_description) => Some(CodeDescription {\n+                    href: lsp::Url::parse(&code_description).unwrap(),\n+                }),\n+                None => None,\n+            },\n+            related_information: Some(related_information),\n+            tags: Some(vec![]),\n+            source: diagnostic.source.clone(),\n+            message: diagnostic.message,\n+            data,\n+        })\n+    }\n+\n+    pub fn serialize_lsp_diagnostic(diagnostic: lsp::Diagnostic) -> Result<proto::LspDiagnostic> {\n+        let range = language::range_from_lsp(diagnostic.range);\n+        let related_information = diagnostic\n+            .related_information\n+            .unwrap_or_default()\n+            .into_iter()\n+            .map(|related_information| {\n+                let location_range_start =\n+                    point_from_lsp(related_information.location.range.start).0;\n+                let location_range_end = point_from_lsp(related_information.location.range.end).0;\n+\n+                Ok(proto::LspDiagnosticRelatedInformation {\n+                    location_url: Some(related_information.location.uri.to_string()),\n+                    location_range_start: Some(proto::PointUtf16 {\n+                        row: location_range_start.row,\n+                        column: location_range_start.column,\n+                    }),\n+                    location_range_end: Some(proto::PointUtf16 {\n+                        row: location_range_end.row,\n+                        column: location_range_end.column,\n+                    }),\n+                    message: related_information.message,\n+                })\n+            })\n+            .collect::<Result<Vec<_>>>()?;\n+\n+        let tags = diagnostic\n+            .tags\n+            .map(|tags| {\n+                tags.into_iter()\n+                    .map(|tag| match tag {\n+                        lsp::DiagnosticTag::UNNECESSARY => proto::LspDiagnosticTag::Unnecessary,\n+                        lsp::DiagnosticTag::DEPRECATED => proto::LspDiagnosticTag::Deprecated,\n+                        _ => proto::LspDiagnosticTag::None,\n+                    } as i32)\n+                    .collect()\n+            })\n+            .unwrap_or_default();\n+\n+        Ok(proto::LspDiagnostic {\n+            start: Some(proto::PointUtf16 {\n+                row: range.start.0.row,\n+                column: range.start.0.column,\n+            }),\n+            end: Some(proto::PointUtf16 {\n+                row: range.end.0.row,\n+                column: range.end.0.column,\n+            }),\n+            severity: match diagnostic.severity {\n+                Some(lsp::DiagnosticSeverity::ERROR) => proto::lsp_diagnostic::Severity::Error,\n+                Some(lsp::DiagnosticSeverity::WARNING) => proto::lsp_diagnostic::Severity::Warning,\n+                Some(lsp::DiagnosticSeverity::INFORMATION) => {\n+                    proto::lsp_diagnostic::Severity::Information\n+                }\n+                Some(lsp::DiagnosticSeverity::HINT) => proto::lsp_diagnostic::Severity::Hint,\n+                _ => proto::lsp_diagnostic::Severity::None,\n+            } as i32,\n+            code: diagnostic.code.as_ref().map(|code| match code {\n+                lsp::NumberOrString::Number(code) => code.to_string(),\n+                lsp::NumberOrString::String(code) => code.clone(),\n+            }),\n+            source: diagnostic.source.clone(),\n+            related_information,\n+            tags,\n+            code_description: diagnostic\n+                .code_description\n+                .map(|desc| desc.href.to_string()),\n+            message: diagnostic.message,\n+            data: diagnostic.data.as_ref().map(|data| data.to_string()),\n+        })\n+    }\n+}\n+\n+#[async_trait(?Send)]\n+impl LspCommand for GetDocumentDiagnostics {\n+    type Response = Option<LspDiagnostics>;\n+    type LspRequest = lsp::request::DocumentDiagnosticRequest;\n+    type ProtoRequest = proto::GetDocumentDiagnostics;\n+\n+    fn display_name(&self) -> &str {\n+        \"Get diagnostics\"\n+    }\n+\n+    fn check_capabilities(&self, server_capabilities: AdapterServerCapabilities) -> bool {\n+        server_capabilities\n+            .server_capabilities\n+            .diagnostic_provider\n+            .is_some()\n+    }\n+\n+    fn to_lsp(\n+        &self,\n+        path: &Path,\n+        _: &Buffer,\n+        language_server: &Arc<LanguageServer>,\n+        _: &AppContext,\n+    ) -> Result<lsp::DocumentDiagnosticParams> {\n+        let identifier = match language_server.capabilities().diagnostic_provider {\n+            Some(lsp::DiagnosticServerCapabilities::Options(options)) => options.identifier.clone(),\n+            Some(lsp::DiagnosticServerCapabilities::RegistrationOptions(options)) => {\n+                options.diagnostic_options.identifier.clone()\n+            }\n+            None => None,\n+        };\n+\n+        Ok(lsp::DocumentDiagnosticParams {\n+            text_document: lsp::TextDocumentIdentifier {\n+                uri: lsp::Url::from_file_path(path).unwrap(),\n+            },\n+            identifier,\n+            previous_result_id: None,\n+            partial_result_params: Default::default(),\n+            work_done_progress_params: Default::default(),\n+        })\n+    }\n+\n+    async fn response_from_lsp(\n+        self,\n+        message: lsp::DocumentDiagnosticReportResult,\n+        lsp_store: Model<LspStore>,\n+        buffer: Model<Buffer>,\n+        server_id: LanguageServerId,\n+        mut cx: AsyncAppContext,\n+    ) -> Result<Self::Response> {\n+        let uri = buffer.read_with(&cx, |buffer, cx| {\n+            buffer\n+                .file()\n+                .and_then(|file| file.as_local())\n+                .map(|file| lsp::Url::from_file_path(file.abs_path(cx).clone()).unwrap())\n+        })?;\n+\n+        let Some(uri) = uri else {\n+            return Ok(None);\n+        };\n+\n+        match message {\n+            lsp::DocumentDiagnosticReportResult::Report(report) => match report {\n+                lsp::DocumentDiagnosticReport::Full(report) => {\n+                    lsp_store.update(&mut cx, |store, cx| {\n+                        for (uri, report) in report.related_documents.into_iter().flatten() {\n+                            match report {\n+                                lsp::DocumentDiagnosticReportKind::Full(report) => {\n+                                    store.update_diagnostics(\n+                                        server_id,\n+                                        lsp::PublishDiagnosticsParams {\n+                                            diagnostics: report.items.clone(),\n+                                            uri,\n+                                            version: None,\n+                                        },\n+                                        &[],\n+                                        cx,\n+                                    ).expect(\"Failed to update diagnostics for the related document\");\n+                                }\n+                                lsp::DocumentDiagnosticReportKind::Unchanged(_) => (),\n+                            }\n+                        }\n+                    }).expect(\"Failed to update diagnostics for related documents\");",
        "comment_created_at": "2025-02-01T21:26:53+00:00",
        "comment_author": "vitallium",
        "comment_body": "Yes, totally makes sense. Changed that. The only ugly part left there is getting the URI of the document. We need that URI for `update_diagnostics` method on the `lsp_store`. If you have any suggestions for that part, please let me know. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2074845692",
    "pr_number": 29591,
    "pr_file": "crates/client/src/socks.rs",
    "created_at": "2025-05-06T07:03:16+00:00",
    "commented_code": "use http_client::Url;\n use tokio_socks::tcp::{Socks4Stream, Socks5Stream};\n \n+/// Identification to a Socks V4 Proxy\n+struct Socks4Identification<'a> {\n+    user_id: &'a str,\n+}\n+\n+/// Authorization to a Socks V5 Proxy\n+struct Socks5Authorization<'a> {\n+    username: &'a str,\n+    password: &'a str,\n+}\n+\n+/// Socks Proxy Protocol Version\n+///\n+/// V4 allows idenfication using a user_id\n+/// V5 allows authorization using a username and password\n+enum SocksVersion<'a> {\n+    V4(Option<Socks4Identification<'a>>),\n+    V5(Option<Socks5Authorization<'a>>),\n+}\n+\n pub(crate) async fn connect_socks_proxy_stream(\n     proxy: Option<&Url>,\n     rpc_host: (&str, u16),\n ) -> Result<Box<dyn AsyncReadWrite>> {\n-    let stream = match parse_socks_proxy(proxy) {\n-        Some((socks_proxy, SocksVersion::V4)) => {\n-            let stream = Socks4Stream::connect_with_socket(\n-                tokio::net::TcpStream::connect(socks_proxy).await?,\n-                rpc_host,\n-            )\n-            .await\n-            .map_err(|err| anyhow!(\"error connecting to socks {}\", err))?;\n-            Box::new(stream) as Box<dyn AsyncReadWrite>\n+    // Connect directly when there is no proxy\n+    let Some(proxy) = proxy else {\n+        return Ok(Box::new(tokio::net::TcpStream::connect(rpc_host).await?));\n+    };\n+\n+    let Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2074845692",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29591,
        "pr_file": "crates/client/src/socks.rs",
        "discussion_id": "2074845692",
        "commented_code": "@@ -3,59 +3,102 @@ use anyhow::{Result, anyhow};\n use http_client::Url;\n use tokio_socks::tcp::{Socks4Stream, Socks5Stream};\n \n+/// Identification to a Socks V4 Proxy\n+struct Socks4Identification<'a> {\n+    user_id: &'a str,\n+}\n+\n+/// Authorization to a Socks V5 Proxy\n+struct Socks5Authorization<'a> {\n+    username: &'a str,\n+    password: &'a str,\n+}\n+\n+/// Socks Proxy Protocol Version\n+///\n+/// V4 allows idenfication using a user_id\n+/// V5 allows authorization using a username and password\n+enum SocksVersion<'a> {\n+    V4(Option<Socks4Identification<'a>>),\n+    V5(Option<Socks5Authorization<'a>>),\n+}\n+\n pub(crate) async fn connect_socks_proxy_stream(\n     proxy: Option<&Url>,\n     rpc_host: (&str, u16),\n ) -> Result<Box<dyn AsyncReadWrite>> {\n-    let stream = match parse_socks_proxy(proxy) {\n-        Some((socks_proxy, SocksVersion::V4)) => {\n-            let stream = Socks4Stream::connect_with_socket(\n-                tokio::net::TcpStream::connect(socks_proxy).await?,\n-                rpc_host,\n-            )\n-            .await\n-            .map_err(|err| anyhow!(\"error connecting to socks {}\", err))?;\n-            Box::new(stream) as Box<dyn AsyncReadWrite>\n+    // Connect directly when there is no proxy\n+    let Some(proxy) = proxy else {\n+        return Ok(Box::new(tokio::net::TcpStream::connect(rpc_host).await?));\n+    };\n+\n+    let Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {",
        "comment_created_at": "2025-05-06T07:03:16+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "We can remove this nesting with\r\n\r\n```rs\r\nuse anyhow::Context as _;\r\n\r\nlet (socks_proxy, version) = parse_socks_proxy(proxy).with_context(|| format!(\"Parsing proxy url '{proxy}'\"))?;\r\n// or use `.context(\"parsing proxy url\")?` if `url` is not secure to print due to the risk of leaking the credentials.\r\n```\r\n\r\nand might be good to do `.context` on more `?` around, such as `TcpStream::connect` or maybe even `.map_err(|err| anyhow!`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2074886247",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29591,
        "pr_file": "crates/client/src/socks.rs",
        "discussion_id": "2074845692",
        "commented_code": "@@ -3,59 +3,102 @@ use anyhow::{Result, anyhow};\n use http_client::Url;\n use tokio_socks::tcp::{Socks4Stream, Socks5Stream};\n \n+/// Identification to a Socks V4 Proxy\n+struct Socks4Identification<'a> {\n+    user_id: &'a str,\n+}\n+\n+/// Authorization to a Socks V5 Proxy\n+struct Socks5Authorization<'a> {\n+    username: &'a str,\n+    password: &'a str,\n+}\n+\n+/// Socks Proxy Protocol Version\n+///\n+/// V4 allows idenfication using a user_id\n+/// V5 allows authorization using a username and password\n+enum SocksVersion<'a> {\n+    V4(Option<Socks4Identification<'a>>),\n+    V5(Option<Socks5Authorization<'a>>),\n+}\n+\n pub(crate) async fn connect_socks_proxy_stream(\n     proxy: Option<&Url>,\n     rpc_host: (&str, u16),\n ) -> Result<Box<dyn AsyncReadWrite>> {\n-    let stream = match parse_socks_proxy(proxy) {\n-        Some((socks_proxy, SocksVersion::V4)) => {\n-            let stream = Socks4Stream::connect_with_socket(\n-                tokio::net::TcpStream::connect(socks_proxy).await?,\n-                rpc_host,\n-            )\n-            .await\n-            .map_err(|err| anyhow!(\"error connecting to socks {}\", err))?;\n-            Box::new(stream) as Box<dyn AsyncReadWrite>\n+    // Connect directly when there is no proxy\n+    let Some(proxy) = proxy else {\n+        return Ok(Box::new(tokio::net::TcpStream::connect(rpc_host).await?));\n+    };\n+\n+    let Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {",
        "comment_created_at": "2025-05-06T07:31:54+00:00",
        "comment_author": "tidely",
        "comment_body": "Mostly a stylistic choice, but I prefer the explicitness of the return when parsing the proxy url, since it's quite critical that we don't use a fallback. However if context adheres better to Zed coding styles I'll gladly change it!\r\n\r\nI'll add a `.map_err` to the `TcpStream::connect`, not sure why I didn't in the first place :)",
        "pr_file_module": null
      },
      {
        "comment_id": "2074891397",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29591,
        "pr_file": "crates/client/src/socks.rs",
        "discussion_id": "2074845692",
        "commented_code": "@@ -3,59 +3,102 @@ use anyhow::{Result, anyhow};\n use http_client::Url;\n use tokio_socks::tcp::{Socks4Stream, Socks5Stream};\n \n+/// Identification to a Socks V4 Proxy\n+struct Socks4Identification<'a> {\n+    user_id: &'a str,\n+}\n+\n+/// Authorization to a Socks V5 Proxy\n+struct Socks5Authorization<'a> {\n+    username: &'a str,\n+    password: &'a str,\n+}\n+\n+/// Socks Proxy Protocol Version\n+///\n+/// V4 allows idenfication using a user_id\n+/// V5 allows authorization using a username and password\n+enum SocksVersion<'a> {\n+    V4(Option<Socks4Identification<'a>>),\n+    V5(Option<Socks5Authorization<'a>>),\n+}\n+\n pub(crate) async fn connect_socks_proxy_stream(\n     proxy: Option<&Url>,\n     rpc_host: (&str, u16),\n ) -> Result<Box<dyn AsyncReadWrite>> {\n-    let stream = match parse_socks_proxy(proxy) {\n-        Some((socks_proxy, SocksVersion::V4)) => {\n-            let stream = Socks4Stream::connect_with_socket(\n-                tokio::net::TcpStream::connect(socks_proxy).await?,\n-                rpc_host,\n-            )\n-            .await\n-            .map_err(|err| anyhow!(\"error connecting to socks {}\", err))?;\n-            Box::new(stream) as Box<dyn AsyncReadWrite>\n+    // Connect directly when there is no proxy\n+    let Some(proxy) = proxy else {\n+        return Ok(Box::new(tokio::net::TcpStream::connect(rpc_host).await?));\n+    };\n+\n+    let Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {",
        "comment_created_at": "2025-05-06T07:35:35+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "I would prefer `.context`/`.with_context` over `.map_err` and `?` usage anyway as indeed, mostly the Zed \"code style\" and the type system being rather explicit itself already. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2074904530",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29591,
        "pr_file": "crates/client/src/socks.rs",
        "discussion_id": "2074845692",
        "commented_code": "@@ -3,59 +3,102 @@ use anyhow::{Result, anyhow};\n use http_client::Url;\n use tokio_socks::tcp::{Socks4Stream, Socks5Stream};\n \n+/// Identification to a Socks V4 Proxy\n+struct Socks4Identification<'a> {\n+    user_id: &'a str,\n+}\n+\n+/// Authorization to a Socks V5 Proxy\n+struct Socks5Authorization<'a> {\n+    username: &'a str,\n+    password: &'a str,\n+}\n+\n+/// Socks Proxy Protocol Version\n+///\n+/// V4 allows idenfication using a user_id\n+/// V5 allows authorization using a username and password\n+enum SocksVersion<'a> {\n+    V4(Option<Socks4Identification<'a>>),\n+    V5(Option<Socks5Authorization<'a>>),\n+}\n+\n pub(crate) async fn connect_socks_proxy_stream(\n     proxy: Option<&Url>,\n     rpc_host: (&str, u16),\n ) -> Result<Box<dyn AsyncReadWrite>> {\n-    let stream = match parse_socks_proxy(proxy) {\n-        Some((socks_proxy, SocksVersion::V4)) => {\n-            let stream = Socks4Stream::connect_with_socket(\n-                tokio::net::TcpStream::connect(socks_proxy).await?,\n-                rpc_host,\n-            )\n-            .await\n-            .map_err(|err| anyhow!(\"error connecting to socks {}\", err))?;\n-            Box::new(stream) as Box<dyn AsyncReadWrite>\n+    // Connect directly when there is no proxy\n+    let Some(proxy) = proxy else {\n+        return Ok(Box::new(tokio::net::TcpStream::connect(rpc_host).await?));\n+    };\n+\n+    let Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {",
        "comment_created_at": "2025-05-06T07:43:12+00:00",
        "comment_author": "tidely",
        "comment_body": "I left this block intact for now, would you like me to replace it with a `map_err` ?\r\n\r\n```rust\r\nlet Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {\r\n    // If parsing the proxy URL fails, we must avoid falling back to an insecure connection.\r\n    // SOCKS proxies are often used in contexts where security and privacy are critical,\r\n    // so any fallback could expose users to significant risks.\r\n    return Err(anyhow!(\"Parsing proxy url failed\"));\r\n};\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2074911939",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29591,
        "pr_file": "crates/client/src/socks.rs",
        "discussion_id": "2074845692",
        "commented_code": "@@ -3,59 +3,102 @@ use anyhow::{Result, anyhow};\n use http_client::Url;\n use tokio_socks::tcp::{Socks4Stream, Socks5Stream};\n \n+/// Identification to a Socks V4 Proxy\n+struct Socks4Identification<'a> {\n+    user_id: &'a str,\n+}\n+\n+/// Authorization to a Socks V5 Proxy\n+struct Socks5Authorization<'a> {\n+    username: &'a str,\n+    password: &'a str,\n+}\n+\n+/// Socks Proxy Protocol Version\n+///\n+/// V4 allows idenfication using a user_id\n+/// V5 allows authorization using a username and password\n+enum SocksVersion<'a> {\n+    V4(Option<Socks4Identification<'a>>),\n+    V5(Option<Socks5Authorization<'a>>),\n+}\n+\n pub(crate) async fn connect_socks_proxy_stream(\n     proxy: Option<&Url>,\n     rpc_host: (&str, u16),\n ) -> Result<Box<dyn AsyncReadWrite>> {\n-    let stream = match parse_socks_proxy(proxy) {\n-        Some((socks_proxy, SocksVersion::V4)) => {\n-            let stream = Socks4Stream::connect_with_socket(\n-                tokio::net::TcpStream::connect(socks_proxy).await?,\n-                rpc_host,\n-            )\n-            .await\n-            .map_err(|err| anyhow!(\"error connecting to socks {}\", err))?;\n-            Box::new(stream) as Box<dyn AsyncReadWrite>\n+    // Connect directly when there is no proxy\n+    let Some(proxy) = proxy else {\n+        return Ok(Box::new(tokio::net::TcpStream::connect(rpc_host).await?));\n+    };\n+\n+    let Some((socks_proxy, version)) = parse_socks_proxy(proxy) else {",
        "comment_created_at": "2025-05-06T07:47:13+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "I think it's fine, thank you for the rest of the fixes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998414896",
    "pr_number": 26903,
    "pr_file": "crates/terminal/src/terminal.rs",
    "created_at": "2025-03-17T10:21:48+00:00",
    "commented_code": "} else if let Some(url_match) = regex_match_at(term, point, &mut self.url_regex) {\n                     let url = term.bounds_to_string(*url_match.start(), *url_match.end());\n                     Some((url, true, url_match))\n+                } else if let Some(python_match) =\n+                    regex_match_at(term, point, &mut self.python_file_line_regex)\n+                {\n+                    let file_line =\n+                        term.bounds_to_string(*python_match.start(), *python_match.end());\n+\n+                    let (file_path, line_number) = python_extract_path_and_line(file_line.as_str())\n+                        .expect(\"Cannot parse python file line syntax\");",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1998414896",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26903,
        "pr_file": "crates/terminal/src/terminal.rs",
        "discussion_id": "1998414896",
        "commented_code": "@@ -926,6 +942,20 @@ impl Terminal {\n                 } else if let Some(url_match) = regex_match_at(term, point, &mut self.url_regex) {\n                     let url = term.bounds_to_string(*url_match.start(), *url_match.end());\n                     Some((url, true, url_match))\n+                } else if let Some(python_match) =\n+                    regex_match_at(term, point, &mut self.python_file_line_regex)\n+                {\n+                    let file_line =\n+                        term.bounds_to_string(*python_match.start(), *python_match.end());\n+\n+                    let (file_path, line_number) = python_extract_path_and_line(file_line.as_str())\n+                        .expect(\"Cannot parse python file line syntax\");",
        "comment_created_at": "2025-03-17T10:21:48+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "I understand that we did a Python regex match and should not fail here, but the logic may have flaws (or gain, with later contributions) causing None to be returned here.\r\n\r\nFor the sake of less panics due to unwrap/expect's in \"prod\" code, let's replace it with `log_err()?` or, `debug_panic!` if you want to pay more attention to this in debug builds.\r\n\r\nI also think we can avoid this entirely, and redo this `else if let` into `else`, then get the `let file_line` and use the regular Rust's regex (see how unit tests do that with `fn re_test` now) to match the rest of the cases, with capture values extractions?",
        "pr_file_module": null
      }
    ]
  }
]