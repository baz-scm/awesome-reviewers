[
  {
    "discussion_id": "2163943704",
    "pr_number": 33199,
    "pr_file": "crates/editor/src/signature_help.rs",
    "created_at": "2025-06-24T12:59:26+00:00",
    "commented_code": "pub fn is_shown(&self) -> bool {\n         self.popover.is_some()\n     }\n+\n+    pub fn has_multiple_signatures(&self) -> bool {\n+        self.popover\n+            .as_ref()\n+            .map_or(false, |popover| popover.signature.len() > 1)",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2163943704",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 33199,
        "pr_file": "crates/editor/src/signature_help.rs",
        "discussion_id": "2163943704",
        "commented_code": "@@ -268,6 +308,12 @@ impl SignatureHelpState {\n     pub fn is_shown(&self) -> bool {\n         self.popover.is_some()\n     }\n+\n+    pub fn has_multiple_signatures(&self) -> bool {\n+        self.popover\n+            .as_ref()\n+            .map_or(false, |popover| popover.signature.len() > 1)",
        "comment_created_at": "2025-06-24T12:59:26+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "```suggestion\r\n            .is_some_and(|popover| popover.signature.len() > 1)\r\n```\r\n\r\nNIT",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163466843",
    "pr_number": 32694,
    "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
    "created_at": "2025-06-24T09:39:25+00:00",
    "commented_code": "+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum PreviewEvent {}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        if let Some(editor) = workspace",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2163466843",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32694,
        "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
        "discussion_id": "2163466843",
        "commented_code": "@@ -0,0 +1,237 @@\n+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum PreviewEvent {}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        if let Some(editor) = workspace",
        "comment_created_at": "2025-06-24T09:39:25+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "> `if let Some`\r\n\r\nThis can be just `?`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164889419",
    "pr_number": 32694,
    "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
    "created_at": "2025-06-24T20:59:22+00:00",
    "commented_code": "+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return Some(file.path().to_path_buf());\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl Render for SvgPreviewView {\n+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n+        v_flex()\n+            .id(\"SvgPreview\")\n+            .key_context(\"SvgPreview\")\n+            .track_focus(&self.focus_handle(cx))\n+            .size_full()\n+            .bg(cx.theme().colors().editor_background)\n+            .flex()\n+            .justify_center()\n+            .items_center()\n+            .child(if let Some(svg_path) = &self.svg_path {\n+                img(ImageSource::from(svg_path.clone()))\n+                    .image_cache(&self.image_cache)\n+                    .max_w_full()\n+                    .max_h_full()\n+                    .with_fallback(|| {\n+                        div()\n+                            .p_4()\n+                            .child(\"Failed to load SVG file\")\n+                            .into_any_element()\n+                    })\n+                    .into_any_element()\n+            } else {\n+                div().p_4().child(\"No SVG file selected\").into_any_element()\n+            })\n+    }\n+}\n+\n+impl Focusable for SvgPreviewView {\n+    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n+        self.focus_handle.clone()\n+    }\n+}\n+\n+impl EventEmitter<()> for SvgPreviewView {}\n+\n+impl Item for SvgPreviewView {\n+    type Event = ();\n+\n+    fn tab_icon(&self, _window: &Window, cx: &App) -> Option<Icon> {\n+        // Use the same icon as SVG files in the file tree\n+        self.svg_path\n+            .as_ref()\n+            .and_then(|svg_path| FileIcons::get_icon(svg_path, cx))\n+            .map(Icon::from_path)\n+            .or_else(|| Some(Icon::new(IconName::Image)))\n+    }\n+\n+    fn tab_content_text(&self, _detail: usize, _cx: &App) -> SharedString {\n+        self.svg_path\n+            .as_ref()\n+            .and_then(|svg_path| svg_path.file_name())\n+            .and_then(|name| name.to_str())",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2164889419",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32694,
        "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
        "discussion_id": "2164889419",
        "commented_code": "@@ -0,0 +1,228 @@\n+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return Some(file.path().to_path_buf());\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl Render for SvgPreviewView {\n+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n+        v_flex()\n+            .id(\"SvgPreview\")\n+            .key_context(\"SvgPreview\")\n+            .track_focus(&self.focus_handle(cx))\n+            .size_full()\n+            .bg(cx.theme().colors().editor_background)\n+            .flex()\n+            .justify_center()\n+            .items_center()\n+            .child(if let Some(svg_path) = &self.svg_path {\n+                img(ImageSource::from(svg_path.clone()))\n+                    .image_cache(&self.image_cache)\n+                    .max_w_full()\n+                    .max_h_full()\n+                    .with_fallback(|| {\n+                        div()\n+                            .p_4()\n+                            .child(\"Failed to load SVG file\")\n+                            .into_any_element()\n+                    })\n+                    .into_any_element()\n+            } else {\n+                div().p_4().child(\"No SVG file selected\").into_any_element()\n+            })\n+    }\n+}\n+\n+impl Focusable for SvgPreviewView {\n+    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n+        self.focus_handle.clone()\n+    }\n+}\n+\n+impl EventEmitter<()> for SvgPreviewView {}\n+\n+impl Item for SvgPreviewView {\n+    type Event = ();\n+\n+    fn tab_icon(&self, _window: &Window, cx: &App) -> Option<Icon> {\n+        // Use the same icon as SVG files in the file tree\n+        self.svg_path\n+            .as_ref()\n+            .and_then(|svg_path| FileIcons::get_icon(svg_path, cx))\n+            .map(Icon::from_path)\n+            .or_else(|| Some(Icon::new(IconName::Image)))\n+    }\n+\n+    fn tab_content_text(&self, _detail: usize, _cx: &App) -> SharedString {\n+        self.svg_path\n+            .as_ref()\n+            .and_then(|svg_path| svg_path.file_name())\n+            .and_then(|name| name.to_str())",
        "comment_created_at": "2025-06-24T20:59:22+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "Here, we'd rather use the `to_string_lossy()` method, to try and show something for invalid UTF-8.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164890044",
    "pr_number": 32694,
    "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
    "created_at": "2025-06-24T20:59:52+00:00",
    "commented_code": "+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2164890044",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32694,
        "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
        "discussion_id": "2164890044",
        "commented_code": "@@ -0,0 +1,228 @@\n+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {",
        "comment_created_at": "2025-06-24T20:59:52+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "`?`",
        "pr_file_module": null
      },
      {
        "comment_id": "2165002090",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32694,
        "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
        "discussion_id": "2164890044",
        "commented_code": "@@ -0,0 +1,228 @@\n+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {",
        "comment_created_at": "2025-06-24T22:01:24+00:00",
        "comment_author": "ronharel02",
        "comment_body": "In case of multibuffers.",
        "pr_file_module": null
      },
      {
        "comment_id": "2165840589",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32694,
        "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
        "discussion_id": "2164890044",
        "commented_code": "@@ -0,0 +1,228 @@\n+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {",
        "comment_created_at": "2025-06-25T05:49:57+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "No, I mean for the 3rd time in a row, this is a method that returns `Option`, so you can `?` instead of `if let Some`",
        "pr_file_module": null
      },
      {
        "comment_id": "2166029290",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32694,
        "pr_file": "crates/svg_preview/src/svg_preview_view.rs",
        "discussion_id": "2164890044",
        "commented_code": "@@ -0,0 +1,228 @@\n+use std::path::PathBuf;\n+\n+use editor::{Editor, EditorEvent};\n+use file_icons::FileIcons;\n+use gpui::{\n+    App, Context, Entity, EventEmitter, FocusHandle, Focusable, ImageSource, IntoElement,\n+    ParentElement, Render, Resource, RetainAllImageCache, Styled, Subscription, WeakEntity, Window,\n+    div, img,\n+};\n+use ui::prelude::*;\n+use workspace::item::Item;\n+use workspace::{Pane, Workspace};\n+\n+use crate::{OpenPreview, OpenPreviewToTheSide};\n+\n+pub struct SvgPreviewView {\n+    focus_handle: FocusHandle,\n+    svg_path: Option<PathBuf>,\n+    image_cache: Entity<RetainAllImageCache>,\n+    _editor_subscription: Subscription,\n+}\n+\n+impl SvgPreviewView {\n+    pub fn register(workspace: &mut Workspace, _window: &mut Window, _cx: &mut Context<Workspace>) {\n+        workspace.register_action(move |workspace, _: &OpenPreview, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor, window, cx);\n+                    workspace.active_pane().update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), true, true, None, window, cx)\n+                        }\n+                    });\n+                    cx.notify();\n+                }\n+            }\n+        });\n+\n+        workspace.register_action(move |workspace, _: &OpenPreviewToTheSide, window, cx| {\n+            if let Some(editor) = Self::resolve_active_item_as_svg_editor(workspace, cx) {\n+                if Self::is_svg_file(&editor, cx) {\n+                    let view = Self::create_svg_view(workspace, editor.clone(), window, cx);\n+                    let pane = workspace\n+                        .find_pane_in_direction(workspace::SplitDirection::Right, cx)\n+                        .unwrap_or_else(|| {\n+                            workspace.split_pane(\n+                                workspace.active_pane().clone(),\n+                                workspace::SplitDirection::Right,\n+                                window,\n+                                cx,\n+                            )\n+                        });\n+                    pane.update(cx, |pane, cx| {\n+                        if let Some(existing_view_idx) = Self::find_existing_preview_item_idx(pane)\n+                        {\n+                            pane.activate_item(existing_view_idx, true, true, window, cx);\n+                        } else {\n+                            pane.add_item(Box::new(view), false, false, None, window, cx)\n+                        }\n+                    });\n+                    editor.focus_handle(cx).focus(window);\n+                    cx.notify();\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+        pane.items_of_type::<SvgPreviewView>()\n+            .nth(0)\n+            .and_then(|view| pane.index_for_item(&view))\n+    }\n+\n+    pub fn resolve_active_item_as_svg_editor(\n+        workspace: &Workspace,\n+        cx: &mut Context<Workspace>,\n+    ) -> Option<Entity<Editor>> {\n+        let editor = workspace.active_item(cx)?.act_as::<Editor>(cx)?;\n+\n+        if Self::is_svg_file(&editor, cx) {\n+            Some(editor)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn create_svg_view(\n+        workspace: &mut Workspace,\n+        editor: Entity<Editor>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<SvgPreviewView> {\n+        let workspace_handle = workspace.weak_handle();\n+        SvgPreviewView::new(editor, workspace_handle, window, cx)\n+    }\n+\n+    pub fn new(\n+        active_editor: Entity<Editor>,\n+        _workspace: WeakEntity<Workspace>,\n+        window: &mut Window,\n+        cx: &mut Context<Workspace>,\n+    ) -> Entity<Self> {\n+        cx.new(|cx| {\n+            let svg_path = Self::get_svg_path(&active_editor, cx);\n+            let image_cache = RetainAllImageCache::new(cx);\n+\n+            let subscription = cx.subscribe_in(\n+                &active_editor,\n+                window,\n+                |this: &mut SvgPreviewView, _editor, event: &EditorEvent, window, cx| {\n+                    match event {\n+                        EditorEvent::Saved => {\n+                            // Remove cached image to force reload\n+                            if let Some(svg_path) = &this.svg_path {\n+                                let resource = Resource::Path(svg_path.clone().into());\n+                                this.image_cache.update(cx, |cache, cx| {\n+                                    cache.remove(&resource, window, cx);\n+                                });\n+                            }\n+                            cx.notify();\n+                        }\n+                        _ => {}\n+                    }\n+                },\n+            );\n+\n+            Self {\n+                focus_handle: cx.focus_handle(),\n+                svg_path,\n+                image_cache,\n+                _editor_subscription: subscription,\n+            }\n+        })\n+    }\n+\n+    pub fn is_svg_file<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> bool {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {\n+            if let Some(file) = buffer.read(cx).file() {\n+                return file\n+                    .path()\n+                    .extension()\n+                    .and_then(|ext| ext.to_str())\n+                    .map(|ext| ext.eq_ignore_ascii_case(\"svg\"))\n+                    .unwrap_or(false);\n+            }\n+        }\n+        false\n+    }\n+\n+    fn get_svg_path<V>(editor: &Entity<Editor>, cx: &mut Context<V>) -> Option<PathBuf> {\n+        let buffer = editor.read(cx).buffer().read(cx);\n+        if let Some(buffer) = buffer.as_singleton() {",
        "comment_created_at": "2025-06-25T07:42:33+00:00",
        "comment_author": "ronharel02",
        "comment_body": "Oh I'm sorry ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161505743",
    "pr_number": 33139,
    "pr_file": "crates/file_finder/src/file_finder.rs",
    "created_at": "2025-06-23T12:28:46+00:00",
    "commented_code": "matches.into_iter(),\n                 extend_old_matches,\n             );\n-            let worktree = self.project.read(cx).visible_worktrees(cx).next();\n-            let filename = query.raw_query.to_string();\n-            let path = Path::new(&filename);\n \n+            let filename = query.raw_query.to_string();\n+            let mut path = Path::new(&filename);\n             // add option of creating new file only if path is relative\n+            let worktree = if let Some(FoundPath { ref project, .. }) = self.currently_opened_path {\n+                let worktree_id = project.worktree_id;\n+                self.project.read(cx).worktree_for_id(worktree_id, cx)\n+            } else {\n+                self.project.read(cx).visible_worktrees(cx).next()\n+            };\n+            let worktree_count = self.project.read(cx).visible_worktrees(cx).count();\n             if let Some(worktree) = worktree {\n                 let worktree = worktree.read(cx);\n+                let root = worktree\n+                    .abs_path()\n+                    .file_name()\n+                    .map_or(String::new(), |f| f.to_string_lossy().to_string());\n+                if worktree_count > 1 && path.starts_with(&root) {\n+                    path = path.strip_prefix(root).unwrap();",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2161505743",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 33139,
        "pr_file": "crates/file_finder/src/file_finder.rs",
        "discussion_id": "2161505743",
        "commented_code": "@@ -939,13 +939,26 @@ impl FileFinderDelegate {\n                 matches.into_iter(),\n                 extend_old_matches,\n             );\n-            let worktree = self.project.read(cx).visible_worktrees(cx).next();\n-            let filename = query.raw_query.to_string();\n-            let path = Path::new(&filename);\n \n+            let filename = query.raw_query.to_string();\n+            let mut path = Path::new(&filename);\n             // add option of creating new file only if path is relative\n+            let worktree = if let Some(FoundPath { ref project, .. }) = self.currently_opened_path {\n+                let worktree_id = project.worktree_id;\n+                self.project.read(cx).worktree_for_id(worktree_id, cx)\n+            } else {\n+                self.project.read(cx).visible_worktrees(cx).next()\n+            };\n+            let worktree_count = self.project.read(cx).visible_worktrees(cx).count();\n             if let Some(worktree) = worktree {\n                 let worktree = worktree.read(cx);\n+                let root = worktree\n+                    .abs_path()\n+                    .file_name()\n+                    .map_or(String::new(), |f| f.to_string_lossy().to_string());\n+                if worktree_count > 1 && path.starts_with(&root) {\n+                    path = path.strip_prefix(root).unwrap();",
        "comment_created_at": "2025-06-23T12:28:46+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "> .unwrap();\r\n\r\nDo not ever use that, please.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160166870",
    "pr_number": 32859,
    "pr_file": "crates/markdown_preview/src/markdown_preview_view.rs",
    "created_at": "2025-06-21T22:05:48+00:00",
    "commented_code": "});\n     }\n \n-    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+    fn find_existing_preview_item_idx(\n+        pane: &Pane,\n+        editor: &Entity<Editor>,\n+        cx: &App,\n+    ) -> Option<usize> {\n         pane.items_of_type::<MarkdownPreviewView>()\n-            .nth(0)\n+            .find(|view| {\n+                if let Some(active_editor) = &view.read(cx).active_editor {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2160166870",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32859,
        "pr_file": "crates/markdown_preview/src/markdown_preview_view.rs",
        "discussion_id": "2160166870",
        "commented_code": "@@ -96,9 +100,19 @@ impl MarkdownPreviewView {\n         });\n     }\n \n-    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+    fn find_existing_preview_item_idx(\n+        pane: &Pane,\n+        editor: &Entity<Editor>,\n+        cx: &App,\n+    ) -> Option<usize> {\n         pane.items_of_type::<MarkdownPreviewView>()\n-            .nth(0)\n+            .find(|view| {\n+                if let Some(active_editor) = &view.read(cx).active_editor {",
        "comment_created_at": "2025-06-21T22:05:48+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "NIT: we could use `view.read(cx).active_editor.as_ref().is_some_and(` instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "2161731582",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 32859,
        "pr_file": "crates/markdown_preview/src/markdown_preview_view.rs",
        "discussion_id": "2160166870",
        "commented_code": "@@ -96,9 +100,19 @@ impl MarkdownPreviewView {\n         });\n     }\n \n-    fn find_existing_preview_item_idx(pane: &Pane) -> Option<usize> {\n+    fn find_existing_preview_item_idx(\n+        pane: &Pane,\n+        editor: &Entity<Editor>,\n+        cx: &App,\n+    ) -> Option<usize> {\n         pane.items_of_type::<MarkdownPreviewView>()\n-            .nth(0)\n+            .find(|view| {\n+                if let Some(active_editor) = &view.read(cx).active_editor {",
        "comment_created_at": "2025-06-23T14:09:05+00:00",
        "comment_author": "ddoemonn",
        "comment_body": "Fixed!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2052180361",
    "pr_number": 29127,
    "pr_file": "crates/editor/src/items.rs",
    "created_at": "2025-04-21T09:25:51+00:00",
    "commented_code": "&mut self,\n         workspace: &mut Workspace,\n         _window: &mut Window,\n-        _: &mut Context<Self>,\n+        cx: &mut Context<Self>,\n     ) {\n         self.workspace = Some((workspace.weak_handle(), workspace.database_id()));\n+        cx.subscribe(\n+            &workspace.weak_handle().upgrade().unwrap(),",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2052180361",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29127,
        "pr_file": "crates/editor/src/items.rs",
        "discussion_id": "2052180361",
        "commented_code": "@@ -928,9 +928,18 @@ impl Item for Editor {\n         &mut self,\n         workspace: &mut Workspace,\n         _window: &mut Window,\n-        _: &mut Context<Self>,\n+        cx: &mut Context<Self>,\n     ) {\n         self.workspace = Some((workspace.weak_handle(), workspace.database_id()));\n+        cx.subscribe(\n+            &workspace.weak_handle().upgrade().unwrap(),",
        "comment_created_at": "2025-04-21T09:25:51+00:00",
        "comment_author": "smitbarmase",
        "comment_body": "We should not use `unwrap` here, as it might panic if the workspace has been dropped. Instead, you can do something like this:\r\n\r\n```rs  \r\n        let weak_handle = workspace.weak_handle();\r\n        self.workspace = Some((weak_handle, workspace.database_id()));\r\n        if let Some(workspace) = weak_handle.upgrade() {\r\n            cx.subscribe(&workspace, |editor, _, event: &workspace::Event, _cx| {\r\n                if matches!(event, workspace::Event::ModalOpened) {\r\n                    editor.mouse_context_menu.take();\r\n                }\r\n            })\r\n            .detach();\r\n        };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2011393255",
    "pr_number": 26369,
    "pr_file": "crates/gpui/src/platform/windows/destination_list.rs",
    "created_at": "2025-03-25T06:21:25+00:00",
    "commented_code": "+use itertools::Itertools;\n+use windows::{\n+    core::{Interface, GUID, HSTRING},\n+    Win32::{\n+        Foundation::PROPERTYKEY,\n+        System::Com::{CoCreateInstance, StructuredStorage::PROPVARIANT, CLSCTX_INPROC_SERVER},\n+        UI::Shell::{\n+            Common::{IObjectArray, IObjectCollection},\n+            DestinationList, EnumerableObjectCollection, ICustomDestinationList, IShellLinkW,\n+            PropertiesSystem::IPropertyStore,\n+            ShellLink,\n+        },\n+    },\n+};\n+\n+use crate::{Action, MenuItem};\n+\n+pub(crate) struct DockMenuItem {\n+    pub(crate) name: String,\n+    pub(crate) description: String,\n+    pub(crate) action: Box<dyn Action>,\n+}\n+\n+impl DockMenuItem {\n+    pub(crate) fn new(item: MenuItem) -> anyhow::Result<Self> {\n+        match item {\n+            MenuItem::Action { name, action, .. } => Ok(Self {\n+                name: name.clone().into(),\n+                description: if name == \"New Window\" {\n+                    \"Opens a new window\".to_string()\n+                } else {\n+                    name.into()\n+                },\n+                action,\n+            }),\n+            _ => Err(anyhow::anyhow!(\n+                \"Only `MenuItem::Action` is supported for dock menu on Windows.\"\n+            )),\n+        }\n+    }\n+}\n+\n+// https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/winui/shell/appshellintegration/RecipePropertyHandler/RecipePropertyHandler.cpp\n+pub(crate) fn update_jump_list(\n+    entries: &[&Vec<String>],\n+    dock_menus: &[DockMenuItem],\n+) -> anyhow::Result<Option<Vec<Vec<String>>>> {\n+    let (list, removed) = create_destination_list()?;\n+    add_recent_folders(&list, entries, removed.as_ref())?;\n+    add_dock_menu(&list, dock_menus)?;\n+    unsafe { list.CommitList() }?;\n+    Ok(removed)\n+}\n+\n+const PKEY_TITLE: PROPERTYKEY = PROPERTYKEY {\n+    fmtid: GUID::from_u128(0xf29f85e0_4ff9_1068_ab91_08002b27b3d9),\n+    pid: 2,\n+};\n+\n+const PKEY_LINK_ARGS: PROPERTYKEY = PROPERTYKEY {\n+    fmtid: GUID::from_u128(0x436f2667_14e2_4feb_b30a_146c53b5b674),\n+    pid: 100,\n+};\n+\n+fn create_destination_list() -> anyhow::Result<(ICustomDestinationList, Option<Vec<Vec<String>>>)> {\n+    let list: ICustomDestinationList =\n+        unsafe { CoCreateInstance(&DestinationList, None, CLSCTX_INPROC_SERVER) }?;\n+\n+    let mut slots = 0;\n+    let user_removed: IObjectArray = unsafe { list.BeginList(&mut slots) }?;\n+\n+    let count = unsafe { user_removed.GetCount() }?;\n+    if count == 0 {\n+        return Ok((list, None));\n+    }\n+\n+    let mut removed = Vec::with_capacity(count as usize);\n+    for i in 0..count {\n+        let shell_link: IShellLinkW = unsafe { user_removed.GetAt(i)? };\n+        let store: IPropertyStore = shell_link.cast()?;\n+        let argument = unsafe { store.GetValue(&PKEY_LINK_ARGS)? };\n+        let args = argument\n+            .to_string()\n+            .split_whitespace()\n+            .map(|s| s.trim_matches('\"').to_string())\n+            .collect_vec();\n+\n+        removed.push(args);\n+    }\n+\n+    Ok((list, Some(removed)))\n+}\n+\n+fn add_dock_menu(list: &ICustomDestinationList, dock_menus: &[DockMenuItem]) -> anyhow::Result<()> {\n+    unsafe {\n+        let tasks: IObjectCollection =\n+            CoCreateInstance(&EnumerableObjectCollection, None, CLSCTX_INPROC_SERVER)?;\n+        for (idx, dock_menu) in dock_menus.iter().enumerate() {\n+            let argument = HSTRING::from(format!(\"--dock-action {}\", idx));\n+            let description = HSTRING::from(dock_menu.description.as_str());\n+            let display = dock_menu.name.as_str();\n+            let task = create_shell_link(argument, description, None, display)?;\n+            tasks.AddObject(&task)?;\n+        }\n+        list.AddUserTasks(&tasks)?;\n+        Ok(())\n+    }\n+}\n+\n+fn add_recent_folders(\n+    list: &ICustomDestinationList,\n+    entries: &[&Vec<String>],\n+    removed: Option<&Vec<Vec<String>>>,\n+) -> anyhow::Result<()> {\n+    unsafe {\n+        let tasks: IObjectCollection =\n+            CoCreateInstance(&EnumerableObjectCollection, None, CLSCTX_INPROC_SERVER)?;\n+\n+        for folder_path in entries\n+            .iter()\n+            .filter(|path| !is_item_in_array(path, removed))",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2011393255",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26369,
        "pr_file": "crates/gpui/src/platform/windows/destination_list.rs",
        "discussion_id": "2011393255",
        "commented_code": "@@ -0,0 +1,189 @@\n+use itertools::Itertools;\n+use windows::{\n+    core::{Interface, GUID, HSTRING},\n+    Win32::{\n+        Foundation::PROPERTYKEY,\n+        System::Com::{CoCreateInstance, StructuredStorage::PROPVARIANT, CLSCTX_INPROC_SERVER},\n+        UI::Shell::{\n+            Common::{IObjectArray, IObjectCollection},\n+            DestinationList, EnumerableObjectCollection, ICustomDestinationList, IShellLinkW,\n+            PropertiesSystem::IPropertyStore,\n+            ShellLink,\n+        },\n+    },\n+};\n+\n+use crate::{Action, MenuItem};\n+\n+pub(crate) struct DockMenuItem {\n+    pub(crate) name: String,\n+    pub(crate) description: String,\n+    pub(crate) action: Box<dyn Action>,\n+}\n+\n+impl DockMenuItem {\n+    pub(crate) fn new(item: MenuItem) -> anyhow::Result<Self> {\n+        match item {\n+            MenuItem::Action { name, action, .. } => Ok(Self {\n+                name: name.clone().into(),\n+                description: if name == \"New Window\" {\n+                    \"Opens a new window\".to_string()\n+                } else {\n+                    name.into()\n+                },\n+                action,\n+            }),\n+            _ => Err(anyhow::anyhow!(\n+                \"Only `MenuItem::Action` is supported for dock menu on Windows.\"\n+            )),\n+        }\n+    }\n+}\n+\n+// https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/winui/shell/appshellintegration/RecipePropertyHandler/RecipePropertyHandler.cpp\n+pub(crate) fn update_jump_list(\n+    entries: &[&Vec<String>],\n+    dock_menus: &[DockMenuItem],\n+) -> anyhow::Result<Option<Vec<Vec<String>>>> {\n+    let (list, removed) = create_destination_list()?;\n+    add_recent_folders(&list, entries, removed.as_ref())?;\n+    add_dock_menu(&list, dock_menus)?;\n+    unsafe { list.CommitList() }?;\n+    Ok(removed)\n+}\n+\n+const PKEY_TITLE: PROPERTYKEY = PROPERTYKEY {\n+    fmtid: GUID::from_u128(0xf29f85e0_4ff9_1068_ab91_08002b27b3d9),\n+    pid: 2,\n+};\n+\n+const PKEY_LINK_ARGS: PROPERTYKEY = PROPERTYKEY {\n+    fmtid: GUID::from_u128(0x436f2667_14e2_4feb_b30a_146c53b5b674),\n+    pid: 100,\n+};\n+\n+fn create_destination_list() -> anyhow::Result<(ICustomDestinationList, Option<Vec<Vec<String>>>)> {\n+    let list: ICustomDestinationList =\n+        unsafe { CoCreateInstance(&DestinationList, None, CLSCTX_INPROC_SERVER) }?;\n+\n+    let mut slots = 0;\n+    let user_removed: IObjectArray = unsafe { list.BeginList(&mut slots) }?;\n+\n+    let count = unsafe { user_removed.GetCount() }?;\n+    if count == 0 {\n+        return Ok((list, None));\n+    }\n+\n+    let mut removed = Vec::with_capacity(count as usize);\n+    for i in 0..count {\n+        let shell_link: IShellLinkW = unsafe { user_removed.GetAt(i)? };\n+        let store: IPropertyStore = shell_link.cast()?;\n+        let argument = unsafe { store.GetValue(&PKEY_LINK_ARGS)? };\n+        let args = argument\n+            .to_string()\n+            .split_whitespace()\n+            .map(|s| s.trim_matches('\"').to_string())\n+            .collect_vec();\n+\n+        removed.push(args);\n+    }\n+\n+    Ok((list, Some(removed)))\n+}\n+\n+fn add_dock_menu(list: &ICustomDestinationList, dock_menus: &[DockMenuItem]) -> anyhow::Result<()> {\n+    unsafe {\n+        let tasks: IObjectCollection =\n+            CoCreateInstance(&EnumerableObjectCollection, None, CLSCTX_INPROC_SERVER)?;\n+        for (idx, dock_menu) in dock_menus.iter().enumerate() {\n+            let argument = HSTRING::from(format!(\"--dock-action {}\", idx));\n+            let description = HSTRING::from(dock_menu.description.as_str());\n+            let display = dock_menu.name.as_str();\n+            let task = create_shell_link(argument, description, None, display)?;\n+            tasks.AddObject(&task)?;\n+        }\n+        list.AddUserTasks(&tasks)?;\n+        Ok(())\n+    }\n+}\n+\n+fn add_recent_folders(\n+    list: &ICustomDestinationList,\n+    entries: &[&Vec<String>],\n+    removed: Option<&Vec<Vec<String>>>,\n+) -> anyhow::Result<()> {\n+    unsafe {\n+        let tasks: IObjectCollection =\n+            CoCreateInstance(&EnumerableObjectCollection, None, CLSCTX_INPROC_SERVER)?;\n+\n+        for folder_path in entries\n+            .iter()\n+            .filter(|path| !is_item_in_array(path, removed))",
        "comment_created_at": "2025-03-25T06:21:25+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "It looks like the interior `&Vec<String>` is being treated like a path? Is there any reason to not use a `&Path` here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2014173559",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26369,
        "pr_file": "crates/gpui/src/platform/windows/destination_list.rs",
        "discussion_id": "2011393255",
        "commented_code": "@@ -0,0 +1,189 @@\n+use itertools::Itertools;\n+use windows::{\n+    core::{Interface, GUID, HSTRING},\n+    Win32::{\n+        Foundation::PROPERTYKEY,\n+        System::Com::{CoCreateInstance, StructuredStorage::PROPVARIANT, CLSCTX_INPROC_SERVER},\n+        UI::Shell::{\n+            Common::{IObjectArray, IObjectCollection},\n+            DestinationList, EnumerableObjectCollection, ICustomDestinationList, IShellLinkW,\n+            PropertiesSystem::IPropertyStore,\n+            ShellLink,\n+        },\n+    },\n+};\n+\n+use crate::{Action, MenuItem};\n+\n+pub(crate) struct DockMenuItem {\n+    pub(crate) name: String,\n+    pub(crate) description: String,\n+    pub(crate) action: Box<dyn Action>,\n+}\n+\n+impl DockMenuItem {\n+    pub(crate) fn new(item: MenuItem) -> anyhow::Result<Self> {\n+        match item {\n+            MenuItem::Action { name, action, .. } => Ok(Self {\n+                name: name.clone().into(),\n+                description: if name == \"New Window\" {\n+                    \"Opens a new window\".to_string()\n+                } else {\n+                    name.into()\n+                },\n+                action,\n+            }),\n+            _ => Err(anyhow::anyhow!(\n+                \"Only `MenuItem::Action` is supported for dock menu on Windows.\"\n+            )),\n+        }\n+    }\n+}\n+\n+// https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/winui/shell/appshellintegration/RecipePropertyHandler/RecipePropertyHandler.cpp\n+pub(crate) fn update_jump_list(\n+    entries: &[&Vec<String>],\n+    dock_menus: &[DockMenuItem],\n+) -> anyhow::Result<Option<Vec<Vec<String>>>> {\n+    let (list, removed) = create_destination_list()?;\n+    add_recent_folders(&list, entries, removed.as_ref())?;\n+    add_dock_menu(&list, dock_menus)?;\n+    unsafe { list.CommitList() }?;\n+    Ok(removed)\n+}\n+\n+const PKEY_TITLE: PROPERTYKEY = PROPERTYKEY {\n+    fmtid: GUID::from_u128(0xf29f85e0_4ff9_1068_ab91_08002b27b3d9),\n+    pid: 2,\n+};\n+\n+const PKEY_LINK_ARGS: PROPERTYKEY = PROPERTYKEY {\n+    fmtid: GUID::from_u128(0x436f2667_14e2_4feb_b30a_146c53b5b674),\n+    pid: 100,\n+};\n+\n+fn create_destination_list() -> anyhow::Result<(ICustomDestinationList, Option<Vec<Vec<String>>>)> {\n+    let list: ICustomDestinationList =\n+        unsafe { CoCreateInstance(&DestinationList, None, CLSCTX_INPROC_SERVER) }?;\n+\n+    let mut slots = 0;\n+    let user_removed: IObjectArray = unsafe { list.BeginList(&mut slots) }?;\n+\n+    let count = unsafe { user_removed.GetCount() }?;\n+    if count == 0 {\n+        return Ok((list, None));\n+    }\n+\n+    let mut removed = Vec::with_capacity(count as usize);\n+    for i in 0..count {\n+        let shell_link: IShellLinkW = unsafe { user_removed.GetAt(i)? };\n+        let store: IPropertyStore = shell_link.cast()?;\n+        let argument = unsafe { store.GetValue(&PKEY_LINK_ARGS)? };\n+        let args = argument\n+            .to_string()\n+            .split_whitespace()\n+            .map(|s| s.trim_matches('\"').to_string())\n+            .collect_vec();\n+\n+        removed.push(args);\n+    }\n+\n+    Ok((list, Some(removed)))\n+}\n+\n+fn add_dock_menu(list: &ICustomDestinationList, dock_menus: &[DockMenuItem]) -> anyhow::Result<()> {\n+    unsafe {\n+        let tasks: IObjectCollection =\n+            CoCreateInstance(&EnumerableObjectCollection, None, CLSCTX_INPROC_SERVER)?;\n+        for (idx, dock_menu) in dock_menus.iter().enumerate() {\n+            let argument = HSTRING::from(format!(\"--dock-action {}\", idx));\n+            let description = HSTRING::from(dock_menu.description.as_str());\n+            let display = dock_menu.name.as_str();\n+            let task = create_shell_link(argument, description, None, display)?;\n+            tasks.AddObject(&task)?;\n+        }\n+        list.AddUserTasks(&tasks)?;\n+        Ok(())\n+    }\n+}\n+\n+fn add_recent_folders(\n+    list: &ICustomDestinationList,\n+    entries: &[&Vec<String>],\n+    removed: Option<&Vec<Vec<String>>>,\n+) -> anyhow::Result<()> {\n+    unsafe {\n+        let tasks: IObjectCollection =\n+            CoCreateInstance(&EnumerableObjectCollection, None, CLSCTX_INPROC_SERVER)?;\n+\n+        for folder_path in entries\n+            .iter()\n+            .filter(|path| !is_item_in_array(path, removed))",
        "comment_created_at": "2025-03-26T13:41:26+00:00",
        "comment_author": "JunkuiZhang",
        "comment_body": "I've changed it to `PathBuf`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1968981370",
    "pr_number": 25517,
    "pr_file": "crates/diagnostics/src/diagnostics.rs",
    "created_at": "2025-02-25T05:48:30+00:00",
    "commented_code": "cx: &mut Context<Workspace>,\n     ) {\n         if let Some(existing) = workspace.item_of_type::<ProjectDiagnosticsEditor>(cx) {\n-            workspace.activate_item(&existing, true, true, window, cx);\n+            let is_active = workspace\n+                .active_item(cx)\n+                .map(|item| item.item_id() == existing.item_id())\n+                .unwrap_or(false);",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1968981370",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 25517,
        "pr_file": "crates/diagnostics/src/diagnostics.rs",
        "discussion_id": "1968981370",
        "commented_code": "@@ -280,7 +280,11 @@ impl ProjectDiagnosticsEditor {\n         cx: &mut Context<Workspace>,\n     ) {\n         if let Some(existing) = workspace.item_of_type::<ProjectDiagnosticsEditor>(cx) {\n-            workspace.activate_item(&existing, true, true, window, cx);\n+            let is_active = workspace\n+                .active_item(cx)\n+                .map(|item| item.item_id() == existing.item_id())\n+                .unwrap_or(false);",
        "comment_created_at": "2025-02-25T05:48:30+00:00",
        "comment_author": "Anthony-Eid",
        "comment_body": "This is a nit, but using `is_some_and()` would show your intent better here\r\n\r\n```rust\r\nlet is_active = workspace\r\n    .active_item(cx)\r\n    .is_some_and(|item| item.item_id() == existing.item_id());\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1969002720",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 25517,
        "pr_file": "crates/diagnostics/src/diagnostics.rs",
        "discussion_id": "1968981370",
        "commented_code": "@@ -280,7 +280,11 @@ impl ProjectDiagnosticsEditor {\n         cx: &mut Context<Workspace>,\n     ) {\n         if let Some(existing) = workspace.item_of_type::<ProjectDiagnosticsEditor>(cx) {\n-            workspace.activate_item(&existing, true, true, window, cx);\n+            let is_active = workspace\n+                .active_item(cx)\n+                .map(|item| item.item_id() == existing.item_id())\n+                .unwrap_or(false);",
        "comment_created_at": "2025-02-25T06:06:19+00:00",
        "comment_author": "5brian",
        "comment_body": "thank you",
        "pr_file_module": null
      }
    ]
  }
]