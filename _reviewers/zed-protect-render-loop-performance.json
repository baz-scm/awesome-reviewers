[
  {
    "discussion_id": "2177365235",
    "pr_number": 33490,
    "pr_file": "crates/outline_panel/src/outline_panel.rs",
    "created_at": "2025-07-01T11:36:58+00:00",
    "commented_code": "_ => false,\n         };\n \n-        let icon = if self.is_singleton_active(cx) {\n-            None\n+        // Check if this outline has children by looking at the next entries\n+        let has_children = self.has_outline_children(outline, cx);",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2177365235",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 33490,
        "pr_file": "crates/outline_panel/src/outline_panel.rs",
        "discussion_id": "2177365235",
        "commented_code": "@@ -2149,11 +2218,24 @@ impl OutlinePanel {\n             _ => false,\n         };\n \n-        let icon = if self.is_singleton_active(cx) {\n-            None\n+        // Check if this outline has children by looking at the next entries\n+        let has_children = self.has_outline_children(outline, cx);",
        "comment_created_at": "2025-07-01T11:36:58+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "It's not superb that we have to use this method during __rendering__ , that might happen fast, e.g. 120 times/second: and we loop over outlines in a potentially large file.\r\n\r\nWhat's more odd, is that we call `render_outline(` in a loop over every item to render, so should know whether the outline has children or not.\r\n\r\nSeems that we can rewrite it into something better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1908795934",
    "pr_number": 22668,
    "pr_file": "crates/editor/src/editor.rs",
    "created_at": "2025-01-09T13:25:23+00:00",
    "commented_code": "None\n     }\n \n+    pub fn render_diagnostics_inline(&mut self, cx: &mut WindowContext) -> bool {\n+        self.show_diagnostics_inline && self.focus_handle.is_focused(cx)\n+    }\n+\n+    pub fn toggle_show_diagnostics_inline(\n+        &mut self,\n+        _: &ToggleShowDiagnosticsInline,\n+        cx: &mut ViewContext<Self>,\n+    ) {\n+        if self.show_diagnostics_inline_enabled {\n+            self.show_diagnostics_inline = false;\n+            self.show_diagnostics_inline_enabled = false;\n+            self.show_diagnostics_inline_delay_task.take();\n+        } else {\n+            self.show_diagnostics_inline = true;\n+            self.show_diagnostics_inline_enabled = true;\n+        }\n+\n+        cx.notify();\n+    }\n+\n+    fn start_show_diagnostics_inline(&mut self, cx: &mut ViewContext<Self>) {\n+        let delay = ProjectSettings::get_global(cx).diagnostics.inline().delay();\n+        if delay > 0 {\n+            self.show_diagnostics_inline = false;",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1908795934",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/editor/src/editor.rs",
        "discussion_id": "1908795934",
        "commented_code": "@@ -4349,6 +4363,47 @@ impl Editor {\n         None\n     }\n \n+    pub fn render_diagnostics_inline(&mut self, cx: &mut WindowContext) -> bool {\n+        self.show_diagnostics_inline && self.focus_handle.is_focused(cx)\n+    }\n+\n+    pub fn toggle_show_diagnostics_inline(\n+        &mut self,\n+        _: &ToggleShowDiagnosticsInline,\n+        cx: &mut ViewContext<Self>,\n+    ) {\n+        if self.show_diagnostics_inline_enabled {\n+            self.show_diagnostics_inline = false;\n+            self.show_diagnostics_inline_enabled = false;\n+            self.show_diagnostics_inline_delay_task.take();\n+        } else {\n+            self.show_diagnostics_inline = true;\n+            self.show_diagnostics_inline_enabled = true;\n+        }\n+\n+        cx.notify();\n+    }\n+\n+    fn start_show_diagnostics_inline(&mut self, cx: &mut ViewContext<Self>) {\n+        let delay = ProjectSettings::get_global(cx).diagnostics.inline().delay();\n+        if delay > 0 {\n+            self.show_diagnostics_inline = false;",
        "comment_created_at": "2025-01-09T13:25:23+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "`show_diagnostics_inline` is what alters the rendering logic, so this code will \"blink\" the diagnostics, if the delay is long enough: e.g for `\"delay_ms\": 500` after an edit, the diagnostics will stop rendering and editor will \"blink\", showing none at all first and 500+Nms later coming up with the new diagnostics.\r\n\r\nWhat if, instead, we rework the approach a bit?\r\nWe'll keep the only `show_diagnostics_inline` in `Editor` (altered via project settings), remove `show_diagnostics_inline_enabled` and altering the delay logic similar to https://github.com/zed-industries/zed/pull/21463 ?\r\n\r\nThe idea is to have a single \"is it enabled?\" flat on the editor level which allows updating the collection of diagnostics to render (can be stored in the editor's element or editor itself).\r\nWhen the flag goes down, the collection is cleared and not updated until the settings change and re-enable the flag.\r\n\r\nThe diagnostics' update happen after buffer edits and on special events (e.g. editor creation), debounced (50ms default seems ok?), so we do not recalculate diagnostics needlessly on quick user typing (current part of the config seems ok syntaxically, but needs a bump from 0ms).\r\n\r\nIf there's something in the collection, it gets rendered straight away, without any complex computations.",
        "pr_file_module": null
      },
      {
        "comment_id": "1912269805",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/editor/src/editor.rs",
        "discussion_id": "1908795934",
        "commented_code": "@@ -4349,6 +4363,47 @@ impl Editor {\n         None\n     }\n \n+    pub fn render_diagnostics_inline(&mut self, cx: &mut WindowContext) -> bool {\n+        self.show_diagnostics_inline && self.focus_handle.is_focused(cx)\n+    }\n+\n+    pub fn toggle_show_diagnostics_inline(\n+        &mut self,\n+        _: &ToggleShowDiagnosticsInline,\n+        cx: &mut ViewContext<Self>,\n+    ) {\n+        if self.show_diagnostics_inline_enabled {\n+            self.show_diagnostics_inline = false;\n+            self.show_diagnostics_inline_enabled = false;\n+            self.show_diagnostics_inline_delay_task.take();\n+        } else {\n+            self.show_diagnostics_inline = true;\n+            self.show_diagnostics_inline_enabled = true;\n+        }\n+\n+        cx.notify();\n+    }\n+\n+    fn start_show_diagnostics_inline(&mut self, cx: &mut ViewContext<Self>) {\n+        let delay = ProjectSettings::get_global(cx).diagnostics.inline().delay();\n+        if delay > 0 {\n+            self.show_diagnostics_inline = false;",
        "comment_created_at": "2025-01-11T22:33:08+00:00",
        "comment_author": "davisp",
        "comment_body": "I've read this comment (and all the others for that matter) a few times now and I'm not entirely sure what is being proposed. In the interest of getting us on the same page, I'll explain how the current approach works, and how I think you're proposing I should change it so that I don't go off doing something you weren't intending me to do.\r\n\r\nCurrently, the implementation is almost zero state other than the enabled flags and the config parameters that affect rendering. Every frame rendered checks if it should rendered inline diagnostics, and if so, grabs what should be currently visible, does a bit of math to translate from buffer coordinates to display coordinates, and then spits out whatever those flex box thingers are collectively known as, and paints them on screen. Specifically, I'm doing absolutely zero tracking of what diagnostics should be rendered as I just rely on the buffer snapshot to give me the correct list of diagnostics on each frame.\r\n\r\nWhat I *think* you're suggesting is that instead I should periodically get the set of diagnostics from the buffer, preprocess them, and then in the render pass I just grab the ones that are currently visible and paint them. So rather than relying on the buffer to maintain a stable set of diagnostics we force it by splitting the current implementation into a background pre-process step that happens at maximum every $debounce milliseconds. This way we're not flipping between states and we can also move some of the heavier work to outside of the render loop.\r\n\r\nAssuming I'm at least in the same timezone as correct, that all seems perfectly reasonable to me. I assume that diagnostic state should live on the editor with the pre-processing being driven by debouncing the `DiagnosticsUpdated` event you linked elsewhere.\r\n\r\nGiven that's a reasonably sized change, I'm gonna wait until you ack or clarify anything before I start working on it. For now I'll keep focusing on the actual rendering so we're still making progress there.",
        "pr_file_module": null
      },
      {
        "comment_id": "1912298626",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/editor/src/editor.rs",
        "discussion_id": "1908795934",
        "commented_code": "@@ -4349,6 +4363,47 @@ impl Editor {\n         None\n     }\n \n+    pub fn render_diagnostics_inline(&mut self, cx: &mut WindowContext) -> bool {\n+        self.show_diagnostics_inline && self.focus_handle.is_focused(cx)\n+    }\n+\n+    pub fn toggle_show_diagnostics_inline(\n+        &mut self,\n+        _: &ToggleShowDiagnosticsInline,\n+        cx: &mut ViewContext<Self>,\n+    ) {\n+        if self.show_diagnostics_inline_enabled {\n+            self.show_diagnostics_inline = false;\n+            self.show_diagnostics_inline_enabled = false;\n+            self.show_diagnostics_inline_delay_task.take();\n+        } else {\n+            self.show_diagnostics_inline = true;\n+            self.show_diagnostics_inline_enabled = true;\n+        }\n+\n+        cx.notify();\n+    }\n+\n+    fn start_show_diagnostics_inline(&mut self, cx: &mut ViewContext<Self>) {\n+        let delay = ProjectSettings::get_global(cx).diagnostics.inline().delay();\n+        if delay > 0 {\n+            self.show_diagnostics_inline = false;",
        "comment_created_at": "2025-01-11T23:31:13+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "Seems like a good summarization, I indeed propose to do less work on each frame, in particular\r\n\r\n> grabs what should be currently visible, does a bit of math to translate from buffer coordinates to display coordinates, and then spits out whatever those flex box thingers are collectively known as, and paints them on screen\r\n\r\nspecifically \"does a bit of math\" part is very concerning to me:\u00a0we have ~16.67ms per frame at best, and potentially very large documents with very large amount of errors, consider scenarios like project.rs from this repo which will have a particular `use` statement(s) malformed (which will trigger a lot of errors).\r\n\r\nWe also do sorting with `sorted_by_key` and all those coordinate transformations are logarithmic at best.\r\n\r\nI just cannot fathom any reason to do that bit of math if we can avoid doing that.\r\nSure, this can wait until other fixes, but has to be made eventually.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1908842266",
    "pr_number": 22668,
    "pr_file": "crates/editor/src/element.rs",
    "created_at": "2025-01-09T13:52:26+00:00",
    "commented_code": "})\n     }\n \n+    #[allow(clippy::too_many_arguments)]\n+    fn layout_inline_diagnostics(\n+        &self,\n+        snapshot: &EditorSnapshot,\n+        hitbox: &Hitbox,\n+        line_layouts: &[LineWithInvisibles],\n+        crease_trailers: &[Option<CreaseTrailerLayout>],\n+        content_origin: gpui::Point<Pixels>,\n+        start_row: DisplayRow,\n+        end_row: DisplayRow,\n+        scroll_pixel_position: gpui::Point<Pixels>,\n+        line_height: Pixels,\n+        em_width: Pixels,\n+        style: &EditorStyle,\n+        cx: &mut WindowContext,\n+    ) -> HashMap<DisplayRow, AnyElement> {\n+        if !self\n+            .editor\n+            .update(cx, |editor, cx| editor.render_diagnostics_inline(cx))\n+        {\n+            return Default::default();\n+        }\n+\n+        let diagnostics = self.gather_inline_diagnostics(\n+            snapshot,\n+            hitbox,\n+            line_layouts,\n+            crease_trailers,\n+            content_origin,\n+            scroll_pixel_position,\n+            line_height,\n+            em_width,\n+            start_row,\n+            end_row,\n+            cx,\n+        );\n+\n+        let sev_to_color = |sev: &DiagnosticSeverity| match sev {\n+            &DiagnosticSeverity::ERROR => Color::Error,\n+            &DiagnosticSeverity::WARNING => Color::Warning,\n+            &DiagnosticSeverity::INFORMATION => Color::Info,\n+            &DiagnosticSeverity::HINT => Color::Hint,\n+            _ => Color::Error,\n+        };\n+\n+        let hover_action = ProjectSettings::get_global(cx).diagnostics.inline().hover();\n+\n+        let mut elements = HashMap::default();\n+        for (line_ix, elem) in diagnostics.into_iter() {\n+            let mut boxes = h_flex().size(line_height).w_full().h_full().gap_1();\n+            for (idx, disp) in elem.entries.iter().enumerate() {\n+                let indicator = Icon::new(IconName::Square)\n+                    .color(sev_to_color(&disp.severity))\n+                    .size(IconSize::Medium);\n+\n+                let tooltip = disp.tooltip.clone();\n+\n+                let div = h_flex()\n+                    .id(SharedString::from(format!(\n+                        \"diagnostic-entry-{}-{}\",\n+                        line_ix.0, idx\n+                    )))\n+                    .size(line_height)\n+                    .h_full()\n+                    .w_full()\n+                    .child(indicator);\n+\n+                let div = if matches!(hover_action, InlineDiagnosticHoverAction::Tooltip) {\n+                    div.hoverable_tooltip(move |_| tooltip.clone().into())\n+                } else if matches!(hover_action, InlineDiagnosticHoverAction::Inline) {\n+                    div.hover(|style| style.bg(cx.theme().colors().element_hover))\n+                        .on_hover({\n+                            let editor = self.editor.clone();\n+                            let group_id = disp.group_id;\n+                            move |hovered, cx| {\n+                                editor.update(cx, |editor, cx| {\n+                                    let current_group = editor\n+                                        .active_diagnostics\n+                                        .as_ref()\n+                                        .map(|group| group.group_id);\n+                                    if *hovered && Some(group_id) != current_group {\n+                                        editor.activate_diagnostics(group_id, cx);\n+                                    }\n+                                });\n+                            }\n+                        })\n+                } else {\n+                    div\n+                };\n+\n+                boxes = boxes.child(div);\n+            }\n+\n+            let boxes = if elem.exceeded_max {\n+                boxes.child(\n+                    h_flex()\n+                        .size(line_height)\n+                        .h_full()\n+                        .w_full()\n+                        .bg(Color::Info.color(cx).opacity(0.25))\n+                        .child(\n+                            Icon::new(IconName::Plus)\n+                                .color(Color::Info)\n+                                .size(IconSize::Medium),\n+                        ),\n+                )\n+            } else {\n+                boxes\n+            };\n+\n+            let mut element = h_flex()\n+                .id(SharedString::from(format!(\"diagnostic-{}\", line_ix.0)))\n+                .h(line_height)\n+                .w_full()\n+                .bg(sev_to_color(&elem.severity).color(cx).opacity(0.07))\n+                .text_color(sev_to_color(&elem.severity).color(cx))\n+                .text_sm()\n+                .font_family(style.text.font().family)\n+                .child(\n+                    h_flex()\n+                        .h(line_height)\n+                        .gap_2()\n+                        .child(boxes)\n+                        .child(elem.message),\n+                )\n+                .into_any();\n+\n+            element.prepaint_as_root(point(elem.x, elem.y), AvailableSpace::min_size(), cx);\n+            elements.insert(line_ix, element);\n+        }\n+\n+        elements\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn gather_inline_diagnostics(",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1908842266",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/editor/src/element.rs",
        "discussion_id": "1908842266",
        "commented_code": "@@ -1558,6 +1589,258 @@ impl EditorElement {\n         })\n     }\n \n+    #[allow(clippy::too_many_arguments)]\n+    fn layout_inline_diagnostics(\n+        &self,\n+        snapshot: &EditorSnapshot,\n+        hitbox: &Hitbox,\n+        line_layouts: &[LineWithInvisibles],\n+        crease_trailers: &[Option<CreaseTrailerLayout>],\n+        content_origin: gpui::Point<Pixels>,\n+        start_row: DisplayRow,\n+        end_row: DisplayRow,\n+        scroll_pixel_position: gpui::Point<Pixels>,\n+        line_height: Pixels,\n+        em_width: Pixels,\n+        style: &EditorStyle,\n+        cx: &mut WindowContext,\n+    ) -> HashMap<DisplayRow, AnyElement> {\n+        if !self\n+            .editor\n+            .update(cx, |editor, cx| editor.render_diagnostics_inline(cx))\n+        {\n+            return Default::default();\n+        }\n+\n+        let diagnostics = self.gather_inline_diagnostics(\n+            snapshot,\n+            hitbox,\n+            line_layouts,\n+            crease_trailers,\n+            content_origin,\n+            scroll_pixel_position,\n+            line_height,\n+            em_width,\n+            start_row,\n+            end_row,\n+            cx,\n+        );\n+\n+        let sev_to_color = |sev: &DiagnosticSeverity| match sev {\n+            &DiagnosticSeverity::ERROR => Color::Error,\n+            &DiagnosticSeverity::WARNING => Color::Warning,\n+            &DiagnosticSeverity::INFORMATION => Color::Info,\n+            &DiagnosticSeverity::HINT => Color::Hint,\n+            _ => Color::Error,\n+        };\n+\n+        let hover_action = ProjectSettings::get_global(cx).diagnostics.inline().hover();\n+\n+        let mut elements = HashMap::default();\n+        for (line_ix, elem) in diagnostics.into_iter() {\n+            let mut boxes = h_flex().size(line_height).w_full().h_full().gap_1();\n+            for (idx, disp) in elem.entries.iter().enumerate() {\n+                let indicator = Icon::new(IconName::Square)\n+                    .color(sev_to_color(&disp.severity))\n+                    .size(IconSize::Medium);\n+\n+                let tooltip = disp.tooltip.clone();\n+\n+                let div = h_flex()\n+                    .id(SharedString::from(format!(\n+                        \"diagnostic-entry-{}-{}\",\n+                        line_ix.0, idx\n+                    )))\n+                    .size(line_height)\n+                    .h_full()\n+                    .w_full()\n+                    .child(indicator);\n+\n+                let div = if matches!(hover_action, InlineDiagnosticHoverAction::Tooltip) {\n+                    div.hoverable_tooltip(move |_| tooltip.clone().into())\n+                } else if matches!(hover_action, InlineDiagnosticHoverAction::Inline) {\n+                    div.hover(|style| style.bg(cx.theme().colors().element_hover))\n+                        .on_hover({\n+                            let editor = self.editor.clone();\n+                            let group_id = disp.group_id;\n+                            move |hovered, cx| {\n+                                editor.update(cx, |editor, cx| {\n+                                    let current_group = editor\n+                                        .active_diagnostics\n+                                        .as_ref()\n+                                        .map(|group| group.group_id);\n+                                    if *hovered && Some(group_id) != current_group {\n+                                        editor.activate_diagnostics(group_id, cx);\n+                                    }\n+                                });\n+                            }\n+                        })\n+                } else {\n+                    div\n+                };\n+\n+                boxes = boxes.child(div);\n+            }\n+\n+            let boxes = if elem.exceeded_max {\n+                boxes.child(\n+                    h_flex()\n+                        .size(line_height)\n+                        .h_full()\n+                        .w_full()\n+                        .bg(Color::Info.color(cx).opacity(0.25))\n+                        .child(\n+                            Icon::new(IconName::Plus)\n+                                .color(Color::Info)\n+                                .size(IconSize::Medium),\n+                        ),\n+                )\n+            } else {\n+                boxes\n+            };\n+\n+            let mut element = h_flex()\n+                .id(SharedString::from(format!(\"diagnostic-{}\", line_ix.0)))\n+                .h(line_height)\n+                .w_full()\n+                .bg(sev_to_color(&elem.severity).color(cx).opacity(0.07))\n+                .text_color(sev_to_color(&elem.severity).color(cx))\n+                .text_sm()\n+                .font_family(style.text.font().family)\n+                .child(\n+                    h_flex()\n+                        .h(line_height)\n+                        .gap_2()\n+                        .child(boxes)\n+                        .child(elem.message),\n+                )\n+                .into_any();\n+\n+            element.prepaint_as_root(point(elem.x, elem.y), AvailableSpace::min_size(), cx);\n+            elements.insert(line_ix, element);\n+        }\n+\n+        elements\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn gather_inline_diagnostics(",
        "comment_created_at": "2025-01-09T13:52:26+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "This is a code with a lot of tree traversals (`display_point_to_point`, `point_to_display_point` and other coordinate transform, `diagnostics_in_range` lookup) and various allocations and whatever sorting on top.\r\n\r\nAll that has a lifecycle of `let diagnostics = self.gather_inline_diagnostics(`, and `layout.inline_diagnostics.drain()` on the other end, so sort of thrown away.\r\n\r\nThis all is done on each frame* potentially 120 times/second, and to me it seems we can try and rewrite the logic so that it scales better: traversing thousands of diagnostics with various tree-manipulations on the side does not seem fun to fit into a frame.\r\n\r\nI've mentioned a proposal in the editor.rs part: we might want to debounce any attempt to update the diagnostics data (unless it's a data purge after disabling the diagnostics); keep the old state as long as possible, swapping it to the new one which is calculated after an edit; keep renrendering that part",
        "pr_file_module": null
      },
      {
        "comment_id": "1914977120",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/editor/src/element.rs",
        "discussion_id": "1908842266",
        "commented_code": "@@ -1558,6 +1589,258 @@ impl EditorElement {\n         })\n     }\n \n+    #[allow(clippy::too_many_arguments)]\n+    fn layout_inline_diagnostics(\n+        &self,\n+        snapshot: &EditorSnapshot,\n+        hitbox: &Hitbox,\n+        line_layouts: &[LineWithInvisibles],\n+        crease_trailers: &[Option<CreaseTrailerLayout>],\n+        content_origin: gpui::Point<Pixels>,\n+        start_row: DisplayRow,\n+        end_row: DisplayRow,\n+        scroll_pixel_position: gpui::Point<Pixels>,\n+        line_height: Pixels,\n+        em_width: Pixels,\n+        style: &EditorStyle,\n+        cx: &mut WindowContext,\n+    ) -> HashMap<DisplayRow, AnyElement> {\n+        if !self\n+            .editor\n+            .update(cx, |editor, cx| editor.render_diagnostics_inline(cx))\n+        {\n+            return Default::default();\n+        }\n+\n+        let diagnostics = self.gather_inline_diagnostics(\n+            snapshot,\n+            hitbox,\n+            line_layouts,\n+            crease_trailers,\n+            content_origin,\n+            scroll_pixel_position,\n+            line_height,\n+            em_width,\n+            start_row,\n+            end_row,\n+            cx,\n+        );\n+\n+        let sev_to_color = |sev: &DiagnosticSeverity| match sev {\n+            &DiagnosticSeverity::ERROR => Color::Error,\n+            &DiagnosticSeverity::WARNING => Color::Warning,\n+            &DiagnosticSeverity::INFORMATION => Color::Info,\n+            &DiagnosticSeverity::HINT => Color::Hint,\n+            _ => Color::Error,\n+        };\n+\n+        let hover_action = ProjectSettings::get_global(cx).diagnostics.inline().hover();\n+\n+        let mut elements = HashMap::default();\n+        for (line_ix, elem) in diagnostics.into_iter() {\n+            let mut boxes = h_flex().size(line_height).w_full().h_full().gap_1();\n+            for (idx, disp) in elem.entries.iter().enumerate() {\n+                let indicator = Icon::new(IconName::Square)\n+                    .color(sev_to_color(&disp.severity))\n+                    .size(IconSize::Medium);\n+\n+                let tooltip = disp.tooltip.clone();\n+\n+                let div = h_flex()\n+                    .id(SharedString::from(format!(\n+                        \"diagnostic-entry-{}-{}\",\n+                        line_ix.0, idx\n+                    )))\n+                    .size(line_height)\n+                    .h_full()\n+                    .w_full()\n+                    .child(indicator);\n+\n+                let div = if matches!(hover_action, InlineDiagnosticHoverAction::Tooltip) {\n+                    div.hoverable_tooltip(move |_| tooltip.clone().into())\n+                } else if matches!(hover_action, InlineDiagnosticHoverAction::Inline) {\n+                    div.hover(|style| style.bg(cx.theme().colors().element_hover))\n+                        .on_hover({\n+                            let editor = self.editor.clone();\n+                            let group_id = disp.group_id;\n+                            move |hovered, cx| {\n+                                editor.update(cx, |editor, cx| {\n+                                    let current_group = editor\n+                                        .active_diagnostics\n+                                        .as_ref()\n+                                        .map(|group| group.group_id);\n+                                    if *hovered && Some(group_id) != current_group {\n+                                        editor.activate_diagnostics(group_id, cx);\n+                                    }\n+                                });\n+                            }\n+                        })\n+                } else {\n+                    div\n+                };\n+\n+                boxes = boxes.child(div);\n+            }\n+\n+            let boxes = if elem.exceeded_max {\n+                boxes.child(\n+                    h_flex()\n+                        .size(line_height)\n+                        .h_full()\n+                        .w_full()\n+                        .bg(Color::Info.color(cx).opacity(0.25))\n+                        .child(\n+                            Icon::new(IconName::Plus)\n+                                .color(Color::Info)\n+                                .size(IconSize::Medium),\n+                        ),\n+                )\n+            } else {\n+                boxes\n+            };\n+\n+            let mut element = h_flex()\n+                .id(SharedString::from(format!(\"diagnostic-{}\", line_ix.0)))\n+                .h(line_height)\n+                .w_full()\n+                .bg(sev_to_color(&elem.severity).color(cx).opacity(0.07))\n+                .text_color(sev_to_color(&elem.severity).color(cx))\n+                .text_sm()\n+                .font_family(style.text.font().family)\n+                .child(\n+                    h_flex()\n+                        .h(line_height)\n+                        .gap_2()\n+                        .child(boxes)\n+                        .child(elem.message),\n+                )\n+                .into_any();\n+\n+            element.prepaint_as_root(point(elem.x, elem.y), AvailableSpace::min_size(), cx);\n+            elements.insert(line_ix, element);\n+        }\n+\n+        elements\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn gather_inline_diagnostics(",
        "comment_created_at": "2025-01-14T14:57:48+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "Just to be more specific, I've got a file with a lot of diagnostics.\r\n\r\n[rust-analyzer-repro-long-diagnostics.zip](https://github.com/user-attachments/files/18411900/rust-analyzer-repro-long-diagnostics.zip)\r\n\r\nand there, I've opened the file both in `Nightly` and my local `--release` build of this branch.\r\nWaited until all diagnostics are shown, and started scrolling through the file, nothing else, profiling.\r\n\r\nBoth versions behave poorly, but the traces show drastic difference in the reasons to do so:\r\n\r\nNightly has some line layout and tree-sitter-query-related issues:\r\n![Nightly](https://github.com/user-attachments/assets/565631de-1b6a-41aa-8a24-0146f35fa880)\r\n\r\nThe branch build does all that diagnostics-related work including extra allocations, not explicitly mentioned in the comment above:\r\n![Dev](https://github.com/user-attachments/assets/9cc29382-9bca-4658-8c61-71a4e762d4b5)",
        "pr_file_module": null
      },
      {
        "comment_id": "1944853837",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/editor/src/element.rs",
        "discussion_id": "1908842266",
        "commented_code": "@@ -1558,6 +1589,258 @@ impl EditorElement {\n         })\n     }\n \n+    #[allow(clippy::too_many_arguments)]\n+    fn layout_inline_diagnostics(\n+        &self,\n+        snapshot: &EditorSnapshot,\n+        hitbox: &Hitbox,\n+        line_layouts: &[LineWithInvisibles],\n+        crease_trailers: &[Option<CreaseTrailerLayout>],\n+        content_origin: gpui::Point<Pixels>,\n+        start_row: DisplayRow,\n+        end_row: DisplayRow,\n+        scroll_pixel_position: gpui::Point<Pixels>,\n+        line_height: Pixels,\n+        em_width: Pixels,\n+        style: &EditorStyle,\n+        cx: &mut WindowContext,\n+    ) -> HashMap<DisplayRow, AnyElement> {\n+        if !self\n+            .editor\n+            .update(cx, |editor, cx| editor.render_diagnostics_inline(cx))\n+        {\n+            return Default::default();\n+        }\n+\n+        let diagnostics = self.gather_inline_diagnostics(\n+            snapshot,\n+            hitbox,\n+            line_layouts,\n+            crease_trailers,\n+            content_origin,\n+            scroll_pixel_position,\n+            line_height,\n+            em_width,\n+            start_row,\n+            end_row,\n+            cx,\n+        );\n+\n+        let sev_to_color = |sev: &DiagnosticSeverity| match sev {\n+            &DiagnosticSeverity::ERROR => Color::Error,\n+            &DiagnosticSeverity::WARNING => Color::Warning,\n+            &DiagnosticSeverity::INFORMATION => Color::Info,\n+            &DiagnosticSeverity::HINT => Color::Hint,\n+            _ => Color::Error,\n+        };\n+\n+        let hover_action = ProjectSettings::get_global(cx).diagnostics.inline().hover();\n+\n+        let mut elements = HashMap::default();\n+        for (line_ix, elem) in diagnostics.into_iter() {\n+            let mut boxes = h_flex().size(line_height).w_full().h_full().gap_1();\n+            for (idx, disp) in elem.entries.iter().enumerate() {\n+                let indicator = Icon::new(IconName::Square)\n+                    .color(sev_to_color(&disp.severity))\n+                    .size(IconSize::Medium);\n+\n+                let tooltip = disp.tooltip.clone();\n+\n+                let div = h_flex()\n+                    .id(SharedString::from(format!(\n+                        \"diagnostic-entry-{}-{}\",\n+                        line_ix.0, idx\n+                    )))\n+                    .size(line_height)\n+                    .h_full()\n+                    .w_full()\n+                    .child(indicator);\n+\n+                let div = if matches!(hover_action, InlineDiagnosticHoverAction::Tooltip) {\n+                    div.hoverable_tooltip(move |_| tooltip.clone().into())\n+                } else if matches!(hover_action, InlineDiagnosticHoverAction::Inline) {\n+                    div.hover(|style| style.bg(cx.theme().colors().element_hover))\n+                        .on_hover({\n+                            let editor = self.editor.clone();\n+                            let group_id = disp.group_id;\n+                            move |hovered, cx| {\n+                                editor.update(cx, |editor, cx| {\n+                                    let current_group = editor\n+                                        .active_diagnostics\n+                                        .as_ref()\n+                                        .map(|group| group.group_id);\n+                                    if *hovered && Some(group_id) != current_group {\n+                                        editor.activate_diagnostics(group_id, cx);\n+                                    }\n+                                });\n+                            }\n+                        })\n+                } else {\n+                    div\n+                };\n+\n+                boxes = boxes.child(div);\n+            }\n+\n+            let boxes = if elem.exceeded_max {\n+                boxes.child(\n+                    h_flex()\n+                        .size(line_height)\n+                        .h_full()\n+                        .w_full()\n+                        .bg(Color::Info.color(cx).opacity(0.25))\n+                        .child(\n+                            Icon::new(IconName::Plus)\n+                                .color(Color::Info)\n+                                .size(IconSize::Medium),\n+                        ),\n+                )\n+            } else {\n+                boxes\n+            };\n+\n+            let mut element = h_flex()\n+                .id(SharedString::from(format!(\"diagnostic-{}\", line_ix.0)))\n+                .h(line_height)\n+                .w_full()\n+                .bg(sev_to_color(&elem.severity).color(cx).opacity(0.07))\n+                .text_color(sev_to_color(&elem.severity).color(cx))\n+                .text_sm()\n+                .font_family(style.text.font().family)\n+                .child(\n+                    h_flex()\n+                        .h(line_height)\n+                        .gap_2()\n+                        .child(boxes)\n+                        .child(elem.message),\n+                )\n+                .into_any();\n+\n+            element.prepaint_as_root(point(elem.x, elem.y), AvailableSpace::min_size(), cx);\n+            elements.insert(line_ix, element);\n+        }\n+\n+        elements\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn gather_inline_diagnostics(",
        "comment_created_at": "2025-02-06T14:44:33+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "After new design, numbers are back to something comparable with the rest of the code for the same exaggerated example:\r\n\r\n![image](https://github.com/user-attachments/assets/72ce4f9d-1d73-427e-96be-8641b6d61ada)\r\n\r\nand the heaviest stacktrace is related to layouting again.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1935525042",
    "pr_number": 23349,
    "pr_file": "crates/workspace/src/pane.rs",
    "created_at": "2025-01-30T12:24:50+00:00",
    "commented_code": ".read(cx)\n                             .item_for_entry(entry, cx)\n                             .and_then(|item| item.project_path(cx))\n-                            .map(|project_path| project_path.path);\n+                            .map(|project_path| project_path.path)\n+                            .map_or(None, |path| if path.exists() { Some(path) } else { None });",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1935525042",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 23349,
        "pr_file": "crates/workspace/src/pane.rs",
        "discussion_id": "1935525042",
        "commented_code": "@@ -2466,7 +2466,9 @@ impl Pane {\n                             .read(cx)\n                             .item_for_entry(entry, cx)\n                             .and_then(|item| item.project_path(cx))\n-                            .map(|project_path| project_path.path);\n+                            .map(|project_path| project_path.path)\n+                            .map_or(None, |path| if path.exists() { Some(path) } else { None });",
        "comment_created_at": "2025-01-30T12:24:50+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "> .exists()\r\n\r\n1. We prefer to avoid using `std::fs`-related methods and use `Fs` instead, https://github.com/zed-industries/zed/blob/5e210c083fc4d1a00c9a7dac7abf185351bb9b3e/crates/fs/src/fs.rs#L112 in this case.\r\n\r\n2. This is a rendering code, potentially called 120 times/second, calling whatever FS-related things here is madness.\r\nIs there another way we can check that file is outside of projects?\r\n\r\n3. We can be on remote, where the client will have no FS at all.",
        "pr_file_module": null
      }
    ]
  }
]