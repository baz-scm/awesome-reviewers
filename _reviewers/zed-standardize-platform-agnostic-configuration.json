[
  {
    "discussion_id": "2150502946",
    "pr_number": 29718,
    "pr_file": "crates/gpui/src/platform/blade/blade_renderer.rs",
    "created_at": "2025-06-16T17:26:26+00:00",
    "commented_code": "window: &I,\n         config: BladeSurfaceConfig,\n     ) -> anyhow::Result<Self> {\n+        // workaround for https://github.com/zed-industries/zed/issues/26143\n+        let sample_count = std::env::var(\"ZED_SAMPLE_COUNT\")",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2150502946",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29718,
        "pr_file": "crates/gpui/src/platform/blade/blade_renderer.rs",
        "discussion_id": "2150502946",
        "commented_code": "@@ -331,6 +333,17 @@ impl BladeRenderer {\n         window: &I,\n         config: BladeSurfaceConfig,\n     ) -> anyhow::Result<Self> {\n+        // workaround for https://github.com/zed-industries/zed/issues/26143\n+        let sample_count = std::env::var(\"ZED_SAMPLE_COUNT\")",
        "comment_created_at": "2025-06-16T17:26:26+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "Let's actually make either environment variable work. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2151832870",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29718,
        "pr_file": "crates/gpui/src/platform/blade/blade_renderer.rs",
        "discussion_id": "2150502946",
        "commented_code": "@@ -331,6 +333,17 @@ impl BladeRenderer {\n         window: &I,\n         config: BladeSurfaceConfig,\n     ) -> anyhow::Result<Self> {\n+        // workaround for https://github.com/zed-industries/zed/issues/26143\n+        let sample_count = std::env::var(\"ZED_SAMPLE_COUNT\")",
        "comment_created_at": "2025-06-17T09:48:10+00:00",
        "comment_author": "sunli829",
        "comment_body": "Now both `ZED_SAMPLE_COUNT` and `ZED_PATH_SAMPLE_COUNT` work.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2116163189",
    "pr_number": 30490,
    "pr_file": "crates/paths/src/paths.rs",
    "created_at": "2025-05-30T15:45:10+00:00",
    "commented_code": "}\n             .join(\"zed\")\n         } else {\n-            home_dir().join(\".config\").join(\"zed\")\n+            let xdg_config_home = std::env::var_os(\"XDG_CONFIG_HOME\").and_then(|val| {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2116163189",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 30490,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2116163189",
        "commented_code": "@@ -78,7 +74,26 @@ pub fn config_dir() -> &'static PathBuf {\n             }\n             .join(\"zed\")\n         } else {\n-            home_dir().join(\".config\").join(\"zed\")\n+            let xdg_config_home = std::env::var_os(\"XDG_CONFIG_HOME\").and_then(|val| {",
        "comment_created_at": "2025-05-30T15:45:10+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "Rather than check these directly, I'd rather we used `dirs::config_dir()`",
        "pr_file_module": null
      },
      {
        "comment_id": "2116176922",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 30490,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2116163189",
        "commented_code": "@@ -78,7 +74,26 @@ pub fn config_dir() -> &'static PathBuf {\n             }\n             .join(\"zed\")\n         } else {\n-            home_dir().join(\".config\").join(\"zed\")\n+            let xdg_config_home = std::env::var_os(\"XDG_CONFIG_HOME\").and_then(|val| {",
        "comment_created_at": "2025-05-30T15:54:15+00:00",
        "comment_author": "chawyehsu",
        "comment_body": "Sorry but `dirs::config_dir()` is already used as a fallback in L84 below. And the point here is to support  `XDG_CONFIG_HOME` on non-Linux platforms.",
        "pr_file_module": null
      },
      {
        "comment_id": "2116189491",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 30490,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2116163189",
        "commented_code": "@@ -78,7 +74,26 @@ pub fn config_dir() -> &'static PathBuf {\n             }\n             .join(\"zed\")\n         } else {\n-            home_dir().join(\".config\").join(\"zed\")\n+            let xdg_config_home = std::env::var_os(\"XDG_CONFIG_HOME\").and_then(|val| {",
        "comment_created_at": "2025-05-30T16:02:43+00:00",
        "comment_author": "chawyehsu",
        "comment_body": "Btw `dirs` crate does not support XDG on non-Linux platforms. And if you are not familiar with the use of XDG spec on non-Linux platforms, I had a discussion recently about it in https://github.com/prefix-dev/pixi/issues/3757 where some context may help.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2073629462",
    "pr_number": 29924,
    "pr_file": "crates/assistant_tools/src/terminal_tool.rs",
    "created_at": "2025-05-05T15:03:34+00:00",
    "commented_code": "Ok(dir) => dir,\n             Err(err) => return Task::ready(Err(err)).into(),\n         };\n-        let command = get_system_shell();\n+        let command = {\n+            #[cfg(windows)]\n+            {\n+                get_windows_system_shell()\n+            }\n+            #[cfg(not(windows))]\n+            {\n+                \"bash\"",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2073629462",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29924,
        "pr_file": "crates/assistant_tools/src/terminal_tool.rs",
        "discussion_id": "2073629462",
        "commented_code": "@@ -99,17 +97,40 @@ impl Tool for TerminalTool {\n             Ok(dir) => dir,\n             Err(err) => return Task::ready(Err(err)).into(),\n         };\n-        let command = get_system_shell();\n+        let command = {\n+            #[cfg(windows)]\n+            {\n+                get_windows_system_shell()\n+            }\n+            #[cfg(not(windows))]\n+            {\n+                \"bash\"",
        "comment_created_at": "2025-05-05T15:03:34+00:00",
        "comment_author": "WeetHet",
        "comment_body": "This would make it impossible to use `agent` on system that don't have bash (e.g. systems with dash). We should at least fall back onto the login shell",
        "pr_file_module": null
      },
      {
        "comment_id": "2073671872",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 29924,
        "pr_file": "crates/assistant_tools/src/terminal_tool.rs",
        "discussion_id": "2073629462",
        "commented_code": "@@ -99,17 +97,40 @@ impl Tool for TerminalTool {\n             Ok(dir) => dir,\n             Err(err) => return Task::ready(Err(err)).into(),\n         };\n-        let command = get_system_shell();\n+        let command = {\n+            #[cfg(windows)]\n+            {\n+                get_windows_system_shell()\n+            }\n+            #[cfg(not(windows))]\n+            {\n+                \"bash\"",
        "comment_created_at": "2025-05-05T15:30:03+00:00",
        "comment_author": "cole-miller",
        "comment_body": "Fair point!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1999191791",
    "pr_number": 26886,
    "pr_file": "crates/paths/src/paths.rs",
    "created_at": "2025-03-17T16:39:36+00:00",
    "commented_code": "pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory if used.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default support directory.\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = if cfg!(target_os = \"windows\") && (dir.contains(r\"\\\") || dir.starts_with(r\"\\\\\")) {\n+            // Windows absolute path (e.g., \"C:\\path\" or \"\\\network\\path\")\n+            PathBuf::from(dir)\n+        } else if dir.starts_with(\"./\") || dir.starts_with(\"../\") || (!dir.starts_with(\"/\") && !cfg!(target_os = \"windows\")) {\n+            // Relative path on any OS (Linux/macOS: no leading \"/\", Windows: no drive letter or UNC)\n+            std::env::current_dir()",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1999191791",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "1999191791",
        "commented_code": "@@ -5,15 +5,45 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory if used.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default support directory.\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = if cfg!(target_os = \"windows\") && (dir.contains(r\"\\\") || dir.starts_with(r\"\\\\\")) {\n+            // Windows absolute path (e.g., \"C:\\path\" or \"\\\\network\\path\")\n+            PathBuf::from(dir)\n+        } else if dir.starts_with(\"./\") || dir.starts_with(\"../\") || (!dir.starts_with(\"/\") && !cfg!(target_os = \"windows\")) {\n+            // Relative path on any OS (Linux/macOS: no leading \"/\", Windows: no drive letter or UNC)\n+            std::env::current_dir()",
        "comment_created_at": "2025-03-17T16:39:36+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "I don't think we need any of these branches, `std::create_dir_all` calls `libc::mkdir` in a loop, and that supports relative paths: https://man7.org/linux/man-pages/man2/mkdir.2.html\r\n\r\nSo we don't need this case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1999473936",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "1999191791",
        "commented_code": "@@ -5,15 +5,45 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory if used.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default support directory.\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = if cfg!(target_os = \"windows\") && (dir.contains(r\"\\\") || dir.starts_with(r\"\\\\\")) {\n+            // Windows absolute path (e.g., \"C:\\path\" or \"\\\\network\\path\")\n+            PathBuf::from(dir)\n+        } else if dir.starts_with(\"./\") || dir.starts_with(\"../\") || (!dir.starts_with(\"/\") && !cfg!(target_os = \"windows\")) {\n+            // Relative path on any OS (Linux/macOS: no leading \"/\", Windows: no drive letter or UNC)\n+            std::env::current_dir()",
        "comment_created_at": "2025-03-17T19:26:37+00:00",
        "comment_author": "mkungla",
        "comment_body": "updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1999202149",
    "pr_number": 26886,
    "pr_file": "crates/zed/src/zed/open_listener.rs",
    "created_at": "2025-03-17T16:43:19+00:00",
    "commented_code": "wait,\n                 open_new_workspace,\n                 env,\n+                user_data_dir,\n             } => {\n+                if let Some(dir) = user_data_dir {\n+                    paths::set_custom_data_dir(&dir);",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1999202149",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/zed/src/zed/open_listener.rs",
        "discussion_id": "1999202149",
        "commented_code": "@@ -261,7 +261,12 @@ pub async fn handle_cli_connection(\n                 wait,\n                 open_new_workspace,\n                 env,\n+                user_data_dir,\n             } => {\n+                if let Some(dir) = user_data_dir {\n+                    paths::set_custom_data_dir(&dir);",
        "comment_created_at": "2025-03-17T16:43:19+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "I don't think we need this, as you're already passing it via CLI arguments and `set_custom_data_dir()` should not be called after `init_paths`. In fact, can we make `set_custom_data_dir()` panic if you call it after calling `init_paths`? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1999474331",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/zed/src/zed/open_listener.rs",
        "discussion_id": "1999202149",
        "commented_code": "@@ -261,7 +261,12 @@ pub async fn handle_cli_connection(\n                 wait,\n                 open_new_workspace,\n                 env,\n+                user_data_dir,\n             } => {\n+                if let Some(dir) = user_data_dir {\n+                    paths::set_custom_data_dir(&dir);",
        "comment_created_at": "2025-03-17T19:26:56+00:00",
        "comment_author": "mkungla",
        "comment_body": "updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2002149459",
    "pr_number": 26886,
    "pr_file": "crates/paths/src/paths.rs",
    "created_at": "2025-03-18T23:16:06+00:00",
    "commented_code": "pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2002149459",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2002149459",
        "commented_code": "@@ -5,61 +5,84 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();",
        "comment_created_at": "2025-03-18T23:16:06+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "Why do we need this third static? I would have thought the check would be something like:\r\n\r\n```rs\r\npub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\r\n  if CUSTOM_DATA_DIR.get().is_some() {\r\n   panic!();\r\n  } \r\n  // Set custom data dir\r\n}\r\n```\r\n\r\nAnd otherwise, it would be the same as it was earlier in the PR",
        "pr_file_module": null
      },
      {
        "comment_id": "2009136188",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2002149459",
        "commented_code": "@@ -5,61 +5,84 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();",
        "comment_created_at": "2025-03-23T14:47:08+00:00",
        "comment_author": "mkungla",
        "comment_body": "I added `CURRENT_DATA_DIR` and `CONFIG_DIR` as separate statics to ensure `set_custom_data_dir` can only be called before any directory (data or config) is initialized. Checking only `CUSTOM_DATA_DIR.get().is_some()` would allow setting a custom directory after `data_dir()` or `config_dir()` has been resolved, which could lead to inconsistent paths during runtime. This will ensure that no mixed paths are never loaded and when CURRENT_DATA_DIR is used then config_dir will return path relative to custom dir and if not then have os specific behaviour. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2002150772",
    "pr_number": 26886,
    "pr_file": "crates/paths/src/paths.rs",
    "created_at": "2025-03-18T23:18:07+00:00",
    "commented_code": "pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved config directory, combining custom or platform defaults, set once.\n+static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default data directory.\n+///\n+/// Panics if called after the data directory has been initialized (e.g., via `data_dir` or `config_dir`).\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    if CURRENT_DATA_DIR.get().is_some() || CONFIG_DIR.get().is_some() {\n+        panic!(\"set_custom_data_dir called after data_dir or config_dir was initialized\");\n+    }\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = PathBuf::from(dir);\n+        std::fs::create_dir_all(&path).expect(\"failed to create custom data directory\");\n+        path\n+    })\n+}\n+\n /// Returns the path to the configuration directory used by Zed.\n pub fn config_dir() -> &'static PathBuf {\n-    static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2002150772",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2002150772",
        "commented_code": "@@ -5,61 +5,84 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved config directory, combining custom or platform defaults, set once.\n+static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default data directory.\n+///\n+/// Panics if called after the data directory has been initialized (e.g., via `data_dir` or `config_dir`).\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    if CURRENT_DATA_DIR.get().is_some() || CONFIG_DIR.get().is_some() {\n+        panic!(\"set_custom_data_dir called after data_dir or config_dir was initialized\");\n+    }\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = PathBuf::from(dir);\n+        std::fs::create_dir_all(&path).expect(\"failed to create custom data directory\");\n+        path\n+    })\n+}\n+\n /// Returns the path to the configuration directory used by Zed.\n pub fn config_dir() -> &'static PathBuf {\n-    static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();",
        "comment_created_at": "2025-03-18T23:18:07+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "I don't think there's any reason to move these out of their functions?",
        "pr_file_module": null
      },
      {
        "comment_id": "2009137161",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2002150772",
        "commented_code": "@@ -5,61 +5,84 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved config directory, combining custom or platform defaults, set once.\n+static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default data directory.\n+///\n+/// Panics if called after the data directory has been initialized (e.g., via `data_dir` or `config_dir`).\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    if CURRENT_DATA_DIR.get().is_some() || CONFIG_DIR.get().is_some() {\n+        panic!(\"set_custom_data_dir called after data_dir or config_dir was initialized\");\n+    }\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = PathBuf::from(dir);\n+        std::fs::create_dir_all(&path).expect(\"failed to create custom data directory\");\n+        path\n+    })\n+}\n+\n /// Returns the path to the configuration directory used by Zed.\n pub fn config_dir() -> &'static PathBuf {\n-    static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();",
        "comment_created_at": "2025-03-23T14:51:31+00:00",
        "comment_author": "mkungla",
        "comment_body": "I moved `CONFIG_DIR` and `CURRENT_DATA_DIR` out of the functions so `set_custom_data_dir` can check their initialization state and panic if they\u2019ve already been set. Keeping them inside would prevent this check. They\u2019re still private to the module (not `pub`), so it doesn\u2019t affect external access. I could refactor to avoid this (e.g., by tracking initialization differently), but I think this approach is cleanest for now. Happy to adjust if you have a better suggestion!",
        "pr_file_module": null
      },
      {
        "comment_id": "2019448034",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26886,
        "pr_file": "crates/paths/src/paths.rs",
        "discussion_id": "2002150772",
        "commented_code": "@@ -5,61 +5,84 @@ use std::sync::OnceLock;\n \n pub use util::paths::home_dir;\n \n+/// A default editorconfig file name to use when resolving project settings.\n+pub const EDITORCONFIG_NAME: &str = \".editorconfig\";\n+\n+// Custom data directory override, set only by set_custom_data_dir.\n+static CUSTOM_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved data directory, combining custom or platform defaults, set once.\n+static CURRENT_DATA_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n+// Resolved config directory, combining custom or platform defaults, set once.\n+static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();\n+\n /// Returns the relative path to the zed_server directory on the ssh host.\n pub fn remote_server_dir_relative() -> &'static Path {\n     Path::new(\".zed_server\")\n }\n \n+/// Sets a custom directory for all user data, overriding the default data directory.\n+///\n+/// Panics if called after the data directory has been initialized (e.g., via `data_dir` or `config_dir`).\n+pub fn set_custom_data_dir(dir: &str) -> &'static PathBuf {\n+    if CURRENT_DATA_DIR.get().is_some() || CONFIG_DIR.get().is_some() {\n+        panic!(\"set_custom_data_dir called after data_dir or config_dir was initialized\");\n+    }\n+    CUSTOM_DATA_DIR.get_or_init(|| {\n+        let path = PathBuf::from(dir);\n+        std::fs::create_dir_all(&path).expect(\"failed to create custom data directory\");\n+        path\n+    })\n+}\n+\n /// Returns the path to the configuration directory used by Zed.\n pub fn config_dir() -> &'static PathBuf {\n-    static CONFIG_DIR: OnceLock<PathBuf> = OnceLock::new();",
        "comment_created_at": "2025-03-28T21:39:43+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "Ahh, I see. Thank you!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1889092696",
    "pr_number": 22045,
    "pr_file": "crates/fs/src/fs.rs",
    "created_at": "2024-12-17T19:19:58+00:00",
    "commented_code": "})\n }\n \n+fn create_temp_file(path: &Path) -> Result<NamedTempFile> {\n+    let temp_file = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n+        // Use the directory of the destination as temp dir to avoid\n+        // invalid cross-device link error, and XDG_CACHE_DIR for fallback.\n+        // See https://github.com/zed-industries/zed/pull/8437 for more details.\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else if cfg!(target_os = \"windows\") {\n+        // If temp dir is set to a different drive than the destination,\n+        // we receive error:\n+        //\n+        // failed to persist temporary file:\n+        // The system cannot move the file to a different disk drive. (os error 17)\n+        //\n+        // So we use the directory of the destination as a temp dir to avoid it.\n+        // https://github.com/zed-industries/zed/issues/16571\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else {\n+        NamedTempFile::new()?\n+    };\n+\n+    Ok(temp_file)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+async fn execute_elevated_command(command: &str) -> Result<()> {\n+    let pkexec_path = Path::new(\"/usr/bin/pkexec\");\n+\n+    if !pkexec_path.exists() {\n+        return Err(anyhow::anyhow!(\n+            \"pkexec not found at {}\",\n+            pkexec_path.display()\n+        ));\n+    }\n+\n+    let mut cmd = Command::new(pkexec_path);\n+    cmd.arg(\"--disable-internal-agent\");\n+\n+    let script_path = PathBuf::from(\"/usr/libexec/zed/elevate.sh\");",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1889092696",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22045,
        "pr_file": "crates/fs/src/fs.rs",
        "discussion_id": "1889092696",
        "commented_code": "@@ -1999,6 +2013,70 @@ fn chunks(rope: &Rope, line_ending: LineEnding) -> impl Iterator<Item = &str> {\n     })\n }\n \n+fn create_temp_file(path: &Path) -> Result<NamedTempFile> {\n+    let temp_file = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n+        // Use the directory of the destination as temp dir to avoid\n+        // invalid cross-device link error, and XDG_CACHE_DIR for fallback.\n+        // See https://github.com/zed-industries/zed/pull/8437 for more details.\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else if cfg!(target_os = \"windows\") {\n+        // If temp dir is set to a different drive than the destination,\n+        // we receive error:\n+        //\n+        // failed to persist temporary file:\n+        // The system cannot move the file to a different disk drive. (os error 17)\n+        //\n+        // So we use the directory of the destination as a temp dir to avoid it.\n+        // https://github.com/zed-industries/zed/issues/16571\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else {\n+        NamedTempFile::new()?\n+    };\n+\n+    Ok(temp_file)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+async fn execute_elevated_command(command: &str) -> Result<()> {\n+    let pkexec_path = Path::new(\"/usr/bin/pkexec\");\n+\n+    if !pkexec_path.exists() {\n+        return Err(anyhow::anyhow!(\n+            \"pkexec not found at {}\",\n+            pkexec_path.display()\n+        ));\n+    }\n+\n+    let mut cmd = Command::new(pkexec_path);\n+    cmd.arg(\"--disable-internal-agent\");\n+\n+    let script_path = PathBuf::from(\"/usr/libexec/zed/elevate.sh\");",
        "comment_created_at": "2024-12-17T19:19:58+00:00",
        "comment_author": "jansol",
        "comment_body": "This is also not going to work on NixOS. Would be nice to have a way to specify this as a command line flag or env variable while building so we don't have to resort to patching the code in the NixOS package.",
        "pr_file_module": null
      },
      {
        "comment_id": "1889709654",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22045,
        "pr_file": "crates/fs/src/fs.rs",
        "discussion_id": "1889092696",
        "commented_code": "@@ -1999,6 +2013,70 @@ fn chunks(rope: &Rope, line_ending: LineEnding) -> impl Iterator<Item = &str> {\n     })\n }\n \n+fn create_temp_file(path: &Path) -> Result<NamedTempFile> {\n+    let temp_file = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n+        // Use the directory of the destination as temp dir to avoid\n+        // invalid cross-device link error, and XDG_CACHE_DIR for fallback.\n+        // See https://github.com/zed-industries/zed/pull/8437 for more details.\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else if cfg!(target_os = \"windows\") {\n+        // If temp dir is set to a different drive than the destination,\n+        // we receive error:\n+        //\n+        // failed to persist temporary file:\n+        // The system cannot move the file to a different disk drive. (os error 17)\n+        //\n+        // So we use the directory of the destination as a temp dir to avoid it.\n+        // https://github.com/zed-industries/zed/issues/16571\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else {\n+        NamedTempFile::new()?\n+    };\n+\n+    Ok(temp_file)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+async fn execute_elevated_command(command: &str) -> Result<()> {\n+    let pkexec_path = Path::new(\"/usr/bin/pkexec\");\n+\n+    if !pkexec_path.exists() {\n+        return Err(anyhow::anyhow!(\n+            \"pkexec not found at {}\",\n+            pkexec_path.display()\n+        ));\n+    }\n+\n+    let mut cmd = Command::new(pkexec_path);\n+    cmd.arg(\"--disable-internal-agent\");\n+\n+    let script_path = PathBuf::from(\"/usr/libexec/zed/elevate.sh\");",
        "comment_created_at": "2024-12-18T06:55:02+00:00",
        "comment_author": "smitbarmase",
        "comment_body": "I\u2019ve added the env variable which can be used in Nix installation. But, I'm not picking that in this PR as I'm not familiar with Nix yet. It should still work on NixOS as long as pkexec is in the PATH without custom message. I will create another PR after setting up NixOS VM and testing there.",
        "pr_file_module": null
      },
      {
        "comment_id": "1889999568",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22045,
        "pr_file": "crates/fs/src/fs.rs",
        "discussion_id": "1889092696",
        "commented_code": "@@ -1999,6 +2013,70 @@ fn chunks(rope: &Rope, line_ending: LineEnding) -> impl Iterator<Item = &str> {\n     })\n }\n \n+fn create_temp_file(path: &Path) -> Result<NamedTempFile> {\n+    let temp_file = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n+        // Use the directory of the destination as temp dir to avoid\n+        // invalid cross-device link error, and XDG_CACHE_DIR for fallback.\n+        // See https://github.com/zed-industries/zed/pull/8437 for more details.\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else if cfg!(target_os = \"windows\") {\n+        // If temp dir is set to a different drive than the destination,\n+        // we receive error:\n+        //\n+        // failed to persist temporary file:\n+        // The system cannot move the file to a different disk drive. (os error 17)\n+        //\n+        // So we use the directory of the destination as a temp dir to avoid it.\n+        // https://github.com/zed-industries/zed/issues/16571\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else {\n+        NamedTempFile::new()?\n+    };\n+\n+    Ok(temp_file)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+async fn execute_elevated_command(command: &str) -> Result<()> {\n+    let pkexec_path = Path::new(\"/usr/bin/pkexec\");\n+\n+    if !pkexec_path.exists() {\n+        return Err(anyhow::anyhow!(\n+            \"pkexec not found at {}\",\n+            pkexec_path.display()\n+        ));\n+    }\n+\n+    let mut cmd = Command::new(pkexec_path);\n+    cmd.arg(\"--disable-internal-agent\");\n+\n+    let script_path = PathBuf::from(\"/usr/libexec/zed/elevate.sh\");",
        "comment_created_at": "2024-12-18T10:28:44+00:00",
        "comment_author": "jansol",
        "comment_body": "Thanks! In nixpkgs we wrap the executable in a shell script to add node.js into its PATH already so adding pkexec in that mix is trivial. Similarly setting the environment variable for the elevate script to point to `/nix/store/<hash>` is easily doable now. Updating the nix files in this repo can indeed be done separately (especially since this is not a change that breaks something that was working before).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1889093804",
    "pr_number": 22045,
    "pr_file": "crates/fs/src/fs.rs",
    "created_at": "2024-12-17T19:20:51+00:00",
    "commented_code": "})\n }\n \n+fn create_temp_file(path: &Path) -> Result<NamedTempFile> {\n+    let temp_file = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n+        // Use the directory of the destination as temp dir to avoid\n+        // invalid cross-device link error, and XDG_CACHE_DIR for fallback.\n+        // See https://github.com/zed-industries/zed/pull/8437 for more details.\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else if cfg!(target_os = \"windows\") {\n+        // If temp dir is set to a different drive than the destination,\n+        // we receive error:\n+        //\n+        // failed to persist temporary file:\n+        // The system cannot move the file to a different disk drive. (os error 17)\n+        //\n+        // So we use the directory of the destination as a temp dir to avoid it.\n+        // https://github.com/zed-industries/zed/issues/16571\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else {\n+        NamedTempFile::new()?\n+    };\n+\n+    Ok(temp_file)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+async fn execute_elevated_command(command: &str) -> Result<()> {\n+    let pkexec_path = Path::new(\"/usr/bin/pkexec\");\n+\n+    if !pkexec_path.exists() {\n+        return Err(anyhow::anyhow!(\n+            \"pkexec not found at {}\",\n+            pkexec_path.display()\n+        ));\n+    }\n+\n+    let mut cmd = Command::new(pkexec_path);\n+    cmd.arg(\"--disable-internal-agent\");\n+\n+    let script_path = PathBuf::from(\"/usr/libexec/zed/elevate.sh\");\n+    if script_path.exists() {\n+        // Custom message will be shown to user\n+        cmd.arg(&script_path).arg(command);\n+    } else {\n+        // Default message will be shown to user\n+        cmd.arg(\"/bin/bash\").arg(\"-c\").arg(command);",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1889093804",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22045,
        "pr_file": "crates/fs/src/fs.rs",
        "discussion_id": "1889093804",
        "commented_code": "@@ -1999,6 +2013,70 @@ fn chunks(rope: &Rope, line_ending: LineEnding) -> impl Iterator<Item = &str> {\n     })\n }\n \n+fn create_temp_file(path: &Path) -> Result<NamedTempFile> {\n+    let temp_file = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n+        // Use the directory of the destination as temp dir to avoid\n+        // invalid cross-device link error, and XDG_CACHE_DIR for fallback.\n+        // See https://github.com/zed-industries/zed/pull/8437 for more details.\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else if cfg!(target_os = \"windows\") {\n+        // If temp dir is set to a different drive than the destination,\n+        // we receive error:\n+        //\n+        // failed to persist temporary file:\n+        // The system cannot move the file to a different disk drive. (os error 17)\n+        //\n+        // So we use the directory of the destination as a temp dir to avoid it.\n+        // https://github.com/zed-industries/zed/issues/16571\n+        NamedTempFile::new_in(path.parent().unwrap_or(paths::temp_dir()))?\n+    } else {\n+        NamedTempFile::new()?\n+    };\n+\n+    Ok(temp_file)\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(target_os = \"windows\")]\n+async fn execute_elevated_command(_command: &str) -> Result<()> {\n+    unimplemented!(\"execute_elevated_command is not implemented\")\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+async fn execute_elevated_command(command: &str) -> Result<()> {\n+    let pkexec_path = Path::new(\"/usr/bin/pkexec\");\n+\n+    if !pkexec_path.exists() {\n+        return Err(anyhow::anyhow!(\n+            \"pkexec not found at {}\",\n+            pkexec_path.display()\n+        ));\n+    }\n+\n+    let mut cmd = Command::new(pkexec_path);\n+    cmd.arg(\"--disable-internal-agent\");\n+\n+    let script_path = PathBuf::from(\"/usr/libexec/zed/elevate.sh\");\n+    if script_path.exists() {\n+        // Custom message will be shown to user\n+        cmd.arg(&script_path).arg(command);\n+    } else {\n+        // Default message will be shown to user\n+        cmd.arg(\"/bin/bash\").arg(\"-c\").arg(command);",
        "comment_created_at": "2024-12-17T19:20:51+00:00",
        "comment_author": "jansol",
        "comment_body": "`/bin/bash` doesn't exist e.g. on NixOS. `/bin/sh` is more reliable in that regard. If bash is *really* necessary `/usr/bin/env bash` is a better way to invoke it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1908709062",
    "pr_number": 22668,
    "pr_file": "crates/project/src/project_settings.rs",
    "created_at": "2025-01-09T12:30:24+00:00",
    "commented_code": "Direct,\n }\n \n+#[derive(Copy, Clone, Debug, Default, Serialize, Deserialize, JsonSchema)]\n+pub struct DiagnosticsSettings {\n+    /// Whether or not to include warning diagnostics\n+    pub include_warnings: bool,",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1908709062",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/project/src/project_settings.rs",
        "discussion_id": "1908709062",
        "commented_code": "@@ -79,6 +83,74 @@ pub enum DirenvSettings {\n     Direct,\n }\n \n+#[derive(Copy, Clone, Debug, Default, Serialize, Deserialize, JsonSchema)]\n+pub struct DiagnosticsSettings {\n+    /// Whether or not to include warning diagnostics\n+    pub include_warnings: bool,",
        "comment_created_at": "2025-01-09T12:30:24+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "That has to have `#[serde(default = \"default_true\")]` , as the default_settings.json mention default = true (which is also good to mention here) + the user setting overrides require this field always (which is not what we want): \r\n\r\n![image](https://github.com/user-attachments/assets/fadef7dc-8010-4a93-b638-2f15b8d4fc90)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1912181361",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/project/src/project_settings.rs",
        "discussion_id": "1908709062",
        "commented_code": "@@ -79,6 +83,74 @@ pub enum DirenvSettings {\n     Direct,\n }\n \n+#[derive(Copy, Clone, Debug, Default, Serialize, Deserialize, JsonSchema)]\n+pub struct DiagnosticsSettings {\n+    /// Whether or not to include warning diagnostics\n+    pub include_warnings: bool,",
        "comment_created_at": "2025-01-11T19:27:25+00:00",
        "comment_author": "davisp",
        "comment_body": "I've added the serde default, but note that that setting predates this PR so hopefully its not a big deal to do drive by fixing like that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1914963150",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22668,
        "pr_file": "crates/project/src/project_settings.rs",
        "discussion_id": "1908709062",
        "commented_code": "@@ -79,6 +83,74 @@ pub enum DirenvSettings {\n     Direct,\n }\n \n+#[derive(Copy, Clone, Debug, Default, Serialize, Deserialize, JsonSchema)]\n+pub struct DiagnosticsSettings {\n+    /// Whether or not to include warning diagnostics\n+    pub include_warnings: bool,",
        "comment_created_at": "2025-01-14T14:51:22+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "The error is gone, so thank you for fixing this.",
        "pr_file_module": null
      }
    ]
  }
]