[
  {
    "discussion_id": "2177307721",
    "pr_number": 33490,
    "pr_file": "crates/outline_panel/src/outline_panel.rs",
    "created_at": "2025-07-01T11:17:49+00:00",
    "commented_code": "multi_buffer_snapshot.text_for_range(line_start..line_end).collect::<String>().trim().to_owned()\n         })\n     }\n+\n+    #[gpui::test(iterations = 10)]\n+    async fn test_outline_expand_collapse_functionality(cx: &mut TestAppContext) {\n+        init_test(cx);\n+\n+        let fs = FakeFs::new(cx.background_executor.clone());\n+        fs.insert_tree(\n+            \"/test\",\n+            json!({\n+                \"src\": {\n+                    \"lib.rs\": indoc!(\"\n+                        mod outer {\n+                            pub struct OuterStruct {\n+                                field: String,\n+                            }\n+\n+                            impl OuterStruct {\n+                                pub fn new() -> Self {\n+                                    Self { field: String::new() }\n+                                }\n+\n+                                pub fn method(&self) {\n+                                    println!(\\\"{}\\\", self.field);\n+                                }\n+                            }\n+\n+                            mod inner {\n+                                pub fn inner_function() {\n+                                    let x = 42;\n+                                    println!(\\\"{}\\\", x);\n+                                }\n+\n+                                pub struct InnerStruct {\n+                                    value: i32,\n+                                }\n+                            }\n+                        }\n+\n+                        fn main() {\n+                            let s = outer::OuterStruct::new();\n+                            s.method();\n+                        }\n+                    \"),\n+                }\n+            }),\n+        )\n+        .await;\n+\n+        let project = Project::test(fs.clone(), [\"/test\".as_ref()], cx).await;\n+        project.read_with(cx, |project, _| {\n+            project.languages().add(Arc::new(\n+                rust_lang()\n+                    .with_outline_query(\n+                        r#\"\n+                        (struct_item\n+                            (visibility_modifier)? @context\n+                            \"struct\" @context\n+                            name: (_) @name) @item\n+\n+                        (impl_item\n+                            \"impl\" @context\n+                            trait: (_)? @context\n+                            \"for\"? @context\n+                            type: (_) @context\n+                            body: (_)) @item\n+\n+                        (function_item\n+                            (visibility_modifier)? @context\n+                            \"fn\" @context\n+                            name: (_) @name\n+                            parameters: (_) @context) @item\n+\n+                        (mod_item\n+                            (visibility_modifier)? @context\n+                            \"mod\" @context\n+                            name: (_) @name) @item\n+\n+                        (enum_item\n+                            (visibility_modifier)? @context\n+                            \"enum\" @context\n+                            name: (_) @name) @item\n+\n+                        (field_declaration\n+                            (visibility_modifier)? @context\n+                            name: (_) @name\n+                            \":\" @context\n+                            type: (_) @context) @item\n+                        \"#,\n+                    )\n+                    .unwrap(),\n+            ))\n+        });\n+        let workspace = add_outline_panel(&project, cx).await;\n+        let cx = &mut VisualTestContext::from_window(*workspace, cx);\n+        let outline_panel = outline_panel(&workspace, cx);\n+\n+        outline_panel.update_in(cx, |outline_panel, window, cx| {\n+            outline_panel.set_active(true, window, cx)\n+        });\n+\n+        workspace\n+            .update(cx, |workspace, window, cx| {\n+                workspace.open_abs_path(\n+                    PathBuf::from(\"/test/src/lib.rs\"),\n+                    OpenOptions {\n+                        visible: Some(OpenVisible::All),\n+                        ..Default::default()\n+                    },\n+                    window,\n+                    cx,\n+                )\n+            })\n+            .unwrap()\n+            .await\n+            .unwrap();\n+\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        // Force another update cycle to ensure outlines are fetched\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.update_non_fs_items(window, cx);\n+            panel.update_cached_entries(Some(UPDATE_DEBOUNCE), window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        let count_visible_outlines = |panel: &OutlinePanel| {\n+            panel\n+                .cached_entries\n+                .iter()\n+                .filter(|e| matches!(e.entry, PanelEntry::Outline(_)))\n+                .count()\n+        };\n+\n+        let initial_count = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+        assert!(initial_count > 0, \"Should have outline entries\");\n+\n+        // Find the first outline that has children (like \"mod outer\" or \"impl OuterStruct\")\n+        let parent_outline = outline_panel\n+            .read_with(cx, |panel, cx| {\n+                panel\n+                    .cached_entries\n+                    .iter()\n+                    .find_map(|entry| match &entry.entry {\n+                        PanelEntry::Outline(OutlineEntry::Outline(outline))\n+                            if panel.has_outline_children(outline, cx) =>\n+                        {\n+                            Some(entry.entry.clone())\n+                        }\n+                        _ => None,\n+                    })\n+            })\n+            .expect(\"Should find an outline with children\");\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.select_entry(parent_outline.clone(), true, window, cx);\n+            panel.collapse_selected_entry(&CollapseSelectedEntry, window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let collapsed_count = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+        assert!(\n+            collapsed_count < initial_count,\n+            \"Should have fewer visible outlines after collapsing parent (initial: {}, collapsed: {})\",\n+            initial_count,\n+            collapsed_count\n+        );\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.expand_selected_entry(&ExpandSelectedEntry, window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let expanded_count = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+        assert_eq!(\n+            expanded_count, initial_count,\n+            \"Should return to initial count after expanding\"\n+        );\n+\n+        // First, make sure we're starting from all expanded state\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.collapsed_entries.clear();\n+            panel.update_cached_entries(None, window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let fully_expanded_count =\n+            outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            let outlines_with_children: Vec<_> = panel\n+                .cached_entries\n+                .iter()\n+                .filter_map(|entry| match &entry.entry {\n+                    PanelEntry::Outline(OutlineEntry::Outline(outline))\n+                        if panel.has_outline_children(outline, cx) =>\n+                    {\n+                        Some(entry.entry.clone())\n+                    }\n+                    _ => None,\n+                })\n+                .collect();\n+\n+            for outline in outlines_with_children {\n+                panel.select_entry(outline, false, window, cx);\n+                panel.collapse_selected_entry(&CollapseSelectedEntry, window, cx);\n+            }\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let all_collapsed_count =\n+            outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+\n+        // When all parents are collapsed, we should only see top-level items without children\n+        // In our test file: \"mod outer\" (has children) and \"fn main\" (no children)\n+        // So when \"mod outer\" is collapsed, we should see 2 items total\n+        assert!(\n+            all_collapsed_count < fully_expanded_count,\n+            \"Should have fewer outlines when all parents are collapsed (all: {}, expanded: {})\",\n+            all_collapsed_count,\n+            fully_expanded_count\n+        );\n+\n+        assert!(\n+            all_collapsed_count <= 2,\n+            \"Should have minimal entries when all parents are collapsed (got {})\",\n+            all_collapsed_count\n+        );\n+\n+        let collapsed_entries_count =\n+            outline_panel.read_with(cx, |panel, _| panel.collapsed_entries.len());\n+        assert!(\n+            collapsed_entries_count > 0,\n+            \"Should have collapsed entries tracked\"\n+        );\n+    }\n+\n+    #[gpui::test(iterations = 10)]\n+    async fn test_expand_collapse_functionality(cx: &mut TestAppContext) {\n+        init_test(cx);\n+\n+        let fs = FakeFs::new(cx.background_executor.clone());\n+        fs.insert_tree(\n+            \"/test\",\n+            json!({\n+                \"src\": {\n+                    \"main.rs\": indoc!(\"\n+                        struct Config {\n+                            name: String,\n+                            value: i32,\n+                        }\n+\n+                        impl Config {\n+                            fn new(name: String) -> Self {\n+                                Self { name, value: 0 }\n+                            }\n+\n+                            fn get_value(&self) -> i32 {\n+                                self.value\n+                            }\n+                        }\n+\n+                        enum Status {\n+                            Active,\n+                            Inactive,\n+                        }\n+\n+                        fn process_config(config: Config) -> Status {\n+                            if config.get_value() > 0 {\n+                                Status::Active\n+                            } else {\n+                                Status::Inactive\n+                            }\n+                        }\n+\n+                        fn main() {\n+                            let config = Config::new(\\\"test\\\".to_string());\n+                            let status = process_config(config);\n+                        }\n+                    \"),\n+                }\n+            }),\n+        )\n+        .await;\n+\n+        let project = Project::test(fs.clone(), [\"/test\".as_ref()], cx).await;\n+        project.read_with(cx, |project, _| {\n+            project.languages().add(Arc::new(\n+                rust_lang()\n+                    .with_outline_query(\n+                        r#\"\n+                        (struct_item\n+                            (visibility_modifier)? @context\n+                            \"struct\" @context\n+                            name: (_) @name) @item\n+\n+                        (impl_item\n+                            \"impl\" @context\n+                            trait: (_)? @context\n+                            \"for\"? @context\n+                            type: (_) @context\n+                            body: (_)) @item\n+\n+                        (function_item\n+                            (visibility_modifier)? @context\n+                            \"fn\" @context\n+                            name: (_) @name\n+                            parameters: (_) @context) @item\n+\n+                        (mod_item\n+                            (visibility_modifier)? @context\n+                            \"mod\" @context\n+                            name: (_) @name) @item\n+\n+                        (enum_item\n+                            (visibility_modifier)? @context\n+                            \"enum\" @context\n+                            name: (_) @name) @item\n+\n+                        (field_declaration\n+                            (visibility_modifier)? @context\n+                            name: (_) @name\n+                            \":\" @context\n+                            type: (_) @context) @item\n+                        \"#,\n+                    )\n+                    .unwrap(),\n+            ))\n+        });\n+        let workspace = add_outline_panel(&project, cx).await;\n+        let cx = &mut VisualTestContext::from_window(*workspace, cx);\n+        let outline_panel = outline_panel(&workspace, cx);\n+\n+        outline_panel.update_in(cx, |outline_panel, window, cx| {\n+            outline_panel.set_active(true, window, cx)\n+        });\n+\n+        workspace\n+            .update(cx, |workspace, window, cx| {\n+                workspace.open_abs_path(\n+                    PathBuf::from(\"/test/src/main.rs\"),\n+                    OpenOptions {\n+                        visible: Some(OpenVisible::All),\n+                        ..Default::default()\n+                    },\n+                    window,\n+                    cx,\n+                )\n+            })\n+            .unwrap()\n+            .await\n+            .unwrap();\n+\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        // Force another update cycle to ensure outlines are fetched\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.update_non_fs_items(window, cx);\n+            panel.update_cached_entries(Some(UPDATE_DEBOUNCE), window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        let count_visible_outlines = |panel: &OutlinePanel| {\n+            panel\n+                .cached_entries\n+                .iter()\n+                .filter(|e| matches!(e.entry, PanelEntry::Outline(_)))\n+                .count()\n+        };\n+\n+        let _initial_count = outline_panel.read_with(cx, |panel, _| panel.cached_entries.len());\n+\n+        // Select and expand first expandable outline entry (like a struct or impl block)\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            if let Some(outline_entry) = panel\n+                .cached_entries\n+                .iter()\n+                .find(|e| matches!(e.entry, PanelEntry::Outline(_)))\n+            {\n+                panel.select_entry(outline_entry.entry.clone(), true, window, cx);\n+                panel.expand_selected_entry(&ExpandSelectedEntry, window, cx);\n+            }\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let _after_expand = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2177307721",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 33490,
        "pr_file": "crates/outline_panel/src/outline_panel.rs",
        "discussion_id": "2177307721",
        "commented_code": "@@ -6898,4 +7138,436 @@ outline: struct OutlineEntryExcerpt\n                 multi_buffer_snapshot.text_for_range(line_start..line_end).collect::<String>().trim().to_owned()\n         })\n     }\n+\n+    #[gpui::test(iterations = 10)]\n+    async fn test_outline_expand_collapse_functionality(cx: &mut TestAppContext) {\n+        init_test(cx);\n+\n+        let fs = FakeFs::new(cx.background_executor.clone());\n+        fs.insert_tree(\n+            \"/test\",\n+            json!({\n+                \"src\": {\n+                    \"lib.rs\": indoc!(\"\n+                        mod outer {\n+                            pub struct OuterStruct {\n+                                field: String,\n+                            }\n+\n+                            impl OuterStruct {\n+                                pub fn new() -> Self {\n+                                    Self { field: String::new() }\n+                                }\n+\n+                                pub fn method(&self) {\n+                                    println!(\\\"{}\\\", self.field);\n+                                }\n+                            }\n+\n+                            mod inner {\n+                                pub fn inner_function() {\n+                                    let x = 42;\n+                                    println!(\\\"{}\\\", x);\n+                                }\n+\n+                                pub struct InnerStruct {\n+                                    value: i32,\n+                                }\n+                            }\n+                        }\n+\n+                        fn main() {\n+                            let s = outer::OuterStruct::new();\n+                            s.method();\n+                        }\n+                    \"),\n+                }\n+            }),\n+        )\n+        .await;\n+\n+        let project = Project::test(fs.clone(), [\"/test\".as_ref()], cx).await;\n+        project.read_with(cx, |project, _| {\n+            project.languages().add(Arc::new(\n+                rust_lang()\n+                    .with_outline_query(\n+                        r#\"\n+                        (struct_item\n+                            (visibility_modifier)? @context\n+                            \"struct\" @context\n+                            name: (_) @name) @item\n+\n+                        (impl_item\n+                            \"impl\" @context\n+                            trait: (_)? @context\n+                            \"for\"? @context\n+                            type: (_) @context\n+                            body: (_)) @item\n+\n+                        (function_item\n+                            (visibility_modifier)? @context\n+                            \"fn\" @context\n+                            name: (_) @name\n+                            parameters: (_) @context) @item\n+\n+                        (mod_item\n+                            (visibility_modifier)? @context\n+                            \"mod\" @context\n+                            name: (_) @name) @item\n+\n+                        (enum_item\n+                            (visibility_modifier)? @context\n+                            \"enum\" @context\n+                            name: (_) @name) @item\n+\n+                        (field_declaration\n+                            (visibility_modifier)? @context\n+                            name: (_) @name\n+                            \":\" @context\n+                            type: (_) @context) @item\n+                        \"#,\n+                    )\n+                    .unwrap(),\n+            ))\n+        });\n+        let workspace = add_outline_panel(&project, cx).await;\n+        let cx = &mut VisualTestContext::from_window(*workspace, cx);\n+        let outline_panel = outline_panel(&workspace, cx);\n+\n+        outline_panel.update_in(cx, |outline_panel, window, cx| {\n+            outline_panel.set_active(true, window, cx)\n+        });\n+\n+        workspace\n+            .update(cx, |workspace, window, cx| {\n+                workspace.open_abs_path(\n+                    PathBuf::from(\"/test/src/lib.rs\"),\n+                    OpenOptions {\n+                        visible: Some(OpenVisible::All),\n+                        ..Default::default()\n+                    },\n+                    window,\n+                    cx,\n+                )\n+            })\n+            .unwrap()\n+            .await\n+            .unwrap();\n+\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        // Force another update cycle to ensure outlines are fetched\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.update_non_fs_items(window, cx);\n+            panel.update_cached_entries(Some(UPDATE_DEBOUNCE), window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        let count_visible_outlines = |panel: &OutlinePanel| {\n+            panel\n+                .cached_entries\n+                .iter()\n+                .filter(|e| matches!(e.entry, PanelEntry::Outline(_)))\n+                .count()\n+        };\n+\n+        let initial_count = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+        assert!(initial_count > 0, \"Should have outline entries\");\n+\n+        // Find the first outline that has children (like \"mod outer\" or \"impl OuterStruct\")\n+        let parent_outline = outline_panel\n+            .read_with(cx, |panel, cx| {\n+                panel\n+                    .cached_entries\n+                    .iter()\n+                    .find_map(|entry| match &entry.entry {\n+                        PanelEntry::Outline(OutlineEntry::Outline(outline))\n+                            if panel.has_outline_children(outline, cx) =>\n+                        {\n+                            Some(entry.entry.clone())\n+                        }\n+                        _ => None,\n+                    })\n+            })\n+            .expect(\"Should find an outline with children\");\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.select_entry(parent_outline.clone(), true, window, cx);\n+            panel.collapse_selected_entry(&CollapseSelectedEntry, window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let collapsed_count = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+        assert!(\n+            collapsed_count < initial_count,\n+            \"Should have fewer visible outlines after collapsing parent (initial: {}, collapsed: {})\",\n+            initial_count,\n+            collapsed_count\n+        );\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.expand_selected_entry(&ExpandSelectedEntry, window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let expanded_count = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+        assert_eq!(\n+            expanded_count, initial_count,\n+            \"Should return to initial count after expanding\"\n+        );\n+\n+        // First, make sure we're starting from all expanded state\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.collapsed_entries.clear();\n+            panel.update_cached_entries(None, window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let fully_expanded_count =\n+            outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            let outlines_with_children: Vec<_> = panel\n+                .cached_entries\n+                .iter()\n+                .filter_map(|entry| match &entry.entry {\n+                    PanelEntry::Outline(OutlineEntry::Outline(outline))\n+                        if panel.has_outline_children(outline, cx) =>\n+                    {\n+                        Some(entry.entry.clone())\n+                    }\n+                    _ => None,\n+                })\n+                .collect();\n+\n+            for outline in outlines_with_children {\n+                panel.select_entry(outline, false, window, cx);\n+                panel.collapse_selected_entry(&CollapseSelectedEntry, window, cx);\n+            }\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let all_collapsed_count =\n+            outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+\n+        // When all parents are collapsed, we should only see top-level items without children\n+        // In our test file: \"mod outer\" (has children) and \"fn main\" (no children)\n+        // So when \"mod outer\" is collapsed, we should see 2 items total\n+        assert!(\n+            all_collapsed_count < fully_expanded_count,\n+            \"Should have fewer outlines when all parents are collapsed (all: {}, expanded: {})\",\n+            all_collapsed_count,\n+            fully_expanded_count\n+        );\n+\n+        assert!(\n+            all_collapsed_count <= 2,\n+            \"Should have minimal entries when all parents are collapsed (got {})\",\n+            all_collapsed_count\n+        );\n+\n+        let collapsed_entries_count =\n+            outline_panel.read_with(cx, |panel, _| panel.collapsed_entries.len());\n+        assert!(\n+            collapsed_entries_count > 0,\n+            \"Should have collapsed entries tracked\"\n+        );\n+    }\n+\n+    #[gpui::test(iterations = 10)]\n+    async fn test_expand_collapse_functionality(cx: &mut TestAppContext) {\n+        init_test(cx);\n+\n+        let fs = FakeFs::new(cx.background_executor.clone());\n+        fs.insert_tree(\n+            \"/test\",\n+            json!({\n+                \"src\": {\n+                    \"main.rs\": indoc!(\"\n+                        struct Config {\n+                            name: String,\n+                            value: i32,\n+                        }\n+\n+                        impl Config {\n+                            fn new(name: String) -> Self {\n+                                Self { name, value: 0 }\n+                            }\n+\n+                            fn get_value(&self) -> i32 {\n+                                self.value\n+                            }\n+                        }\n+\n+                        enum Status {\n+                            Active,\n+                            Inactive,\n+                        }\n+\n+                        fn process_config(config: Config) -> Status {\n+                            if config.get_value() > 0 {\n+                                Status::Active\n+                            } else {\n+                                Status::Inactive\n+                            }\n+                        }\n+\n+                        fn main() {\n+                            let config = Config::new(\\\"test\\\".to_string());\n+                            let status = process_config(config);\n+                        }\n+                    \"),\n+                }\n+            }),\n+        )\n+        .await;\n+\n+        let project = Project::test(fs.clone(), [\"/test\".as_ref()], cx).await;\n+        project.read_with(cx, |project, _| {\n+            project.languages().add(Arc::new(\n+                rust_lang()\n+                    .with_outline_query(\n+                        r#\"\n+                        (struct_item\n+                            (visibility_modifier)? @context\n+                            \"struct\" @context\n+                            name: (_) @name) @item\n+\n+                        (impl_item\n+                            \"impl\" @context\n+                            trait: (_)? @context\n+                            \"for\"? @context\n+                            type: (_) @context\n+                            body: (_)) @item\n+\n+                        (function_item\n+                            (visibility_modifier)? @context\n+                            \"fn\" @context\n+                            name: (_) @name\n+                            parameters: (_) @context) @item\n+\n+                        (mod_item\n+                            (visibility_modifier)? @context\n+                            \"mod\" @context\n+                            name: (_) @name) @item\n+\n+                        (enum_item\n+                            (visibility_modifier)? @context\n+                            \"enum\" @context\n+                            name: (_) @name) @item\n+\n+                        (field_declaration\n+                            (visibility_modifier)? @context\n+                            name: (_) @name\n+                            \":\" @context\n+                            type: (_) @context) @item\n+                        \"#,\n+                    )\n+                    .unwrap(),\n+            ))\n+        });\n+        let workspace = add_outline_panel(&project, cx).await;\n+        let cx = &mut VisualTestContext::from_window(*workspace, cx);\n+        let outline_panel = outline_panel(&workspace, cx);\n+\n+        outline_panel.update_in(cx, |outline_panel, window, cx| {\n+            outline_panel.set_active(true, window, cx)\n+        });\n+\n+        workspace\n+            .update(cx, |workspace, window, cx| {\n+                workspace.open_abs_path(\n+                    PathBuf::from(\"/test/src/main.rs\"),\n+                    OpenOptions {\n+                        visible: Some(OpenVisible::All),\n+                        ..Default::default()\n+                    },\n+                    window,\n+                    cx,\n+                )\n+            })\n+            .unwrap()\n+            .await\n+            .unwrap();\n+\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        // Force another update cycle to ensure outlines are fetched\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            panel.update_non_fs_items(window, cx);\n+            panel.update_cached_entries(Some(UPDATE_DEBOUNCE), window, cx);\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(500));\n+        cx.run_until_parked();\n+\n+        let count_visible_outlines = |panel: &OutlinePanel| {\n+            panel\n+                .cached_entries\n+                .iter()\n+                .filter(|e| matches!(e.entry, PanelEntry::Outline(_)))\n+                .count()\n+        };\n+\n+        let _initial_count = outline_panel.read_with(cx, |panel, _| panel.cached_entries.len());\n+\n+        // Select and expand first expandable outline entry (like a struct or impl block)\n+        outline_panel.update_in(cx, |panel, window, cx| {\n+            if let Some(outline_entry) = panel\n+                .cached_entries\n+                .iter()\n+                .find(|e| matches!(e.entry, PanelEntry::Outline(_)))\n+            {\n+                panel.select_entry(outline_entry.entry.clone(), true, window, cx);\n+                panel.expand_selected_entry(&ExpandSelectedEntry, window, cx);\n+            }\n+        });\n+        cx.executor()\n+            .advance_clock(UPDATE_DEBOUNCE + Duration::from_millis(100));\n+        cx.run_until_parked();\n+\n+        let _after_expand = outline_panel.read_with(cx, |panel, _| count_visible_outlines(panel));\n+\n+        outline_panel.update_in(cx, |panel, window, cx| {",
        "comment_created_at": "2025-07-01T11:17:49+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "Super nice to see the tests on the new functionality, thank you.\r\n\r\nOne thing I really lack in them is a visual part: instead of each \"visible count\" and other digits assertion, we should do what other tests do, comparing a file+outline string representations.\r\n(all these\r\n\r\n```\r\noutline: struct OutlineEntryExcerpt\r\n  outline: id\r\n  outline: buffer_id\r\n  outline: range\"\r\n```\r\nparts).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126006313",
    "pr_number": 31763,
    "pr_file": "crates/editor/src/editor_tests.rs",
    "created_at": "2025-06-04T08:28:38+00:00",
    "commented_code": "assert!(!snapshot.is_line_folded(MultiBufferRow(1)));\n }\n \n+#[gpui::test]",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2126006313",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 31763,
        "pr_file": "crates/editor/src/editor_tests.rs",
        "discussion_id": "2126006313",
        "commented_code": "@@ -18068,6 +18237,126 @@ fn test_crease_insertion_and_rendering(cx: &mut TestAppContext) {\n     assert!(!snapshot.is_line_folded(MultiBufferRow(1)));\n }\n \n+#[gpui::test]",
        "comment_created_at": "2025-06-04T08:28:38+00:00",
        "comment_author": "probably-neb",
        "comment_body": "I think we should try testing with more than just comments. Functions and objects are also in scope for `folds.scm` so I think we should test those scenarios (as well as maybe some others) to have a bit more comprehensive testing on the feature before merging.",
        "pr_file_module": null
      },
      {
        "comment_id": "2136680188",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 31763,
        "pr_file": "crates/editor/src/editor_tests.rs",
        "discussion_id": "2126006313",
        "commented_code": "@@ -18068,6 +18237,126 @@ fn test_crease_insertion_and_rendering(cx: &mut TestAppContext) {\n     assert!(!snapshot.is_line_folded(MultiBufferRow(1)));\n }\n \n+#[gpui::test]",
        "comment_created_at": "2025-06-09T23:49:59+00:00",
        "comment_author": "Daquisu",
        "comment_body": "Done, thanks for the suggestion.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135408806",
    "pr_number": 27556,
    "pr_file": "crates/editor/src/display_map/semantic_tokens.rs",
    "created_at": "2025-06-09T09:43:35+00:00",
    "commented_code": "+use gpui::HighlightStyle;\n+use language::Chunk;\n+use multi_buffer::MultiBufferSnapshot;\n+use multi_buffer::ToOffset;\n+use std::cmp;\n+use std::collections::BTreeMap;\n+use std::ops::Range;\n+\n+use super::{Highlights, custom_highlights::CustomHighlightsChunks};\n+\n+#[derive(Debug, Clone)]\n+pub struct Token {\n+    pub(crate) id: usize,\n+    pub range: Range<multi_buffer::Anchor>,\n+    pub style: HighlightStyle,\n+    pub text: text::Rope,\n+}\n+\n+impl Token {\n+    pub fn new<T: Into<text::Rope>>(\n+        id: usize,\n+        range: Range<multi_buffer::Anchor>,\n+        style: HighlightStyle,\n+        text: T,\n+    ) -> Self {\n+        Self {\n+            id,\n+            range,\n+            style,\n+            text: text.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+struct HighlightEndpoint {\n+    id: usize,\n+    offset: usize,\n+    is_start: bool,\n+    style: HighlightStyle,\n+}\n+\n+impl PartialOrd for HighlightEndpoint {\n+    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for HighlightEndpoint {\n+    fn cmp(&self, other: &Self) -> cmp::Ordering {\n+        self.offset\n+            .cmp(&other.offset)\n+            .then_with(|| other.is_start.cmp(&self.is_start))\n+    }\n+}\n+\n+pub struct TokenChunks<'a> {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2135408806",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 27556,
        "pr_file": "crates/editor/src/display_map/semantic_tokens.rs",
        "discussion_id": "2135408806",
        "commented_code": "@@ -0,0 +1,164 @@\n+use gpui::HighlightStyle;\n+use language::Chunk;\n+use multi_buffer::MultiBufferSnapshot;\n+use multi_buffer::ToOffset;\n+use std::cmp;\n+use std::collections::BTreeMap;\n+use std::ops::Range;\n+\n+use super::{Highlights, custom_highlights::CustomHighlightsChunks};\n+\n+#[derive(Debug, Clone)]\n+pub struct Token {\n+    pub(crate) id: usize,\n+    pub range: Range<multi_buffer::Anchor>,\n+    pub style: HighlightStyle,\n+    pub text: text::Rope,\n+}\n+\n+impl Token {\n+    pub fn new<T: Into<text::Rope>>(\n+        id: usize,\n+        range: Range<multi_buffer::Anchor>,\n+        style: HighlightStyle,\n+        text: T,\n+    ) -> Self {\n+        Self {\n+            id,\n+            range,\n+            style,\n+            text: text.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+struct HighlightEndpoint {\n+    id: usize,\n+    offset: usize,\n+    is_start: bool,\n+    style: HighlightStyle,\n+}\n+\n+impl PartialOrd for HighlightEndpoint {\n+    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for HighlightEndpoint {\n+    fn cmp(&self, other: &Self) -> cmp::Ordering {\n+        self.offset\n+            .cmp(&other.offset)\n+            .then_with(|| other.is_start.cmp(&self.is_start))\n+    }\n+}\n+\n+pub struct TokenChunks<'a> {",
        "comment_created_at": "2025-06-09T09:43:35+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "We need much more tests for something as fundamental as \"show me all highlights for a random chunk of text in the buffer\".\r\n\r\nIf this panics or somehow misbehaves, it might be very frequent and frustrating, and overall, it's very scary to merge whatever related thing.\r\n\r\nWe should cover:\r\n\r\n* overlapping ranges (both LSP overlaps and LSP + tree-sitter highlights overlap LSP ones)\r\n* multi-line LSP highlights\r\n* something else? \r\nFor inlays, we have `test_random_inlays` fuzzy test checks how text behaves for random inlays' inserts.\r\nShould we do something for highlights too?",
        "pr_file_module": null
      },
      {
        "comment_id": "2135436294",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 27556,
        "pr_file": "crates/editor/src/display_map/semantic_tokens.rs",
        "discussion_id": "2135408806",
        "commented_code": "@@ -0,0 +1,164 @@\n+use gpui::HighlightStyle;\n+use language::Chunk;\n+use multi_buffer::MultiBufferSnapshot;\n+use multi_buffer::ToOffset;\n+use std::cmp;\n+use std::collections::BTreeMap;\n+use std::ops::Range;\n+\n+use super::{Highlights, custom_highlights::CustomHighlightsChunks};\n+\n+#[derive(Debug, Clone)]\n+pub struct Token {\n+    pub(crate) id: usize,\n+    pub range: Range<multi_buffer::Anchor>,\n+    pub style: HighlightStyle,\n+    pub text: text::Rope,\n+}\n+\n+impl Token {\n+    pub fn new<T: Into<text::Rope>>(\n+        id: usize,\n+        range: Range<multi_buffer::Anchor>,\n+        style: HighlightStyle,\n+        text: T,\n+    ) -> Self {\n+        Self {\n+            id,\n+            range,\n+            style,\n+            text: text.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+struct HighlightEndpoint {\n+    id: usize,\n+    offset: usize,\n+    is_start: bool,\n+    style: HighlightStyle,\n+}\n+\n+impl PartialOrd for HighlightEndpoint {\n+    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for HighlightEndpoint {\n+    fn cmp(&self, other: &Self) -> cmp::Ordering {\n+        self.offset\n+            .cmp(&other.offset)\n+            .then_with(|| other.is_start.cmp(&self.is_start))\n+    }\n+}\n+\n+pub struct TokenChunks<'a> {",
        "comment_created_at": "2025-06-09T10:01:58+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "Also, all that \r\n\r\n> The delta is now expressed on these number arrays without any form of interpretation what these numbers mean. \r\n\r\nsection in the spec is somewhat scary: if I've read it correctly, we should fiddle with digits on the client, when computing token deltas?\r\n\r\nDefinitely worth testing then, if/when the delta support arrives.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2114179323",
    "pr_number": 31596,
    "pr_file": "crates/terminal/src/terminal.rs",
    "created_at": "2025-05-29T15:13:44+00:00",
    "commented_code": "vec![\"http://example.com\", \"mailto:bob@example.com\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_valid_url_ending() {\n+        let valid_urls = [\n+            \"http://example.com\",\n+            \"http://example.com/(test)\",\n+            \"[http://example.com]\",\n+            \"(http://example.com)\",\n+            \"(http://example.com(test))\",\n+            \"[http://example.com(test)]\",\n+\n+        ];\n+        \n+        let invalid_urls = [\n+            \"http://example.com(test))\",\n+            \"http://example.com/(test)]\",\n+        ];\n+\n+        for url in valid_urls {\n+            assert!(valid_url_ending(url));",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "2114179323",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 31596,
        "pr_file": "crates/terminal/src/terminal.rs",
        "discussion_id": "2114179323",
        "commented_code": "@@ -2321,6 +2354,32 @@ mod tests {\n             vec![\"http://example.com\", \"mailto:bob@example.com\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_valid_url_ending() {\n+        let valid_urls = [\n+            \"http://example.com\",\n+            \"http://example.com/(test)\",\n+            \"[http://example.com]\",\n+            \"(http://example.com)\",\n+            \"(http://example.com(test))\",\n+            \"[http://example.com(test)]\",\n+\n+        ];\n+        \n+        let invalid_urls = [\n+            \"http://example.com(test))\",\n+            \"http://example.com/(test)]\",\n+        ];\n+\n+        for url in valid_urls {\n+            assert!(valid_url_ending(url));",
        "comment_created_at": "2025-05-29T15:13:44+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "I think it would be better to add these cases into `test_url_regex` and ensure we match out the right thing.\r\n`valid_url_ending` is pretty local method to test instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "2115991240",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 31596,
        "pr_file": "crates/terminal/src/terminal.rs",
        "discussion_id": "2114179323",
        "commented_code": "@@ -2321,6 +2354,32 @@ mod tests {\n             vec![\"http://example.com\", \"mailto:bob@example.com\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_valid_url_ending() {\n+        let valid_urls = [\n+            \"http://example.com\",\n+            \"http://example.com/(test)\",\n+            \"[http://example.com]\",\n+            \"(http://example.com)\",\n+            \"(http://example.com(test))\",\n+            \"[http://example.com(test)]\",\n+\n+        ];\n+        \n+        let invalid_urls = [\n+            \"http://example.com(test))\",\n+            \"http://example.com/(test)]\",\n+        ];\n+\n+        for url in valid_urls {\n+            assert!(valid_url_ending(url));",
        "comment_created_at": "2025-05-30T14:02:10+00:00",
        "comment_author": "parkji30",
        "comment_body": "sorry, i was wondering what you meant by `pretty local method to test instead.`\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2115999377",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 31596,
        "pr_file": "crates/terminal/src/terminal.rs",
        "discussion_id": "2114179323",
        "commented_code": "@@ -2321,6 +2354,32 @@ mod tests {\n             vec![\"http://example.com\", \"mailto:bob@example.com\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_valid_url_ending() {\n+        let valid_urls = [\n+            \"http://example.com\",\n+            \"http://example.com/(test)\",\n+            \"[http://example.com]\",\n+            \"(http://example.com)\",\n+            \"(http://example.com(test))\",\n+            \"[http://example.com(test)]\",\n+\n+        ];\n+        \n+        let invalid_urls = [\n+            \"http://example.com(test))\",\n+            \"http://example.com/(test)]\",\n+        ];\n+\n+        for url in valid_urls {\n+            assert!(valid_url_ending(url));",
        "comment_created_at": "2025-05-30T14:07:02+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "The idea of unit tests is to test certain contracts of a single code unit, usually by using its public API for testing.\r\nObviously, nothing forbids doing otherwise and test the private api, but unit tests also slow down development, as every adjusment might require test rewrites/fixes \u2014 private, \"pretty local\", methods are meant to be moved/removed/adjusted/etc. thus testing them is not that great.\r\n\r\nJust a general rule of thumb: you're fixing the way regex captures strings, so test that, not something that checks whether the URL \"ending\" is valid.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1988183497",
    "pr_number": 26410,
    "pr_file": "crates/language/src/buffer_tests.rs",
    "created_at": "2025-03-11T00:19:53+00:00",
    "commented_code": ");\n }\n \n+#[gpui::test]\n+fn test_words_in_range(cx: &mut gpui::App) {\n+    init_settings(cx, |_| {});\n+\n+    let contents = r#\"let word=foo.bar Foo word2-FoO-Pizza-word FOO word\"#;\n+\n+    let buffer = cx.new(|cx| {\n+        let buffer = Buffer::local(contents, cx).with_language(Arc::new(rust_lang()), cx);\n+        assert_eq!(buffer.text(), contents);\n+        buffer.check_invariants();\n+        buffer\n+    });\n+\n+    buffer.update(cx, |buffer, _| {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1988183497",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26410,
        "pr_file": "crates/language/src/buffer_tests.rs",
        "discussion_id": "1988183497",
        "commented_code": "@@ -3140,6 +3141,81 @@ fn test_trailing_whitespace_ranges(mut rng: StdRng) {\n     );\n }\n \n+#[gpui::test]\n+fn test_words_in_range(cx: &mut gpui::App) {\n+    init_settings(cx, |_| {});\n+\n+    let contents = r#\"let word=foo.bar Foo word2-FoO-Pizza-word FOO word\"#;\n+\n+    let buffer = cx.new(|cx| {\n+        let buffer = Buffer::local(contents, cx).with_language(Arc::new(rust_lang()), cx);\n+        assert_eq!(buffer.text(), contents);\n+        buffer.check_invariants();\n+        buffer\n+    });\n+\n+    buffer.update(cx, |buffer, _| {",
        "comment_created_at": "2025-03-11T00:19:53+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think in this test, it would probably be good to have some assertions where the query (and the buffer) contain multibyte characters.",
        "pr_file_module": null
      },
      {
        "comment_id": "1989114228",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 26410,
        "pr_file": "crates/language/src/buffer_tests.rs",
        "discussion_id": "1988183497",
        "commented_code": "@@ -3140,6 +3141,81 @@ fn test_trailing_whitespace_ranges(mut rng: StdRng) {\n     );\n }\n \n+#[gpui::test]\n+fn test_words_in_range(cx: &mut gpui::App) {\n+    init_settings(cx, |_| {});\n+\n+    let contents = r#\"let word=foo.bar Foo word2-FoO-Pizza-word FOO word\"#;\n+\n+    let buffer = cx.new(|cx| {\n+        let buffer = Buffer::local(contents, cx).with_language(Arc::new(rust_lang()), cx);\n+        assert_eq!(buffer.text(), contents);\n+        buffer.check_invariants();\n+        buffer\n+    });\n+\n+    buffer.update(cx, |buffer, _| {",
        "comment_created_at": "2025-03-11T12:09:16+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "Done, and that lead to a better way to compare chars case-insensitively, thank you.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1926222689",
    "pr_number": 22616,
    "pr_file": "crates/worktree/src/worktree_tests.rs",
    "created_at": "2025-01-23T01:16:07+00:00",
    "commented_code": "second_head: UnmergedStatusCode::Updated,\n });\n \n+// NOTE:\n+// This test always fails on Windows, because on Windows, unlike on Unix, you can't rename\n+// a directory to a name that some program has open.\n+// This is a limitation of the Windows.\n+// See: https://stackoverflow.com/questions/41365318/access-is-denied-when-renaming-folder\n #[gpui::test]\n+#[cfg(not(target_os = \"windows\"))]",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1926222689",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 22616,
        "pr_file": "crates/worktree/src/worktree_tests.rs",
        "discussion_id": "1926222689",
        "commented_code": "@@ -2156,7 +2156,13 @@ const CONFLICT: FileStatus = FileStatus::Unmerged(UnmergedStatus {\n     second_head: UnmergedStatusCode::Updated,\n });\n \n+// NOTE:\n+// This test always fails on Windows, because on Windows, unlike on Unix, you can't rename\n+// a directory to a name that some program has open.\n+// This is a limitation of the Windows.\n+// See: https://stackoverflow.com/questions/41365318/access-is-denied-when-renaming-folder\n #[gpui::test]\n+#[cfg(not(target_os = \"windows\"))]",
        "comment_created_at": "2025-01-23T01:16:07+00:00",
        "comment_author": "mikayla-maki",
        "comment_body": "let's change this `#[cfg_attr(target_os = \"windows\", ignore)]`, so that it shows up in `skipped` lists :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1647102102",
    "pr_number": 12909,
    "pr_file": "crates/editor/src/signature_help_popover.rs",
    "created_at": "2024-06-20T07:32:52+00:00",
    "commented_code": "+use crate::{Editor, EditorStyle};\n+use gpui::{\n+    div, AnyElement, FontWeight, InteractiveElement, IntoElement, MouseButton, ParentElement,\n+    Pixels, Size, StatefulInteractiveElement, Styled, ViewContext, WeakView,\n+};\n+use language::markdown::{MarkdownHighlight, MarkdownHighlightStyle};\n+use language::ParsedMarkdown;\n+use lsp::SignatureHelp;\n+use std::ops::Range;\n+use ui::StyledExt;\n+use workspace::Workspace;\n+\n+const SIGNATURE_HELP_HIGHLIGHT: MarkdownHighlight =\n+    MarkdownHighlight::Style(MarkdownHighlightStyle {\n+        italic: false,\n+        underline: true,\n+        strikethrough: false,\n+        weight: FontWeight::EXTRA_BOLD,\n+    });\n+\n+const SIGNATURE_HELP_OVERLOAD_HIGHLIGHT: MarkdownHighlight =\n+    MarkdownHighlight::Style(MarkdownHighlightStyle {\n+        italic: true,\n+        underline: false,\n+        strikethrough: false,\n+        weight: FontWeight::NORMAL,\n+    });\n+\n+#[derive(Clone, Debug)]\n+pub struct SignatureHelpPopover {\n+    pub parsed_content: ParsedMarkdown,\n+}\n+\n+/// create_signature_help_markdown_string generates the markdown text that is displayed in the `SignatureHelp` window.\n+pub fn create_signature_help_markdown_string(\n+    signature_help: SignatureHelp,\n+) -> Option<(String, Vec<(Range<usize>, MarkdownHighlight)>)> {\n+    let (signature_information, maybe_active_signature, maybe_active_parameter) = (\n+        signature_help.signatures,\n+        signature_help.active_signature,\n+        signature_help.active_parameter,\n+    );\n+\n+    let function_options_count = signature_information.len();\n+\n+    let maybe_signature_information = maybe_active_signature\n+        .and_then(|active_signature| signature_information.get(active_signature as usize));\n+    let signature_information = if let Some(signature_information) = maybe_signature_information {\n+        Some(signature_information)\n+    } else {\n+        signature_information.first()\n+    }?;\n+\n+    let str_for_join = \", \";\n+    let parameter_length = signature_information\n+        .parameters\n+        .as_ref()\n+        .map(|parameters| parameters.len())\n+        .unwrap_or(0);\n+    let mut highlight_start = 0;\n+    let (markdown, mut highlights): (Vec<_>, Vec<_>) = signature_information\n+        .parameters\n+        .as_ref()?\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(i, parameter_information)| {\n+            let string = match parameter_information.label.clone() {\n+                lsp::ParameterLabel::Simple(string) => string,\n+                lsp::ParameterLabel::LabelOffsets(offset) => signature_information\n+                    .label\n+                    .chars()\n+                    .skip(offset[0] as usize)\n+                    .take((offset[1] - offset[0]) as usize)\n+                    .collect::<String>(),\n+            };\n+            let string_length = string.len();\n+\n+            let result = if let Some(active_parameter) = maybe_active_parameter {\n+                if i == active_parameter as usize {\n+                    Some((\n+                        string,\n+                        Some((\n+                            highlight_start..(highlight_start + string_length),\n+                            SIGNATURE_HELP_HIGHLIGHT,\n+                        )),\n+                    ))\n+                } else {\n+                    Some((string, None))\n+                }\n+            } else {\n+                Some((string, None))\n+            };\n+\n+            if i != parameter_length {\n+                highlight_start += string_length + str_for_join.len();\n+            }\n+\n+            result\n+        })\n+        .unzip();\n+    let markdown = markdown.join(str_for_join);\n+    let markdown = if function_options_count >= 2 {\n+        let suffix = format!(\"(+{} overload)\", function_options_count - 1);\n+        let highlight_start = markdown.len() + 1;\n+        highlights.push(Some((\n+            highlight_start..(highlight_start + suffix.len()),\n+            SIGNATURE_HELP_OVERLOAD_HIGHLIGHT,\n+        )));\n+        let markdown = format!(\"{} {}\", markdown, suffix);\n+        markdown\n+    } else {\n+        markdown\n+    };\n+\n+    let highlights = highlights.into_iter().flatten().collect::<Vec<_>>();\n+\n+    if markdown.is_empty() {\n+        None\n+    } else {\n+        Some((markdown, highlights))\n+    }\n+}\n+\n+impl SignatureHelpPopover {\n+    pub fn render(\n+        &mut self,\n+        style: &EditorStyle,\n+        max_size: Size<Pixels>,\n+        workspace: Option<WeakView<Workspace>>,\n+        cx: &mut ViewContext<Editor>,\n+    ) -> AnyElement {\n+        div()\n+            .id(\"signature_help_popover\")\n+            .elevation_2(cx)\n+            .overflow_y_scroll()\n+            .max_w(max_size.width)\n+            .max_h(max_size.height)\n+            .on_mouse_move(|_, cx| cx.stop_propagation())\n+            .on_mouse_down(MouseButton::Left, |_, cx| cx.stop_propagation())\n+            .child(div().p_2().child(crate::render_parsed_markdown(\n+                \"content\",\n+                &self.parsed_content,\n+                style,\n+                workspace,\n+                cx,\n+            )))\n+            .into_any_element()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::signature_help_popover::{\n+        create_signature_help_markdown_string, SIGNATURE_HELP_HIGHLIGHT,\n+        SIGNATURE_HELP_OVERLOAD_HIGHLIGHT,\n+    };\n+    use lsp::{SignatureHelp, SignatureInformation};\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_1() {\n+        let signature_help = SignatureHelp {\n+            signatures: vec![SignatureInformation {\n+                label: \"fn test(foo: u8, bar: &str)\".to_string(),\n+                documentation: None,\n+                parameters: Some(vec![\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"foo: u8\".to_string()),\n+                        documentation: None,\n+                    },\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"bar: &str\".to_string()),\n+                        documentation: None,\n+                    },\n+                ]),\n+                active_parameter: None,\n+            }],\n+            active_signature: Some(0),\n+            active_parameter: Some(0),\n+        };\n+        let maybe_markdown = create_signature_help_markdown_string(signature_help);\n+        assert!(maybe_markdown.is_some());\n+\n+        let markdown = maybe_markdown.unwrap();\n+        assert_eq!(\n+            markdown,\n+            (\n+                \"foo: u8, bar: &str\".to_string(),\n+                vec![(0..7, SIGNATURE_HELP_HIGHLIGHT)]\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_2() {\n+        let signature_help = SignatureHelp {\n+            signatures: vec![SignatureInformation {\n+                label: \"fn test(foo: u8, bar: &str)\".to_string(),\n+                documentation: None,\n+                parameters: Some(vec![\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"foo: u8\".to_string()),\n+                        documentation: None,\n+                    },\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"bar: &str\".to_string()),\n+                        documentation: None,\n+                    },\n+                ]),\n+                active_parameter: None,\n+            }],\n+            active_signature: Some(0),\n+            active_parameter: Some(1),\n+        };\n+        let maybe_markdown = create_signature_help_markdown_string(signature_help);\n+        assert!(maybe_markdown.is_some());\n+\n+        let markdown = maybe_markdown.unwrap();\n+        assert_eq!(\n+            markdown,\n+            (\n+                \"foo: u8, bar: &str\".to_string(),\n+                vec![(9..18, SIGNATURE_HELP_HIGHLIGHT)]\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_3() {\n+        let signature_help = SignatureHelp {\n+            signatures: vec![\n+                SignatureInformation {\n+                    label: \"fn test1(foo: u8, bar: &str)\".to_string(),\n+                    documentation: None,\n+                    parameters: Some(vec![\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"foo: u8\".to_string()),\n+                            documentation: None,\n+                        },\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"bar: &str\".to_string()),\n+                            documentation: None,\n+                        },\n+                    ]),\n+                    active_parameter: None,\n+                },\n+                SignatureInformation {\n+                    label: \"fn test2(hoge: String, fuga: bool)\".to_string(),\n+                    documentation: None,\n+                    parameters: Some(vec![\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"hoge: String\".to_string()),\n+                            documentation: None,\n+                        },\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"fuga: bool\".to_string()),\n+                            documentation: None,\n+                        },\n+                    ]),\n+                    active_parameter: None,\n+                },\n+            ],\n+            active_signature: Some(0),\n+            active_parameter: Some(0),\n+        };\n+        let maybe_markdown = create_signature_help_markdown_string(signature_help);\n+        assert!(maybe_markdown.is_some());\n+\n+        let markdown = maybe_markdown.unwrap();\n+        assert_eq!(\n+            markdown,\n+            (\n+                \"foo: u8, bar: &str (+1 overload)\".to_string(),\n+                vec![\n+                    (0..7, SIGNATURE_HELP_HIGHLIGHT),\n+                    (19..32, SIGNATURE_HELP_OVERLOAD_HIGHLIGHT)\n+                ]\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_4() {",
    "repo_full_name": "zed-industries/zed",
    "discussion_comments": [
      {
        "comment_id": "1647102102",
        "repo_full_name": "zed-industries/zed",
        "pr_number": 12909,
        "pr_file": "crates/editor/src/signature_help_popover.rs",
        "discussion_id": "1647102102",
        "commented_code": "@@ -0,0 +1,553 @@\n+use crate::{Editor, EditorStyle};\n+use gpui::{\n+    div, AnyElement, FontWeight, InteractiveElement, IntoElement, MouseButton, ParentElement,\n+    Pixels, Size, StatefulInteractiveElement, Styled, ViewContext, WeakView,\n+};\n+use language::markdown::{MarkdownHighlight, MarkdownHighlightStyle};\n+use language::ParsedMarkdown;\n+use lsp::SignatureHelp;\n+use std::ops::Range;\n+use ui::StyledExt;\n+use workspace::Workspace;\n+\n+const SIGNATURE_HELP_HIGHLIGHT: MarkdownHighlight =\n+    MarkdownHighlight::Style(MarkdownHighlightStyle {\n+        italic: false,\n+        underline: true,\n+        strikethrough: false,\n+        weight: FontWeight::EXTRA_BOLD,\n+    });\n+\n+const SIGNATURE_HELP_OVERLOAD_HIGHLIGHT: MarkdownHighlight =\n+    MarkdownHighlight::Style(MarkdownHighlightStyle {\n+        italic: true,\n+        underline: false,\n+        strikethrough: false,\n+        weight: FontWeight::NORMAL,\n+    });\n+\n+#[derive(Clone, Debug)]\n+pub struct SignatureHelpPopover {\n+    pub parsed_content: ParsedMarkdown,\n+}\n+\n+/// create_signature_help_markdown_string generates the markdown text that is displayed in the `SignatureHelp` window.\n+pub fn create_signature_help_markdown_string(\n+    signature_help: SignatureHelp,\n+) -> Option<(String, Vec<(Range<usize>, MarkdownHighlight)>)> {\n+    let (signature_information, maybe_active_signature, maybe_active_parameter) = (\n+        signature_help.signatures,\n+        signature_help.active_signature,\n+        signature_help.active_parameter,\n+    );\n+\n+    let function_options_count = signature_information.len();\n+\n+    let maybe_signature_information = maybe_active_signature\n+        .and_then(|active_signature| signature_information.get(active_signature as usize));\n+    let signature_information = if let Some(signature_information) = maybe_signature_information {\n+        Some(signature_information)\n+    } else {\n+        signature_information.first()\n+    }?;\n+\n+    let str_for_join = \", \";\n+    let parameter_length = signature_information\n+        .parameters\n+        .as_ref()\n+        .map(|parameters| parameters.len())\n+        .unwrap_or(0);\n+    let mut highlight_start = 0;\n+    let (markdown, mut highlights): (Vec<_>, Vec<_>) = signature_information\n+        .parameters\n+        .as_ref()?\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(i, parameter_information)| {\n+            let string = match parameter_information.label.clone() {\n+                lsp::ParameterLabel::Simple(string) => string,\n+                lsp::ParameterLabel::LabelOffsets(offset) => signature_information\n+                    .label\n+                    .chars()\n+                    .skip(offset[0] as usize)\n+                    .take((offset[1] - offset[0]) as usize)\n+                    .collect::<String>(),\n+            };\n+            let string_length = string.len();\n+\n+            let result = if let Some(active_parameter) = maybe_active_parameter {\n+                if i == active_parameter as usize {\n+                    Some((\n+                        string,\n+                        Some((\n+                            highlight_start..(highlight_start + string_length),\n+                            SIGNATURE_HELP_HIGHLIGHT,\n+                        )),\n+                    ))\n+                } else {\n+                    Some((string, None))\n+                }\n+            } else {\n+                Some((string, None))\n+            };\n+\n+            if i != parameter_length {\n+                highlight_start += string_length + str_for_join.len();\n+            }\n+\n+            result\n+        })\n+        .unzip();\n+    let markdown = markdown.join(str_for_join);\n+    let markdown = if function_options_count >= 2 {\n+        let suffix = format!(\"(+{} overload)\", function_options_count - 1);\n+        let highlight_start = markdown.len() + 1;\n+        highlights.push(Some((\n+            highlight_start..(highlight_start + suffix.len()),\n+            SIGNATURE_HELP_OVERLOAD_HIGHLIGHT,\n+        )));\n+        let markdown = format!(\"{} {}\", markdown, suffix);\n+        markdown\n+    } else {\n+        markdown\n+    };\n+\n+    let highlights = highlights.into_iter().flatten().collect::<Vec<_>>();\n+\n+    if markdown.is_empty() {\n+        None\n+    } else {\n+        Some((markdown, highlights))\n+    }\n+}\n+\n+impl SignatureHelpPopover {\n+    pub fn render(\n+        &mut self,\n+        style: &EditorStyle,\n+        max_size: Size<Pixels>,\n+        workspace: Option<WeakView<Workspace>>,\n+        cx: &mut ViewContext<Editor>,\n+    ) -> AnyElement {\n+        div()\n+            .id(\"signature_help_popover\")\n+            .elevation_2(cx)\n+            .overflow_y_scroll()\n+            .max_w(max_size.width)\n+            .max_h(max_size.height)\n+            .on_mouse_move(|_, cx| cx.stop_propagation())\n+            .on_mouse_down(MouseButton::Left, |_, cx| cx.stop_propagation())\n+            .child(div().p_2().child(crate::render_parsed_markdown(\n+                \"content\",\n+                &self.parsed_content,\n+                style,\n+                workspace,\n+                cx,\n+            )))\n+            .into_any_element()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::signature_help_popover::{\n+        create_signature_help_markdown_string, SIGNATURE_HELP_HIGHLIGHT,\n+        SIGNATURE_HELP_OVERLOAD_HIGHLIGHT,\n+    };\n+    use lsp::{SignatureHelp, SignatureInformation};\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_1() {\n+        let signature_help = SignatureHelp {\n+            signatures: vec![SignatureInformation {\n+                label: \"fn test(foo: u8, bar: &str)\".to_string(),\n+                documentation: None,\n+                parameters: Some(vec![\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"foo: u8\".to_string()),\n+                        documentation: None,\n+                    },\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"bar: &str\".to_string()),\n+                        documentation: None,\n+                    },\n+                ]),\n+                active_parameter: None,\n+            }],\n+            active_signature: Some(0),\n+            active_parameter: Some(0),\n+        };\n+        let maybe_markdown = create_signature_help_markdown_string(signature_help);\n+        assert!(maybe_markdown.is_some());\n+\n+        let markdown = maybe_markdown.unwrap();\n+        assert_eq!(\n+            markdown,\n+            (\n+                \"foo: u8, bar: &str\".to_string(),\n+                vec![(0..7, SIGNATURE_HELP_HIGHLIGHT)]\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_2() {\n+        let signature_help = SignatureHelp {\n+            signatures: vec![SignatureInformation {\n+                label: \"fn test(foo: u8, bar: &str)\".to_string(),\n+                documentation: None,\n+                parameters: Some(vec![\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"foo: u8\".to_string()),\n+                        documentation: None,\n+                    },\n+                    lsp::ParameterInformation {\n+                        label: lsp::ParameterLabel::Simple(\"bar: &str\".to_string()),\n+                        documentation: None,\n+                    },\n+                ]),\n+                active_parameter: None,\n+            }],\n+            active_signature: Some(0),\n+            active_parameter: Some(1),\n+        };\n+        let maybe_markdown = create_signature_help_markdown_string(signature_help);\n+        assert!(maybe_markdown.is_some());\n+\n+        let markdown = maybe_markdown.unwrap();\n+        assert_eq!(\n+            markdown,\n+            (\n+                \"foo: u8, bar: &str\".to_string(),\n+                vec![(9..18, SIGNATURE_HELP_HIGHLIGHT)]\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_3() {\n+        let signature_help = SignatureHelp {\n+            signatures: vec![\n+                SignatureInformation {\n+                    label: \"fn test1(foo: u8, bar: &str)\".to_string(),\n+                    documentation: None,\n+                    parameters: Some(vec![\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"foo: u8\".to_string()),\n+                            documentation: None,\n+                        },\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"bar: &str\".to_string()),\n+                            documentation: None,\n+                        },\n+                    ]),\n+                    active_parameter: None,\n+                },\n+                SignatureInformation {\n+                    label: \"fn test2(hoge: String, fuga: bool)\".to_string(),\n+                    documentation: None,\n+                    parameters: Some(vec![\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"hoge: String\".to_string()),\n+                            documentation: None,\n+                        },\n+                        lsp::ParameterInformation {\n+                            label: lsp::ParameterLabel::Simple(\"fuga: bool\".to_string()),\n+                            documentation: None,\n+                        },\n+                    ]),\n+                    active_parameter: None,\n+                },\n+            ],\n+            active_signature: Some(0),\n+            active_parameter: Some(0),\n+        };\n+        let maybe_markdown = create_signature_help_markdown_string(signature_help);\n+        assert!(maybe_markdown.is_some());\n+\n+        let markdown = maybe_markdown.unwrap();\n+        assert_eq!(\n+            markdown,\n+            (\n+                \"foo: u8, bar: &str (+1 overload)\".to_string(),\n+                vec![\n+                    (0..7, SIGNATURE_HELP_HIGHLIGHT),\n+                    (19..32, SIGNATURE_HELP_OVERLOAD_HIGHLIGHT)\n+                ]\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_create_signature_help_markdown_string_4() {",
        "comment_created_at": "2024-06-20T07:32:52+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "There's a lot of rendering tests, which is amazing, thank you!\r\n\r\nWhat's lacking are new ones in the `editor_tests.rs`, and after we deal with the brackets and whatever else that triggers the pop-up display, it would be fantastic to have that logic tested too.",
        "pr_file_module": null
      }
    ]
  }
]